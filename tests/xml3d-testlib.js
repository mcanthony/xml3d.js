!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.XML3DTestLib=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.2
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


(function(_global) {
  "use strict";

  var shim = {};
  if (typeof(exports) === 'undefined') {
    if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      shim.exports = {};
      define(function() {
        return shim.exports;
      });
    } else {
      // gl-matrix lives in a browser, define its namespaces in global
      shim.exports = typeof(window) !== 'undefined' ? window : _global;
    }
  }
  else {
    // gl-matrix lives in commonjs, define its namespaces in exports
    shim.exports = exports;
  }

  (function(exports) {
    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

if(!GLMAT_ARRAY_TYPE) {
    var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
}

if(!GLMAT_RANDOM) {
    var GLMAT_RANDOM = Math.random;
}

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

if(typeof(exports) !== 'undefined') {
    exports.glMatrix = glMatrix;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */

var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec2 = vec2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */

var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    var z = (GLMAT_RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec3 = vec3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */

var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
        out[3] = a[3] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = GLMAT_RANDOM();
    out[1] = GLMAT_RANDOM();
    out[2] = GLMAT_RANDOM();
    out[3] = GLMAT_RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec4 = vec4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x2 Matrix
 * @name mat2
 */

var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2 = mat2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;


/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2d = mat2d;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3x3 Matrix
 * @name mat3
 */

var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


if(typeof(exports) !== 'undefined') {
    exports.mat3 = mat3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4x4 Matrix
 * @name mat4
 */

var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
        Math.abs(eyey - centery) < GLMAT_EPSILON &&
        Math.abs(eyez - centerz) < GLMAT_EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


if(typeof(exports) !== 'undefined') {
    exports.mat4 = mat4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class Quaternion
 * @name quat
 */

var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.quat = quat;
}
;













  })(shim.exports);
})(this);

},{}],2:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(require,module,exports){
module.exports = require( './lib/' );

},{"./lib/":4}],4:[function(require,module,exports){
module.exports = function () {

    var now = require("performance-now");

    function find(arr, predicate) {
            if (arr == null) {
                throw new TypeError('Array.prototype.find called on null or undefined');
            }
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            var list = Object(arr);
            var length = list.length >>> 0;
            var value;

            for (var i = 0; i < length; i++) {
                value = list[i];
                if (predicate.call(null, value, i, list)) {
                    return value;
                }
            }
            return undefined;
    };

    var SimpleTextureManager = function (opt) {
        opt = opt || {};
        this._units = [];
        for (var i = 0; i < (opt.units || 8); i++) {
            this._units[i] = {slot: i, use: 0};
        }
    };

    SimpleTextureManager.NOT_FOUND = -1;
    SimpleTextureManager.FULL = -2;

    SimpleTextureManager.prototype = {

        _set: function (slot, newEntry) {
            var oldEntry = this._units[slot];
            if (oldEntry.dispose) {
                oldEntry.dispose(oldEntry, this);
            }
            if (newEntry) {
                this._units[slot] = newEntry;
                this._units[slot].slot = slot;
            } else {
                this._units[slot] = {slot: slot, use: 0};
            }
        },

        bind: function (id, opt) {
            opt = opt || {};
            var fixed = !!opt.fixed;
            var dispose = typeof opt.dispose == "function" ? opt.dispose : null;

            // Check if texture is already bound
            var result = this.get(id);
            if (result !== SimpleTextureManager.NOT_FOUND) {
                return result;
            }

            var candidates = this._units.filter(function (unit) {
                return !unit.fixed;
            });
            //console.log("Candidates,", candidates, candidates.length);

            if (!candidates.length) {
                return SimpleTextureManager.FULL;
            }

            var selected = candidates.reduce(function (prev, curr) {
                return prev ? (curr.use < prev.use ? curr : prev) : curr;
            }, null);
            //console.log("Selected entry", selected);

            var slot = selected.slot;
            this._set(slot, {
                fixed: fixed, use: now(), id: id, dispose: dispose
            });
            return slot;

        },

        dispose: function (id) {
            var entry = this.getEntry(id);
            this._set(entry.slot, null);
        },
        /**
         * Returns if the texture of the given id is bound to an unit
         * @param id
         * @returns {boolean}
         */
        has: function (id) {
            return !!this.getEntry(id);
        },
        /**
         * Returns the current texture unit for the id or SimpleTextureManager.NOT_FOUND
         * if the texture is currently not bound
         * @param id
         * @returns {*}
         */
        get: function (id) {
            var result = this.getEntry(id);
            if(result) {
                result.use = now();
                return result.slot;
            }
            return SimpleTextureManager.NOT_FOUND;
        },

        use: function (id) {
            var result = this.getEntry(id);
            if(result) {
                result.use = now();
            }
        },

        getEntry: function (id) {
            return find(this._units, function (entry) {
                return entry.id === id;
            });
        }

    };


    return {
        SimpleTextureManager: SimpleTextureManager
    };
}();

},{"performance-now":5}],5:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

}).call(this,require('_process'))

},{"_process":2}],6:[function(require,module,exports){
var Set = require("../xflow/utils/utils.js").set;
var DataNode = require("../xflow/interface/graph.js").DataNode;

function AssetError(message, node){
    this.message = message;
    this.node = node;
}

var Asset = function(refNode){
    this.name = null;
    this.srcAsset = null;
    this.children = [];
    this.subAssets = [];
    this.pickFilter = null;
    this.parents = [];
    this.listener = [];
    this.loading = false;
    this.refNode = refNode || null;
    this.shader = null;
    this.transform = null;

    this.assetResult = null;
    this.loadLevel = 0;
    this.progressLevel = Infinity;
};

Asset.prototype.checkValidity = function(){
    if(this.isSubtreeLoading())
        return;
    checkRecursive(this);
};
function checkRecursive(asset){
    if(asset.srcAsset){
        checkRecursive(asset.srcAsset);
    }
    var localNames = [];
    for(var i = 0; i < asset.children.length; ++i){
        var child = asset.children[i], name = child.name;
        if(name && localNames.indexOf(name) != -1){
            throw new AssetError("Two subdata elements with the same name: '" + name + "'", child.refNode);
        }
        if(name) localNames.push(name);
    }
    for(var i = 0; i < asset.subAssets.length; ++i){
        checkRecursive(asset.subAssets[i]);
    }
}


Asset.prototype.setLoading = function(loading){
    if(loading != this.loading){
        this.loading = loading;
        updateLoadingState(this);
        invalidateAsset(this);

    }
};

Asset.prototype.isSubtreeLoading = function(){
    return this.progressLevel == 0;
};
Asset.prototype.getProgressLevel = function(){
    return this.progressLevel;
};

Asset.prototype.setName = function(name){
    this.name = name;
    invalidateAsset(this);
};

Asset.prototype.setShader = function(shader){
    this.shader = shader;
    invalidateAsset(this);
};

Asset.prototype.setTransform = function(transform){
    this.transform = transform;
    if (this.refNode.localName.toLowerCase() !== "model") {
        invalidateAsset(this);
    }
};

Asset.prototype.appendChild = function(child){
    this.children.push(child);
    child.assetParent = this;
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype.setPickFilter = function(pickFilterString){
    if(typeof pickFilterString == "string"){
        this.pickFilter = new AssetPickFilter();
        this.pickFilter.parse(pickFilterString);
    }
    else
        this.pickFilter = null;
    invalidateAsset(this);
};

Asset.prototype.appendSubAsset = function(subAsset){
    subAsset._addParent(this);
    this.subAssets.push(subAsset);
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype.setSrcAsset = function(asset){
    if(this.srcAsset)
        this.srcAsset._removeParent(this);

    this.srcAsset = asset;

    if(this.srcAsset)
        this.srcAsset._addParent(this);
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype.clearChildren = function(){
    var i = this.children.length;
    while(i--) this.children[i].assetParent = null;
    this.children = [];
    updateLoadingState(this);
    invalidateAsset(this);

};
Asset.prototype.clearSubAssets = function(){
    var i = this.subAssets.length;
    while(i--) {
        this.subAssets[i]._removeParent(this);
    }
    this.subAssets.length = 0;
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype._addParent = function(asset){
    this.parents.push(asset);
};
Asset.prototype._removeParent = function(asset){
    var idx = this.parents.indexOf(asset);
    if(idx != -1)
        this.parents.splice(idx, 1);
};

Asset.prototype._callLoadListeners = function(newLevel, oldLevel){
    var listeners = this.listener;
    for(var i = 0; i < listeners.length; ++i){
        listeners[i].onAssetLoadChange && listeners[i].onAssetLoadChange(this, newLevel, oldLevel);
    }
};


Asset.prototype.addChangeListener = function(listener){
    Set.add(this.listener, listener);
};
Asset.prototype.removeChangeListener = function(listener){
    Set.remove(this.listener, listener);
};

Asset.prototype.getResult = function(){
    if(!this.assetResult){
        this.assetResult = new AssetResult();
        this.assetResult.construct(this);
    }
    return this.assetResult;
};

function invalidateAsset(asset){
    if(asset.assetResult){
        asset.assetResult = null;
    }
    var listeners = asset.listener;
    for(var i = 0; i < listeners.length; ++i){
        listeners[i].onAssetChange && listeners[i].onAssetChange(this);
    }
    var i = asset.parents.length;
    while(i--){
        invalidateAsset(asset.parents[i]);
    }
}


function updateLoadingState(asset){
    var progressLevel = asset.loading ? asset.loadLevel : Infinity;
    if(progressLevel && asset.srcAsset){
        progressLevel = Math.min(progressLevel, Math.max(asset.srcAsset.loadLevel, asset.srcAsset.progressLevel));
    }
    var i = asset.subAssets.length;
    while(progressLevel && i--){
        progressLevel = Math.min(progressLevel, Math.max(asset.subAssets[i].loadLevel, asset.subAssets[i].progressLevel));
    }
    var i = asset.children.length;
    while(progressLevel && i--){
        progressLevel = Math.min(progressLevel, asset.children[i].progressLevel);
    }
    var oldLevel = asset.progressLevel;
    asset.progressLevel = progressLevel;

    if(oldLevel != asset.progressLevel){
        asset._callLoadListeners(asset.progressLevel, oldLevel);
        for(var i = 0; i < asset.parents.length; ++i)
            updateLoadingState(asset.parents[i]);
    }
}


//----------------------------------------------------------------------------------------------------------------------
// SubData
//----------------------------------------------------------------------------------------------------------------------

var SubData = function(xflowNodeOut, xflowNodeIn, refNode){
    this.xflowNodeOut = xflowNodeOut;
    this.xflowNodeIn = xflowNodeIn;
    this.refNode = refNode || null;
    this.name = null;
    this.matchFilter = null;
    this.classNames = [];
    this.postDataflow = null;
    this.postCompute = null;
    this.postFilter = null;
    this.includes = [];
    this.shader = null;
    this.transform = null;
    this.meshType = null;
    this.assetParent = null;
    this.loading = false;
    this.loadLevel = 0;
    this.progressLevel = Infinity;
    xflowNodeIn.addLoadListener(this.onXflowLoadEvent.bind(this));
    this._updateLoadingState();
};

SubData.prototype.setLoading = function(loading){
    if(loading != this.loading){
        this.loading = loading;
        this._updateLoadingState();
        invalidateParent(this);

    }
};

SubData.prototype._updateLoadingState = function(){
    var progressLevel = this.loading ? this.loadLevel : Infinity;
    progressLevel = Math.min(progressLevel, this.xflowNodeIn.getProgressLevel());
    var oldLevel = this.progressLevel;
    this.progressLevel = progressLevel;

    if(oldLevel != this.progressLevel){
        this.assetParent && updateLoadingState(this.assetParent);
        invalidateParent(this);
    }
};
SubData.prototype.onXflowLoadEvent = function(){
    this._updateLoadingState();
};

SubData.prototype.isSubtreeLoading = function(){
    return this.loading;
};

SubData.prototype.isMesh = function(){
    return !!this.meshType;
};

SubData.prototype.setName = function(name){
    this.name = name;
    invalidateParent(this);
};

SubData.prototype.setMatchFilter = function(matchString){
    if(typeof matchString == "string"){
        this.matchFilter = new AssetPickFilter();
        this.matchFilter.parse(matchString);
    }
    else
        this.matchFilter = null;
    invalidateParent(this);
};

SubData.prototype.setClassNames = function(classNames){
    this.classNames = classNames;
    invalidateParent(this);
};
SubData.prototype.setClassNamesString = function(classNamesString){
    if(!classNamesString)
        this.setClassNames([]);
    else{
        var array = classNamesString.split(/\s+/);
        var i = array.length;
        while(i--) array[i] = array[i].trim();
        this.setClassNames(array);
    }
};


SubData.prototype.setPostDataflow = function(postDataflow){
    this.postDataflow = postDataflow;
    invalidateParent(this);
};

SubData.prototype.setPostCompute = function(postCompute){
    this.postCompute = postCompute;
    invalidateParent(this);
};

SubData.prototype.setPostFilter = function(postFilter){
    this.postFilter = postFilter;
    invalidateParent(this);
};

SubData.prototype.setIncludes = function(includes){
    this.includes = includes;
    invalidateParent(this);
};

SubData.prototype.setShader = function(shader){
    this.shader = shader;
    invalidateParent(this);
};

SubData.prototype.setTransform = function(transform){
    this.transform = transform;
    invalidateParent(this);
};

SubData.prototype.setMeshType = function(meshType){
    this.meshType = meshType;
    invalidateParent(this);
};

function invalidateParent(subData){
    if(subData.assetParent){
        invalidateAsset(subData.assetParent);
    }
}

//----------------------------------------------------------------------------------------------------------------------
// AssetResult
//----------------------------------------------------------------------------------------------------------------------

var AssetResult = function(){
    this.parentResult = null;
    this.name = null;
    this.namedEntries = {};
    this.allEntries = [];
    this.matchEntries = [];
    this.namedSubResults = {};
    this.allSubResults = [];

    this.shader = null;
    this.transform = null;
    this.pickFilter = null;
};

AssetResult.prototype.construct = function(asset){
    constructAssetTable(this, asset);
};

AssetResult.prototype.getDataTree = function(){
    return rec_getDataTree(this);
};


function constructAssetTable(table, asset){
    table.name = asset.name;

    var srcAsset = asset.srcAsset, srcResult = srcAsset && srcAsset.getResult();
    if(srcResult){
        copySrcTable(table, srcAsset.getResult(), asset.pickFilter);
    }
    else
        table.pickFilter = asset.pickFilter;

    if(asset.shader) table.shader = asset.shader;
    if(asset.transform) table.transform = combineTransform(table.transform, asset.transform);


    var subAssets = asset.subAssets;
    var i = subAssets.length;
    while(i--){
        var result = subAssets[i].getResult();
        mergeSubAssetResult(table, result);
    }
    var matchChildren = [];
    var children = asset.children;
    for(var i = 0; i < children.length; ++i){
        var child = children[i];
        var name = child.name;
        var entry;
        if(child.name && child.matchFilter){
            XML3D.debug.logWarning("Asset entry defines both name and match attribute. Match attribute will be ignored", child.refNode);
        }
        if(name){
            if(!table.namedEntries[name]){
                entry = new AssetTableEntry(child);
                applyMatchEntries(entry, table.matchEntries);
                table.namedEntries[name] = entry;
                table.allEntries.push(entry);
            }
            else
                entry = table.namedEntries[name];
        }
        else if(child.matchFilter){
            matchChildren.push(child);
            continue;
        }
        else{
            entry = new AssetTableEntry(child);
            applyMatchEntries(entry, table.matchEntries);
            table.allEntries.push(entry);
        }
        entry.pushPostEntry(child);
    }
    for(var i = 0; i < matchChildren.length; ++i){
        var child = matchChildren[i];
        var matchEntry = {filter: child.matchFilter, subdata: child};
        table.matchEntries.push(matchEntry);
        for(var j = 0; j < table.allEntries.length; ++j){
            applyMatchEntry(table.allEntries[j], matchEntry);
        }
    }
}

function applyMatchEntries(destEntry, matchEntries){
    for(var i = 0; i < matchEntries.length; ++i){
        applyMatchEntry(destEntry, matchEntries[i]);
    }
}

function applyMatchEntry(destEntry, matchEntry){
    var child = matchEntry.subdata;
    if(child.isMesh() == destEntry.isMesh() && matchEntry.filter.check(destEntry)){
        destEntry.pushPostEntry(child);
    }
}


function copySrcTable(table, srcTable, pickFilter){

    if(srcTable.matchEntries.length > 0){
        var i = table.allEntries.length;
        while(i--){
            var entry = table.allEntries[i];
            if(!entry.name || !srcTable.namedEntries[entry.name]){
                applyMatchEntries(entry, srcTable.matchEntries);
            }
        }
    }

    var i = srcTable.allEntries.length;
    while(i--){
        var srcEntry = srcTable.allEntries[i];
        var destEntry, newlyCreated = false;
        if(srcEntry.name && table.namedEntries[srcEntry.name]){
            destEntry = table.namedEntries[srcEntry.name];
        }
        else{
            destEntry = new AssetTableEntry();
            newlyCreated = true;
            table.allEntries.push(destEntry);
        }
        destEntry.pushTableEntry(srcEntry);
        if(newlyCreated)
            applyMatchEntries(destEntry, table.matchEntries);

        if(destEntry.name) table.namedEntries[destEntry.name] = destEntry;
    }

    table.matchEntries.push.apply(table.matchEntries, srcTable.matchEntries);


    var i = srcTable.allSubResults.length;
    while(i--){
        mergeSubAssetResult(table, srcTable.allSubResults[i]);
    }

    if(pickFilter && srcTable.pickFilter){
        table.pickFilter = new AssetPickFilter();
        table.pickFilter.intersection(pickFilter, srcTable.pickFilter);
    }
    else{
        table.pickFilter = pickFilter || srcTable.pickFilter;
    }
    if(srcTable.shader) table.shader = srcTable.shader;
    if(srcTable.transform) table.transform = combineTransform(table.transform, srcTable.transform);
}


function mergeSubAssetResult(table, srcSubTable){
    var destSubTable;
    if(srcSubTable.name && table.namedSubResults[srcSubTable.name]){
        destSubTable = table.namedSubResults[srcSubTable.name];
    }
    else{
        destSubTable = new AssetResult();
        destSubTable.parentResult = table;
        destSubTable.name = srcSubTable.name;
        table.allSubResults.push(destSubTable);
        if(destSubTable.name) table.namedSubResults[destSubTable.name] = destSubTable;
    }
    copySrcTable(destSubTable, srcSubTable, destSubTable.pickFilter);
}

function rec_getDataTree(table){
    var node = {
        meshes: [],
        groups: [],
        transform: table.transform,
        shader: table.shader,
        postTransformXflowNode: null
    };

    for(var i = 0; i < table.allEntries.length; ++i){
        var entry = table.allEntries[i];
        if(entry.meshType && (!table.pickFilter || table.pickFilter.check(entry)) ){
            updateAccumulatedNode(table, entry);
            node.meshes.push({
                xflowNode: entry.accumulatedXflowNode,
                type: entry.meshType,
                shader: entry.shader,
                transform: entry.transform,
                refNode: entry.refNode
            });
        }
    }
    var postTransformEntry = table.namedEntries["_postTransform"];
    if(postTransformEntry){
        updateAccumulatedNode(table, postTransformEntry);
        node.postTransformXflowNode = postTransformEntry.accumulatedXflowNode;
    }
    for(var i = 0; i < table.allSubResults.length; ++i){
        var subNode = rec_getDataTree(table.allSubResults[i]);
        node.groups.push(subNode);
    }
    return node;
}

function updateAccumulatedNode(table, entry){
    if(!entry.outOfSync)
        return;

    if(entry.accumulatedXflowNode){
        entry.accumulatedXflowNode.clearChildren();
        entry.accumulatedXflowNode.setCompute("");
        entry.accumulatedXflowNode.setFilter("");
        entry.accumulatedXflowNode.dataflowNode = null;
        entry.accumulatedXflowNode.setLoading(false);
    }
    else{
        entry.accumulatedXflowNode = new DataNode(false);
    }

    var dataNode = entry.postQueue.length == 1 ? entry.accumulatedXflowNode : new DataNode(false);
    for(var i = 0; i < entry.postQueue.length; ++i){
        var includes = entry.postQueue[i].includes;
        for(var j = 0; j < includes.length; ++j){
            var addEntry = getIncludeEntry(table, includes[j]);
            dataNode.appendChild(addEntry.accumulatedXflowNode);
        }
        if(entry.postQueue[i].xflowNode)
            dataNode.appendChild(entry.postQueue[i].xflowNode);
    }
    var node = dataNode, parentNode = null;
    for(var i = 0; i < entry.postQueue.length; ++i){
        var postEntry = entry.postQueue[i];
        if(!node) node = (i == entry.postQueue.length - 1 ? entry.accumulatedXflowNode : new DataNode(false));
        node.setCompute(postEntry.compute);
        node.setFilter(postEntry.filter);
        node.dataflowNode = postEntry.dataflow;
        node.setLoading(postEntry.dataflowLoading);
        if(parentNode) node.appendChild(parentNode);
        parentNode = node;
        node = null;
    }
    entry.outOfSync = false;
}


var c_accum_entries = [],
    c_accum_names = [];

function getIncludeEntry(table, includeString){
    var segments = includeString.split(".");
    for(var i = 0; i < segments.length -1; ++i){
        var seg = segments[i];
        if(seg == "parent"){
            if(!table.parentResult)
                throw new Error("Includes entry '" + includeString + "' (token "+ i +") accesses non existent parent.");
            table = table.parentResult;
        }
        else{
            if(!table.namedSubResults[seg])
                throw new Error("Includes entry '" + includeString + "' (token "+ i +") accesses non existent sub result '" + seg + "'");
            table = table.namedSubResults[seg];
        }
    }
    var entryKey = segments[segments.length - 1];
    var entry = table.namedEntries[entryKey];
    if(!entry){
        throw new Error("Includes entry '" + includeString + "' accesses non existent asset entry '" + entryKey + "'" );
    }

    c_accum_names.push(includeString);
    if(c_accum_entries.indexOf(entry) != -1){
        var path = c_accum_names.join(" > ");
        throw new Error("Recursive include dependencies detected: " + path);
    }
    c_accum_entries.push(entry);

    updateAccumulatedNode(table, entry);
    c_accum_entries.pop();
    c_accum_names.pop();
    return entry;
}




function AssetTableEntry (subData){
    this.name = null;
    this.classNames = [];
    this.meshType = null;

    this.postQueue = [];
    this.shader = null;
    this.transform = null;

    this.accumulatedXflowNode = null;
    this.outOfSync = true;
    this.refNode = null;
    if(subData){
        this.name = subData.name;
        Set.add(this.classNames, subData.classNames);
    }
}

AssetTableEntry.prototype.isMesh = function(){
    return !!this.meshType;
};

AssetTableEntry.prototype.pushTableEntry = function(srcEntry){
    this.name = srcEntry.name;
    Set.add(this.classNames, srcEntry.classNames);
    if(srcEntry.meshType) this.meshType = srcEntry.meshType;

    if(srcEntry.transform) this.transform = combineTransform(this.transform, srcEntry.transform);
    if(srcEntry.shader) this.shader = srcEntry.shader;

    this.postQueue.push.apply(this.postQueue, srcEntry.postQueue);
};


AssetTableEntry.prototype.pushPostEntry = function(subData){
    this.name = subData.name;
    this.postQueue.push({
        dataflow: subData.postDataflow,
        dataflowLoading: subData.loading,
        compute: subData.postCompute,
        filter: subData.postFilter,
        includes: subData.includes,
        xflowNode: subData.xflowNodeIn
    });
    this.refNode = subData.refNode;
    this.accumulatedXflowNode = subData.xflowNodeOut;
    Set.add(this.classNames, subData.classNames);
    if(subData.meshType) this.meshType = subData.meshType;
    if(subData.shader) this.shader = subData.shader;
    if(subData.transform) this.transform = combineTransform(this.transform, subData.transform);
};


function combineTransform(oldTransform, newTransform){
    // TODO: Better multiply transformations here
    return newTransform;
}


function AssetPickFilter(){
    this.all = false;
    this.names = [];
    this.classNames = [];
}

AssetPickFilter.prototype.parse = function(string){
    var entries = string.split(",");
    var i = entries.length;
    while(i--){
        var entry = entries[i].trim();
        if(entry == "*"){
            this.all = true;
        }
        else if(entry.indexOf(".") == 0){
            var classNames = entry.split(".");
            var j = classNames.length;
            while(j--){
                if(!classNames[j].trim())
                    classNames.splice(j,1);
            }
            this.classNames.push(classNames);
        }
        else{
            Set.add(this.names, entry);
        }
    }
};

AssetPickFilter.prototype.intersection = function(setA, setB){
    Set.intersection(this.names, setA.names, setB.names);
    Set.intersection(this.classNames, setA.classNames, setB.classNames);
};

AssetPickFilter.prototype.check = function(entry){
    if(this.all)
        return true;
    if(entry.classNames.length > 0){
        var i = this.classNames.length;
        while(i--){
            if(Set.isSubset(this.classNames[i], entry.classNames))
                return true;
        }
    }
    return (entry.name && this.names.indexOf(entry.name) != -1);
};

module.exports = {
    Asset: Asset,
    SubData: SubData,
    AssetResult: AssetResult
};

},{"../xflow/interface/graph.js":138,"../xflow/utils/utils.js":187}],7:[function(require,module,exports){
var registerFactory = require("./resourcemanager.js").registerFactory;
var Resource = require("./resourcemanager.js").Resource;
var Events = require("../interface/notification.js");
var config = require("../interface/elements.js").config;

/**
 * A normal adapter that doesn't need to be connected to a DOM node
 * @constructor
 * @param {XML3D.base.AdapterFactory} factory - the factory this adapter was created from
 */
var Adapter = function(factory) {
    this.factory = factory;
};

/**
 * Connect an adapterHandle to a certain key.
 * This will enable the ConnectedAdapterNotifcations for notifyChanged.
 * @param {string} key - the key that will also be provided in connectAdapterChanged callback
 * @param {XML3D.base.AdapterHandle} adapterHandle handle of adapter to be added
 */
Adapter.prototype.connectAdapterHandle = function(key, adapterHandle) {
    if (!this.connectedAdapterHandles) {
        this.connectedAdapterHandles = {};
        this._bindedAdapterHandleCallback = adapterHandleCallback.bind(this);
    }

    this.disconnectAdapterHandle(key);

    if (adapterHandle) {
        this.connectedAdapterHandles[key] = adapterHandle;
        this.connectedAdapterHandles[key].addListener(this._bindedAdapterHandleCallback);
    }
    else
        delete this.connectedAdapterHandles[key];

};

/**
 * Disconnects the adapter handle from the given key.
 * @param {string} key - the key that was provided when this adapter handle was connected
 */
Adapter.prototype.disconnectAdapterHandle = function(key) {
    if (this.connectedAdapterHandles && this.connectedAdapterHandles[key]) {
        this.connectedAdapterHandles[key].removeListener(this._bindedAdapterHandleCallback);
        delete this.connectedAdapterHandles[key];
    }
};

/**
 * Disconnects all adapter handles.
 */
Adapter.prototype.clearAdapterHandles = function() {
    for (var i in this.connectedAdapterHandles) {
        this.connectedAdapterHandles[i].removeListener(this._bindedAdapterHandleCallback);
    }

    this.connectedAdapterHandles = null;
};

/**
 * Get the connected AdapterHandle of a certain key.
 * This will only return AdapterHandles previously added via connectAdapterHandle
 * @param {string} key
 * @return {?AdapterHandle} the adapter of that key, or null if not available
 */
Adapter.prototype.getConnectedAdapterHandle = function(key) {
    return this.connectedAdapterHandles && this.connectedAdapterHandles[key];
};

/**
 * Get the connected adapter of a certain key.
 * This will only return adapters of AdapterHandles previously added via connectAdapter
 * @param {string} key
 * @return {?XML3D.base.Adapter} the adapter of that key, or null if not available
 */
Adapter.prototype.getConnectedAdapter = function(key) {
    var handle = this.getConnectedAdapterHandle(key);
    return handle && handle.getAdapter();
};

/**
 * This function is called, when the adapater is detached from the node.
 * At this point, the adapater should disconnect from any other adapter and prepare to be properly garbage collected
 */
Adapter.prototype.onDispose = function() {
};


/**
 * Internal function that converts an AdapterHandleNotification to a ConnectedAdapterNotification
 * @private
 * @param {Events.AdapterHandleNotification} evt
 */
function adapterHandleCallback(evt) {
    for (var key in this.connectedAdapterHandles) {
        if (this.connectedAdapterHandles[key] == evt.adapterHandle) {
            var subEvent = new Events.ConnectedAdapterNotification(evt, key);
            this.notifyChanged(subEvent);
        }
    }
}


/**
 * An Adapter connected to a DOMNode (possibly of an external document)
 * @constructor
 * @param {AdapterFactory} factory the AdapterFactory this adapter was created from
 * @param {Object} node - DOM node of this Adapter
 */
var NodeAdapter = function(factory, node) {
    Adapter.call(this, factory);
    this.node = node;
};
XML3D.createClass(NodeAdapter, Adapter);

/**
 * called by the factory after adding the adapter to the node
 */
NodeAdapter.prototype.init = function() {
};

/**
 * Notifiction due to a change in DOM, related adapters and so on.
 * @param {Events.Notification} e
 */
NodeAdapter.prototype.notifyChanged = function(e) {

};

/**
 * @param {string|XML3D.URI} uri Uri to referred adapterHandle
 * @param {Object=} aspectType Optional: the type of adapter (use same adapter type by default)
 * @param {number=} canvasId Optional: the canvas id of the adapter (use canvas id of this adapter by default)
 * @returns an AdapterHandle to the referred Adapter of the same aspect and canvasId
 */
NodeAdapter.prototype.getAdapterHandle = function(uri, aspectType, canvasId) {
    canvasId = canvasId === undefined ? this.factory.canvasId : canvasId;
    return Resource.getAdapterHandle(this.node.ownerDocument._documentURL || this.node.ownerDocument.URL,
        uri, aspectType || this.factory.aspect, canvasId);
};
/**
 * notifies all adapter that refer to this adapter through AdapterHandles.
 * @param {number?} type The type of change
 */
NodeAdapter.prototype.notifyOppositeAdapters = function(type) {
    type = type || Events.ADAPTER_HANDLE_CHANGED;
    return Resource.notifyNodeAdapterChange(this.node,
        this.factory.aspect, this.factory.canvasId, type);
};

/**
 * Depth-first traversal over element hierarchy
 * @param {function(NodeAdapter)} callback
 */
NodeAdapter.prototype.traverse = function(callback) {
    callback(this);
    var child = this.node.firstElementChild;
    while (child) {
        var adapter = this.factory.getAdapter(child);
        adapter && adapter.traverse(callback);
        child = child.nextElementSibling;
    }
};


/**
 * @interface
 */
var IFactory = function() {
};

/** @type {string} */
IFactory.prototype.aspect;


/**
 * An adapter factory is responsible for creating adapter from a certain data source.
 * Note that any AdapterFactory is registered with Resource
 * @constructor
 * @implements {IFactory}
 * @param {Object} aspect The aspect this factory serves (e.g. XML3D.data or XML3D.webgl)
 * @param {string|Array.<string>} mimetypes The mimetype this factory is compatible to
 * @param {number} canvasId The id of the corresponding canvas handler. 0, if not dependent on any GLCanvasHandler
 */
var AdapterFactory = function(aspect, mimetypes, canvasId) {
    this.aspect = aspect;
    this.canvasId = canvasId || 0;
    this.mimetypes = typeof mimetypes == "string" ? [ mimetypes] : mimetypes;

    registerFactory(this);
};

 /** Implemented by subclass
 * Create adapter from an object (node in case of an xml, and object in case of json)
 * @param {object} obj
 * @returns {?Adapter} created adapter or null if no adapter can be created
 */
AdapterFactory.prototype.createAdapter = function(obj) {
    return null;
};

/**
 * Checks if the adapter factory supports specified mimetype. Can be overridden by subclass.
 * @param {String} mimetype
 * @return {Boolean} true if the adapter factory supports specified mimetype
 */
AdapterFactory.prototype.supportsMimetype = function(mimetype) {
    return this.mimetypes.indexOf(mimetype) != -1;
};

/**
 * A NodeAdaperFactory is a AdapterFactory, that works specifically for DOM nodes / elements.
 * @constructor
 * @param {Object} aspect The aspect this factory serves (e.g. XML3D.data or XML3D.webgl)
 * @param {number} canvasId The id of the corresponding canvas handler. 0, if not dependent on any GLCanvasHandler
 */
var NodeAdapterFactory = function(aspect, canvasId) {
    AdapterFactory.call(this, aspect, ["text/xml", "application/xml"], canvasId);
};
XML3D.createClass(NodeAdapterFactory, AdapterFactory);

/**
 * This function first checks, if an adapter has been already created for the corresponding node
 * If yes, this adapter is returned, otherwise, a new adapter is created and returned.
 * @param {Object} node
 * @returns {Adapter} The adapter of the node
 */
NodeAdapterFactory.prototype.getAdapter = function(node) {
    if(node && node._configured === undefined)
        config.element(node);
    if (!node || node._configured === undefined)
        return null;

    var elemHandler = node._configured;
    var key = this.aspect + "_" + this.canvasId;
    var adapter = elemHandler.adapters[key];
    if (adapter !== undefined)
        return adapter;

    // No adapter found, try to create one
    adapter = this.createAdapter(node);
    if (adapter) {
        elemHandler.adapters[key] = adapter;
        adapter.init();
    }
    return adapter;
};

XML3D.resource.AdapterFactory = AdapterFactory;

module.exports = {
NodeAdapter : NodeAdapter,
AdapterFactory : AdapterFactory,
NodeAdapterFactory : NodeAdapterFactory
};

},{"../interface/elements.js":34,"../interface/notification.js":36,"./resourcemanager.js":10}],8:[function(require,module,exports){
var Events = require("../interface/notification.js");

"use strict";
/**
 * An adapter handle is a connection piece for an adapter that is referred through a uri (e.g. id reference)
 * AdapterHandles are always fetched from the Resource object
 * @constructor
 */
var AdapterHandle = function(url) {
    this.url = url;
    this.adapter = null;
    this.listeners = [];
    this.status = 0; // STATUS.LOADING
};

/**
 * Enumaeration of states for the adapter handle
 * @enum {number}
 */
AdapterHandle.STATUS = {
    LOADING: 0,
    NOT_FOUND: 1,
    READY: 2
};

/**
 * @returns {Boolean} true iff an adapter is available
 */
AdapterHandle.prototype.hasAdapter = function() {
    return this.adapter != null;
};

/**
 * @returns {?XML3D.base.Adapter} the adapter connected to the handle. Can be null
 */
AdapterHandle.prototype.getAdapter = function() {
    return this.adapter;
};

/**
 * Note: this function should only be called by Resource
 * @param {XML3D.base.Adapter} adapter The adapter connected to the AdapterHandler
 * @param {AdapterHandle.STATUS} status
 */
AdapterHandle.prototype.setAdapter = function(adapter, status) {
    this.adapter = adapter;
    this.status = status;
    this.notifyListeners(Events.ADAPTER_HANDLE_CHANGED);
};

/**
 * This function is called to notify all listeners of this AdapterHandle about some change.
 * @param {number} type A type number with the type of change (usually Events.ADAPTER_HANDLE_CHANGED)
 */
AdapterHandle.prototype.notifyListeners = function(type) {
    var event = new Events.AdapterHandleNotification(this, type);
    var i = this.listeners.length;
    while (i--) {
        this.listeners[i](event);
    }
};

/**
 * Add a listener to the AdapterHandle that is notified about changes.
 * Listeners cannot be inserted twice.
 * @param {Function} listener - Function to be called when something concering the adapter changes
 */
AdapterHandle.prototype.addListener = function(listener) {
    var idx = this.listeners.indexOf(listener);
    if (idx == -1)
        this.listeners.push(listener);
};

/**
 * Remove a listener from the AdapterHandle
 * @param {Function} listener
 */
AdapterHandle.prototype.removeListener = function(listener) {
    var idx = this.listeners.indexOf(listener);
    if (idx != -1)
        this.listeners.splice(idx, 1);
};

module.exports = AdapterHandle;
},{"../interface/notification.js":36}],9:[function(require,module,exports){
var AdapterFactory = require("./adapter.js").AdapterFactory;
var registerFormat = require("./resourcemanager.js").registerFormat;
var config = require("../interface/elements.js").config;

/**
 * A format handler is provide functionality for detecting format of resources
 * and providing format-specific services.
 * FormatHandlers are registered with XML3D.base.registerFormat() function.
 * @constructor
 */
var FormatHandler = function() {
    this.factoryClasses = {}; // a map from an aspect name to a factory class
    this.factoryCache = {}; // maps unique keys (aspect + "_" + canvasId) to the factory instance
};

FormatHandler.prototype.registerFactoryClass = function (factoryClass) {
    if (!factoryClass.prototype.aspect || !XML3D.isSuperclassOf(AdapterFactory, factoryClass))
        throw new Error("factoryClass must be a subclass of XML3D.base.AdapterFactory");
    this.factoryClasses[factoryClass.prototype.aspect] = factoryClass;
};

FormatHandler.prototype.getFactoryClassByAspect = function (aspect) {
    return this.factoryClasses[aspect];
};

FormatHandler.prototype.getFactory = function (aspect, canvasId) {
    canvasId = canvasId || 0;
    var key = aspect + "_" + canvasId;
    var factory = this.factoryCache[key];
    if (!factory) {
        var factoryClass = this.getFactoryClassByAspect(aspect);
        if (!factoryClass)
            return null;
        factory = new factoryClass(canvasId);
        this.factoryCache[key] = factory;
    }
    return factory;
};

//noinspection JSUnusedLocalSymbols
/**
 * Returns true if response data format is supported.
 * response, responseType, and mimetype values are returned by XMLHttpRequest.
 * Data type of the response is one of ArrayBuffer, Blob, Document, String, Object.
 * responseType is one of "", "arraybuffer", "blob", "document", "json", "text"
 *
 * @override
 * @param {Object} response
 * @param {string} responseType
 * @param {string} mimetype
 * @return {Boolean}
 */
FormatHandler.prototype.isFormatSupported = function (response, responseType, mimetype) {
    return false;
};

/**
 * Converts response data to format data.
 * Default implementation returns value of response.
 *
 * @override
 * @param {Object} response
 * @param {string} responseType
 * @param {string} mimetype
 * @param {function} callback
 * @return {Object}
 */
FormatHandler.prototype.getFormatData = function (response, responseType, mimetype, callback) {
    callback(true, response);
};

/**
 * Extracts data for a fragment from document data and fragment reference.
 *
 * @override
 * @param {Object} documentData
 * @param {string} fragment Fragment without pound key which defines the part of the document
 * @return {*}
 */
FormatHandler.prototype.getFragmentData = function (documentData, fragment) {
    if (!fragment)
        return documentData;
    return null;
};

/**
 * XMLFormatHandler supports all XML and HTML-based documents.
 * @constructor
 * @extends FormatHandler
 */
var XMLFormatHandler = function () {
    FormatHandler.call(this);
};
XML3D.createClass(XMLFormatHandler, FormatHandler);

XMLFormatHandler.prototype.isFormatSupported = function (response, responseType, mimetype) {
    return response && response.nodeType === 9 && (mimetype.match(/xml/));
};

XMLFormatHandler.prototype.getFormatData = function (response, responseType, mimetype, callback) {
    callback(true, response);
};

XMLFormatHandler.prototype.getFragmentData = function (documentData, fragment) {
    return documentData.querySelectorAll("*[id='" + fragment + "']")[0];
};


/**
 *
 * @constructor
 * @extends FormatHandler
 */
var XML3DFormatHandler = function () {
    XMLFormatHandler.call(this);
};
XML3D.createClass(XML3DFormatHandler, XMLFormatHandler);

XML3DFormatHandler.prototype.isFormatSupported = function (response, responseType, mimetype) {
    var xml3ds = [];
    if (response instanceof XMLDocument) {
        xml3ds = response.getElementsByTagName("xml3d");
        if (!xml3ds.length) {
            // Also check cases where the XML3D element may have been fitted with a NS prefix (eg. ns1:xml3d)
            xml3ds = response.getElementsByTagNameNS(XML3D.xml3dNS, "xml3d");
        }
    }
    return xml3ds.length !== 0;
};

XML3DFormatHandler.prototype.getFormatData = function (response, responseType, mimetype, callback) {
    // Configure all xml3d elements:
    var xml3dElements = response.querySelectorAll("xml3d");
    for (var i = 0; i < xml3dElements.length; ++i) {
        config.element(xml3dElements[i]);
    }
    callback(true, response);
};

/**
 * @constructor
 * @extends FormatHandler
 */
var JSONFormatHandler = function () {
    FormatHandler.call(this);
};
XML3D.createClass(JSONFormatHandler, FormatHandler);

JSONFormatHandler.prototype.isFormatSupported = function (response, responseType, mimetype) {
    return mimetype === "application/json";
};

var xml3dFormatHandler = new XML3DFormatHandler();
registerFormat(xml3dFormatHandler);
XML3D.xml3dFormatHandler = xml3dFormatHandler;
XML3D.resource.FormatHandler = FormatHandler;
XML3D.resource.JSONFormatHandler = JSONFormatHandler;

module.exports = {
    JSONFormatHandler: JSONFormatHandler,
    XMLFormatHandler: XMLFormatHandler,
    XML3DFormatHandler: XML3DFormatHandler,
    FormatHandler: FormatHandler,
    xml3dFormatHandler: xml3dFormatHandler
};
},{"../interface/elements.js":34,"./adapter.js":7,"./resourcemanager.js":10}],10:[function(require,module,exports){
"use strict";

var AdapterHandle = require("./adapterhandle.js");
var URIResolver = require("../utils/uri.js").URIResolver;
var URI = require("../utils/uri.js").URI;
var Options = require("../utils/options.js");

var OPTION_RESOURCE_CORS = "resource-crossorigin-attribute";
Options.register(OPTION_RESOURCE_CORS, "anonymous");

var c_cachedDocuments = {};
var c_factories = {};
var c_cachedAdapterHandles = {};
var c_canvasIdCounters = {};
var c_formatHandlers = [];

var c_binaryContentTypes = ["application/octet-stream", "text/plain; charset=x-user-defined"];
var c_binaryExtensions = [".bin", ".bson"];

/**
 * Register a factory with the resource manager
 * @param {AdapterFactory} factory - the factory to be registered
 */
var registerFactory = function(factory) {
    var canvasId = factory.canvasId;
    if (!c_factories[canvasId])
        c_factories[canvasId] = [];
    c_factories[canvasId].push(factory);
};

var registerFormat = function(formatHandler) {
    if (formatHandler)
        c_formatHandlers.push(formatHandler);
};

var findFormat = function(response, responseType, mimetype) {
    for (var i = 0; i < c_formatHandlers.length; ++i) {
        var formatHandler = c_formatHandlers[i];
        if (c_formatHandlers[i].isFormatSupported(response, responseType, mimetype)) {
            return formatHandler;
        }
    }
    return null;
};

/**
 * @constructor
 */
var Resource = {};

function getCounterObject(canvasId) {
    return c_canvasIdCounters[canvasId];
}

function getOrCreateCounterObject(canvasId) {
    var counterObject = c_canvasIdCounters[canvasId];
    if (!counterObject) {
        counterObject = {counter: 0, listeners: []};
        c_canvasIdCounters[canvasId] = counterObject;
    }
    return counterObject;
}

function notifyLoadCompleteListeners(counterObject) {
    var listeners = counterObject.listeners;
    //counterObject.listeners = new Array();
    var i = listeners.length;
    while (i--) {
        listeners[i](this);
    }
}

function loadComplete(canvasId) {
    // notify all load complete listeners
    var counterObject = getCounterObject(canvasId);
    if (counterObject) {
        XML3D.debug.assert(counterObject.counter > 0, "counter must be > 0");
        counterObject.counter--;
        if (counterObject.counter == 0) {
            notifyLoadCompleteListeners(counterObject);
        }
    }
}

Resource.isLoadComplete = function(canvasId) {
    var counterObject = getCounterObject(canvasId);
    return !counterObject || counterObject.counter == 0;
};

/*
 * Register listener that will be fired when all resources for specified canvasId are loaded.
 * Listener is fired only once.
 *
 * @param {number} canvasId
 * @param {EventListener} listener
 */
Resource.addLoadCompleteListener = function(canvasId, listener) {
    var counterObject = getOrCreateCounterObject(canvasId);

    /*
    if (counterObject === undefined || counterObject.counter == 0) {
        listener(canvasId);
        return;
    }
    */

    var idx = counterObject.listeners.indexOf(listener);
    if (idx == -1) {
        counterObject.listeners.push(listener);
    }
};

//noinspection JSUnusedGlobalSymbols
/**
 *
 * @param {number} canvasId
 * @param {function} listener
 */
Resource.removeLoadCompleteListener = function(canvasId, listener) {
    var counterObject = getCounterObject(canvasId);
    if (counterObject) {
        var idx = counterObject.listeners.indexOf(listener);
        if (idx != -1)
            counterObject.listeners.splice(idx, 1);
    }
};


function stringEndsWithSuffix(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
}

//noinspection JSUnusedGlobalSymbols
Resource.addBinaryContentType = function(type) {
    if (c_binaryContentTypes.indexOf(type) == -1)
        c_binaryContentTypes.push(type);
};

//noinspection JSUnusedGlobalSymbols
Resource.removeBinaryContentType = function(type) {
    var idx = c_binaryContentTypes.indexOf(type);
    if (idx != -1)
        c_binaryContentTypes.splice(idx, 1);
};

function isBinaryContentType(contentType) {
    for (var i in c_binaryContentTypes) {
        if (contentType == c_binaryContentTypes[i]) {
            return true;
        }
    }
    return false;
}

Resource.addBinaryExtension = function(extension) {
    if (c_binaryExtensions.indexOf(extension) == -1)
        c_binaryExtensions.push(extension);
};

//noinspection JSUnusedGlobalSymbols
Resource.removeBinaryExtension = function(extension) {
    var idx = c_binaryExtensions.indexOf(extension);
    if (idx != -1)
        c_binaryExtensions.splice(idx, 1);
};

function isBinaryExtension(url) {
    for (var i in c_binaryExtensions) {
        if (stringEndsWithSuffix(url, c_binaryExtensions[i]))
            return true;
    }
    return false;
}

/**
 * Load a document via XMLHttpRequest
 * @private
 * @param {string} url URL of the document
 */
function loadDocument(url) {
    var xmlHttp = null;
    try {
        xmlHttp = new XMLHttpRequest();
    } catch (e) {
        xmlHttp = null;
    }
    if (xmlHttp) {
        xmlHttp._url = url;
        xmlHttp._contentChecked = false;
        xmlHttp.open('GET', url, true);
        if (isBinaryExtension(url))
            xmlHttp.responseType = "arraybuffer";

        xmlHttp.onreadystatechange = function() {
            if (xmlHttp._aborted) // This check is possibly not needed
                return;
            // check compatibility between content and request mode
            if (!xmlHttp._contentChecked &&
                // 2 - HEADERS_RECEIVED, 3 - LOADING, 4 - DONE
                ((xmlHttp.readyState == 2 || xmlHttp.readyState == 3 || xmlHttp.readyState == 4) &&
                    xmlHttp.status == 200)) {
                xmlHttp._contentChecked = true; // we check only once
                // check if we need to change request mode
                var contentType = xmlHttp.getResponseHeader("content-type");
                if (contentType) {
                    var binaryContent = isBinaryContentType(contentType);
                    var binaryRequest = (xmlHttp.responseType == "arraybuffer");
                    // When content is not the same as request, we need to repeat request
                    if (binaryContent != binaryRequest) {
                        xmlHttp._aborted = true;
                        var cb = xmlHttp.onreadystatechange;
                        xmlHttp.onreadystatechange = null;
                        var url = xmlHttp._url;
                        xmlHttp.abort();

                        // Note: We do not recycle XMLHttpRequest !
                        //       This does work only when responseType is changed to "arraybuffer",
                        //       however the size of the xmlHttp.response buffer is then wrong !
                        //       It does not work at all (at least in Chrome) when we use overrideMimeType
                        //       with "text/plain; charset=x-user-defined" argument.
                        //       The latter mode require creation of the fresh XMLHttpRequest.

                        xmlHttp = new XMLHttpRequest();
                        xmlHttp._url = url;
                        xmlHttp._contentChecked = true;
                        xmlHttp.open('GET', url, true);
                        if (binaryContent)
                            xmlHttp.responseType = "arraybuffer";
                        xmlHttp.onreadystatechange = cb;
                        xmlHttp.send(null);
                        return;
                    }
                }
            }
            // Request mode and content type are compatible here (both binary or both text)
            if (xmlHttp.readyState == 4) {
                if (xmlHttp.status == 200) {
                    XML3D.debug.logDebug("Loaded: " + xmlHttp._url);
                    XML3D.xmlHttpCallback && XML3D.xmlHttpCallback(xmlHttp);
                    processResponse(xmlHttp);
                }
                else {
                    XML3D.debug.logError("Could not load external document '" + xmlHttp._url +
                        "': " + xmlHttp.status + " - " + xmlHttp.statusText);
                    invalidateDocumentHandles(xmlHttp._url);
                }
            }
        };
        xmlHttp.send(null);
    }
}
/**
 * Process response of ajax request from loadDocument()
 * @private
 * @param {XMLHttpRequest} httpRequest
 */
function processResponse(httpRequest) {
    var mimetype = httpRequest.getResponseHeader("content-type");
    if (!mimetype) {
        XML3D.debug.logError("Could not load external document because the server did not provide a content-type header: "+httpRequest._url);
        invalidateDocumentHandles(httpRequest._url);
        return;
    }
    setDocumentData(httpRequest, httpRequest._url, mimetype);
}
/**
 * Initialize data of a received document
 * @private
 * @param {XMLHttpRequest} httpRequest The XMLHttpRequest of the loaded document
 * @param {string} url URL of the loaded document
 * @param {string} mimetype The mimetype of the loaded document
 */
function setDocumentData(httpRequest, url, mimetype) {
    var docCache = c_cachedDocuments[url];
    docCache.mimetype = mimetype;

    var cleanedMimetype = mimetype;

    if (mimetype.indexOf(';') > 0)
        cleanedMimetype = mimetype.substr(0, mimetype.indexOf(';'));

    var response = null;
    if (httpRequest.responseType == "arraybuffer") {
        response = httpRequest.response;
    } else if (cleanedMimetype == "application/json") {
        response = JSON.parse(httpRequest.responseText);
    } else if (cleanedMimetype.match(/xml/)) {
        response = httpRequest.responseXML;
        //Workaround for IE "bug" where external documents always report their document.URL as being identical to window.location.href
        response._documentURL = url;
        if (!response) {
            XML3D.debug.logError("Invalid external XML document '" + httpRequest._url +
                "': XML Syntax error");
            return;
        }
    } else if (cleanedMimetype == "application/octet-stream" || mimetype == "text/plain; charset=x-user-defined") {
        XML3D.debug.logError("Possibly wrong loading of resource " + url + ". Mimetype is " + mimetype + " but response is not an ArrayBuffer");
        response = httpRequest.response;
    } else if (cleanedMimetype == "application/javascript" || mimetype == "text/javascript") {
        response = httpRequest.response;
    }else {
        XML3D.debug.logError("Unidentified response type (response = '" + httpRequest.response + "', responseType = '" + httpRequest.responseType + "')");
        response = httpRequest.response;
    }

    var formatHandler = findFormat(response, httpRequest.responseType, cleanedMimetype);
    if (!formatHandler) {
        XML3D.debug.logError("No format handler for resource (response = '" + response + "', responseType = '" + httpRequest.responseType + "')");
        invalidateDocumentHandles(url);
        return;
    }
    docCache.format = formatHandler;
    formatHandler.getFormatData(response, httpRequest.responseType, cleanedMimetype, function(success, result){
        if(success){
            docCache.response = result;
            updateDocumentHandles(url)
        }
        else{
            invalidateDocumentHandles(url);
        }
    } );

}

/**
 * Update all existing handles of a received document
 * @param {string} url The URL of the document
 */
function updateDocumentHandles(url) {
    var docCache = c_cachedDocuments[url];
    var fragments = docCache.fragments;
    docCache.fragments = [];
    for (var i = 0; i < fragments.length; ++i) {
        updateExternalHandles(url, fragments[i]);
    }
}

/**
 * Invalidate all handles of a document, that could not be loaded.
 * @param {string} url The URL of the document
 */
function invalidateDocumentHandles(url) {
    var docCache = c_cachedDocuments[url];
    var fragments = docCache.fragments;
    docCache.fragments = [];
    for (var i = 0; i < fragments.length; ++i) {
        var fullUrl = url + (fragments[i] ? "#" + fragments[i] : "");
        invalidateHandles(fullUrl);
    }
}

/**
 * Update all handles of a part from an external document
 * @param {string} url The URL of the document
 * @param {string} fragment Fragment without pound key which defines the part of the document
 */
function updateExternalHandles(url, fragment) {

    var response = c_cachedDocuments[url].response;
    var mimetype = c_cachedDocuments[url].mimetype;
    var format = c_cachedDocuments[url].format;

    var fullUrl = url + (fragment ? "#" + fragment : "");
    if (!response) {
        // In the case the loaded document is not supported we still need to decrement counter object
        invalidateHandles(fullUrl);
        return;
    }

    // get part of the resource represented by the fragment
    var data = format.getFragmentData(response, fragment);

    if (data) {
        updateMissingHandles(fullUrl, format, data);
    }
    else {
        invalidateHandles(fullUrl);
    }
}


/**
 * Update all AdapterHandles without adapters of a certain url
 * @param {string} url The complete url + fragment
 * @param {FormatHandler} formatHandler Format handler
 * @param {Object} data Data of the document corresponding to the url. Possibly a DOM element
 * @param {boolean?} localChange If true, then this is about a local id change. do not call loadComplete
 */
function updateMissingHandles(url, formatHandler, data, localChange) {
    for (var adapterType in c_cachedAdapterHandles[url]) {
        for (var canvasId in c_cachedAdapterHandles[url][adapterType]) {
            var handle = c_cachedAdapterHandles[url][adapterType][canvasId];
            if (!handle.hasAdapter()) {
                updateHandle(handle, adapterType, +canvasId, formatHandler, data);
                if(!localChange) loadComplete(canvasId);
            }
        }
    }
}

/**
 * Invalidate all AdapterHandles without adapters of a certain url
 * @param {string} url The complete url + fragment
 */
function invalidateHandles(url) {
    for (var adapterType in c_cachedAdapterHandles[url]) {
        for (var canvasId in c_cachedAdapterHandles[url][adapterType]) {
            var handle = c_cachedAdapterHandles[url][adapterType][canvasId];
            handle.setAdapter(null, AdapterHandle.STATUS.NOT_FOUND);
            loadComplete(canvasId);
        }
    }
}

/**
 * Update a specific AdapterHandle with the provided data.
 * Internally an adapter will be created with 'data' and added to 'handle'
 * All other argument are required to find the correct factory
 * @param {AdapterHandle} handle The AdapterHandle to be updated
 * @param {Object} adapterType The type / aspect of the adapter (e.g. XML3D.data or XML3D.webgl)
 * @param {number} canvasId Id of corresponding canvas handler. 0 if not dependent of canvas handler
 * @param {FormatHandler} format Format handler of the corresponding document
 * @param {Object} data Data for this handle. Possibly a DOM element
 */
function updateHandle(handle, adapterType, canvasId, format, data) {

    var factory = format.getFactory(adapterType, canvasId);

    if(!factory) {
        XML3D.debug.logError("Format does not support adapterType " + adapterType);
        return;
    }

    var adapter = factory.getAdapter ? factory.getAdapter(data) : factory.createAdapter(data);
    if (adapter) {
        handle.setAdapter(adapter, AdapterHandle.STATUS.READY);
    }


}

/**
 * Remove the adapter of all AdapterHandles corresponding to the given URL.
 * This is called e.g. when a node is remove from the document, or an id changes
 * @param {string} url The URL of all AdapterHandles to be cleared.
 */
function clearHandles(url) {
    for (var adapterType in c_cachedAdapterHandles[url]) {
        for (var canvasId in c_cachedAdapterHandles[url][adapterType]) {
            var handle = c_cachedAdapterHandles[url][adapterType][canvasId];
            if (handle.hasAdapter()) {
                handle.setAdapter(null, AdapterHandle.STATUS.NOT_FOUND);
            }
        }
    }
}

/**
 * This methods returns an absolute URI compatible with the resource manager.
 * This means: Any reference from an external document will be absolute and any id reference from the current
 * document will remain an id reference.
 * @param {String} baseURI - the base URI that the uri is relative to
 * @param {URI} uri - The URI used to find the referred AdapterHandle. Can be relative
 * @returns {URI} The (sometimes) absolute URI
 */
Resource.getAbsoluteURI = function(baseURI, uri){
    if (!uri)
        return null;

    if (typeof uri == "string") uri = new URI(uri);
    if (baseURI != document.URL || !uri.isLocal()) {
        uri = uri.getAbsoluteURI(baseURI);
    }
    return uri;
};

/**
 * Get any adapter, internal or external.
 * This function will trigger the loading of documents, if required.
 * An AdapterHandle will be always be returned, expect when an invalid (empty) uri is passed.
 *
 * @param {String} baseURI - the base URI from which to look up the reference
 * @param {URI} uri - The URI used to find the referred AdapterHandle. Can be relative
 * @param {Object} adapterType The type of adapter required (e.g. XML3D.data or XML3D.webgl)
 * @param {number=} canvasId Id of GLCanvasHandler handler this adapter depends on, 0 if not depending on any GLCanvasHandler
 * @returns {?AdapterHandle} The requested AdapterHandler. Note: might be null
 */
Resource.getAdapterHandle = function(baseURI, uri, adapterType, canvasId) {
    canvasId = canvasId || 0;
    uri = Resource.getAbsoluteURI(baseURI, uri);

    if (!uri)
        return null;

    if (!c_cachedAdapterHandles[uri])
        c_cachedAdapterHandles[uri] = {};

    if (!c_cachedAdapterHandles[uri][adapterType]) {
        c_cachedAdapterHandles[uri][adapterType] = {};
    }

    var handle = c_cachedAdapterHandles[uri][adapterType][canvasId];
    if (handle)
        return handle;

    handle = new AdapterHandle(uri);
    c_cachedAdapterHandles[uri][adapterType][canvasId] = handle;

    if (uri.isLocal()) {
        var node = URIResolver.resolveLocal(uri);
        if (node)
            updateHandle(handle, adapterType, canvasId, XML3D.xml3dFormatHandler, node);
        else
            handle.setAdapter(null, AdapterHandle.STATUS.NOT_FOUND);
    }
    else {
        var counterObject = getOrCreateCounterObject(canvasId);
        counterObject.counter++;

        var docURI = uri.toStringWithoutFragment();
        var docData = c_cachedDocuments[docURI];
        if (docData && docData.response) {
            updateExternalHandles(docURI, uri.fragment);
        } else {
            if (!docData) {
                loadDocument(docURI);
                c_cachedDocuments[docURI] = docData = {
                    fragments: []
                };
            }
            docData.fragments.push(uri.fragment);
        }
    }
    return handle;
};

/**
 * Get any adapter, internal or external.
 *
 * @param node
 * @param adapterType
 * @param canvasId
 * @return {XML3D.base.Adapter?}
 */
Resource.getAdapter = function(node, adapterType, canvasId) {
    var factory = XML3D.xml3dFormatHandler.getFactory(adapterType, canvasId);
    if (factory) {
        return factory.getAdapter(node);
    }
    return null;
};

/**
 * This function is called when an id of an element changes or if that element is now reachable
 * or not reachable anymore. It will update all AdapterHandles connected to the element.
 * @param {Element} node Element of which id has changed
 * @param {string} previousId Previous id of element
 * @param {string} newId New id of element
 */
Resource.notifyNodeIdChange = function(node, previousId, newId) {
    var parent = node;
    while (parent.parentNode) parent = parent.parentNode;
    if (parent != window.document)
        return;

    // clear cached adapters of previous id"
    if (previousId) {
        clearHandles("#" + previousId);
    }
    if (newId) {
        updateMissingHandles("#" + newId, XML3D.xml3dFormatHandler, node, true);
    }
};

/**
 * This function is called to notify an AdapterHandler about a change (can be triggered through adapters)
 * Note that this function only works with nodes inside window.document
 * @param {Element} element Element of AdapterHandler. Must be from window.document
 * @param {Object} adapterType Type/Aspect of AdapterHandler (e.g. XML3D.data or XML3D.webgl)
 * @param {number} canvasId GLCanvasHandler id of AdapterHandler, 0 if not depending on GLCanvasHandler
 * @param {number} type Type of Notification. Usually Events.ADAPTER_HANDLE_CHANGED
 */
Resource.notifyNodeAdapterChange = function(element, adapterType, canvasId, type) {
    canvasId = canvasId || 0;
    var uri = "#" + element.id;
    if (c_cachedAdapterHandles[uri] && c_cachedAdapterHandles[uri][adapterType] &&
        c_cachedAdapterHandles[uri][adapterType][canvasId]) {
        c_cachedAdapterHandles[uri][adapterType][canvasId].notifyListeners(type);
    }
};


/**
 * Load data via XMLHttpRequest
 * @private
 * @param {string} url URL of the document
 * @param {function(object)} loadListener Gets the response of the XHR
 * @param {function(XMLHttpRequest)} errorListener Get the XHR object for further analysis
 */
Resource.loadData = function(url, loadListener, errorListener) {
    var xmlHttp = null;
    try {
        xmlHttp = new XMLHttpRequest();
    } catch (e) {
        xmlHttp = null;
    }
    if (xmlHttp) {
        xmlHttp._url = url;
        xmlHttp._contentChecked = false;
        xmlHttp.open('GET', url, true);
        if (isBinaryExtension(url))
            xmlHttp.responseType = "arraybuffer";

        xmlHttp.onreadystatechange = function() {
            if (xmlHttp._aborted) // This check is possibly not needed
                return;
            // check compatibility between content and request mode
            if (!xmlHttp._contentChecked &&
                // 2 - HEADERS_RECEIVED, 3 - LOADING, 4 - DONE
                ((xmlHttp.readyState == 2 || xmlHttp.readyState == 3 || xmlHttp.readyState == 4) &&
                    xmlHttp.status == 200)) {
                xmlHttp._contentChecked = true; // we check only once
                // check if we need to change request mode
                var contentType = xmlHttp.getResponseHeader("content-type");
                if (contentType) {
                    var binaryContent = isBinaryContentType(contentType);
                    var binaryRequest = (xmlHttp.responseType == "arraybuffer");
                    // When content is not the same as request, we need to repeat request
                    if (binaryContent != binaryRequest) {
                        xmlHttp._aborted = true;
                        var cb = xmlHttp.onreadystatechange;
                        xmlHttp.onreadystatechange = null;
                        var url = xmlHttp._url;
                        xmlHttp.abort();

                        // Note: We do not recycle XMLHttpRequest !
                        //       This does work only when responseType is changed to "arraybuffer",
                        //       however the size of the xmlHttp.response buffer is then wrong !
                        //       It does not work at all (at least in Chrome) when we use overrideMimeType
                        //       with "text/plain; charset=x-user-defined" argument.
                        //       The latter mode require creation of the fresh XMLHttpRequest.

                        xmlHttp = new XMLHttpRequest();
                        xmlHttp._url = url;
                        xmlHttp._contentChecked = true;
                        xmlHttp.open('GET', url, true);
                        if (binaryContent)
                            xmlHttp.responseType = "arraybuffer";
                        xmlHttp.onreadystatechange = cb;
                        xmlHttp.send(null);
                        return;
                    }
                }
            }
            // Request mode and content type are compatible here (both binary or both text)
            if (xmlHttp.readyState == 4) {
                if (xmlHttp.status == 200) {
                    XML3D.debug.logDebug("Loaded: " + xmlHttp._url);

                    var mimetype = xmlHttp.getResponseHeader("content-type");
                    var response = null;

                    if (xmlHttp.responseType == "arraybuffer") {
                        response = xmlHttp.response;
                    } else if (mimetype == "application/json") {
                        response = JSON.parse(xmlHttp.responseText);
                    } else if (mimetype == "application/xml" || mimetype == "text/xml") {
                        response = xmlHttp.responseXML;
                    } else if (mimetype == "application/octet-stream" || mimetype == "text/plain; charset=x-user-defined") {
                        XML3D.debug.logError("Possibly wrong loading of resource " + url + ". Mimetype is " + mimetype + " but response is not an ArrayBuffer");
                        response = xmlHttp.responseText; // FIXME is this correct ?
                    }
                    if (loadListener)
                        loadListener(response);
                }
                else {
                    XML3D.debug.logError("Could not load external document '" + xmlHttp._url +
                        "': " + xmlHttp.status + " - " + xmlHttp.statusText);
                    if (errorListener)
                        errorListener(xmlHttp);
                }
            }
        };
        xmlHttp.send(null);
    }
};

/**
 * This function is called to load an Image.
 *
 * @param {URI} uri Image URI
 * @param {function(Event, HTMLImageElement)} loadListener Function called when image was successfully loaded.
 *                                It will be called with event as the first and image as the second parameter.
 * @param {function(Event, HTMLImageElement)} errorListener Function called when image could not be loaded.
 *                                 It will be called with event as the first and image as the second parameter.
 * @return {HTMLImageElement}
 */
Resource.getImage = function(uri, loadListener, errorListener) {
    // we use canvasId 0 to represent images loaded in a document
    getOrCreateCounterObject(0).counter++;

    var image = new Image();
    image.onload = function(e) {
        loadListener(e, image);
        loadComplete(0);
    };
    image.onerror = function(e) {
        errorListener(e, image);
        loadComplete(0);
    };
    if(!uri.hasSameOrigin(document.location.href)) {
        image.crossOrigin = Options.getValue(OPTION_RESOURCE_CORS);
        XML3D.debug.logWarning("You are using an cross-origin image as texture. This might cause troubles cause the canvas is 'tainted'.")
    }

    image.src = uri.toString(); // here loading starts
    return image;
};


/**
 * This function is called to load a Video.
 *
 * @param {URI} uri Video URI
 * @param {boolean} autoplay
 * @param {boolean} loop
 * @param {Object} listeners  Dictionary of all listeners to register with video element.
 *                            Listeners will be called with event as the first and video as the second parameter.
 * @return {HTMLVideoElement}
 */
Resource.getVideo = function(uri, autoplay, loop, listeners) {
    // we use canvasId 0 to represent videos loaded in a document
    getOrCreateCounterObject(0).counter++;

    // FIXME: In HTML, we create a configured video, play/pause won't work
    var video = document.createElement("video");

    var loadCompleteCallback = function(event) {
        loadComplete(0);
        video.removeEventListener("canplay", loadCompleteCallback, true);
        video.removeEventListener("error", loadCompleteCallback, true);
    };

    if (!uri.hasSameOrigin(document.location.href)) {
        video.crossOrigin = Options.getValue(OPTION_RESOURCE_CORS);
        XML3D.debug.logWarning("You are using an cross-origin video as texture. This might cause troubles cause the canvas is 'tainted'.", uri)
    }

    video.autoplay = autoplay;
    video.loop = loop;

    function createCallback(listener) {
        return function(event) {
            listener(event, video);
        };
    }

    for (var eventName in listeners) {
        video.addEventListener(eventName, createCallback(listeners[eventName]), true);
    }

    video.addEventListener("canplay", loadCompleteCallback, true);
    video.addEventListener("error", loadCompleteCallback, true);

    video.src = uri.toString(); // here loading starts
    return video;
};

module.exports = {
    registerFactory: registerFactory,
    registerFormat: registerFormat,
    findFormat: findFormat,
    Resource: Resource
};

},{"../utils/options.js":132,"../utils/uri.js":133,"./adapterhandle.js":8}],11:[function(require,module,exports){

    /**
     * @author mrdoob / http://mrdoob.com/
     */

var EventDispatcher = function () {
};

EventDispatcher.prototype = {

    constructor: EventDispatcher,

    addEventListener: function (type, listener) {

        if (this._listeners === undefined) this._listeners = {};

        var listeners = this._listeners;

        if (listeners[ type ] === undefined) {

            listeners[ type ] = [];

        }

        if (listeners[ type ].indexOf(listener) === -1) {

            listeners[ type ].push(listener);

        }

    },

    hasEventListener: function (type, listener) {

        if (this._listeners === undefined) return false;

        var listeners = this._listeners;

        if (listeners[ type ] !== undefined && listeners[ type ].indexOf(listener) !== -1) {

            return true;

        }

        return false;

    },

    removeEventListener: function (type, listener) {

        if (this._listeners === undefined) return;

        var listeners = this._listeners;
        var index = listeners[ type ].indexOf(listener);

        if (index !== -1) {

            listeners[ type ].splice(index, 1);

        }

    },

    dispatchEvent: function (event) {

        if (this._listeners === undefined) return;

        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];

        if (listenerArray !== undefined) {

            event.target = this;

            for (var i = 0, l = listenerArray.length; i < l; i++) {

                listenerArray[ i ].call(this, event);

            }

        }

    }

};

module.exports = EventDispatcher;
},{}],12:[function(require,module,exports){
/*jslint white: false, onevar: false, undef: true, nomen: true, eqeqeq: true, plusplus: true, bitwise: true, regexp: true, newcap: true, immed: true, sub: true, nomen: false */

/**
* This file contains code that may be under the following license:
*
* SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
* Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
*
* See http://oss.sgi.com/projects/FreeB/ for more information.
*
* All code in this file which is NOT under the SGI FREE SOFTWARE LICENSE B
* is free and unencumbered software released into the public domain.
*
* Anyone is free to copy, modify, publish, use, compile, sell, or
* distribute this software, either in source code form or as a compiled
* binary, for any purpose, commercial or non-commercial, and by any
* means.
*
* In jurisdictions that recognize copyright laws, the author or authors
* of this software dedicate any and all copyright interest in the
* software to the public domain. We make this dedication for the benefit
* of the public at large and to the detriment of our heirs and
* successors. We intend this dedication to be an overt act of
* relinquishment in perpetuity of all present and future rights to this
* software under copyright law.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
* OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/

var GLU = {};
/**
* Unproject a screen point.
*
* @param {number} winX the window point for the x value.
* @param {number} winY the window point for the y value.
* @param {number} winZ the window point for the z value.
* @param {Array.<number>} model the model-view matrix.
* @param {Array.<number>} proj the projection matrix.
* @param {Array.<number>} view the viewport coordinate array.
* @param {Array.<number>} objPos the model point result.
* @return {boolean} true if the unproject operation was successful, false otherwise.
*/
GLU.unProject = function(winX, winY, winZ, model, proj, view, objPos) {

    /** @type {Array.<number>} */
    var inp = [
        winX,
        winY,
        winZ,
        1.0
    ];

    /** @type {Array.<number>} */
    var finalMatrix = [];

    GLU.multMatrices(model, proj, finalMatrix);
    if (!GLU.invertMatrix(finalMatrix, finalMatrix)) {
        return (false);
    }

    /* Map x and y from window coordinates */
    inp[0] = (inp[0] - view[0]) / view[2];
    inp[1] = (inp[1] - view[1]) / view[3];

    /* Map to range -1 to 1 */
    inp[0] = inp[0] * 2 - 1;
    inp[1] = inp[1] * 2 - 1;
    inp[2] = inp[2] * 2 - 1;

    /** @type {Array.<number>} */
    var out = [];

    GLU.multMatrixVec(finalMatrix, inp, out);

    if (out[3] === 0.0) {
        return false;
    }

    out[0] /= out[3];
    out[1] /= out[3];
    out[2] /= out[3];

    objPos[0] = out[0];
    objPos[1] = out[1];
    objPos[2] = out[2];

    return true;
};

/**
* Multiply the matrix by the specified vector.
*
* @param {Array.<number>} matrix the matrix.
* @param {Array.<number>} inp the vector.
* @param {Array.<number>} out the output.
*/
GLU.multMatrixVec = function(matrix, inp, out) {
    for (var i = 0; i < 4; i = i + 1) {
        out[i] =
            inp[0] * matrix[0 * 4 + i] +
            inp[1] * matrix[1 * 4 + i] +
            inp[2] * matrix[2 * 4 + i] +
            inp[3] * matrix[3 * 4 + i];
    }
};

/**
* Multiply the specified matrices.
*
* @param {Array.<number>} a the first matrix.
* @param {Array.<number>} b the second matrix.
* @param {Array.<number>} r the result.
*/
GLU.multMatrices = function(a, b, r) {
    for (var i = 0; i < 4; i = i + 1) {
        for (var j = 0; j < 4; j = j + 1) {
            r[i * 4 + j] =
                a[i * 4 + 0] * b[0 * 4 + j] +
                a[i * 4 + 1] * b[1 * 4 + j] +
                a[i * 4 + 2] * b[2 * 4 + j] +
                a[i * 4 + 3] * b[3 * 4 + j];
        }
    }
};

/**
* Invert a matrix.
*
* @param {Array.<number>} m the matrix.
* @param {Array.<number>} invOut the inverted output.
* @return {boolean} true if successful, false otherwise.
*/
GLU.invertMatrix = function(m, invOut) {
    /** @type {Array.<number>} */
    var inv = [];

    inv[0] = m[5] * m[10] * m[15] - m[5] * m[11] * m[14] - m[9] * m[6] * m[15] +
        m[9] * m[7] * m[14] + m[13] * m[6] * m[11] - m[13] * m[7] * m[10];
    inv[4] = -m[4] * m[10] * m[15] + m[4] * m[11] * m[14] + m[8] * m[6] * m[15] -
        m[8] * m[7] * m[14] - m[12] * m[6] * m[11] + m[12] * m[7] * m[10];
    inv[8] = m[4] * m[9] * m[15] - m[4] * m[11] * m[13] - m[8] * m[5] * m[15] +
        m[8] * m[7] * m[13] + m[12] * m[5] * m[11] - m[12] * m[7] * m[9];
    inv[12] = -m[4] * m[9] * m[14] + m[4] * m[10] * m[13] + m[8] * m[5] * m[14] -
        m[8] * m[6] * m[13] - m[12] * m[5] * m[10] + m[12] * m[6] * m[9];
    inv[1] = -m[1] * m[10] * m[15] + m[1] * m[11] * m[14] + m[9] * m[2] * m[15] -
        m[9] * m[3] * m[14] - m[13] * m[2] * m[11] + m[13] * m[3] * m[10];
    inv[5] = m[0] * m[10] * m[15] - m[0] * m[11] * m[14] - m[8] * m[2] * m[15] +
        m[8] * m[3] * m[14] + m[12] * m[2] * m[11] - m[12] * m[3] * m[10];
    inv[9] = -m[0] * m[9] * m[15] + m[0] * m[11] * m[13] + m[8] * m[1] * m[15] -
        m[8] * m[3] * m[13] - m[12] * m[1] * m[11] + m[12] * m[3] * m[9];
    inv[13] = m[0] * m[9] * m[14] - m[0] * m[10] * m[13] - m[8] * m[1] * m[14] +
        m[8] * m[2] * m[13] + m[12] * m[1] * m[10] - m[12] * m[2] * m[9];
    inv[2] = m[1] * m[6] * m[15] - m[1] * m[7] * m[14] - m[5] * m[2] * m[15] +
        m[5] * m[3] * m[14] + m[13] * m[2] * m[7] - m[13] * m[3] * m[6];
    inv[6] = -m[0] * m[6] * m[15] + m[0] * m[7] * m[14] + m[4] * m[2] * m[15] -
        m[4] * m[3] * m[14] - m[12] * m[2] * m[7] + m[12] * m[3] * m[6];
    inv[10] = m[0] * m[5] * m[15] - m[0] * m[7] * m[13] - m[4] * m[1] * m[15] +
        m[4] * m[3] * m[13] + m[12] * m[1] * m[7] - m[12] * m[3] * m[5];
    inv[14] = -m[0] * m[5] * m[14] + m[0] * m[6] * m[13] + m[4] * m[1] * m[14] -
        m[4] * m[2] * m[13] - m[12] * m[1] * m[6] + m[12] * m[2] * m[5];
    inv[3] = -m[1] * m[6] * m[11] + m[1] * m[7] * m[10] + m[5] * m[2] * m[11] -
        m[5] * m[3] * m[10] - m[9] * m[2] * m[7] + m[9] * m[3] * m[6];
    inv[7] = m[0] * m[6] * m[11] - m[0] * m[7] * m[10] - m[4] * m[2] * m[11] +
        m[4] * m[3] * m[10] + m[8] * m[2] * m[7] - m[8] * m[3] * m[6];
    inv[11] = -m[0] * m[5] * m[11] + m[0] * m[7] * m[9] + m[4] * m[1] * m[11] -
        m[4] * m[3] * m[9] - m[8] * m[1] * m[7] + m[8] * m[3] * m[5];
    inv[15] = m[0] * m[5] * m[10] - m[0] * m[6] * m[9] - m[4] * m[1] * m[10] +
        m[4] * m[2] * m[9] + m[8] * m[1] * m[6] - m[8] * m[2] * m[5];

    /** @type {number} */
    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    if (det === 0) {
        return false;
    }

    det = 1.0 / det;

    for (var i = 0; i < 16; i = i + 1) {
        invOut[i] = inv[i] * det;
    }

    return true;
};

module.exports = GLU;
},{}],13:[function(require,module,exports){
// Domain Public by Eric Wendelin http://eriwen.com/ (2008)
//                  Luke Smith http://lucassmith.name/ (2008)
//                  Loic Dachary <loic@dachary.org> (2008)
//                  Johan Euphrosine <proppy@aminche.com> (2008)
//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)
//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)


/**
 * Main function giving a function stack trace with a forced or passed in
 * Error
 *
 * @cfg {Error} e The error to create a stacktrace from (optional)
 * @cfg {Boolean} guess If we should try to resolve the names of anonymous
 * functions
 * @return {Array} of Strings with functions, lines, files, and arguments
 * where possible
 */
var printStackTrace = function (options) {
    options = options || {
        guess : true
    };
    var ex = options.e || null, guess = !!options.guess;
    var p = new printStackTrace.implementation(), result = p.run(ex);
    return (guess) ? p.guessAnonymousFunctions(result) : result;
};

printStackTrace.implementation = function() {};

printStackTrace.implementation.prototype = {
    /**
     * @param {Error} ex The error to create a stacktrace from (optional)
     * @param {String} mode Forced mode (optional, mostly for unit tests)
     */
    run : function(ex, mode) {
        ex = ex || this.createException();
        // examine exception properties w/o debugger
        // for (var prop in ex) {alert("Ex['" + prop + "']=" + ex[prop]);}
        mode = mode || this.mode(ex);
        if (mode === 'other') {
            return this.other(arguments.callee);
        } else {
            return this[mode](ex);
        }
    },

    createException : function() {
        try {
            this.undef();
        } catch (e) {
            return e;
        }
    },

    /**
     * Mode could differ for different exception, e.g. exceptions in Chrome
     * may or may not have arguments or stack.
     *
     * @return {String} mode of operation for the exception
     */
    mode : function(e) {
        if (e['arguments'] && e.stack) {
            return 'chrome';
        } else if (e.stack && e.sourceURL) {
            return 'safari';
        } else if (typeof e.message === 'string' && typeof window !== 'undefined' && window.opera) {
            // e.message.indexOf("Backtrace:") > -1 -> opera
            // !e.stacktrace -> opera
            if (!e.stacktrace) {
                return 'opera9'; // use e.message
            }
            // 'opera#sourceloc' in e -> opera9, opera10a
            if (e.message.indexOf('\n') > -1 && e.message.split('\n').length > e.stacktrace.split('\n').length) {
                return 'opera9'; // use e.message
            }
            // e.stacktrace && !e.stack -> opera10a
            if (!e.stack) {
                return 'opera10a'; // use e.stacktrace
            }
            // e.stacktrace && e.stack -> opera10b
            if (e.stacktrace.indexOf("called from line") < 0) {
                return 'opera10b'; // use e.stacktrace, format differs from
                                    // 'opera10a'
            }
            // e.stacktrace && e.stack -> opera11
            return 'opera11'; // use e.stacktrace, format differs from
                                // 'opera10a', 'opera10b'
        } else if (e.stack) {
            return 'firefox';
        }
        return 'other';
    },

    /**
     * Given a context, function name, and callback function, overwrite it
     * so that it calls printStackTrace() first with a callback and then
     * runs the rest of the body.
     *
     * @param {Object} context of execution (e.g. window)
     * @param {String} functionName to instrument
     * @param {Function} function to call with a stack trace on invocation
     */
    instrumentFunction : function(context, functionName, callback) {
        context = context || window;
        var original = context[functionName];
        context[functionName] = function instrumented() {
            callback.call(this, printStackTrace().slice(4));
            return context[functionName]._instrumented.apply(this, arguments);
        };
        context[functionName]._instrumented = original;
    },

    /**
     * Given a context and function name of a function that has been
     * instrumented, revert the function to it's original (non-instrumented)
     * state.
     *
     * @param {Object} context of execution (e.g. window)
     * @param {String} functionName to de-instrument
     */
    deinstrumentFunction : function(context, functionName) {
        if (context[functionName].constructor === Function && context[functionName]._instrumented
                && context[functionName]._instrumented.constructor === Function) {
            context[functionName] = context[functionName]._instrumented;
        }
    },

    /**
     * Given an Error object, return a formatted Array based on Chrome's
     * stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    chrome : function(e) {
        var stack = (e.stack + '\n').replace(/^\S[^\(]+?[\n$]/gm, '').replace(/^\s+(at eval )?at\s+/gm, '').replace(/^([^\(]+?)([\n$])/gm,
                '{anonymous}()@$1$2').replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}()@$1').split('\n');
        stack.pop();
        return stack;
    },

    /**
     * Given an Error object, return a formatted Array based on Safari's
     * stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    safari : function(e) {
        return e.stack.replace(/\[native code\]\n/m, '').replace(/^@/gm, '{anonymous}()@').split('\n');
    },

    /**
     * Given an Error object, return a formatted Array based on Firefox's
     * stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    firefox : function(e) {
        return e.stack.replace(/(?:\n@:0)?\s+$/m, '').replace(/^[\(@]/gm, '{anonymous}()@').split('\n');
    },

    opera11 : function(e) {
        var ANON = '{anonymous}', lineRE = /^.*line (\d+), column (\d+)(?: in (.+))? in (\S+):$/;
        var lines = e.stacktrace.split('\n'), result = [];

        for ( var i = 0, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                var location = match[4] + ':' + match[1] + ':' + match[2];
                var fnName = match[3] || "global code";
                fnName = fnName.replace(/<anonymous function: (\S+)>/, "$1").replace(/<anonymous function>/, ANON);
                result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
            }
        }

        return result;
    },

    opera10b : function(e) {
        // "<anonymous function: run>([arguments not
        // available])@file://localhost/G:/js/stacktrace.js:27\n" +
        // "printStackTrace([arguments not
        // available])@file://localhost/G:/js/stacktrace.js:18\n" +
        // "@file://localhost/G:/js/test/functional/testcase1.html:15"
        var lineRE = /^(.*)@(.+):(\d+)$/;
        var lines = e.stacktrace.split('\n'), result = [];

        for ( var i = 0, len = lines.length; i < len; i++) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                var fnName = match[1] ? (match[1] + '()') : "global code";
                result.push(fnName + '@' + match[2] + ':' + match[3]);
            }
        }

        return result;
    },

    /**
     * Given an Error object, return a formatted Array based on Opera 10's
     * stacktrace string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    opera10a : function(e) {
        // " Line 27 of linked script
        // file://localhost/G:/js/stacktrace.js\n"
        // " Line 11 of inline#1 script in
        // file://localhost/G:/js/test/functional/testcase1.html: In
        // function foo\n"
        var ANON = '{anonymous}', lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
        var lines = e.stacktrace.split('\n'), result = [];

        for ( var i = 0, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                var fnName = match[3] || ANON;
                result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
            }
        }

        return result;
    },

    // Opera 7.x-9.2x only!
    opera9 : function(e) {
        // " Line 43 of linked script
        // file://localhost/G:/js/stacktrace.js\n"
        // " Line 7 of inline#1 script in
        // file://localhost/G:/js/test/functional/testcase1.html\n"
        var ANON = '{anonymous}', lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
        var lines = e.message.split('\n'), result = [];

        for ( var i = 2, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
            }
        }

        return result;
    },

    // Safari 5-, IE 9-, and others
    other : function(curr) {
        var ANON = '{anonymous}', fnRE = /function\s*([\w\-$]+)?\s*\(/i, stack = [], fn, args, maxStackSize = 10;
        while (curr && curr['arguments'] && stack.length < maxStackSize) {
            fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;
            args = Array.prototype.slice.call(curr['arguments'] || []);
            stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';
            curr = curr.caller;
        }
        return stack;
    },

    /**
     * Given arguments array as a String, subsituting type names for
     * non-string types.
     *
     * @param {Arguments} args
     * @return {Array} of Strings with stringified arguments
     */
    stringifyArguments : function(args) {
        var result = [];
        var slice = Array.prototype.slice;
        for ( var i = 0; i < args.length; ++i) {
            var arg = args[i];
            if (arg === undefined) {
                result[i] = 'undefined';
            } else if (arg === null) {
                result[i] = 'null';
            } else if (arg.constructor) {
                if (arg.constructor === Array) {
                    if (arg.length < 3) {
                        result[i] = '[' + this.stringifyArguments(arg) + ']';
                    } else {
                        result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';
                    }
                } else if (arg.constructor === Object) {
                    result[i] = '#object';
                } else if (arg.constructor === Function) {
                    result[i] = '#function';
                } else if (arg.constructor === String) {
                    result[i] = '"' + arg + '"';
                } else if (arg.constructor === Number) {
                    result[i] = arg;
                }
            }
        }
        return result.join(',');
    },

    sourceCache : {},

    /**
     * @return the text from a given URL
     */
    ajax : function(url) {
        var req = this.createXMLHTTPObject();
        if (req) {
            try {
                req.open('GET', url, false);
                // req.overrideMimeType('text/plain');
                // req.overrideMimeType('text/javascript');
                req.send(null);
                // return req.status == 200 ? req.responseText : '';
                return req.responseText;
            } catch (e) {
            }
        }
        return '';
    },

    /**
     * Try XHR methods in order and store XHR factory.
     *
     * @return <Function> XHR function or equivalent
     */
    createXMLHTTPObject : function() {
        var xmlhttp, XMLHttpFactories = [ function() {
            return new XMLHttpRequest();
        }, function() {
            return new ActiveXObject('Msxml2.XMLHTTP');
        }, function() {
            return new ActiveXObject('Msxml3.XMLHTTP');
        }, function() {
            return new ActiveXObject('Microsoft.XMLHTTP');
        } ];
        for ( var i = 0; i < XMLHttpFactories.length; i++) {
            try {
                xmlhttp = XMLHttpFactories[i]();
                // Use memoization to cache the factory
                this.createXMLHTTPObject = XMLHttpFactories[i];
                return xmlhttp;
            } catch (e) {
            }
        }
    },

    /**
     * Given a URL, check if it is in the same domain (so we can get the
     * source via Ajax).
     *
     * @param url <String> source url
     * @return False if we need a cross-domain request
     */
    isSameDomain : function(url) {
        return typeof location !== "undefined" && url.indexOf(location.hostname) !== -1; // location
                                                                                            // may
                                                                                            // not
                                                                                            // be
                                                                                            // defined,
                                                                                            // e.g.
                                                                                            // when
                                                                                            // running
                                                                                            // from
                                                                                            // nodejs.
    },

    /**
     * Get source code from given URL if in the same domain.
     *
     * @param url <String> JS source URL
     * @return <Array> Array of source code lines
     */
    getSource : function(url) {
        // TODO reuse source from script tags?
        if (!(url in this.sourceCache)) {
            this.sourceCache[url] = this.ajax(url).split('\n');
        }
        return this.sourceCache[url];
    },

    guessAnonymousFunctions : function(stack) {
        for ( var i = 0; i < stack.length; ++i) {
            var reStack = /\{anonymous\}\(.*\)@(.*)/, reRef = /^(.*?)(?::(\d+))(?::(\d+))?(?: -- .+)?$/, frame = stack[i], ref = reStack.exec(frame);

            if (ref) {
                var m = reRef.exec(ref[1]);
                if (m) { // If falsey, we did not get any file/line
                            // information
                    var file = m[1], lineno = m[2], charno = m[3] || 0;
                    if (file && this.isSameDomain(file) && lineno) {
                        var functionName = this.guessAnonymousFunction(file, lineno, charno);
                        stack[i] = frame.replace('{anonymous}', functionName);
                    }
                }
            }
        }
        return stack;
    },

    guessAnonymousFunction : function(url, lineNo, charNo) {
        var ret;
        try {
            ret = this.findFunctionName(this.getSource(url), lineNo);
        } catch (e) {
            ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();
        }
        return ret;
    },

    findFunctionName : function(source, lineNo) {
        // FIXME findFunctionName fails for compressed source
        // (more than one function on the same line)
        // TODO use captured args
        // function {name}({args}) m[1]=name m[2]=args
        var reFunctionDeclaration = /function\s+([^(]*?)\s*\(([^)]*)\)/;
        // {name} = function ({args}) TODO args capture
        // /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function(?:[^(]*)/
        var reFunctionExpression = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function\b/;
        // {name} = eval()
        var reFunctionEvaluation = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*(?:eval|new Function)\b/;
        // Walk backwards in the source lines until we find
        // the line which matches one of the patterns above
        var code = "", line, maxLines = Math.min(lineNo, 20), m, commentPos;
        for ( var i = 0; i < maxLines; ++i) {
            // lineNo is 1-based, source[] is 0-based
            line = source[lineNo - i - 1];
            commentPos = line.indexOf('//');
            if (commentPos >= 0) {
                line = line.substr(0, commentPos);
            }
            // TODO check other types of comments? Commented code may lead to false positive
            if (line) {
                code = line + code;
                m = reFunctionExpression.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
                m = reFunctionDeclaration.exec(code);
                if (m && m[1]) {
                    //return m[1] + "(" + (m[2] || "") + ")";
                    return m[1];
                }
                m = reFunctionEvaluation.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
            }
        }
        return '(?)';
    }
};

module.exports = printStackTrace;
},{}],14:[function(require,module,exports){

var StateMachine = {

    //---------------------------------------------------------------------------

    VERSION: "2.2.0",

    //---------------------------------------------------------------------------

    Result: {
      SUCCEEDED:    1, // the event transitioned successfully from one state to another
      NOTRANSITION: 2, // the event was successfull but no state transition was necessary
      CANCELLED:    3, // the event was cancelled by the caller in a beforeEvent callback
      ASYNC:        4 // the event is asynchronous and the caller is in control of when the transition occurs
    },

    Error: {
      INVALID_TRANSITION: 100, // caller tried to fire an event that was innapropriate in the current state
      PENDING_TRANSITION: 200, // caller tried to fire an event while an async transition was still pending
      INVALID_CALLBACK:   300 // caller provided callback function threw an exception
    },

    WILDCARD: '*',
    ASYNC: 'async',

    //---------------------------------------------------------------------------

    create: function(cfg, target) {

      var initial   = (typeof cfg.initial == 'string') ? { state: cfg.initial } : cfg.initial; // allow for a simple string, or an object with { state: 'foo', event: 'setup', defer: true|false }
      var fsm       = target || cfg.target  || {};
      var events    = cfg.events || [];
      var callbacks = cfg.callbacks || {};
      var map       = {};

      var add = function(e) {
        var from = (e.from instanceof Array) ? e.from : (e.from ? [e.from] : [StateMachine.WILDCARD]); // allow 'wildcard' transition if 'from' is not specified
        map[e.name] = map[e.name] || {};
        for (var n = 0 ; n < from.length ; n++)
          map[e.name][from[n]] = e.to || from[n]; // allow no-op transition if 'to' is not specified
      };

      if (initial) {
        initial.event = initial.event || 'startup';
        add({ name: initial.event, from: 'none', to: initial.state });
      }

      for(var n = 0 ; n < events.length ; n++)
        add(events[n]);

      for(var name in map) {
        if (map.hasOwnProperty(name))
          fsm[name] = StateMachine.buildEvent(name, map[name]);
      }

      for(var name in callbacks) {
        if (callbacks.hasOwnProperty(name))
          fsm[name] = callbacks[name]
      }

      fsm.current = 'none';
      fsm.is      = function(state) { return this.current == state; };
      fsm.can     = function(event) { return !this.transition && (map[event].hasOwnProperty(this.current) || map[event].hasOwnProperty(StateMachine.WILDCARD)); }
      fsm.cannot  = function(event) { return !this.can(event); };
      fsm.error   = cfg.error || function(name, from, to, args, error, msg, e) { throw e || msg; }; // default behavior when something unexpected happens is to throw an exception, but caller can override this behavior if desired (see github issue #3 and #17)

      if (initial && !initial.defer)
        fsm[initial.event]();

      return fsm;

    },

    //===========================================================================

    doCallback: function(fsm, func, name, from, to, args) {
      if (func) {
        try {
          return func.apply(fsm, [name, from, to].concat(args));
        }
        catch(e) {
          return fsm.error(name, from, to, args, StateMachine.Error.INVALID_CALLBACK, "an exception occurred in a caller-provided callback function", e);
        }
      }
    },

    beforeEvent: function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onbefore' + name],                     name, from, to, args); },
    afterEvent:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onafter'  + name] || fsm['on' + name], name, from, to, args); },
    leaveState:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onleave'  + from],                     name, from, to, args); },
    enterState:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onenter'  + to]   || fsm['on' + to],   name, from, to, args); },
    changeState: function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onchangestate'],                       name, from, to, args); },


    buildEvent: function(name, map) {
      return function() {

        var from  = this.current;
        var to    = map[from] || map[StateMachine.WILDCARD] || from;
        var args  = Array.prototype.slice.call(arguments); // turn arguments into pure array

        if (this.transition)
          return this.error(name, from, to, args, StateMachine.Error.PENDING_TRANSITION, "event " + name + " inappropriate because previous transition did not complete");

        if (this.cannot(name))
          return this.error(name, from, to, args, StateMachine.Error.INVALID_TRANSITION, "event " + name + " inappropriate in current state " + this.current);

        if (false === StateMachine.beforeEvent(this, name, from, to, args))
          return StateMachine.Result.CANCELLED;

        if (from === to) {
          StateMachine.afterEvent(this, name, from, to, args);
          return StateMachine.Result.NOTRANSITION;
        }

        // prepare a transition method for use EITHER lower down, or by caller if they want an async transition (indicated by an ASYNC return value from leaveState)
        var fsm = this;
        this.transition = function() {
          fsm.transition = null; // this method should only ever be called once
          fsm.current = to;
          StateMachine.enterState( fsm, name, from, to, args);
          StateMachine.changeState(fsm, name, from, to, args);
          StateMachine.afterEvent( fsm, name, from, to, args);
        };
        this.transition.cancel = function() { // provide a way for caller to cancel async transition if desired (issue #22)
          fsm.transition = null;
          StateMachine.afterEvent(fsm, name, from, to, args);
        };

        var leave = StateMachine.leaveState(this, name, from, to, args);
        if (false === leave) {
          this.transition = null;
          return StateMachine.Result.CANCELLED;
        }
        else if ("async" === leave) {
          return StateMachine.Result.ASYNC;
        }
        else {
          if (this.transition)
            this.transition(); // in case user manually called transition() but forgot to return ASYNC
          return StateMachine.Result.SUCCEEDED;
        }

      };
    }

}; // StateMachine

//===========================================================================

/*if ("function" === typeof define) {
define(function(require) { return StateMachine; });
}
else {*/
window.StateMachine = StateMachine;
/*}*/

module.exports = StateMachine;


},{}],15:[function(require,module,exports){
var DOMTransformFetcher = require("../transform-fetcher.js");
var DataAdapter = require("./data.js");
var DataNode = require("../../xflow/interface/graph.js").DataNode;
var getComputeDataflowUrl = require("../../xflow/interface/graph.js").getComputeDataflowUrl;
var Asset = require("../../asset/asset.js").Asset;
var SubData = require("../../asset/asset.js").SubData;
var Events = require("../../interface/notification.js");
var dispatchCustomEvent = require("../../utils/misc.js").dispatchCustomEvent;
var Resource = require("../../base/resourcemanager.js").Resource;

var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var createClass = XML3D.createClass;
var AdapterHandle = require("../../base/adapterhandle.js");


var AssetAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);

    // Node handles for src and proto
    this.asset = null;
    if (node.localName.toLowerCase() !== "model") {
        this.transformFetcher = new DOMTransformFetcher(this, "transform", "transform");
    }
};

createClass(AssetAdapter, NodeAdapter);

AssetAdapter.prototype.init = function () {
    this.asset = new Asset(this.node);
    this.asset.addChangeListener(this);
    this.asset.setName(this.node.getAttribute("name"));
    updateAdapterHandle(this, "src", this.node.getAttribute("src"));
    updatePickFilter(this);
    updateChildren(this);
    setShaderUrl(this, this.asset);
    this.transformFetcher && this.transformFetcher.update();
};

AssetAdapter.prototype.onAssetLoadChange = function (asset, newLevel, oldLevel) {
    if (newLevel == Infinity) {
        dispatchCustomEvent(this.node, 'load', false, true, null);
    } else if (newLevel > oldLevel) {
        dispatchCustomEvent(this.node, 'progress', false, true, null);
    }
};

AssetAdapter.prototype.getAssetComplete = function () {
    return this.asset.getProgressLevel() == Infinity;
};
AssetAdapter.prototype.getAssetProgressLevel = function () {
    return this.asset.getProgressLevel();
};

AssetAdapter.prototype.getAsset = function () {
    return this.asset;
};

function updateChildren(adapter) {
    adapter.asset.clearChildren();
    adapter.asset.clearSubAssets();
    for (var child = adapter.node.firstElementChild; child !== null; child = child.nextElementSibling) {
        var subadapter = adapter.factory.getAdapter(child);
        if (subadapter && subadapter.getAsset) {
            adapter.asset.appendSubAsset(subadapter.getAsset());
        }
        if (subadapter && subadapter.assetEntry) {
            adapter.asset.appendChild(subadapter.assetEntry);
        }
    }
}

function updateAdapterHandle(adapter, key, url) {
    var adapterHandle = adapter.getAdapterHandle(url), status = (adapterHandle && adapterHandle.status);

    if (status === AdapterHandle.STATUS.NOT_FOUND) {
        XML3D.debug.logError("Could not find element of url '" + adapterHandle.url + "' for " + key, adapter.node);
    }
    adapter.connectAdapterHandle(key, adapterHandle);
    adapter.connectedAdapterChanged(key, adapterHandle ? adapterHandle.getAdapter() : null, status);
}

function updateAssetLoadState(dataAdapter) {
    var loading = false, handle;

    handle = dataAdapter.getConnectedAdapterHandle("src");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }
    dataAdapter.asset.setLoading(loading);
}

function updatePickFilter(adapter) {
    if (!adapter.node.hasAttribute("pick"))
        adapter.asset.setPickFilter(null); else {
        var value = adapter.node.getAttribute("pick");
        adapter.asset.setPickFilter(value);
    }
}

AssetAdapter.prototype.connectedAdapterChanged = function (attributeName, adapter) {
    if (attributeName == "src")
        this.asset.setSrcAsset(adapter && adapter.getAsset() || null);
    updateAssetLoadState(this);
};

AssetAdapter.prototype.onTransformChange = function (attrName, matrix) {
    this.asset.setTransform(matrix);
};


AssetAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type == Events.ADAPTER_HANDLE_CHANGED) {
        this.connectedAdapterChanged(evt.key, evt.adapter);
        if (evt.handleStatus == AdapterHandle.STATUS.NOT_FOUND) {
            XML3D.debug.logError("Could not find <asset> element of url '" + evt.url + "' for " + evt.key);
        }
    } else if (evt.type == Events.NODE_INSERTED) {
        updateChildren(this);

    } else if (evt.type == Events.NODE_REMOVED) {
        updateChildren(this);

    } else if (evt.type == Events.VALUE_MODIFIED) {
        var attr = evt.mutation.attributeName;
        switch (attr) {
            case "name":
                this.asset.setName(this.node.getAttribute("name"));
                break;
            case "shader":
                setShaderUrl(this, this.asset);
                break;
            case "style":
            case "transform":
                this.transformFetcher && this.transformFetcher.update();
                break;
            case "src":
                updateAdapterHandle(this, "src", this.node.getAttribute("src"));
                break;
            case "pick":
                updatePickFilter(this);
                break;
        }

    } else if (evt.type == Events.THIS_REMOVED) {
        this.clearAdapterHandles();
    }
};

var AssetDataAdapter = function (factory, node) {
    this.assetData = true;
    DataAdapter.call(this, factory, node);

    // Node handles for src and proto
    this.assetEntry = null;
    this.outputXflowNode = null;
};
createClass(AssetDataAdapter, DataAdapter);

AssetDataAdapter.prototype.init = function () {
    DataAdapter.prototype.init.call(this);
    this.outputXflowNode = new DataNode(false);
    this.assetEntry = new SubData(this.outputXflowNode, this.getXflowNode(), this.node);
    this.assetEntry.setName(this.node.getAttribute("name"));
    updateClassNames(this);
    updatePostCompute(this);
    this.assetEntry.setPostFilter(this.node.getAttribute("filter"));
    updateIncludes(this.assetEntry, this.node.getAttribute("includes"));
};

AssetDataAdapter.prototype.connectedAdapterChanged = function (attributeName, adapter) {
    if (attributeName == "postDataflow") {
        this.assetEntry.setPostDataflow(adapter && adapter.getXflowNode() || null);
        updateSubDataLoadState(this);
    } else {
        DataAdapter.prototype.connectedAdapterChanged.call(this, attributeName, adapter);
    }
};

AssetDataAdapter.prototype.notifyChanged = function (evt) {
    DataAdapter.prototype.notifyChanged.call(this, evt);
    if (evt.type == Events.VALUE_MODIFIED) {
        var attr = evt.mutation.attributeName;
        switch (attr) {
            case "name":
                this.assetEntry.setName(this.node.getAttribute("name"));
                break;
            case "compute":
                updatePostCompute(this);
                break;
            case "class":
                updateClassNames(this);
                break;
            case "filter":
                this.assetEntry.setPostFilter(this.node.getAttribute("filter"));
                break;
            case "includes":
                updateIncludes(this.node.getAttribute("includes"));
                break;
        }

    }
};

AssetDataAdapter.prototype.onTransformChange = function (attrName, matrix) {
    this.assetEntry.setTransform(matrix);
};

function updateIncludes(assetEntry, includeString) {
    if (!includeString)
        assetEntry.setIncludes([]); else
        assetEntry.setIncludes(includeString.trim().split(/\s*,\s*/));
}

function updateClassNames(adapter) {
    var classNames = adapter.node.getAttribute("class");
    adapter.assetEntry.setClassNamesString(classNames)
}

function updatePostCompute(adapter) {
    var computeString = adapter.node.getAttribute("compute");
    var dataflowUrl = getComputeDataflowUrl(computeString);
    if (dataflowUrl) {
        updateAdapterHandle(adapter, "postDataflow", dataflowUrl);
    } else {
        adapter.disconnectAdapterHandle("postDataflow");
        updateSubDataLoadState(adapter);
    }
    adapter.assetEntry.setPostCompute(computeString);
}

function updateSubDataLoadState(dataAdapter) {
    var loading = false, handle;

    handle = dataAdapter.getConnectedAdapterHandle("postDataflow");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }
    dataAdapter.assetEntry.setLoading(loading);
}


function setShaderUrl(adapter, dest) {
    var node = adapter.node;
    var shaderUrl = node.getAttribute("shader");
    if (shaderUrl) {
        var shaderId = Resource.getAbsoluteURI(node.ownerDocument._documentURL || node.ownerDocument.URL, shaderUrl);
        dest.setShader(shaderId.toString());
    } else {
        dest.setShader(null);
    }
}

var AssetMeshAdapter = function (factory, node) {
    AssetDataAdapter.call(this, factory, node);
    this.transformFetcher = new DOMTransformFetcher(this, "transform", "transform");
};
createClass(AssetMeshAdapter, AssetDataAdapter);

AssetMeshAdapter.prototype.init = function () {
    AssetDataAdapter.prototype.init.call(this);
    setShaderUrl(this, this.assetEntry);
    this.assetEntry.setMeshType(this.node.getAttribute("type") || "triangles");
    this.assetEntry.setMatchFilter(this.node.getAttribute("match"));
    this.transformFetcher.update();
};
AssetMeshAdapter.prototype.notifyChanged = function (evt) {
    AssetDataAdapter.prototype.notifyChanged.call(this, evt);
    if (evt.type == Events.VALUE_MODIFIED) {
        var attr = evt.mutation.attributeName;
        switch (attr) {
            case "shader":
                setShaderUrl(this, this.assetEntry);
                break;
            case "match":
                this.assetEntry.setMatchFilter(this.node.getAttribute("match"));
                break;
            case "style":
            case "transform":
                this.transformFetcher.update();
                break;
            case "type":
                this.assetEntry.setMeshType(this.node.getAttribute("type") || "triangles")
        }

    }
};

module.exports = {
    AssetAdapter: AssetAdapter, AssetMeshAdapter: AssetMeshAdapter, AssetDataAdapter: AssetDataAdapter
};

},{"../../asset/asset.js":6,"../../base/adapter.js":7,"../../base/adapterhandle.js":8,"../../base/resourcemanager.js":10,"../../interface/notification.js":36,"../../utils/misc.js":131,"../../xflow/interface/graph.js":138,"../transform-fetcher.js":28,"./data.js":18}],16:[function(require,module,exports){
var ComputeRequest = require("../../xflow/interface/request.js").ComputeRequest;
var setShaderConstant = require("../../xflow/processing/vs-connect.js").setShaderConstant;
var registerErrorCallback = require("../../xflow/base.js").registerErrorCallback;
var XC = require("../../xflow/interface/constants.js");
var URI = require("../../utils/uri.js").URI;

var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var createClass = XML3D.createClass;

/**
 * @extends NodeAdapter
 * @abstract
 *
 * @param factory
 * @param node
 */
var BaseDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
    this.xflowDataNode = null;
};
createClass(BaseDataAdapter, NodeAdapter);


BaseDataAdapter.prototype.getXflowNode = function () {
    return this.xflowDataNode;
};

BaseDataAdapter.prototype.getComputeRequest = function (filter, callback) {
    return new ComputeRequest(this.xflowDataNode, filter, callback);
};

BaseDataAdapter.prototype.getComputeResult = function (filter) {
    return this.xflowDataNode._getResult(XC.RESULT_TYPE.COMPUTE, filter);
};

BaseDataAdapter.prototype.getOutputNames = function () {
    return this.xflowDataNode.getOutputNames();
};

BaseDataAdapter.prototype.getOutputChannelInfo = function (name) {
    return this.xflowDataNode.getOutputChannelInfo(name);
};

setShaderConstant(XC.SHADER_CONSTANT_KEY.OBJECT_ID, "objectID");
setShaderConstant(XC.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM, "modelViewProjectionMatrix");
setShaderConstant(XC.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM_NORMAL, "modelViewProjectionNormalMatrix");
setShaderConstant(XC.SHADER_CONSTANT_KEY.VIEW_TRANSFORM, "modelViewMatrix");
setShaderConstant(XC.SHADER_CONSTANT_KEY.VIEW_TRANSFORM_NORMAL, "modelViewMatrixN");
setShaderConstant(XC.SHADER_CONSTANT_KEY.WORLD_TRANSFORM, "modelMatrix");
registerErrorCallback(function(message, xflowNode){
    message = "Xflow: " + message;
    var userData = xflowNode ? xflowNode.userData : null;
    if (userData && userData.ownerDocument) {
        if (userData.ownerDocument === document) {
            XML3D.debug.logError(message, userData);
        }
        else if (userData.id) {
            var uri = new URI("#" + userData.id);
            uri = uri.getAbsoluteURI(userData.ownerDocument._documentURL || userData.ownerDocument.URL);
            XML3D.debug.logError(message, "External Node: " + uri);
        }
        else {
            XML3D.debug.logError(message, "External Document: " + userData.ownerDocument.URL);
        }
    }
    else if (typeof userData == "string") {
        XML3D.debug.logError(message, userData);
    }
    else {
        XML3D.debug.logError(message);
    }
});

module.exports = BaseDataAdapter;

},{"../../base/adapter.js":7,"../../utils/uri.js":133,"../../xflow/base.js":135,"../../xflow/interface/constants.js":136,"../../xflow/interface/request.js":139,"../../xflow/processing/vs-connect.js":186}],17:[function(require,module,exports){
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

/**
 * DataAdapter handling a <compute> element
 * @param {AdapterFactory} factory
 * @param {Element} node
 * @constructor
 */
var ComputeDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
};
XML3D.createClass(ComputeDataAdapter, NodeAdapter);

ComputeDataAdapter.prototype.getComputeCode = function () {
    return this.node.value;
};

/**
 * @param evt notification of type XML3D.Notification
 */
ComputeDataAdapter.prototype.notifyChanged = function (evt) {
    switch (evt.type) {
        case Events.VALUE_MODIFIED:
        case Events.NODE_INSERTED:
        case Events.NODE_REMOVED:
            var parent = this.node.parentNode;
            if (parent) {
                var parentAdapter = this.factory.getAdapter(parent);
                parentAdapter && parentAdapter.updateXflowNode();
            }
    }
};

module.exports = ComputeDataAdapter;

},{"../../base/adapter.js":7,"../../interface/notification.js":36}],18:[function(require,module,exports){
var BaseDataAdapter = require("./base.js");
var DataNode = require("../../xflow/interface/graph.js").DataNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var dispatchCustomEvent = require("../../utils/misc.js").dispatchCustomEvent;
var AdapterHandle = require("../../base/adapterhandle.js");

/**
 * The DataAdapter implements the
 * DataCollector concept and serves as basis of all DataAdapter classes. In
 * general, a DataAdapter is associated with an element node which uses
 * generic data and should be instantiated via
 * XML3DDataAdapterFactory to ensure proper functionality.
 *
 * @extends Adapter
 * @constructor
 *
 * @param factory
 * @param node
 */
var DataAdapter = function (factory, node) {
    BaseDataAdapter.call(this, factory, node);
    // Node handles for src and proto
    this.xflowDataNode = null;
    this.externalScripts = {};
};
XML3D.createClass(DataAdapter, BaseDataAdapter);

DataAdapter.prototype.init = function () {
    this.xflowDataNode = new DataNode(false);
    this.xflowDataNode.addLoadListener(this.onXflowLoadEvent.bind(this));
    this.xflowDataNode.userData = this.node;

    // Setting platform and node type information for a data sequence
    this.xflowDataNode.setPlatform(this.node.getAttribute("platform"));

    this.updateAdapterHandle("src", this.node.getAttribute("src"));
    if(!this.assetData){
        this.xflowDataNode.setFilter(this.node.getAttribute("filter"));
        updateCompute(this);
    }
    recursiveDataAdapterConstruction(this);
};

DataAdapter.prototype.updateAdapterHandle = function(key, url) {
    var oldAdapterHandle = this.getConnectedAdapterHandle(key);

    var adapterHandle = this.getAdapterHandle(url),
        status = (adapterHandle && adapterHandle.status);

    if(oldAdapterHandle == adapterHandle)
        return;
    if (status === AdapterHandle.STATUS.NOT_FOUND) {
        XML3D.debug.logError("Could not find element of url '" + adapterHandle.url + "' for " + key, this.node);
    }
    this.connectAdapterHandle(key, adapterHandle);
    this.connectedAdapterChanged(key, adapterHandle ? adapterHandle.getAdapter() : null, status);
};

DataAdapter.prototype.onXflowLoadEvent = function(node, newLevel, oldLevel){
    if(newLevel == Infinity){
        dispatchCustomEvent(this.node, 'load', false, true, null);
    }
    else if(newLevel > oldLevel){
        dispatchCustomEvent(this.node, 'progress', false, true, null);
    }
};
DataAdapter.prototype.getDataComplete = function(){
    return this.xflowDataNode.getProgressLevel() == Infinity;
};
DataAdapter.prototype.getDataProgressLevel = function(){
    return this.xflowDataNode.getProgressLevel();
};

    /** Recursively passing platform information to children of a data node
     *  Requires that the children and the parents of data nodes are defined
     *
     * @param {DataNode} parentNode
     */
function recursiveDataNodeAttrInit(parentNode) {
    var children = parentNode._children, NChildren, i;

    if (children && children.length > 0) {
        NChildren = children.length;

        for (i = NChildren; i--;) {
            if (children[i] instanceof DataNode) {
                children[i].setPlatform(parentNode._platform);
                recursiveDataNodeAttrInit(children[i]);
            }
        }
    }
}

function recursiveDataAdapterConstruction(adapter) {
    for (var child = adapter.node.firstElementChild; child !== null; child = child.nextElementSibling) {
        var subadapter = adapter.factory.getAdapter(child);
        if (subadapter) {
            if (subadapter.getXflowNode) {
                adapter.xflowDataNode.appendChild(subadapter.getXflowNode());
            } else if (subadapter.getScriptType) {
                var scriptId = subadapter.node.name;
                if (!scriptId) {
                    XML3D.debug.logError("Parsing error: Externally referenced operators must have a 'name' attribute matching the name they were registered with. ", subadapter.node);
                    scriptId = "unknown_operator";
                }
                adapter.externalScripts[scriptId] = subadapter;
                if (subadapter.connectedAdapterHandle) {
                    adapter.connectAdapterHandle(scriptId, subadapter.connectedAdapterHandle);
                }
                adapter.xflowDataNode.setLoading(true);
            }
            // Passes _platform values to children nodes starting from the node
            // where these attributes are first defined
            if (adapter.xflowDataNode._platform !== null) {
                recursiveDataNodeAttrInit(adapter.xflowDataNode);
            }
        }
    }
}

/**
 * The notifyChanged() method is called by the XML3D data structure to
 * notify the DataAdapter about data changes (DOM mustation events) in its
 * associating node. When this method is called, all observers of the
 * DataAdapter are notified about data changes via their notifyDataChanged()
 * method.
 *
 * @param evt notification of type XML3D.Notification
 */
DataAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type === Events.ADAPTER_HANDLE_CHANGED) {
        this.connectedAdapterChanged(evt.key, evt.adapter, evt.handleStatus);
        if (evt.handleStatus === AdapterHandle.STATUS.NOT_FOUND) {
            XML3D.debug.logError("Could not find <data> element of url '" + evt.url + "' for " + evt.key, this.node);
        }

    } else if (evt.type === Events.NODE_INSERTED) {
        var insertedNode = evt.affectedNode;
        var adapter = this.factory.getAdapter(insertedNode);
        if (!adapter) {
            return;
        }

        var insertedXflowNode = adapter.getXflowNode();
        var sibling = insertedNode, followUpAdapter = null;

        do {
            sibling = sibling.nextSibling;
        } while (sibling && !(followUpAdapter = this.factory.getAdapter(sibling)));

        if (followUpAdapter) {
            this.xflowDataNode.insertBefore(insertedXflowNode, followUpAdapter.getXflowNode());
        } else {
            this.xflowDataNode.appendChild(insertedXflowNode);
        }

    } else if (evt.type === Events.NODE_REMOVED) {
        var adapter = this.factory.getAdapter(evt.affectedNode);
        if (!adapter) {
            return;
        }

        var removedXflowNode = adapter.getXflowNode();
        this.xflowDataNode.removeChild(removedXflowNode);

    } else if (evt.type === Events.VALUE_MODIFIED) {
        var attr = evt.mutation.attributeName;

        if (attr === "filter" && !this.assetData) {
            this.xflowDataNode.setFilter(this.node.getAttribute(attr));
        }
        else if (attr === "compute" && !this.assetData) {
            updateCompute(this);
        }
        else if (attr === "src") {
            this.updateAdapterHandle(attr, this.node.getAttribute(attr));
        } else if (attr === "platform") {
            updatePlatform(this);
        }

    } else if (evt.type === Events.THIS_REMOVED) {
        this.clearAdapterHandles();
    }
};

DataAdapter.prototype.connectedAdapterChanged = function (key, adapter /*, status */) {
    if (key === "src") {
        this.xflowDataNode.sourceNode = adapter ? adapter.getXflowNode() : null;
    } else if (key === "dataflow") {
        this.xflowDataNode.dataflowNode = adapter ? adapter.getXflowNode() : null;
    } else if (this.externalScripts[key]) {
        window.eval(adapter.script);
        this.xflowDataNode.notify(XC.RESULT_STATE.CHANGED_STRUCTURE);
    }
    // Cycle the load state to force a load event even if the new sourceNode is cached
    this.xflowDataNode.setLoading(true);
    updateLoadState(this);
};

/**
 * Returns String representation of this DataAdapter
 */
DataAdapter.prototype.toString = function () {
    return "DataAdapter";
};

function updateCompute(dataAdapter) {
    var xflowNode = dataAdapter.xflowDataNode;
    xflowNode.setCompute(dataAdapter.node.getAttribute("compute"));
    if (xflowNode.computeDataflowUrl) {
        dataAdapter.updateAdapterHandle("dataflow", xflowNode.computeDataflowUrl);
    }
    else {
        dataAdapter.disconnectAdapterHandle("dataflow");
        updateLoadState(dataAdapter);
    }
}

function updatePlatform(dataAdapter) {
    var xflowNode = dataAdapter.xflowDataNode;

    xflowNode.setPlatform(dataAdapter.node.getAttribute("platform"));
    recursiveDataNodeAttrInit(xflowNode);
}

function updateLoadState(dataAdpater) {
    var loading = false, handle;

    handle = dataAdpater.getConnectedAdapterHandle("src");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }

    handle = dataAdpater.getConnectedAdapterHandle("dataflow");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }

    for (var name in dataAdpater.externalScripts) {
        handle = dataAdpater.getConnectedAdapterHandle(name);
        if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
            loading = true;
        }
    }

    dataAdpater.xflowDataNode.setLoading(loading);
}


module.exports = DataAdapter;



},{"../../base/adapterhandle.js":8,"../../interface/notification.js":36,"../../utils/misc.js":131,"../../xflow/interface/constants.js":136,"../../xflow/interface/graph.js":138,"./base.js":16}],19:[function(require,module,exports){
var BaseDataAdapter = require("./base.js");
var DataNode = require("../../xflow/interface/graph.js").DataNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var AdapterHandle = require("../../base/adapterhandle.js");

/**
 * DataAdapter handling a <dataflow> element
 * @param factory
 * @param node
 * @constructor
 */
var DataflowDataAdapter = function (factory, node) {
    BaseDataAdapter.call(this, factory, node);
    this.xflowDataNode = null;
    this.externalScripts = {};
};
XML3D.createClass(DataflowDataAdapter, BaseDataAdapter);

DataflowDataAdapter.prototype.init = function () {
    this.xflowDataNode = new DataNode(false);
    this.dataflowRefs = [];
    updateDataflowXflowNode(this, this.node);
};

DataflowDataAdapter.prototype.updateAdapterHandle = function(key, url) {
    var oldAdapterHandle = this.getConnectedAdapterHandle(key);

    var adapterHandle = this.getAdapterHandle(url),
        status = (adapterHandle && adapterHandle.status);

    if(oldAdapterHandle == adapterHandle)
        return;
    if (status === AdapterHandle.STATUS.NOT_FOUND) {
        XML3D.debug.logError("Could not find element of url '" + adapterHandle.url + "' for " + key, this.node);
    }
    this.connectAdapterHandle(key, adapterHandle);
    this.connectedAdapterChanged(key, adapterHandle ? adapterHandle.getAdapter() : null, status);
};


/**
 * @param evt notification of type XML3D.Notification
 */
DataflowDataAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type === Events.ADAPTER_HANDLE_CHANGED) {
        //TODO: Handle ADAPTER_HANDLE_CHANGED
        if (this.externalScripts[evt.key]) {
            window.eval(evt.adapter.script);
            setLoadingStateForMatchingXflowNodes(this.xflowDataNode, evt.key, false);
            this.xflowDataNode.notify(XC.RESULT_STATE.CHANGED_STRUCTURE);
        }
    }

    switch (evt.type) {
        case Events.ADAPTER_HANDLE_CHANGED:
            this.connectedAdapterChanged(evt.key, evt.adapter, evt.handleStatus);
            if (evt.handleStatus === AdapterHandle.STATUS.NOT_FOUND) {
                XML3D.debug.logError("Could not find dataflow of url '" + evt.url, this.node);
            }
            break;

        case Events.NODE_INSERTED:
        case Events.NODE_REMOVED:
            updateDataflowXflowNode(this);
            break;

        case Events.VALUE_MODIFIED:
            var attr = evt.mutation.attributeName;
            if (attr === "out") {
                updateDataflowOut(this);
            } else if (attr === "platform") {
                updateDataflowXflowNode(this, this.node);
            }
            break;
    }
};

/**
 * Traverse all subnodes of a dataflow and set the loading state of
 * all nodes with a compute operator that relies on the matching external script name.
 * A compute node will only be executed if its loading state is 'false' and none of its children are 'loading', so
 * this ensures we don't do the compute operations until the external operators have been loaded.
 * @param {DataNode} node the current node to check for instances of the given operator
 * @param {string} name the name of the external operator to check for
 * @param {boolean} loading whether the operator has finished loading or not
 */
function setLoadingStateForMatchingXflowNodes(node, name, loading) {
    if (node._computeOperator === name) {
        node.setLoading(loading);
    }
    if (node._children) {
        var i = node._children.length;
        while (i--) {
            setLoadingStateForMatchingXflowNodes(node._children[i], name, loading);
        }
    }
}

DataflowDataAdapter.prototype.updateXflowNode = function () {
    updateDataflowXflowNode(this, this.node);
};

DataflowDataAdapter.prototype.connectedAdapterChanged = function (key, adapter, status) {
    var xflowNode = this.dataflowRefs[key];
    if (xflowNode) {
        xflowNode.dataflowNode = adapter ? adapter.getXflowNode() : null;
        xflowNode.setLoading(status === AdapterHandle.STATUS.LOADING);
    }
};

function updateDataflowOut(adapter) {
    var out = adapter.node.getAttribute("out");
    if (out) {
        adapter.xflowDataNode.setFilter("keep(" + out + ")");
    } else {
        adapter.xflowDataNode.setFilter("");
    }
}

function updateDataflowXflowNode(adapter, node) {
    // Getting platform and node type information for a Dataflow node
    var platform = node.getAttribute("platform");

    adapter.xflowDataNode.clearChildren();
    adapter.xflowDataNode.setCompute("");
    adapter.clearAdapterHandles();
    adapter.dataflowRefs = [];
    adapter.externalScripts = {};
    updateDataflowOut(adapter);

    var child = node.lastElementChild, firstNode = true, prevNode = null, currentNode = adapter.xflowDataNode, subAdapter, xflowNode;

    do {
        subAdapter = adapter.factory.getAdapter(child);
        if (!subAdapter) {
            continue;
        }

        if (subAdapter.getXflowNode) {
            xflowNode = subAdapter.getXflowNode();

            if (prevNode) {
                currentNode.insertBefore(xflowNode, prevNode);
            } else {
                currentNode.appendChild(xflowNode);
            }
            prevNode = xflowNode;
        } else if (subAdapter.getComputeCode) {
            var statements = subAdapter.getComputeCode().split(";");
            var j = statements.length;

            while (j--) {
                var compute = statements[j].trim();
                if (!compute) {
                    continue;
                }

                if (firstNode) {
                    firstNode = false;
                } else {
                    xflowNode = new DataNode(false);
                    if (prevNode) {
                        currentNode.insertBefore(xflowNode, prevNode);
                    } else {
                        currentNode.appendChild(xflowNode);
                    }
                    currentNode = xflowNode;
                    prevNode = null;
                }
                currentNode.userData = child;

                currentNode.setPlatform(platform);

                currentNode.setCompute(statements[j].trim());

                if (currentNode.computeDataflowUrl) {
                    var idx = adapter.dataflowRefs.length;
                    adapter.dataflowRefs.push(currentNode);
                    adapter.updateAdapterHandle(idx, currentNode.computeDataflowUrl);
                }
            }
        } else if (subAdapter.getScriptType) {
            var scriptId = subAdapter.node.name;
            if (!scriptId) {
                XML3D.debug.logError("Parsing error: Externally referenced operators must have a 'name' attribute matching the name they were registered with. ", subAdapter.node);
                scriptId = "unknown_operator";
            }
            adapter.externalScripts[scriptId] = subAdapter;
            if (subAdapter.connectedAdapterHandle) {
                adapter.connectAdapterHandle(scriptId, subAdapter.connectedAdapterHandle);
            }
        }

    } while (child = child.previousElementSibling);

    for (var name in adapter.externalScripts) {
        // Ensure XFlow doesn't execute any compute nodes that depend on external scripts until they're loaded
        setLoadingStateForMatchingXflowNodes(adapter.xflowDataNode, name, true);
    }
}


module.exports = DataflowDataAdapter;

},{"../../base/adapterhandle.js":8,"../../interface/notification.js":36,"../../xflow/interface/constants.js":136,"../../xflow/interface/graph.js":138,"./base.js":16}],20:[function(require,module,exports){
var NodeAdapterFactory = require("../../base/adapter.js").NodeAdapterFactory;
var Asset = require("./asset.js");
var Misc = require("./misc.js");
var ScriptDataAdapter = require("./script.js");
var TextureDataAdapter = require("./texture.js");
var TransformDataAdapter = require("./transform.js");
var ValueDataAdapter = require("./values.js");
var DataAdapter = require("./data.js");
var ComputeDataAdapter = require("./compute.js");
var DataflowDataAdapter = require("./dataflow.js");
// Register JSON Handler
require("./json/factory.js");
// Register JavaScript Handler (required for external shade.js Javascript resources)
require("./javascript/factory.js");

/**
 * Constructor of XML3DDataAdapterFactory
 * XML3DDataAdapterFactory creates DataAdapter instances for elements using generic data (<mesh>, <data>, <float>,...).
 * Additionally, it manages all DataAdapter instances so that for each node there is always just one DataAdapter. When
 * it creates a DataAdapter, it calls its init method.
 *
 * @constructor
 * @extends AdapterFactory
 */

var XML3DDataAdapterFactory = function () {
    NodeAdapterFactory.call(this, "data");
};
XML3D.createClass(XML3DDataAdapterFactory, NodeAdapterFactory);
XML3DDataAdapterFactory.prototype.aspect = "data";

var reg = {
    'mesh': Misc.SinkDataAdapter,
    'shader': Misc.SinkDataAdapter,
    'lightshader': Misc.SinkDataAdapter,
    'float': ValueDataAdapter,
    'float2': ValueDataAdapter,
    'float3': ValueDataAdapter,
    'float4': ValueDataAdapter,
    'float4x4': ValueDataAdapter,
    'int': ValueDataAdapter,
    'int4': ValueDataAdapter,
    'bool': ValueDataAdapter,
    'byte': ValueDataAdapter,
    'ubyte': ValueDataAdapter,
    'img': Misc.ImgDataAdapter,
    'texture': TextureDataAdapter,
    'data': DataAdapter,
    'proto': DataAdapter,
    'dataflow': DataflowDataAdapter,
    'compute': ComputeDataAdapter,
    'video': Misc.VideoDataAdapter,
    'script': ScriptDataAdapter,
    'transform': TransformDataAdapter,
    'asset': Asset.AssetAdapter,
    'assetdata': Asset.AssetDataAdapter,
    'assetmesh': Asset.AssetMeshAdapter,
    'model': Asset.AssetAdapter
};

/**
 * Creates a DataAdapter associated with the given node.
 *
 * @param node
 *            element node which uses generic data. The supported elements
 *            are listed in the class description above.
 * @returns DataAdapter instance
 */
XML3DDataAdapterFactory.prototype.createAdapter = function (node) {
    //XML3D.debug.logDebug("Creating adapter: " + node.localName);
    var adapterContructor = reg[node.localName];
    if (adapterContructor !== undefined) {
        return new adapterContructor(this, node);
    }
    XML3D.debug.logWarning("Not supported as data element: " + node.localName);
    return null;
};

module.exports =  XML3DDataAdapterFactory;

},{"../../base/adapter.js":7,"./asset.js":15,"./compute.js":17,"./data.js":18,"./dataflow.js":19,"./javascript/factory.js":21,"./json/factory.js":22,"./misc.js":23,"./script.js":24,"./texture.js":25,"./transform.js":26,"./values.js":27}],21:[function(require,module,exports){
var registerFormat = require("../../../base/resourcemanager.js").registerFormat;
var FormatHandler = require("../../../base/formathandler.js").FormatHandler;
var AdapterFactory = require("../../../base/adapter.js").AdapterFactory;

var JavaScriptFormatHandler = function () {
    FormatHandler.call(this);
};
XML3D.createClass(JavaScriptFormatHandler, FormatHandler);

JavaScriptFormatHandler.prototype.isFormatSupported = function (response, responseType, mimetype) {
    return mimetype === "application/javascript" || mimetype === "text/javascript";
};


JavaScriptFormatHandler.prototype.getFormatData = function (response, responseType, mimetype, callback) {
    callback(true, response);
};

var javaScriptFormatHandler = new JavaScriptFormatHandler();
registerFormat(javaScriptFormatHandler);


var ScriptDataAdapter = function (script) {
    this.script = script;
};

ScriptDataAdapter.prototype.getScriptType = function () {
    return "application/javascript";
};

ScriptDataAdapter.prototype.getScript= function () {
    return this.script;
};


var ScriptFactory = function () {
    AdapterFactory.call(this, "data");
};
XML3D.createClass(ScriptFactory, AdapterFactory);


ScriptFactory.prototype.aspect = "data";

ScriptFactory.prototype.createAdapter = function (xflowNode) {
    return new ScriptDataAdapter(xflowNode);
};

javaScriptFormatHandler.registerFactoryClass(ScriptFactory);

},{"../../../base/adapter.js":7,"../../../base/formathandler.js":9,"../../../base/resourcemanager.js":10}],22:[function(require,module,exports){
var XC = require("../../../xflow/interface/constants.js");
var InputNode = require("../../../xflow/interface/graph.js").InputNode;
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var Resource = require("../../../base/resourcemanager.js").Resource;
var registerFormat = require("../../../base/resourcemanager.js").registerFormat;
var JSONFormatHandler = require("../../../base/formathandler.js").JSONFormatHandler;
var AdapterFactory = require("../../../base/adapter.js").AdapterFactory;

var XML3DJSONFormatHandler = function() {
    JSONFormatHandler.call(this);
};
XML3D.createClass(XML3DJSONFormatHandler, JSONFormatHandler);

XML3DJSONFormatHandler.prototype.isFormatSupported = function(response, responseType, mimetype) {
    return mimetype === "application/json" && response.format == "xml3d-json" && response.version == "0.4.0";
};


XML3DJSONFormatHandler.prototype.getFormatData = function(response, responseType, mimetype, callback) {
    try{
        var xflowNode = createXflowNode(response);
        callback(true, xflowNode);
    } catch (e) {
        XML3D.debug.logException(e, "Failed to process XML3D json file");
        callback(false);
    }

};

var xml3dJSonFormatHandler = new XML3DJSONFormatHandler();
registerFormat(xml3dJSonFormatHandler);


var empty = function() {};

var TYPED_ARRAY_MAP = {
    "int" : Int32Array,
    "int4" : Int32Array,
    "float" : Float32Array,
    "float2" : Float32Array,
    "float3" : Float32Array,
    "float4" : Float32Array,
    "float4x4" : Float32Array,
    "bool" : Uint8Array,
    "byte" : Int8Array,
    "ubyte" : Uint8Array
};

var isLittleEndian = (function () {
    var buf = new ArrayBuffer(4);
    var dv = new DataView(buf);
    var view = new Int32Array(buf);
    view[0] = 0x01020304;
    var littleEndian = (dv.getInt32(0, true) === 0x01020304);
    return function () { return littleEndian; }
})();

function realTypeOf(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1);
}

function createXflowValue(dataNode, dataType, name, key, value) {
    var v = new (TYPED_ARRAY_MAP[dataType])(value);
    var type = XC.DATA_TYPE.fromString(dataType);
    var buffer = new BufferEntry(type, v);

    var inputNode = new InputNode();
    inputNode.data = buffer;
    inputNode.name = name;
    inputNode.key = key;
    dataNode.appendChild(inputNode);
}

function createXflowValueFromBuffer(dataNode, dataType, name, key, arrayBuffer, byteOffset, byteLength) {
    var ArrayType = TYPED_ARRAY_MAP[dataType];
    var v = new (ArrayType)(arrayBuffer, byteOffset, byteLength/ArrayType.BYTES_PER_ELEMENT);
    var type = XC.DATA_TYPE.fromString(dataType);
    var buffer = new BufferEntry(type, v);

    var inputNode = new InputNode();
    inputNode.data = buffer;
    inputNode.name = name;
    inputNode.key = key;
    dataNode.appendChild(inputNode);
}

function createXflowInputs(dataNode, name, jsonData){
    var v = null;

    if (!TYPED_ARRAY_MAP[jsonData.type])
        return;

    for(var i = 0; i < jsonData.seq.length; ++i) {
        var entry = jsonData.seq[i];
        var value = entry.value;
        var key = entry.key;

        if (realTypeOf(value) === 'Object' && value.url) {
            if (!isLittleEndian()) {
                // FIXME add big-endian -> little-endian conversion
                throw new Error("Big-endian binary data are not supported yet");
            }
            Resource.loadData(value.url, function (arrayBuffer) {
                createXflowValueFromBuffer(dataNode, jsonData.type, name, key, arrayBuffer, value.byteOffset, value.byteLength);
            }, null);
        } else {
            createXflowValue(dataNode, jsonData.type, name, key, value);
        }
    }
}

function createXflowNode(jsonData){
    if (jsonData.format != "xml3d-json")
        throw new Error("Unknown JSON format: " + jsonData.format);
    if (jsonData.version != "0.4.0")
        throw new Error("Unknown JSON version: " + jsonData.version);

    var node = new DataNode(false);
    node.userData = "External Json"; // TODO: Try to add document URL here (how to get it?)

    var entries = jsonData.data;
    for(var name in entries) {
        createXflowInputs(node, name, entries[name]);
    }
    return node;
}

/**
 * @implements IDataAdapter
 */
var JSONDataAdapter = function(xflowNode) {
    this.xflowDataNode = xflowNode;
};

JSONDataAdapter.prototype.getXflowNode = function(){
    return this.xflowDataNode;
};

/**
 * @constructor
 * @implements {XML3D.base.IFactory}
 */
var JSONFactory = function()
{
    AdapterFactory.call(this, "data");
};
XML3D.createClass(JSONFactory, AdapterFactory);


JSONFactory.prototype.aspect = "data";

JSONFactory.prototype.createAdapter = function(xflowNode) {
    return new JSONDataAdapter(xflowNode);
};

xml3dJSonFormatHandler.registerFactoryClass(JSONFactory);

},{"../../../base/adapter.js":7,"../../../base/formathandler.js":9,"../../../base/resourcemanager.js":10,"../../../xflow/interface/constants.js":136,"../../../xflow/interface/data.js":137,"../../../xflow/interface/graph.js":138}],23:[function(require,module,exports){
var DataAdapter = require("./data.js");
var Events = require("../../interface/notification.js");
var URI = require("../../utils/uri.js").URI;
var Util = require("../../utils/misc.js");

var Resource = require("../../base/resourcemanager.js").Resource;
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var createClass = XML3D.createClass;
    /**
     * SinkDataAdapter represents the sink in the data hierarchy (no parents).
     * @constructor
     * @extends {DataAdapter}
     * @param factory
     * @param node
     */
    var SinkDataAdapter = function(factory, node) {
        DataAdapter.call(this, factory, node);
    };
    createClass(SinkDataAdapter, DataAdapter);

    /**
     * Indicates whether this DataAdapter is a SinkAdapter (has no parent
     * DataAdapter).
     *
     * @returns true if this DataAdapter is a SinkAdapter, otherwise false.
     */
    SinkDataAdapter.prototype.isSinkAdapter = function() {
        return true;
    };

    /**
     * Returns String representation of this DataAdapter
     */
    SinkDataAdapter.prototype.toString = function() {
        return "XML3D.data.SinkDataAdapter";
    };


    var ImgDataAdapter = function(factory, node) {
        NodeAdapter.call(this, factory, node);
        this.textureEntry = null;
        this.image = null;
        if (node.src)
            this.createImageFromURL(node.src);
    };
    createClass(ImgDataAdapter, NodeAdapter);

    /**
     * Creates a new image object
     *
     * @param {string} url
     */
    ImgDataAdapter.prototype.createImageFromURL = function(url) {
        var that = this;
        var uri = new URI(url).getAbsoluteURI(this.node.ownerDocument._documentURL || this.node.ownerDocument.URL);
        var onload = function (e, image) {
            if (that.textureEntry) {
                that.textureEntry.setImage(image, true);
            }
        };
        var onerror = function (e, image) {
            XML3D.debug.logError("Could not load image URI="+image.src);
        };
        this.image = Resource.getImage(uri, onload, onerror);
        if (that.textureEntry) {
            that.textureEntry.setImage(this.image, true);
        }
    };

    /**
     * @param {Xflow.TextureEntry} entry
     */
    ImgDataAdapter.prototype.setTextureEntry = function(entry) {
        this.textureEntry = entry;
        if (this.image) {
            this.textureEntry.setImage(this.image, true);
        }
    };

    ImgDataAdapter.prototype.notifyChanged = function(evt) {
        if (evt.type == Events.VALUE_MODIFIED) {
            var attr = evt.mutation.attributeName;
            if(attr == "src"){
                this.createImageFromURL(this.node.src);
            }
        };
    };

    ImgDataAdapter.prototype.getValue = function(cb, obj) {
        return this.image;
    };

    ImgDataAdapter.prototype.getOutputs = function() {
        var result = {};
        result['image'] = this;
        return result;
    };

    ImgDataAdapter.prototype.resolveScript = function() {
        return null;
    };

    var VideoDataAdapter = function(factory, node) {
        DataAdapter.call(this, factory, node);
        this.textureEntry = null;
        this.video = null;
        this._ticking = false;
        this._boundTick = this._tick.bind(this);
        if (node.src)
            this.createVideoFromURL(node.src);
    };
    createClass(VideoDataAdapter, NodeAdapter);

    /**
     * Creates a new video object
     *
     * @param {string} url
     */
    VideoDataAdapter.prototype.createVideoFromURL = function(url) {
        var that = this;
        var uri = new URI(url).getAbsoluteURI(this.node.ownerDocument._documentURL || this.node.ownerDocument.URL);
        this.video = Resource.getVideo(uri, this.node.autoplay, this.node.loop,
            {
                canplay : function(event, video) {
                    Util.dispatchCustomEvent(that.node, 'canplay', true, true, null);
                    that._startVideoRefresh();
                },
                ended : function(event, video) {
                    Util.dispatchCustomEvent(that.node, 'ended', true, true, null);
                },
                load : function(event, video) {
                    Util.dispatchEvent(that.node, 'load');
                },
                error : function(event, video) {
                    Util.dispatchCustomEvent(that.node, 'error', true, true, null);
                    XML3D.debug.logError("Could not load video URI="+video.src);
                }
            }
        );
        if (this.textureEntry)
            this.textureEntry.setImage(this.video, true);
    };

    VideoDataAdapter.prototype.play = function() {
        if (this.video)
            this.video.play();
    };

    VideoDataAdapter.prototype.pause = function() {
        if (this.video)
            this.video.pause();
    };

    VideoDataAdapter.prototype._startVideoRefresh = function() {
        if (!this._ticking)
            this._tick();
    };

    VideoDataAdapter.prototype._tick = function() {
        this._ticking = true;
        window.requestAnimFrame(this._boundTick, 30);
        // FIXME Do this only when currentTime is changed (what about webcam ?)
        if (this.textureEntry) {
            this.textureEntry.setImage(this.video);
        }
    };

    /**
     * @param {Xflow.TextureEntry} entry
     */
    VideoDataAdapter.prototype.setTextureEntry = function(entry) {
        this.textureEntry = entry;
        if (this.video) {
            this.textureEntry.setImage(this.video, true);
        }
    };

    VideoDataAdapter.prototype.notifyChanged = function(evt) {
        if (evt.type == Events.VALUE_MODIFIED) {
            var attr = evt.mutation.attributeName;
            if(attr == "src"){
                this.createVideoFromURL(this.node.src);
            }
        };
    };

    VideoDataAdapter.prototype.getValue = function(cb, obj) {
        return this.video;
    };

    VideoDataAdapter.prototype.getOutputs = function() {
        var result = {};
        result['video'] = this;
        return result;
    };

    // Export
    module.exports = {
        ImgDataAdapter: ImgDataAdapter,
        VideoDataAdapter: VideoDataAdapter,
        SinkDataAdapter: SinkDataAdapter
    };


},{"../../base/adapter.js":7,"../../base/resourcemanager.js":10,"../../interface/notification.js":36,"../../utils/misc.js":131,"../../utils/uri.js":133,"./data.js":18}],24:[function(require,module,exports){
var Events = require("../../interface/notification.js");
var createClass = XML3D.createClass;
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

var ScriptDataAdapter = function(factory, node) {
    NodeAdapter.call(this, factory, node);
    this.connectedAdapterHandle = null;
    if (node.src) {
        this.connectedAdapterHandle = this.getAdapterHandle(node.src);
        this.connectAdapterHandle(node.name, this.connectedAdapterHandle);
    }
};
createClass(ScriptDataAdapter, NodeAdapter);

ScriptDataAdapter.prototype.getScriptType = function(){
    return this.node.type;
};

ScriptDataAdapter.prototype.getScript = function(){
    if (this.node.src) {
        return this.externalScript;
    } else {
        return this.node.value;
    }
};

ScriptDataAdapter.prototype.notifyChanged = function(evt) {
    switch(evt.type){
        case Events.VALUE_MODIFIED:
        case Events.NODE_INSERTED:
        case Events.NODE_REMOVED:
            this.notifyOppositeAdapters();
            break;

        case Events.ADAPTER_HANDLE_CHANGED:
            this.externalScript = evt.adapter.script;
            this.notifyOppositeAdapters();
            break;
    }
};

module.exports = ScriptDataAdapter;
},{"../../base/adapter.js":7,"../../interface/notification.js":36}],25:[function(require,module,exports){
var TextureEntry = require("../../xflow/interface/data.js").TextureEntry;
var InputNode = require("../../xflow/interface/graph.js").InputNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

var clampToGL = function (modeStr) {
    if (modeStr == "clamp")
        return WebGLRenderingContext.CLAMP_TO_EDGE;
    if (modeStr == "repeat")
        return WebGLRenderingContext.REPEAT;
};

var filterToGL = function (modeStr) {
    if (modeStr == "nearest")
        return WebGLRenderingContext.NEAREST;
    if (modeStr == "linear")
        return WebGLRenderingContext.LINEAR;
    if (modeStr == "nearest-mipmap-nearest")
        return WebGLRenderingContext.NEAREST_MIPMAP_NEAREST;
    if (modeStr == "linear-mipmap-nearest")
        return WebGLRenderingContext.LINEAR_MIPMAP_NEAREST;
    if (modeStr == "nearest-mipmap-linear")
        return WebGLRenderingContext.NEAREST_MIPMAP_LINEAR;
    if (modeStr == "linear-mipmap-linear")
        return WebGLRenderingContext.LINEAR_MIPMAP_LINEAR;
};

var TextureDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
};
XML3D.createClass(TextureDataAdapter, NodeAdapter);

TextureDataAdapter.prototype.init = function () {
    this.xflowInputNode = this.createXflowNode();
    this.xflowInputNode.data = this.createTextureEntry();
};

TextureDataAdapter.prototype.createTextureEntry = function () {
    var node = this.node;
    var entry = new TextureEntry(null);
    var config = entry.getSamplerConfig();
    config.wrapS = clampToGL(node.wrapS);
    config.wrapT = clampToGL(node.wrapT);
    config.minFilter = filterToGL(node.filterMin);
    config.magFilter = filterToGL(node.filterMag);
    config.textureType = XC.TEX_TYPE.TEXTURE_2D;
    config.generateMipMap = this.shouldGenerateMipMaps(config.minFilter, config.magFilter);

    var imageAdapter = this.factory.getAdapter(this.node.firstElementChild);
    if (imageAdapter) {
        imageAdapter.setTextureEntry(entry);
    }
    return entry;
};

TextureDataAdapter.prototype.shouldGenerateMipMaps = function (minFilter, magFilter) {
    return (minFilter != WebGLRenderingContext.NEAREST && minFilter != WebGLRenderingContext.LINEAR) || (magFilter != WebGLRenderingContext.NEAREST && magFilter != WebGLRenderingContext.LINEAR);
};

TextureDataAdapter.prototype.createXflowNode = function () {
    var xnode = new InputNode();
    xnode.name = this.node.name;
    xnode.paramName = this.node.param ? this.node.name : null;
    xnode.key = this.node.key;
    return xnode;
};

TextureDataAdapter.prototype.setScriptValue = function (value) {
    XML3D.debug.logError("Texture currently does not support setScriptValue()");
}

TextureDataAdapter.prototype.getOutputs = function () {
    var result = {};
    result[this.node.name] = this;
    return result;
};

TextureDataAdapter.prototype.getValue = function () {
    return this.value;
};

TextureDataAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type == Events.VALUE_MODIFIED) {
        var attr = evt.mutation.attributeName;
        if (attr == "name") {
            this.xflowInputNode.name = this.node.name;
        } else if (attr == "key") {
            this.xflowInputNode.key = this.node.key;
        } else if (attr == "param") {
            this.xflowInputNode.paramName = this.node.param ? this.node.name : null;
        }
    }
};

/**
 * @return {Element}
 */
TextureDataAdapter.prototype.getXflowNode = function () {
    return this.xflowInputNode;
};

/**
 * Returns String representation of this TextureDataAdapter
 */
TextureDataAdapter.prototype.toString = function () {
    return "XML3D.data.TextureDataAdapter";
};

// Export
module.exports = TextureDataAdapter;

},{"../../base/adapter.js":7,"../../interface/notification.js":36,"../../xflow/interface/constants.js":136,"../../xflow/interface/data.js":137,"../../xflow/interface/graph.js":138}],26:[function(require,module,exports){
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

var TransformDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
    this.isValid = true;
    this.needsUpdate = true;
};

XML3D.createClass(TransformDataAdapter, NodeAdapter);

var IDENT_MAT = XML3D.math.mat4.identity(XML3D.math.mat4.create());

TransformDataAdapter.prototype.init = function () {
    // Create all matrices, no valid values yet
    this.matrix = XML3D.math.mat4.create();
    this.transform = {
        translate: XML3D.math.mat4.create(),
        scale: XML3D.math.mat4.create(),
        scaleOrientation: XML3D.math.mat4.create(),
        scaleOrientationInv: XML3D.math.mat4.create(),
        center: XML3D.math.mat4.create(),
        centerInverse: XML3D.math.mat4.create(),
        rotation: XML3D.math.mat4.create()
    };
    this.needsUpdate = true;
    this.checkForImproperNesting();
};

TransformDataAdapter.prototype.updateMatrix = function () {
    var n = this.node;
    var transform = this.transform;
    var centerVec = n.center._data;

    XML3D.math.mat4.fromQuat(transform.scaleOrientation, n.scaleOrientation._data);
    XML3D.math.mat4.fromQuat(transform.rotation, n.rotation._data);

    XML3D.math.mat4.translate(transform.translate, IDENT_MAT, n.translation._data);
    XML3D.math.mat4.translate(transform.center, IDENT_MAT, centerVec);
    XML3D.math.mat4.translate(transform.centerInverse, IDENT_MAT, XML3D.math.vec3.negate(centerVec, centerVec));
    XML3D.math.mat4.scale(transform.scale, IDENT_MAT, n.scale._data);
    XML3D.math.mat4.invert(transform.scaleOrientationInv, transform.scaleOrientation);

    multiplyComponents(transform, this.matrix);
    this.needsUpdate = false;
};

function multiplyComponents(transform, matrix) {
    // M = T * C
    XML3D.math.mat4.multiply(matrix, transform.translate, transform.center);
    // M = T * C * R
    XML3D.math.mat4.multiply(matrix, matrix, transform.rotation);
    // M = T * C * R * SO
    XML3D.math.mat4.multiply(matrix, matrix, transform.scaleOrientation);
    // M = T * C * R * SO * S
    XML3D.math.mat4.multiply(matrix, matrix, transform.scale);
    // M = T * C * R * SO * S * -SO
    XML3D.math.mat4.multiply(matrix, matrix, transform.scaleOrientationInv);
    // M = T * C * R * SO * S * -SO * -C
    XML3D.math.mat4.multiply(matrix, matrix, transform.centerInverse);
}

TransformDataAdapter.prototype.getMatrix = function () {
    this.needsUpdate && this.updateMatrix();
    return this.matrix;
};


TransformDataAdapter.prototype.notifyChanged = function (e) {
    if (e.type == Events.VALUE_MODIFIED) {
        this.needsUpdate = true;
        this.notifyOppositeAdapters(Events.ADAPTER_VALUE_CHANGED);
    } else if (e.type == Events.NODE_REMOVED) {
        this.dispose();
        this.notifyOppositeAdapters(Events.ADAPTER_HANDLE_CHANGED);
    }
};
TransformDataAdapter.prototype.dispose = function () {
    this.isValid = false;
};

TransformDataAdapter.prototype.checkForImproperNesting = function () {
    for (var i = 0; i < this.node.childNodes.length; i++) {
        if (this.node.childNodes[i].localName === "transform") {
            XML3D.debug.logError("Parsing error: Transform elements cannot be nested!", this.node);
        }
    }
};

// Export to XML3D.data namespace
module.exports = TransformDataAdapter;




},{"../../base/adapter.js":7,"../../interface/notification.js":36}],27:[function(require,module,exports){
var BufferEntry = require("../../xflow/interface/data.js").BufferEntry;
var InputNode = require("../../xflow/interface/graph.js").InputNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

/**
 * Constructor of XML3D.data.ValueDataAdapter
 *
 * @extends XML3D.data.DataAdapter
 * @constructor
 *
 * @param factory
 * @param {Element} node
 */
var ValueDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
    this.xflowInputNode = null;
};
XML3D.createClass(ValueDataAdapter, NodeAdapter);

ValueDataAdapter.prototype.init = function()
{
    var config = this.node._configured, value;
    if(this.node.textContent == "[value set by script]"){
        value = config.scriptValue;
    }
    else{
        delete config.scriptValue;
        value = this.node.value;
    }

    var type = XC.DATA_TYPE.fromString(this.node.localName);
    var buffer = new BufferEntry(type, value);

    this.xflowInputNode = new InputNode(null);
    this.xflowInputNode.name = this.node.name;
    this.xflowInputNode.data = buffer;
    this.xflowInputNode.key = this.node.key;
    this.xflowInputNode.paramName = this.node.param ? this.node.name : null;
    this.checkForImproperNesting();
};

ValueDataAdapter.prototype.getXflowNode = function () {
    return this.xflowInputNode;
};

/**
 *
 */
ValueDataAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type == Events.VALUE_MODIFIED) {
        var attr = evt.mutation.attributeName;
        if (!attr) {
            delete this.node._configured.scriptValue;
            this.xflowInputNode.data.setValue(this.node.value);
        } else if (attr == "name") {
            this.xflowInputNode.name = this.node.name;
        } else if (attr == "key") {
            this.xflowInputNode.key = this.node.key;
        } else if (attr == "param") {
            this.xflowInputNode.paramName = this.node.param ? this.node.name : null;
        }
    }
};

ValueDataAdapter.prototype.setScriptValue = function (value) {
    // TODO: Add Type check
    this.xflowInputNode.data.setValue(value);
};

/**
 * Returns String representation of this DataAdapter
 */
ValueDataAdapter.prototype.toString = function () {
    return "XML3D.data.ValueDataAdapter";
};

ValueDataAdapter.prototype.checkForImproperNesting = function() {
    for (var i=0; i < this.node.childNodes.length; i++) {
        if (XC.DATA_TYPE.fromString(this.node.childNodes[i].localName)) {
            XML3D.debug.logError("Parsing error: Value elements cannot be nested!", this.node);
        }
    }
};

// Export
module.exports = ValueDataAdapter;

},{"../../base/adapter.js":7,"../../interface/notification.js":36,"../../xflow/interface/constants.js":136,"../../xflow/interface/data.js":137,"../../xflow/interface/graph.js":138}],28:[function(require,module,exports){
var ComputeRequest = require("../xflow/interface/request.js").ComputeRequest;
var Events = require("../interface/notification.js");
var CSS = require("../utils/css.js");

var DOMTransformFetcher = function (owner, attrName, dataName, onlyDataTransform) {
    this.owner = owner;
    this.node = owner.node;
    this.attrName = attrName;
    this.dataName = dataName;
    this.adapterHandle = null;
    this.xflowRequest = null;
    this.onlyDataTransform = onlyDataTransform || false;
    this._bindedCallback = this._onChange.bind(this);
};
DOMTransformFetcher.prototype.clear = function () {
    this.xflowRequest && this.xflowRequest.clear();
    this.xflowRequest = null;
    this.adapterHandle && this.adapterHandle.removeListener(this._bindedCallback)
};

DOMTransformFetcher.prototype.update = function () {
    var newHandle = this.owner.getAdapterHandle(this.node.getAttribute(this.attrName), "data", 0);
    if (newHandle != this.adapterHandle) {
        this.clear();
        this.adapterHandle = newHandle;
        if (newHandle)
            newHandle.addListener(this._bindedCallback)
    }
    this.updateMatrix();
};

DOMTransformFetcher.prototype.updateMatrix = function () {
    this.owner.onTransformChange(this.attrName, this.getMatrix());
};

DOMTransformFetcher.prototype.getMatrix = ( function () {
    var IDENTITY = XML3D.math.mat4.create();
    return function () {
        if (!this.onlyDataTransform) {
            var cssMatrix = CSS.getCSSMatrix(this.node);
            if (cssMatrix) {
                return CSS.convertCssToMat4(cssMatrix);
            }
        }
        var adapter;
        if (this.adapterHandle && (adapter = this.adapterHandle.getAdapter())) {
            if (adapter.getXflowNode) {
                if (!this.xflowRequest)
                    this.xflowRequest = new ComputeRequest(adapter.getXflowNode(), [this.dataName], this._bindedCallback);
                var dataResult = this.xflowRequest.getResult();
                var transformData = (dataResult.getOutputData(this.dataName) && dataResult.getOutputData(this.dataName).getValue());
                if (transformData)
                    return transformData;
            }
            if (adapter.getMatrix) {
                return adapter.getMatrix();
            }
        }
        return this.onlyDataTransform ? null : IDENTITY;
    };
}());

DOMTransformFetcher.prototype._onChange = function (evt) {
    if (evt.type == Events.ADAPTER_VALUE_CHANGED) {
        this.owner.onTransformChange(this.attrName, evt.adapterHandle.getAdapter().getMatrix());
    } else { // If the adapter changed, we need to re-evaluate the matrix
        this.updateMatrix();
    }
};

module.exports = DOMTransformFetcher;

},{"../interface/notification.js":36,"../utils/css.js":128,"../xflow/interface/request.js":139}],29:[function(require,module,exports){
if (window.XML3D !== undefined) {
    throw new Error("Tried to define the XML3D namespace a second time. Please ensure xml3d.js is only loaded once!");
}
/** @namespace * */
var XML3D = XML3D || {};
var Xflow = Xflow || {};
window.XML3D = XML3D;
window.Xflow = Xflow;

XML3D.version = '%VERSION%';
/** @const */
XML3D.xml3dNS = 'http://www.xml3d.org/2009/xml3d';
/** @const */
XML3D.xhtmlNS = 'http://www.w3.org/1999/xhtml';
/** @const */
XML3D.webglNS = 'http://www.xml3d.org/2009/xml3d/webgl';
XML3D._xml3d = document.createElementNS(XML3D.xml3dNS, "xml3d");
XML3D._parallel = XML3D._parallel != undefined ? XML3D._parallel : false;
XML3D.xhtml = !!(document.doctype && new XMLSerializer().serializeToString(document.doctype).match(/xhtml/i));

XML3D.createElement = function(tagName) {
    return document.createElementNS(XML3D.xml3dNS, tagName);
};

XML3D.extend = function(a, b) {
    for ( var prop in b) {
        var g = b.__lookupGetter__(prop), s = b.__lookupSetter__(prop);
        if (g||s) {
            if (g) {
                a.__defineGetter__(prop, g);
            }
            if (s) {
                a.__defineSetter__(prop, s);
            }
        } else {
            if (b[prop] === undefined) {
                delete a[prop];
            } else if (prop !== "constructor" || a !== window) {
                a[prop] = b[prop];
            }
        }
    }
    return a;
};

/**
 * Returns true if ctor is a superclass of subclassCtor.
 * @param ctor
 * @param subclassCtor
 * @return {Boolean}
 */
XML3D.isSuperclassOf = function(ctor, subclassCtor) {
    while (subclassCtor && subclassCtor.superclass) {
        if (subclassCtor.superclass === ctor.prototype)
            return true;
        subclassCtor = subclassCtor.superclass.constructor;
    }
    return false;
};

/**
 *
 * @param {Object} ctor Constructor
 * @param {Object} parent Parent class
 * @param {Object=} methods Methods to add to the class
 * @return {Object!}
 */
XML3D.createClass = function(ctor, parent, methods) {
    methods = methods || {};
    if (parent) {
        /** @constructor */
        var F = function() {
        };
        F.prototype = parent.prototype;
        ctor.prototype = new F();
        ctor.prototype.constructor = ctor;
        ctor.superclass = parent.prototype;
    }
    ctor.isSuperclassOf = XML3D.isSuperclassOf.bind(ctor, ctor);
    for ( var m in methods) {
        ctor.prototype[m] = methods[m];
    }
    return ctor;
};

XML3D.debug = require("./utils/debug.js");
XML3D.util = require("./utils/misc.js");
XML3D.options = require("./utils/options.js");
XML3D.shaders = require("./renderer/webgl/materials/urn/shaders.js");
XML3D.resource = require("./base/resourcemanager.js").Resource; //Required for the test library because the RM needs to "belong" to the same document as the XML3D element in order to resolve references correctly
XML3D.resource.registerFormat = require("./base/resourcemanager.js").registerFormat;
//XML3D.resource.FormatHandler
//XML3D.resource.JSONFormatHandler
//XML3D.resource.AdapterFactory
XML3D.webcl = require("./utils/webcl.js").webcl;
XML3D.math = require("gl-matrix");
XML3D.math.bbox = require("./math/bbox.js");
require("./math/math.js")(XML3D.math);

window.XML3DBox = require("./types/box.js");
XML3D.extend(window, require("./types/data-observer.js"));
window.XML3DMatrix = require("./types/matrix.js");
window.XML3DRay = require("./types/ray.js");
window.XML3DRotation = require("./types/rotation.js");
window.XML3DVec3 = require("./types/vec3.js");

Xflow.registerOperator = require("./xflow/operator/operator.js").registerOperator;
Xflow.constants = require("./xflow/interface/constants.js");
XML3D.extend(Xflow, require("./xflow/interface/graph.js"));
XML3D.extend(Xflow, require("./xflow/interface/data.js"));
Xflow.ComputeRequest = require("./xflow/interface/request.js").ComputeRequest;

XML3D.webgl = XML3D.webgl || {};
XML3D.webgl.FullscreenQuad = require("./renderer/webgl/base/fullscreenquad.js");
XML3D.webgl.BaseRenderPass = require("./renderer/webgl/render-passes/base.js");
XML3D.webgl.ForwardRenderPass = require("./renderer/webgl/render-passes/forward.js");
XML3D.webgl.BaseRenderTree = require("./renderer/webgl/render-trees/base.js");
XML3D.extend(XML3D.webgl, require("./renderer/webgl/base/rendertarget.js"));


require("./xflow/operator/default");

module.exports = {
    XML3D : XML3D,
    Xflow : Xflow
};

},{"./base/resourcemanager.js":10,"./math/bbox.js":38,"./math/math.js":39,"./renderer/webgl/base/fullscreenquad.js":74,"./renderer/webgl/base/rendertarget.js":77,"./renderer/webgl/materials/urn/shaders.js":94,"./renderer/webgl/render-passes/base.js":99,"./renderer/webgl/render-passes/forward.js":101,"./renderer/webgl/render-trees/base.js":110,"./types/box.js":121,"./types/data-observer.js":122,"./types/matrix.js":123,"./types/ray.js":124,"./types/rotation.js":125,"./types/vec3.js":126,"./utils/debug.js":130,"./utils/misc.js":131,"./utils/options.js":132,"./utils/webcl.js":134,"./xflow/interface/constants.js":136,"./xflow/interface/data.js":137,"./xflow/interface/graph.js":138,"./xflow/interface/request.js":139,"./xflow/operator/default":156,"./xflow/operator/operator.js":176,"gl-matrix":1}],30:[function(require,module,exports){
var XML3D = require("./global.js").XML3D;
var Config = require("./interface/elements.js").config;
var sendAdapterEvent = require("./utils/misc.js").sendAdapterEvent;
var Options = require("./utils/options.js");
var CSS = require("./utils/css.js");
var ConfigureRenderer = require("./renderer/renderer/configure.js");
var WebglSupported = require("./renderer/webgl/base/utils.js").supported;
require("./interface/dom.js");
require("./utils/debug.js");

(function () {
    if (navigator.userAgent.match(/(iPad|iPhone|iPod touch)/i)) {
        var m = document.createElement("meta");
        m.name = "format-detection";
        m.content = "telephone=no";
        document.head.appendChild(m)
    }
}());

function displayWebGLNotSupportedInfo(xml3dElement){

    if(xml3dElement.hasAttribute("onunsupported")){
        var callback = new Function("event", xml3dElement.getAttribute("onunsupported"));
        xml3dElement.addEventListener('unsupported', callback, false);
    }
    var doDefault = XML3D.util.dispatchCustomEvent(xml3dElement, 'unsupported', false, true, null);
    if(doDefault){
        // Place xml3dElement inside an invisible div
        var hideDiv = document.createElementNS(XML3D.xhtmlNS, 'div');

        xml3dElement.parentNode.insertBefore(hideDiv, xml3dElement);
        hideDiv.appendChild(xml3dElement);
        hideDiv.style.display = "none";

        var infoDiv = document.createElementNS(XML3D.xhtmlNS, 'div');
        if(xml3dElement.hasAttribute("class")){
            infoDiv.setAttribute("class", xml3dElement.getAttribute("class"));
        }

        infoDiv.setAttribute("style", xml3dElement.getAttribute("style"));
        infoDiv.style.border = "2px solid red";
        infoDiv.style.fontFamily = "verdana,sans-serif";
        infoDiv.style.color = "red";
        infoDiv.style.padding = "10px";
        infoDiv.style.backgroundColor = "rgba(255, 0, 0, 0.3)";

        var width = xml3dElement.getAttribute("width");
        if (width !== null) {
            infoDiv.style.width = width;
        }

        var height = xml3dElement.getAttribute("height");
        if (height !== null) {
            infoDiv.style.height = height;
        }

        var hElement = document.createElement("h3");
        var hTxt = document.createTextNode("Sorry, your browser doesn't appear to support XML3D.");
        hElement.appendChild(hTxt);

        var pElement = document.createElement("p");
        pElement.appendChild(document.createTextNode("Please visit "));
        var link = document.createElement("a");
        link.setAttribute("href", "http://www.xml3d.org/help");
        link.appendChild(document.createTextNode("http://www.xml3d.org/help"));
        pElement.appendChild(link);
        pElement.appendChild(document.createTextNode(" for more information."));
        infoDiv.appendChild(hElement);
        infoDiv.appendChild(pElement);

        hideDiv.parentNode.insertBefore(infoDiv, hideDiv);
    }

}

/*  a list of elements that are currently initialized. More specifically,
 *  they're currently in a call to the method below.
 *
 *  Why?
 *  In webgl we actually reattach the xml3d element in the DOM. Thus, when
 *  we're in the middle of working on a onNodeInserted event, there will probably
 *  come right another event which we actually don't care for.
 *  So we use this list to keep track of which elements are currently initializing.
 */
var curXML3DInitElements = [];

/**
 * @param {Element} xml3dElement
 */
function initXML3DElement(xml3dElement) {
    if(-1 < curXML3DInitElements.indexOf(xml3dElement))
        return;

    curXML3DInitElements.push(xml3dElement);

    var debug = XML3D.debug.setup();

    if (!WebglSupported()) {
        debug && XML3D.debug.logWarning("Could not initialise WebGL, sorry :-(");
        displayWebGLNotSupportedInfo(xml3dElement);
        curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
        return;
    }

    XML3D.debug.logInfo("Configuring", xml3dElement.querySelectorAll("*").length, "elements");

    try {
        Config.configure(xml3dElement);
    } catch (e) {
        debug && XML3D.debug.logException(e);
        curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
        return;
    }
    try {
        ConfigureRenderer(xml3dElement);
    } catch (e) {
        debug && XML3D.debug.logException(e);
        curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
        return;
    }

    // initialize all attached adapters
    sendAdapterEvent(xml3dElement, {onConfigured : []});

    curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
    clearObserver();
}

/**
 * @param {Element} xml3dElement
 */
function destroyXML3DElement(xml3dElement)
{
    if(-1 < curXML3DInitElements.indexOf(xml3dElement))
        return;

    xml3dElement._configured = undefined;

    if(!xml3dElement.parentNode)
        return; // already removed

    var canvas = xml3dElement.parentNode.previousElementSibling;

    var grandParentNode = xml3dElement.parentNode.parentNode;
    if(!grandParentNode)
        return; // subtree containing canvas is not attached, can't remove it

    if(!canvas || canvas.tagName !== "canvas")
        return; // an element we didn't create, skip deletion

    grandParentNode.removeChild(xml3dElement.parentNode);
    grandParentNode.removeChild(canvas);
}

/**
 * @param {Event} evt
 */
function onNodeInserted(evt) {

    if(evt.target.tagName === "xml3d") {
        initXML3DElement(evt.target);
    }
}

/**
 * @param {Event} evt
 */
function onNodeRemoved(evt) {

    if(evt.target.tagName === "xml3d") {
        destroyXML3DElement(evt.target);
    }
}

function onLoad() {

    Options.setOptionsFromQuery();

    CSS.init();

    var debug = XML3D.debug.setup();
    debug && XML3D.debug.logInfo("xml3d.js version: " + XML3D.version);

    /**
     * Find all the XML3D tags in the document
     * @type {NodeList}
     */
    var xml3ds = document.querySelectorAll("xml3d");

    debug && XML3D.debug.logInfo("Found " + xml3ds.length + " xml3d node(s)");

    for(var i = 0; i < xml3ds.length; i++) {
        initXML3DElement(xml3ds[i]);
    }

    if(!MutationObserver){
        document.addEventListener('DOMNodeInserted', onNodeInserted, false);
        document.addEventListener('DOMNodeRemoved', onNodeRemoved, false);
    }
    else{
        observer = new MutationObserver(resolveMutations);
        observer.observe(document.documentElement, { childList: true, subtree: true} );
    }
}

function onUnload() {
    if (XML3D.document)
        XML3D.document.onunload();
}

var MutationObserver = (window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver),
    observer = null;

function resolveMutations(mutations){
    for(var i = 0; i < mutations.length; ++i){
        var mutation = mutations[i];
        if(mutation.type == 'childList'){
            var addedNodes = mutation.addedNodes;
            var j = addedNodes.length;
            while(j--){
                if(addedNodes[j].tagName == "xml3d")
                    initXML3DElement(addedNodes[j]);
            }
            var removedNodes = mutation.removedNodes;
            var j = removedNodes.length;
            while(j--) {
                if(removedNodes[j].tagName == "xml3d")
                    destroyXML3DElement(removedNodes[j]);
            }

        }
    }
}

function flushObserver(){
    if(observer){
        resolveMutations(observer.takeRecords());
    }
}
function clearObserver(){
    if(observer){
        observer.takeRecords();
    }
}


document.addEventListener('DOMContentLoaded', onLoad, false);
window.addEventListener('unload', onUnload, false);
window.addEventListener('reload', onUnload, false);

module.exports = XML3D;


},{"./global.js":29,"./interface/dom.js":33,"./interface/elements.js":34,"./renderer/renderer/configure.js":53,"./renderer/webgl/base/utils.js":79,"./utils/css.js":128,"./utils/debug.js":130,"./utils/misc.js":131,"./utils/options.js":132}],31:[function(require,module,exports){
require("../utils/array.js");
var Resource = require("../base/resourcemanager.js").Resource;

var string2bool = function(string) {
    if (!string) {
        return false;
    }
    switch (string.toLowerCase()) {
    case "true":
    case "1":
        return true;
    case "false":
    case "0":
        return false;
    default:
        return Boolean(string);
    }
};
var handlers = {};

function getStorage(elem){
    return elem._configured.storage;
}

var AttributeHandler = function(elem) {
};

handlers.IDHandler = function(id) {
    this.setFromAttribute = function(value, prevValue, elem) {
        Resource.notifyNodeIdChange(elem, prevValue, value);
    };
    this.desc = {
        get : function() {
            return this.getAttribute(id) || "";
        },
        set : function(value) {
            this.setAttribute(id, value);
        }
    };
};

handlers.StringAttributeHandler = function(id) {
    this.desc = {
        get : function() {
            return this.getAttribute(id) || "";
        },
        set : function(value) {
            this.setAttribute(id, value);
        }
    };
};

handlers.EnumAttributeHandler = function(id, p) {
    AttributeHandler.call(this);

    this.init = function(elem, storage){
        storage[id] = p.d;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };
    this.setFromAttribute = function(v, prevValue, elem, storage) {
        var value = v.toLowerCase();
        storage[id] = (value && p.e[value] !== undefined) ? p.e[value] : p.d;
        return false;
    };
    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return p.e[storage[id]];
        },
        set : function(v) {
                // Attribute is set to whatever comes in
            this.setAttribute(id, v);
            var storage = getStorage(this);
            var value = typeof v == 'string' ? v.toLowerCase() : undefined;
            if (value && p.e[value] !== undefined)
                storage[id] = p.e[value];
            else
                storage[id] = p.d;
        }
    };
};
handlers.EnumAttributeHandler.prototype = new AttributeHandler();
handlers.EnumAttributeHandler.prototype.constructor = handlers.EnumAttributeHandler;

handlers.EventAttributeHandler = function(id) {
    AttributeHandler.call(this);
    var eventType = id.substring(2);

    this.init = function(elem, storage){
        storage[id] = null;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        if(storage[id] != null)
            elem.removeEventListener(eventType, storage[id]);
        if(!value){
            storage[id] = null;
        }
        else{
            storage[id] = eval("crx = function " + id + "(event){\n  " + value + "\n}");
            if (XML3D.xhtml) {
                // only XHTML documents require this polyfill for mouse event attributes
                elem.addEventListener(eventType, storage[id], false);
            }
        }
        return false;
    };
    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            if(XML3D.xhtml && storage[id]) this.removeEventListener(eventType, storage[id]);
            storage[id] = (typeof value == 'function') ? value : undefined;
            if(XML3D.xhtml && storage[id]) this.addEventListener(eventType, storage[id], false);
            return false;
        }
    };
};

handlers.EventAttributeHandler.prototype = new AttributeHandler();
handlers.EventAttributeHandler.prototype.constructor = handlers.EventAttributeHandler;

handlers.IntAttributeHandler = function(id, defaultValue) {

    this.init = function(elem, storage){
        storage[id] = defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        var v = value.match(/^\d+/);
        if (!v || isNaN(+v[0])) {
            XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, elem);
            elem.setAttribute(id, prevValue);
            storage[id] = defaultValue;
        } else {
            storage[id] =  +v[0];
        }
        if(elem._configured.canvas)
            elem._configured.canvas[id] = storage[id];
        return false;
    };

    this.desc = {
        get : function(){
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            var v = +value;
            if (isNaN(v)) {
                XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, this);
                storage[id] = defaultValue;
            } else {
                storage[id] =  Math.floor(v);
            }
            this.setAttribute(id, storage[id] + '');
        }
    };
};
handlers.IntAttributeHandler.prototype = new AttributeHandler();
handlers.IntAttributeHandler.prototype.constructor = handlers.IntAttributeHandler;

handlers.FloatAttributeHandler = function(id, defaultValue) {

    this.init = function(elem, storage){
        storage[id] = defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        var v = +value;
        if (isNaN(v)) {
            XML3D.debug.logWarning("Invalid attribute value: " + value, elem);
            elem.setAttribute(id, prevValue);
            storage[id] = defaultValue;
        } else {
            storage[id] =  v;
        }
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            var v = +value;
            if (isNaN(v)) {
                XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, this);
                storage[id] = defaultValue;
            } else {
                storage[id] =  v;
            }
            this.setAttribute(id, storage[id] + '');
        }
    };
};

handlers.BoolAttributeHandler = function(id, defaultValue) {
    this.init = function(elem, storage){
        storage[id] = defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };
    this.setFromAttribute = function(value, prevValue, elem, storage) {
        storage[id] = string2bool(value);
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            storage[id] = Boolean(value);
            this.setAttribute(id, storage[id] + '');
        }
    };
};

handlers.XML3DVec3AttributeHandler = function(id, d) {
    var that = this;

    this.init = function(elem, storage){
        storage[id] = null;
    };

    this.initVec3 = function(elem, storage, x, y, z){
        var changed = function(value) {
            elem.setAttribute(id, value.x + " " + value.y + " " + value.z);
        };
        storage[id] = new window.XML3DVec3(x, y, z, changed);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        if (!storage[id]) {
            var initializing = true;
            this.initVec3(elem, storage, 0, 0, 0);
        }
        var v = storage[id];
        var m = /^\s*(\S+)\s+(\S+)\s+(\S+)\s*$/.exec(value);
        if (!m || isNaN(+m[1]) || isNaN(+m[2]) || isNaN(+m[3])) {
            v._data.set(d);
            !initializing && XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, elem);
        } else {
            v._data[0] = +m[1];
            v._data[1] = +m[2];
            v._data[2] = +m[3];
        }
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            if (!storage[id]) {
                that.setFromAttribute(this.getAttribute(id), null, this, storage);
            }
            return storage[id];
        },
        set : function(value) {
            throw Error("Can't set " + this.nodeName + "::" + id + ": it's readonly");
        }
    };
};

handlers.XML3DRotationAttributeHandler = function(id, d) {
    var that = this;

    this.init = function(elem, storage){
        storage[id] = null;
    };

    this.initRotation = function(elem, storage){
        var changed = function(v) {
            elem.setAttribute(id, v.axis.x + " " + v.axis.y + " " + v.axis.z + " " + v.angle);
        };
        storage[id] = new window.XML3DRotation(null, null, changed);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        if (!storage[id]) {
            var initializing = true;
            this.initRotation(elem, storage);
        }
        var v = storage[id];
        var m = /^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s*$/.exec(value);
        if (!m  || isNaN(+m[1]) || isNaN(+m[2]) || isNaN(+m[3]) || isNaN(+m[4])) {
            v._axis._data[0] = d[0];
            v._axis._data[1] = d[1];
            v._axis._data[2] = d[2];
            v._angle = d[3];
            v._updateQuaternion();
            !initializing && XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, elem);
        } else {
            v._axis._data[0] = +m[1];
            v._axis._data[1] = +m[2];
            v._axis._data[2] = +m[3];
            v._angle = +m[4];
            v._updateQuaternion();
        }
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            if (!storage[id]) {
                that.setFromAttribute(this.getAttribute(id), null, this, storage);
            }
            return storage[id];
        },
        set : function(value) {
            throw Error("Can't set " + this.nodeName + "::" + id + ": it's readonly");
        }
    };
};

var mixedContent = function(handler) {
    handler.init = function(elem, storage){
        elem._configured.registerMixed();
    };
    handler.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            if (!storage.value) {
                storage.value = handler.parse(this);
            }
            return storage.value;
        },
        set : function(value) {
            // Throw error?
            throw Error("Can't set " + this.nodeName + "::value: it's readonly");
        }
    };
    handler.resetValue = function(storage) { storage.value = null; };
};

var getContent = function(elem) {
    var str = "";
    var k = elem.firstChild;
    while (k) {
        str += k.nodeType == 3 ? k.textContent : " ";
        k = k.nextSibling;
    }
    return str;
};

handlers.FloatArrayValueHandler = function(id) {
    mixedContent(this);
};

handlers.FloatArrayValueHandler.prototype.parse = function(elem) {
    var exp = /([+\-0-9eE\.]+)/g;
    var str = getContent(elem);
    var m = str.match(exp);
    return m ? new Float32Array(m) : new Float32Array();
};

handlers.Float2ArrayValueHandler = handlers.FloatArrayValueHandler;
handlers.Float3ArrayValueHandler = handlers.FloatArrayValueHandler;
handlers.Float4ArrayValueHandler = handlers.FloatArrayValueHandler;
handlers.Float4x4ArrayValueHandler = handlers.FloatArrayValueHandler;

handlers.IntArrayValueHandler = function(id) {
    mixedContent(this);
};
handlers.IntArrayValueHandler.prototype.parse = function(elem) {
    var exp = /([+\-0-9]+)/g;
    var str = getContent(elem);
    var m = str.match(exp);
    return m ? new Int32Array(m) : new Int32Array();
};

handlers.BoolArrayValueHandler = function(id) {
    mixedContent(this);
};
handlers.BoolArrayValueHandler.prototype.parse = function(elem) {
    var exp = /(true|false|0|1)/ig;
    var str = getContent(elem);
    var m = str.match(exp);
    if (!m)
        return new Uint8Array();
    m = Array.map(m, string2bool);
    return m ? new Uint8Array(m) : new Uint8Array();
};

handlers.StringValueHandler = function(id) {
    mixedContent(this);
};
handlers.StringValueHandler.prototype.parse = function(elem) {
    return elem.textContent;
};

handlers.CanvasStyleHandler = function(id, d) {

    this.init = function(elem, storage){
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        elem._configured.canvas.setAttribute(id, value);
    };

    this.desc = {
        get: function() { return this._configured.canvas.style; },
        set: function(value) {}
    };

};

handlers.CanvasClassHandler = function(id) {

    this.init = function(elem, storage){
        var canvas = elem._configured.canvas;
        canvas.className = "_xml3d"; // Class name always defined for xml3d canvas
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        var canvas = elem._configured.canvas;
        canvas.setAttribute(id, value + " _xml3d");
    };

    this.desc = {
        // TODO: Should we not strip the _xml3d class here?
        get: function() { return this._configured.canvas.className; },
        set: function(value) { this._configured.canvas.className = value; }
    };
};

module.exports = handlers;

},{"../base/resourcemanager.js":10,"../utils/array.js":127}],32:[function(require,module,exports){
var methods = require("./methods.js");
var handlers = require("./attributes.js");
var properties = require("./properties.js");

// MeshTypes
var MeshTypes = {};
MeshTypes["triangles"] = 0;
MeshTypes[0] = "triangles";
MeshTypes["trianglestrips"] = 1;
MeshTypes[1] = "trianglestrips";
MeshTypes["lines"] = 2;
MeshTypes[2] = "lines";
MeshTypes["linestrips"] = 3;
MeshTypes[3] = "linestrips";
MeshTypes["points"] = 4;
MeshTypes[4] = "points";
// TextureTypes
var TextureTypes = {};
TextureTypes["2d"] = 0;
TextureTypes[0] = "2d";
TextureTypes["1d"] = 1;
TextureTypes[1] = "1d";
TextureTypes["3d"] = 2;
TextureTypes[2] = "3d";
// FilterTypes
var FilterTypes = {};
FilterTypes["nearest"] = 1;
FilterTypes[1] = "nearest";
FilterTypes["linear"] = 2;
FilterTypes[2] = "linear";
FilterTypes["nearest-mipmap-nearest"] = 3;
FilterTypes[3] = "nearest-mipmap-nearest";
FilterTypes["linear-mipmap-nearest"] = 4;
FilterTypes[4] = "linear-mipmap-nearest";
FilterTypes["nearest-mipmap-linear"] = 5;
FilterTypes[5] = "nearest-mipmap-linear";
FilterTypes["linear-mipmap-linear"] = 6;
FilterTypes[6] = "linear-mipmap-linear";
// WrapTypes
var WrapTypes = {};
WrapTypes["clamp"] = 0;
WrapTypes[0] = "clamp";
WrapTypes["repeat"] = 1;
WrapTypes[1] = "repeat";
WrapTypes["border"] = 2;
WrapTypes[2] = "border";
// PlatformTypes
var PlatformTypes = {};
PlatformTypes["auto"] = 1;
PlatformTypes[1] = "auto";
PlatformTypes["js"] = 2;
PlatformTypes[2] = "js";
PlatformTypes["gl"] = 3;
PlatformTypes[3] = "gl";
PlatformTypes["cl"] = 4;
PlatformTypes[4] = "cl";
// DataFieldType
var DataFieldType = {};
DataFieldType["float "] = 0;
DataFieldType[0] = "float ";
DataFieldType["float2 "] = 1;
DataFieldType[1] = "float2 ";
DataFieldType["float3"] = 2;
DataFieldType[2] = "float3";
DataFieldType["float4"] = 3;
DataFieldType[3] = "float4";
DataFieldType["float4x4"] = 4;
DataFieldType[4] = "float4x4";
DataFieldType["int"] = 10;
DataFieldType[10] = "int";
DataFieldType["int4"] = 11;
DataFieldType[11] = "int4";
DataFieldType["bool"] = 20;
DataFieldType[20] = "bool";
DataFieldType["texture"] = 30;
DataFieldType[30] = "texture";
// DataChannelOrigin
var DataChannelOrigin = {};
DataChannelOrigin["origin_value "] = 0;
DataChannelOrigin[0] = "origin_value ";
DataChannelOrigin["origin_child"] = 1;
DataChannelOrigin[1] = "origin_child";
DataChannelOrigin["origin_source"] = 2;
DataChannelOrigin[2] = "origin_source";
DataChannelOrigin["origin_compute"] = 3;
DataChannelOrigin[3] = "origin_compute";
DataChannelOrigin["origin_proto"] = 4;
DataChannelOrigin[4] = "origin_proto";

var classInfo = {};

/**
 * Properties and methods for <xml3d>
 **/
classInfo['xml3d'] = {
    id : {a: handlers.IDHandler},
    className : {a: handlers.CanvasClassHandler, id: 'class'},
    style : {a: handlers.CanvasStyleHandler},
    onclick : {a: handlers.EventAttributeHandler},
    ondblclick : {a: handlers.EventAttributeHandler},
    onmousedown : {a: handlers.EventAttributeHandler},
    onmouseup : {a: handlers.EventAttributeHandler},
    onmouseover : {a: handlers.EventAttributeHandler},
    onmousemove : {a: handlers.EventAttributeHandler},
    onmouseout : {a: handlers.EventAttributeHandler},
    onkeypress : {a: handlers.EventAttributeHandler},
    onkeydown : {a: handlers.EventAttributeHandler},
    onkeyup : {a: handlers.EventAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    complete: {p: properties.xml3dComplete},
    height : {a: handlers.IntAttributeHandler, params: 600},
    width : {a: handlers.IntAttributeHandler, params: 800},
    getElementByPoint : {m: methods.xml3dGetElementByPoint},
    generateRay : {m: methods.xml3dGenerateRay},
    getElementByRay : {m: methods.xml3dGetElementByRay},
    getBoundingBox : {m: methods.deprecatedGetBoundingBoxWorld},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    getRenderInterface : {m: methods.xml3dGetRenderInterface},
    activeView : {a: handlers.StringAttributeHandler},
    _term: undefined
};

classInfo['compute'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    value: {a: handlers.StringValueHandler},
    _term: undefined
};

/**
 * Properties and methods for <data>
 **/
classInfo['data'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    compute: {a: handlers.StringAttributeHandler},
    platform: {a: handlers.EnumAttributeHandler, params: {e: PlatformTypes, d: 1}},
    filter: {a: handlers.StringAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    progressLevel: {p: properties.XML3DNestedDataContainerTypeProgressLevel},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getComputeInfo: {m: methods.XML3DNestedDataContainerTypeGetComputeInfo},
    getProtoInfo: {m: methods.XML3DNestedDataContainerTypeGetProtoInfo},
    isOutputConnected: {m: methods.XML3DNestedDataContainerTypeIsOutputConnected},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult},
    src: {a: handlers.StringAttributeHandler},
    _term: undefined
};
/**
 * Properties and methods for <dataflow>
 **/
classInfo['dataflow'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    platform: {a: handlers.EnumAttributeHandler, params: {e: PlatformTypes, d: 1}},
    out: {a: handlers.StringAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    progressLevel: {p: properties.XML3DNestedDataContainerTypeProgressLevel},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getComputeInfo: {m: methods.XML3DNestedDataContainerTypeGetComputeInfo},
    getProtoInfo: {m: methods.XML3DNestedDataContainerTypeGetProtoInfo},
    isOutputConnected: {m: methods.XML3DNestedDataContainerTypeIsOutputConnected},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult},
    _term: undefined
};
/**
 * Properties and methods for <data>
 **/
classInfo['asset'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.AssetComplete},
    progressLevel: {p: properties.AssetProgressLevel},
    src: {a: handlers.StringAttributeHandler},
    name: {a: handlers.StringAttributeHandler},
    pick: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    shader: {a: handlers.StringAttributeHandler},
    _term: undefined
};
/**
 * Properties and methods for <defs>
 **/
classInfo['defs'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    _term: undefined
};
/**
 * Properties and methods for <group>
 **/
classInfo['group'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    visible: {a: handlers.BoolAttributeHandler, params: true},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getLocalMatrix: {m: methods.groupGetLocalMatrix},
    getBoundingBox : {m: methods.deprecatedGetBoundingBoxWorld},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    transform: {a: handlers.StringAttributeHandler},
    shader: {a: handlers.StringAttributeHandler},
    _term: undefined
};
/**
 * Properties and methods for <mesh>
 **/
classInfo['mesh'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    progressLevel: {p: properties.XML3DNestedDataContainerTypeProgressLevel},
    visible: {a: handlers.BoolAttributeHandler, params: true},
    type: {a: handlers.EnumAttributeHandler, params: {e: MeshTypes, d: 0}},
    compute: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    shader: {a: handlers.StringAttributeHandler},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getBoundingBox : {m: methods.deprecatedGetBoundingBoxLocal},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    getOutputNames: {m: methods.meshGetOutputNames},
    getOutputChannelInfo: {m: methods.meshGetOutputChannelInfo},
    getComputeInfo: {m: methods.meshGetComputeInfo},
    getProtoInfo: {m: methods.meshGetProtoInfo},
    isOutputConnected: {m: methods.meshIsOutputConnected},
    getResult: {m: methods.meshGetResult},
    src: {a: handlers.StringAttributeHandler},
    _term: undefined
};
/**
 * Properties and methods for <model>
 **/
classInfo['model'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.AssetComplete},
    progressLevel: {p: properties.AssetProgressLevel},
    visible: {a: handlers.BoolAttributeHandler, params: true},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getBoundingBox : {m: methods.deprecatedGetBoundingBoxLocal},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    src: {a: handlers.StringAttributeHandler},
    pick: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    shader: {a: handlers.StringAttributeHandler},
    _term: undefined
};
/**
 * Properties and methods for <transform>
 **/
classInfo['transform'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    translation: {a: handlers.XML3DVec3AttributeHandler, params: [0, 0, 0]},
    scale: {a: handlers.XML3DVec3AttributeHandler, params: [1, 1, 1]},
    rotation: {a: handlers.XML3DRotationAttributeHandler, params: [0, 0, 1, 0]},
    center: {a: handlers.XML3DVec3AttributeHandler, params: [0, 0, 0]},
    scaleOrientation: {a: handlers.XML3DRotationAttributeHandler, params: [0, 0, 1, 0]},
    _term: undefined
};
/**
 * Properties and methods for <shader>
 **/
classInfo['shader'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    progressLevel: {p: properties.XML3DNestedDataContainerTypeProgressLevel},
    compute: {a: handlers.StringAttributeHandler},
    getOutputNames: {m: methods.XML3DShaderProviderTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DShaderProviderTypeGetOutputChannelInfo},
    getComputeInfo: {m: methods.XML3DShaderProviderTypeGetComputeInfo},
    getProtoInfo: {m: methods.XML3DShaderProviderTypeGetProtoInfo},
    isOutputConnected: {m: methods.XML3DShaderProviderTypeIsOutputConnected},
    getResult: {m: methods.XML3DShaderProviderTypeGetResult},
    script: {a: handlers.StringAttributeHandler},
    src: {a: handlers.StringAttributeHandler},
    _term: undefined
};
/**
 * Properties and methods for <light>
 **/
classInfo['light'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    visible: {a: handlers.BoolAttributeHandler, params: true},
    global: {a: handlers.BoolAttributeHandler, params: false},
    intensity: {a: handlers.FloatAttributeHandler, params: 1},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    shader: {a: handlers.StringAttributeHandler},
    _term: undefined
};
/**
 * Properties and methods for <lightshader>
 **/
classInfo['lightshader'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    progressLevel: {p: properties.XML3DNestedDataContainerTypeProgressLevel},
    compute: {a: handlers.StringAttributeHandler},
    getOutputNames: {m: methods.XML3DShaderProviderTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DShaderProviderTypeGetOutputChannelInfo},
    getComputeInfo: {m: methods.XML3DShaderProviderTypeGetComputeInfo},
    getProtoInfo: {m: methods.XML3DShaderProviderTypeGetProtoInfo},
    isOutputConnected: {m: methods.XML3DShaderProviderTypeIsOutputConnected},
    getResult: {m: methods.XML3DShaderProviderTypeGetResult},
    script: {a: handlers.StringAttributeHandler},
    src: {a: handlers.StringAttributeHandler},
    _term: undefined
};
/**
 * Properties and methods for <script>
 **/
classInfo['script'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    value: {a: handlers.StringValueHandler},
    src: {a: handlers.StringAttributeHandler},
    name: {a: handlers.StringAttributeHandler},
    type: {a: handlers.StringAttributeHandler},
    _term: undefined
};
/**
 * Properties and methods for <assetmesh>
 **/
classInfo['assetmesh'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    match: {a: handlers.StringAttributeHandler},
    type: {a: handlers.EnumAttributeHandler, params: {e: MeshTypes, d: 0}},
    compute: {a: handlers.StringAttributeHandler},
    filter: {a: handlers.StringAttributeHandler},
    includes: {a: handlers.StringAttributeHandler},
    shader: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    platform: {a: handlers.EnumAttributeHandler, params: {e: PlatformTypes, d: 1}},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getComputeInfo: {m: methods.XML3DNestedDataContainerTypeGetComputeInfo},
    getProtoInfo: {m: methods.XML3DNestedDataContainerTypeGetProtoInfo},
    isOutputConnected: {m: methods.XML3DNestedDataContainerTypeIsOutputConnected},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult},
    src: {a: handlers.StringAttributeHandler},
    _term: undefined
};
/**
 * Properties and methods for <assetdata>
 **/
classInfo['assetdata'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    compute: {a: handlers.StringAttributeHandler},
    filter: {a: handlers.StringAttributeHandler},
    includes: {a: handlers.StringAttributeHandler},
    platform: {a: handlers.EnumAttributeHandler, params: {e: PlatformTypes, d: 1}},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getComputeInfo: {m: methods.XML3DNestedDataContainerTypeGetComputeInfo},
    getProtoInfo: {m: methods.XML3DNestedDataContainerTypeGetProtoInfo},
    isOutputConnected: {m: methods.XML3DNestedDataContainerTypeIsOutputConnected},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult},
    src: {a: handlers.StringAttributeHandler},
    _term: undefined
};
/**
 * Properties and methods for <float>
 **/
classInfo['float'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.FloatArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue},
    _term: undefined
};
/**
 * Properties and methods for <float2>
 **/
classInfo['float2'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float2ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue},
    _term: undefined
};
/**
 * Properties and methods for <float3>
 **/
classInfo['float3'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float3ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue},
    _term: undefined
};
/**
 * Properties and methods for <float4>
 **/
classInfo['float4'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float4ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue},
    _term: undefined
};
/**
 * Properties and methods for <float4x4>
 **/
classInfo['float4x4'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float4x4ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue},
    _term: undefined
};
/**
 * Properties and methods for <int>
 **/
classInfo['int'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.IntArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue},
    _term: undefined
};
/**
 * Properties and methods for <int4>
 **/
classInfo['int4'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.IntArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue},
    _term: undefined
};
/**
 * Properties and methods for <bool>
 **/
classInfo['bool'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.BoolArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue},
    _term: undefined
};
/**
 * Properties and methods for <texture>
 **/
classInfo['texture'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    type: {a: handlers.EnumAttributeHandler, params: {e: TextureTypes, d: 0}},
    filterMin: {a: handlers.EnumAttributeHandler, params: {e: FilterTypes, d: 6}},
    filterMag: {a: handlers.EnumAttributeHandler, params: {e: FilterTypes, d: 2}},
    filterMip: {a: handlers.EnumAttributeHandler, params: {e: FilterTypes, d: 1}},
    wrapS: {a: handlers.EnumAttributeHandler, params: {e: WrapTypes, d: 0}},
    wrapT: {a: handlers.EnumAttributeHandler, params: {e: WrapTypes, d: 0}},
    wrapU: {a: handlers.EnumAttributeHandler, params: {e: WrapTypes, d: 0}},
    borderColor: {a: handlers.StringAttributeHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue},
    _term: undefined
};
/**
 * Properties and methods for <img>
 **/
classInfo['img'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    src: {a: handlers.StringAttributeHandler},
    _term: undefined
};
/**
 * Properties and methods for <video>
 **/
classInfo['video'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    src: {a: handlers.StringAttributeHandler},
    autoplay: {a: handlers.BoolAttributeHandler, params: false},
    play: {m: methods.videoPlay},
    pause: {m: methods.videoPause},
    _term: undefined
};
/**
 * Properties and methods for <view>
 **/
classInfo['view'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    visible: {a: handlers.BoolAttributeHandler, params: true},
    position: {a: handlers.XML3DVec3AttributeHandler, params: [0, 0, 0]},
    orientation: {a: handlers.XML3DRotationAttributeHandler, params: [0, 0, 1, 0]},
    fieldOfView: {a: handlers.FloatAttributeHandler, params: 0.785398},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    setDirection: {m: methods.viewSetDirection},
    setUpVector: {m: methods.viewSetUpVector},
    lookAt: {m: methods.viewLookAt},
    getDirection: {m: methods.viewGetDirection},
    getUpVector: {m: methods.viewGetUpVector},
    getViewMatrix: {m: methods.viewGetViewMatrix},
    perspective: {a: handlers.StringAttributeHandler},
    _term: undefined
};

module.exports = {
    classInfo : classInfo,
    MeshTypes : MeshTypes,
    FilterTypes : FilterTypes,
    TextureTypes : TextureTypes,
    WrapTypes : WrapTypes,
    PlatformTypes : PlatformTypes,
    DataFieldTypes : DataFieldType,
    DataChannelOrigin : DataChannelOrigin
};

},{"./attributes.js":31,"./methods.js":35,"./properties.js":37}],33:[function(require,module,exports){
var config = require("./elements.js").config;
var classInfo = require("./configuration.js").classInfo;

var doc = {};
var nativeGetElementById = document.getElementById;
doc.getElementById = function(id) {
    var elem = nativeGetElementById.call(this, id);
    if (elem) {
        return elem;
    } else {
        var elems = this.getElementsByTagName("*");
        for ( var i = 0; i < elems.length; i++) {
            var node = elems[i];
            if (node.getAttribute("id") === id) {
                return node;
            }
        }
    }
    return null;
};
var nativeCreateElementNS = document.createElementNS;
doc.createElementNS = function(ns, name) {
    var r = nativeCreateElementNS.call(this, ns, name);
    if (ns == XML3D.xml3dNS || classInfo[name.toLowerCase()]) {
        config.element(r);
    }
    return r;
};
var nativeCreateElement = document.createElement;
doc.createElement = function(name) {
    var r = nativeCreateElement.call(this, name);
    if (classInfo[name.toLowerCase()] ) {
        config.element(r);
    }
    return r;
};

XML3D.extend(window.document, doc);

},{"./configuration.js":32,"./elements.js":34}],34:[function(require,module,exports){
var events = require("./notification.js");
var ClassInfo = require("./configuration.js").classInfo;
require("../utils/array.js");
var Resource = require("../base/resourcemanager.js").Resource;

var MutationObserver = (window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver),
    mutObserver;

if(MutationObserver){
    mutObserver = new MutationObserver(handleMutations);
} else {
    XML3D.debug.logError("XML3D requires MutationObservers, which your browser does not support. Please consider upgrading to a newer version.");
    mutObserver = {
        takeRecords:function(){return []},
        observe: function(a,b) {}
    }
}

XML3D.flushDOMChanges = function(){
    var records = mutObserver.takeRecords();
    records.length && handleMutations(records);
};

function handleMutations(mutations) {
    for(var i = 0; i < mutations.length; ++i){
        var mutationRecord = mutations[i];
        if (mutationRecord.type === 'attributes') {
            handleAttributeChanged(mutationRecord);
        } else if (mutationRecord.type === 'childList') {
            handleChildListChanged(mutationRecord);
        } else if(mutationRecord.type == 'characterData'){
            handleCharacterDataChanged(mutationRecord);
        }
    }
}

function handleCharacterDataChanged(mutation) {
    var target = mutation.target;
    while(!target._configured && target.parentElement) {
        target = target.parentElement;
    }
    var elementHandler = target._configured;
    if (!elementHandler) {
        return;
    }
    var n = new events.NotificationWrapper(mutation, events.VALUE_MODIFIED, target);
    if (elementHandler.handlers.value !== undefined) {
        elementHandler.handlers.value.resetValue(elementHandler.storage);
    }
    elementHandler.notify(n);
}

function handleChildListChanged(mutation) {
    var addedNodes = mutation.addedNodes;
    for (var i = 0; i < addedNodes.length; i++) {
        if (addedNodes[i].nodeType === Node.TEXT_NODE){
            // This may have been the value of eg. a float3 element, we should treat it as a characterDataChanged event
            handleCharacterDataChanged(mutation);
            continue;
        }
        handleNodeInserted(addedNodes[i], mutation);
    }

    var removedNodes = mutation.removedNodes;
    for (var i=0; i < removedNodes.length; i++) {
        if (removedNodes[i].nodeType === Node.TEXT_NODE){
            continue; // characterDataChanged events were already handled in addedNodes
        }
        handleNodeRemoved(removedNodes[i], mutation);
    }
}

function handleNodeInserted(node, mutation) {
    var targetHandler = mutation.target._configured;
    if (!targetHandler) {
        return;
    }
    config.element(node);
    addRecursive(node);
    var n = new events.NotificationWrapper(mutation, events.NODE_INSERTED, node);
    targetHandler.notify(n);
}

function handleNodeRemoved(node, mutation) {
    var targetHandler = mutation.target._configured;
    if (!targetHandler) {
        return;
    }
    var n = new events.NotificationWrapper(mutation, events.NODE_REMOVED, node);
    targetHandler.notify(n);
    if(node._configured) {
        n.type = events.THIS_REMOVED;
        removeRecursive(node, n);
        notifyNodeIdChangeRecursive(node);
    } else if (node.nodeType === Node.TEXT_NODE){
        // This may have been the value of eg. a float3 element, we should also treat it as a characterDataChanged event
        handleCharacterDataChanged(mutation);
    }
}

function notifyNodeIdChangeRecursive(element){
    Resource.notifyNodeIdChange(element, element.id, null);
    var n = element.firstElementChild;
    while(n) {
        notifyNodeIdChangeRecursive(n);
        n = n.nextElementSibling;
    }
}

function removeRecursive(element, evt) {
    if(element._configured) {
        element._configured.notify(evt);
        element._configured.remove(evt);
    }
    var child = element.firstElementChild;
    while(child) {
        removeRecursive(child, evt);
        child = child.nextElementSibling;
    }
}

function addRecursive(element){
    var n = element.firstElementChild;
    while(n) {
        addRecursive(n);
        n = n.nextElementSibling;
    }
    // We call this here in addition to nodeInsertedIntoDocument, since the later is not supported by Firefox
    Resource.notifyNodeIdChange(element, null, element.id);
}

function handleAttributeChanged(mutation) {
    var target = mutation.target;
    var elementHandler = target._configured;
    if (!elementHandler) {
        return;
    }
    var notified = false;
    var attributeHandler = elementHandler.handlers[mutation.attributeName] || elementHandler.handlers[mutation.attributeName.toLowerCase()];
    if (attributeHandler && attributeHandler.setFromAttribute) {
        var newValue = target.getAttribute(mutation.attributeName);
        notified = attributeHandler.setFromAttribute(newValue, mutation.oldValue, target, elementHandler.storage);
    }

    if (!notified) {
        var n = new events.NotificationWrapper(mutation, events.VALUE_MODIFIED, mutation.target);
        elementHandler.notify(n);
    }
}


var ElementHandler = function(elem) {
    if (!elem) {
        return;
    }
    this.element = elem;
    this.handlers = null;
    this.storage = {};
    this.adapters = {};
    mutObserver.observe(elem, { childList: true,  attributes: true, attributeOldValue: true} );

};

ElementHandler.prototype.registerAttributes = function(config) {
    var elem = this.element;

    var isHTML = (elem instanceof HTMLElement);
    var keyPrefix = (isHTML ? "_html" : "_xml");
    var handlerKey = keyPrefix + "handlers",
        protoKey = keyPrefix + "proto";

    var canProto = !!elem.__proto__;

    if(!config._cache) config._cache = {};

    if(!config._cache[handlerKey]){
        // Create handlers and prototype only once per configuration
        var proto;
        if(canProto){
            var F = function () {
            };
            F.prototype = elem.__proto__;
            proto = new F();
        }

        var handlers = {};
        for ( var prop in config) {
            if(prop =="_cache") continue;
            if (config[prop] === undefined) {
                if(proto) delete proto[prop];
            } else {
                if (config[prop].a !== undefined) {
                    var attrName = config[prop].id || prop;
                    var handler = new config[prop].a(attrName, config[prop].params);
                    handlers[isHTML ? attrName.toLowerCase() : attrName] = handler;
                    if(proto) {
                        try {
                            Object.defineProperty(proto, prop, handler.desc);
                        } catch (e) {
                            XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                        }
                    }

                } else if (config[prop].m !== undefined) {
                    if(proto) proto[prop] = config[prop].m;
                } else if (config[prop].p !== undefined) {
                    if(proto){
                        try {
                            Object.defineProperty(proto, prop, config[prop].p);
                        } catch (e) {
                            XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                        }
                    }
                }else
                    XML3D.debug.logError("Can't configure " + elem.nodeName + "::" + prop);
            }
        }
        config._cache[handlerKey] = handlers;
        config._cache[protoKey] = proto;
    }
    // Set and initialize handlers for element
    this.handlers = config._cache[handlerKey];
    if(canProto){
        elem.__proto__ = config._cache[protoKey];
        for ( var prop in config) {
            if(prop =="_cache") continue;
            if(config[prop] && config[prop].a !== undefined){
                var attrName = config[prop].id || prop;
                var handler = this.handlers[isHTML ? attrName.toLowerCase() : attrName];
                handler.init && handler.init(elem, this.storage);
                delete elem[prop];
            }
        }
    }
    else{
        for ( var prop in config) {
            if(prop =="_cache") continue;
            if (config[prop] === undefined) {
                delete elem[prop];
            }
            else if (config[prop].a !== undefined){
                var attrName = config[prop].id || prop;
                var handler = this.handlers[isHTML ? attrName.toLowerCase() : attrName];
                handler.init && handler.init(elem, this.storage);
                try {
                    Object.defineProperty(elem, prop, handler.desc);
                } catch (e) {
                    XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                }
            }else if (config[prop].m !== undefined) {
                elem[prop] = config[prop].m;
            } else if (config[prop].p !== undefined) {
                try {
                    Object.defineProperty(elem, prop, config[prop].p);
                } catch (e) {
                    XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                }
            }
        }
    }

    return elem;
};


ElementHandler.prototype.registerMixed = function() {
    mutObserver.observe(this.element, { childList: true,  attributes: true, attributeOldValue: true, characterData: true, subtree: true} );
};

/**
 * @param evt
 */
ElementHandler.prototype.notify =  function(evt) {
    var adapters = this.adapters;
    for(var a in adapters) {
        try {
            adapters[a].notifyChanged(evt);
        } catch (e) {
            XML3D.debug.logException(e);
        }
    }
};

/*
 * Get called, if the related node gets removed from the DOM
 */
ElementHandler.prototype.remove = function(evt) {
    for(var h in this.adapters) {
        var adapter = this.adapters[h];
        if(adapter.onDispose)
            adapter.onDispose();
        if(adapter.clearAdapterHandles)
            adapter.clearAdapterHandles();
    }
    this.adapters = {};
    for(var h in this.handlers) {
        var handler = this.handlers[h];
        if(handler.remove)
            handler.remove();
    }

};

ElementHandler.prototype.toString = function() {
    return "ElementHandler ("+this.element.nodeName + ", id: "+this.element.id+")";
};

var delegateProperties = ["clientHeight", "clientLeft", "clientTop", "clientWidth",
    "offsetHeight", "offsetLeft", "offsetTop", "offsetWidth"];
function delegateProp(name, elem, canvas) {
    var desc = {
        get : function() {
            return canvas[name];
        }
    };
    try {
        Object.defineProperty(elem, name, desc);
    } catch (e){
        XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + name);
    }
}

var XML3DHandler = function(elem) {
    ElementHandler.call(this, elem);
    var c = document.createElement("canvas");
    c.width = 800;
    c.height = 600;
    this.canvas = c;

    for(var i in delegateProperties) {
        delegateProp(delegateProperties[i], elem, c);
    }

    elem.getBoundingClientRect = function() {
        return c.getBoundingClientRect();
    };
};

XML3D.createClass(XML3DHandler, ElementHandler);


var config = {};

/**
 * @param {Element} element
 * @return {undefined}
 */
config.element = function(element) {
    if (element._configured === undefined ) {
        var classInfo = ClassInfo[element.localName];
        if (classInfo === undefined) {
            XML3D.debug.logInfo("Unrecognised element " + element.localName);
        } else {
            element._configured = element.localName == "xml3d" ?
                new XML3DHandler(element)
                : new ElementHandler(element);
            element._configured.registerAttributes(classInfo);
            // Fix difference in Firefox (undefined) and Chrome (null)
            try{
                if (element.style == undefined)
                    element.style = null;
            }
            catch(e){
                // Firefox throws exception here...
            }

            var n = element.firstElementChild;

            Resource.notifyNodeIdChange(element, null, element.getAttribute("id"));

            while(n) {
                config.element(n);
                n = n.nextElementSibling;
            }
        }
    }
};

/**
 * @param {Element} element
 * @return {undefined}
 */
config.configure = function(element) {
    if (Array.isArray(element)) {
        Array.forEach(element, function(el) {
            config.element(el);
        });
    } else {
        config.element(element);
    }
};


module.exports = {
    ElementHandler : ElementHandler,
    XML3DHandler : XML3DHandler,
    config : config
};

},{"../base/resourcemanager.js":10,"../utils/array.js":127,"./configuration.js":32,"./notification.js":36}],35:[function(require,module,exports){
var Resource = require("../base/resourcemanager.js").Resource;
var sendAdapterEvent = require("../utils/misc.js").sendAdapterEvent;
var callAdapterFunc = require("../utils/misc.js").callAdapterFunc;

var methods = {};

methods.xml3dGetElementByRay = function(ray, hitPoint, hitNormal) {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getElementByRay) {
            return adapters[adapter].getElementByRay(ray, hitPoint, hitNormal);
        }
    }
    return null;
};

methods.viewGetDirection = function() {
    return this.orientation.rotateVec3(new window.XML3DVec3(0, 0, -1));
};

methods.viewSetPosition = function(pos) {
    this.position = pos;
};

var tmpX = XML3D.math.vec3.create();
var tmpY = XML3D.math.vec3.create();
var tmpZ = XML3D.math.vec3.create();

methods.viewSetDirection = function(direction) {
    direction = direction || new window.XML3DVec3(0,0,-1);
    direction = direction.normalize();

    var up = this.orientation.rotateVec3(new window.XML3DVec3(0,1,0));
    up = up.normalize();

    XML3D.math.vec3.cross(tmpX,direction._data,up._data);
    if(!XML3D.math.vec3.length(tmpX)) {
            tmpX = this.orientation.rotateVec3(new window.XML3DVec3(1,0,0))._data;
    }
    XML3D.math.vec3.cross(tmpY,tmpX,direction._data);
    XML3D.math.vec3.negate(tmpZ,direction._data);

    var q = XML3D.math.quat.create();
    XML3D.math.quat.setFromBasis(tmpX, tmpY, tmpZ, q);
    this.orientation._setQuaternion(q);
};

methods.viewSetUpVector = function(up) {
    up = up || new window.XML3DVec3(0,1,0);
    up = up.normalize();

    var r = new window.XML3DRotation();
    r.setRotation(new window.XML3DVec3(0,1,0),up);
    r = this.orientation.multiply(r);
    r = r.normalize();
    this.orientation.set(r);
};

methods.viewGetUpVector = function() {
    return this.orientation.rotateVec3(new window.XML3DVec3(0, 1, 0));
};

methods.viewLookAt = function(point) {
    this.setDirection(point.subtract(this.position));
};

methods.viewGetViewMatrix = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for ( var adapter in adapters) {
        if (adapters[adapter].getViewMatrix) {
            return adapters[adapter].getViewMatrix();
        }
    }
    // Fallback implementation
    var p = this.position;
    var r = this.orientation;
    var a = r.axis;
    return new window.XML3DMatrix().translate(p.x, p.y, p.z).rotateAxisAngle(a.x, a.y, a.z, r.angle).inverse();
};

methods.xml3dGetElementByPoint = function(x, y, hitPoint, hitNormal) {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getElementByPoint) {
            return adapters[adapter].getElementByPoint(x, y, hitPoint, hitNormal);
        }
    }
    return null;
};

methods.xml3dGenerateRay = function(x, y) {
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].generateRay) {
            return adapters[adapter].generateRay(x, y);
        }
    }
    return new window.XML3DRay();
};

methods.deprecatedGetBoundingBoxWorld = function() {
    XML3D.debug.logWarning("getBoundingBox is deprecated and will be removed in a future version! Please use getLocalBoundingBox or getWorldBoundingBox instead.");
    return methods.getWorldBoundingBox.call(this);
};

methods.deprecatedGetBoundingBoxLocal = function() {
    XML3D.debug.logWarning("getBoundingBox is deprecated and will be removed in a future version! Please use getLocalBoundingBox or getWorldBoundingBox instead.");
    return methods.getLocalBoundingBox.call(this);
};

methods.groupGetLocalMatrix = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for ( var adapter in adapters) {
        if (adapters[adapter].getLocalMatrix) {
            return adapters[adapter].getLocalMatrix();
        }
    }
    return new window.XML3DMatrix();
};

/**
 * return the bounding box of the owning space in world space
 */
methods.getWorldBoundingBox = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getWorldBoundingBox) {
            return adapters[adapter].getWorldBoundingBox();
        }
    }
    return new window.XML3DBox();
};

/**
 * return the bounding box of the owning space in local space (object BB)
 */
methods.getLocalBoundingBox = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getLocalBoundingBox) {
            return adapters[adapter].getLocalBoundingBox();
        }
    }
    return new window.XML3DBox();
};

methods.xml3dGetRenderInterface = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for ( var adapter in adapters) {
        if (adapters[adapter].getRenderInterface) {
            return adapters[adapter].getRenderInterface();
        }
    }
    return {};
};


methods.XML3DGraphTypeGetWorldMatrix = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getWorldMatrix) {
            return adapters[adapter].getWorldMatrix();
        }
    }
    return new window.XML3DMatrix();
};

methods.videoPlay = function() {
    sendAdapterEvent(this, {play: []});
};

methods.videoPause = function() {
    sendAdapterEvent(this, {pause: []});
};

methods.XML3DNestedDataContainerTypeGetOutputNames =
methods.XML3DShaderProviderTypeGetOutputNames =
methods.meshGetOutputNames = function() {
    XML3D.flushDOMChanges();
    var dataAdapter = Resource.getAdapter(this, "data");
    if(dataAdapter){
        return dataAdapter.getOutputNames();
    }
    return null;
};

methods.XML3DNestedDataContainerTypeGetResult =
methods.XML3DShaderProviderTypeGetResult =
methods.meshGetResult = function(filter) {
    XML3D.flushDOMChanges();
    var dataAdapter = Resource.getAdapter(this, "data");
    if(dataAdapter){
        var result = dataAdapter.getComputeResult(filter);
        if(!result) return null;
        return new window.XML3DDataResult(result);
    }
    return null;
};

methods.XML3DNestedDataContainerTypeGetOutputChannelInfo =
    methods.XML3DShaderProviderTypeGetOutputChannelInfo =
        methods.meshGetOutputChannelInfo = function (name) {
            XML3D.flushDOMChanges();
            var dataAdapter = Resource.getAdapter(this, "data");
            if (dataAdapter) {
                var result = dataAdapter.getOutputChannelInfo(name);
                if (!result) return null;
                return new window.XML3DDataChannelInfo(result.type, result.origin, result.originalName,
                    result.seqLength, result.seqMinKey, result.seqMaxKey);
            }
            return null;
        };

methods.XML3DNestedDataContainerTypeGetComputeInfo =
    methods.XML3DShaderProviderTypeGetComputeInfo =
        methods.meshGetComputeInfo = function () {
            XML3D.flushDOMChanges();
            XML3D.debug.logError(this.nodeName + "::getComputeInfo is not implemeted yet.");
            return null;
        };

methods.XML3DNestedDataContainerTypeGetProtoInfo =
    methods.XML3DShaderProviderTypeGetProtoInfo =
        methods.meshGetProtoInfo = function () {
            XML3D.flushDOMChanges();
            XML3D.debug.logError(this.nodeName + "::getProtoInfo is not implemeted yet.");
            return null;
        };

methods.XML3DNestedDataContainerTypeIsOutputConnected =
    methods.XML3DShaderProviderTypeIsOutputConnected =
        methods.meshIsOutputConnected = function () {
            XML3D.flushDOMChanges();
            XML3D.debug.logError(this.nodeName + "::isOutputConnected is not implemeted yet.");
            return false;
        };


function createValues(result, names) {
    var values = {};
    for (var i in names) {
        var name = names[i];
        var data = result.getOutputData(name) && result.getOutputData(name).getValue();
        if (data)
            values[name] = data;
    }
    return values;
}

/** Register data listener for data fields specified by names.
 *
 * @param names   single name or array of names that are monitored.
 * @param callback function that is called when selected data are changed.
 * @return {Boolean}
 */
methods.dataAddOutputFieldListener = function(names, callback) {
    XML3D.flushDOMChanges();
    if (!names)
        return false;

    // check if names is a single string, and convert it to array then
    var typeOfNames = Object.prototype.toString.call(names).slice(8, -1);
    if (typeOfNames === "String") {
        names = [names];
    }
    if (names.length == 0)
        return false;

    var request = callAdapterFunc(this, {
        getComputeRequest : [names, function(request, changeType) {
            callback(createValues(request.getResult(), names));
        }
        ]});
    if (request.length == 0)
        return false;
    var result = request[0].getResult();
    var values = createValues(result, names);
    if (Object.keys(values).length)
        callback(values);
    return true;
};

methods.XML3DDataSourceTypeSetScriptValue = function(data){
    var configData = this._configured;

    if(!configData)
        return;

    if(this.textContent != "[value set by script]")
        this.textContent = "[value set by script]";
    XML3D.flushDOMChanges();
    configData.scriptValue = data;

    var dataAdapter = Resource.getAdapter(this, "data");
    if(dataAdapter)
        dataAdapter.setScriptValue(data);

};

module.exports = methods;
},{"../base/resourcemanager.js":10,"../utils/misc.js":131}],36:[function(require,module,exports){

/**
 * Types of change events
 * @enum {number}
 */
var events = {
      NODE_INSERTED: 0,
      VALUE_MODIFIED:  1,
      NODE_REMOVED: 2,
      THIS_REMOVED: 3,
      ADAPTER_HANDLE_CHANGED: 4,
      ADAPTER_VALUE_CHANGED: 5
};

//-----------------------------------------------------------------------------
//Class Notification
//-----------------------------------------------------------------------------
events.Notification = function(type) {
    this.type = type;
};
events.Notification.prototype.toString = function() {
    return "Notification (type:" + this.type + ")";
};
//-----------------------------------------------------------------------------
events.NotificationWrapper = function(mutation, type, affectedNode) {
    this.mutation = mutation;
    this.type = type;
    this.affectedNode = affectedNode;
};
XML3D.createClass(events.NotificationWrapper, events.Notification);
events.NotificationWrapper.prototype.toString = function() {
    return "NotificationWrapper (type:" + this.type + ", wrapped: "+ this.mutation +")";
};

//-----------------------------------------------------------------------------

/**
 * @param {AdapterHandle} handle
 * @param {int} type
 * @constructor
 */
events.AdapterHandleNotification = function (handle, type) {
    this.adapterHandle = handle;
    this.type = type;
};
XML3D.createClass(events.AdapterHandleNotification, events.Notification);
events.AdapterHandleNotification.prototype.toString = function () {
    return "AdapterHandleNotification (type:" + this.type + ")";
};
//-----------------------------------------------------------------------------

events.ConnectedAdapterNotification = function(adapterHandleNotification, key) {
    this.adapter = adapterHandleNotification.adapterHandle.getAdapter();
    this.key = key;
    this.url = adapterHandleNotification.adapterHandle.url;
    this.type = adapterHandleNotification.type;
    this.handleStatus = adapterHandleNotification.adapterHandle.status;
};
XML3D.createClass(events.ConnectedAdapterNotification, events.Notification);
events.ConnectedAdapterNotification.prototype.toString = function() {
    return "ConnectedAdapterNotification (type:" + this.type + ", key: " + this.key + ")";
};

module.exports = events;
},{}],37:[function(require,module,exports){
var properties = {};

properties.XML3DNestedDataContainerTypeComplete = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getDataComplete) {
                return adapters[adapter].getDataComplete();
            }
        }
        return false;
    },
    set: function(){}
};

properties.XML3DNestedDataContainerTypeProgressLevel = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getDataProgressLevel) {
                return adapters[adapter].getDataProgressLevel();
            }
        }
        return false;
    },
    set: function(){}
};

properties.AssetComplete = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getAssetComplete) {
                return adapters[adapter].getAssetComplete();
            }
        }
        return false;
    },
    set: function(){}
};


properties.AssetProgressLevel = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getAssetProgressLevel) {
                return adapters[adapter].getAssetProgressLevel();
            }
        }
        return false;
    },
    set: function(){}
};

properties.xml3dComplete = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getComplete) {
                return adapters[adapter].getComplete();
            }
        }
        return false;
    },
    set: function(){}
};

module.exports = properties;

},{}],38:[function(require,module,exports){
(function (module) {

    /**
     * @class An axis aligned bounding box in the style of glMatrix
     * @name bbox
     */
    var bbox = {};

    /**
     * Creates a new, empty bounding box
     *
     * @returns {bbox} a new empty bounding box
     */
    bbox.create = function () {
        var out = new Float32Array(6);
        out[0] = Number.MAX_VALUE;
        out[1] = Number.MAX_VALUE;
        out[2] = Number.MAX_VALUE;
        out[3] = -Number.MAX_VALUE;
        out[4] = -Number.MAX_VALUE;
        out[5] = -Number.MAX_VALUE;
        return out;
    };

    bbox.clone = function (a) {
        var out = new Float32Array(6);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        return out;
    };

    bbox.copy = function (out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        return out;
    };

    bbox.copyMin = function (target, source) {
        target[0] = source[0];
        target[1] = source[1];
        target[2] = source[2];
        return target;
    };

    bbox.copyMax = function (target, source) {
        target[0] = source[3];
        target[1] = source[4];
        target[2] = source[5];
        return target;
    };

    bbox.extendWithBox = function (target, other) {
        for (var i = 0; i < 3; i++) {
            target[i] = Math.min(other[i], target[i]);
            target[i + 3] = Math.max(other[i + 3], target[i + 3]);
        }
        return target;
    };

    bbox.empty = function (b) {
        b[0] = Number.MAX_VALUE;
        b[1] = Number.MAX_VALUE;
        b[2] = Number.MAX_VALUE;
        b[3] = -Number.MAX_VALUE;
        b[4] = -Number.MAX_VALUE;
        b[5] = -Number.MAX_VALUE;
        return b;
    };

    bbox.isEmpty = function (b) {
        return (b[0] > b[3] || b[1] > b[4] || b[2] > b[5]);
    };

    bbox.center = function (target, b) {
        target[0] = (b[0] + b[3]) * 0.5;
        target[1] = (b[1] + b[4]) * 0.5;
        target[2] = (b[2] + b[5]) * 0.5;
        return target;
    };

    bbox.size = function (target, b) {
        target[0] = b[3] - b[0];
        target[1] = b[4] - b[1];
        target[2] = b[5] - b[2];
        return target;
    };

    bbox.halfSize = function (target, b) {
        target[0] = (b[3] - b[0]) * 0.5;
        target[1] = (b[4] - b[1]) * 0.5;
        target[2] = (b[5] - b[2]) * 0.5;
        return target;
    };

    bbox.transform = function (out, mat, box) {
        if (box[0] > box[3] || box[1] > box[4] || box[2] > box[5]) {
            bbox.copy(out, box); // an empty box remains empty
            return;
        }
        box = bbox.clone(box);

        if (mat[3] == 0 && mat[7] == 0 && mat[11] == 0 && mat[15] == 1) {

            for (var i = 0; i < 3; i++) {
                out[i] = out[i + 3] = mat[12 + i];

                for (var j = 0; j < 3; j++) {
                    var a, b;

                    a = mat[j * 4 + i] * box[j];
                    b = mat[j * 4 + i] * box[j + 3];

                    if (a < b) {
                        out[i] += a;
                        out[i + 3] += b;
                    }
                    else {
                        out[i] += b;
                        out[i + 3] += a;
                    }
                }
            }
            return out;
        }
        throw new Error("Matrix is not affine");
    };

    bbox.transform2 = (function () {
        var absMat = XML3D.math.mat4.create();
        var center = XML3D.math.vec3.create();
        var extend = XML3D.math.vec3.create();

        return function (out, mat, box) {

            bbox.center(center, box);
            bbox.halfSize(extend, box);

            XML3D.math.mat4.copy(absMat, mat);
            absMat.set([0, 0, 0, 1], 12);
            for (var i = 0; i < 16; i++) {
                absMat[i] = Math.abs(absMat[i]);
            }

            XML3D.math.vec3.transformMat4(extend, extend, absMat);
            XML3D.math.vec3.transformMat4(center, center, mat);

            out[0] = center[0] - extend[0];
            out[1] = center[1] - extend[1];
            out[2] = center[2] - extend[2];
            out[3] = center[0] + extend[0];
            out[4] = center[1] + extend[1];
            out[5] = center[2] + extend[2];

            return out;
        }
    }());

    bbox.longestSide = function (b) {
        var x = Math.abs(b[3] - b[0]);
        var y = Math.abs(b[4] - b[1]);
        var z = Math.abs(b[5] - b[2]);
        return Math.max(x, Math.max(y, z));
    };

    /**
     * Tests a given ray against a given bounding box and returns true if the ray intersects it, false otherwise.
     * @param bb The axis aligned bounding box to test against
     * @param xml3dRay The ray to test for intersection with
     * @param opt {object} If opt.dist is provided the function will fill it with the distance from the ray origin to
     *                     the hit point on the bounding box, or MAX_VALUE if the ray does not intersect.
     * @returns {boolean}
     */
    bbox.intersects = function(bb, xml3dRay, opt) {
        var inverseDirX = 1 / xml3dRay._direction.x;
        var inverseDirY = 1 / xml3dRay._direction.y;
        var inverseDirZ = 1 / xml3dRay._direction.z;

        var t1 = (bb[0] - xml3dRay._origin.x) * inverseDirX;
        var t2 = (bb[3] - xml3dRay._origin.x) * inverseDirX;
        var t3 = (bb[1] - xml3dRay._origin.y) * inverseDirY;
        var t4 = (bb[4] - xml3dRay._origin.y) * inverseDirY;
        var t5 = (bb[2] - xml3dRay._origin.z) * inverseDirZ;
        var t6 = (bb[5] - xml3dRay._origin.z) * inverseDirZ;

        var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
        var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

        if (opt === undefined || opt.dist === undefined) {
            return tmax > 0 && tmin <= tmax;
        }

        if (tmax < 0) {
            opt.dist = Number.MAX_VALUE;
            return false;
        }

        if (tmin > tmax) {
            opt.dist = Number.MAX_VALUE;
            return false;
        }

        opt.dist = tmin;
        return true;
    };

    bbox.asXML3DBox = function (bb) {
        var result = new window.XML3DBox();
        result.min._data[0] = bb[0];
        result.min._data[1] = bb[1];
        result.min._data[2] = bb[2];
        result.max._data[0] = bb[3];
        result.max._data[1] = bb[4];
        result.max._data[2] = bb[5];
        return result;
    };

    bbox.fromXML3DBox = function(bb) {
        var out = new Float32Array(6);
        out[0] = bb.min._data[0];
        out[1] = bb.min._data[1];
        out[2] = bb.min._data[2];
        out[3] = bb.max._data[0];
        out[4] = bb.max._data[1];
        out[5] = bb.max._data[2];
        return out;
    };

    bbox.str = function (a) {
        return 'bbox(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
            a[4] + ', ' + a[5] + ')';
    };

    bbox.EMPTY_BOX = bbox.create();

    module.exports = bbox;


}(module));


},{}],39:[function(require,module,exports){
module.exports = function (math) {

// Additional methods in glMatrix style
    math.vec3.reciprocal = function (vec, dest) {
        if (!dest) {
            dest = vec;
        }

        dest[0] = 1 / vec[0];
        dest[1] = 1 / vec[1];
        dest[2] = 1 / vec[2];
        return dest;
    };


    math.mat4.multiplyOffsetVec3 = function (mat, matOffset, vec, vecOffset, dest) {
        if (!dest) {
            dest = vec;
        }
        if (!vecOffset) {
            vecOffset = 0;
        }

        var x = vec[vecOffset + 0], y = vec[vecOffset + 1], z = vec[vecOffset + 2];

        dest[0] = mat[matOffset + 0] * x + mat[matOffset + 4] * y + mat[matOffset + 8] * z + mat[matOffset + 12];
        dest[1] = mat[matOffset + 1] * x + mat[matOffset + 5] * y + mat[matOffset + 9] * z + mat[matOffset + 13];
        dest[2] = mat[matOffset + 2] * x + mat[matOffset + 6] * y + mat[matOffset + 10] * z + mat[matOffset + 14];

        return dest;
    };


    math.mat4.multiplyOffsetDirection = function (mat, matOffset, vec, vecOffset, dest) {
        if (!dest) {
            dest = vec;
        }
        if (!vecOffset) {
            vecOffset = 0;
        }

        var x = vec[vecOffset + 0], y = vec[vecOffset + 1], z = vec[vecOffset + 2], w;

        dest[0] = mat[matOffset + 0] * x + mat[matOffset + 4] * y + mat[matOffset + 8] * z;
        dest[1] = mat[matOffset + 1] * x + mat[matOffset + 5] * y + mat[matOffset + 9] * z;
        dest[2] = mat[matOffset + 2] * x + mat[matOffset + 6] * y + mat[matOffset + 10] * z;

        return dest;
    };

    var IDENT_MAT = XML3D.math.mat4.identity(XML3D.math.mat4.create());
    var TMP_MATRIX = XML3D.math.mat4.create();
    var TMP_VEC = XML3D.math.vec3.create();

    math.mat4.makeTransformXflow = function (translation, rotation, scale, center, scaleOrientation, dest) {
        XML3D.math.mat4.identity(dest);
        if (translation) XML3D.math.mat4.translate(dest, dest, translation);
        if (center) XML3D.math.mat4.translate(dest, dest, center);
        if (rotation) {
            XML3D.math.mat4.fromRotationTranslation(TMP_MATRIX, [rotation[0], rotation[1], rotation[2], rotation[3]], [0, 0, 0]);
            XML3D.math.mat4.multiply(dest, dest, TMP_MATRIX);
        }
        if (scaleOrientation) {
            XML3D.math.mat4.fromRotationTranslation(TMP_MATRIX, [scaleOrientation[0], scaleOrientation[1], scaleOrientation[2], scaleOrientation[3]], [0, 0, 0]);
            XML3D.math.mat4.multiply(dest, dest, TMP_MATRIX);
        }
        if (scale) XML3D.math.mat4.scale(dest, dest, scale);
        if (scaleOrientation) {
            XML3D.math.mat4.fromRotationTranslation(TMP_MATRIX, [scaleOrientation[0], scaleOrientation[1], scaleOrientation[2], -scaleOrientation[3]], [0, 0, 0]);
            XML3D.math.mat4.multiply(dest, dest, TMP_MATRIX);
        }
        if (center) {
            XML3D.math.mat4.translate(dest, dest, XML3D.math.vec3.negate(TMP_VEC, center));
        }
    };

    math.mat4.makeTransformInvXflow = function (translation, rotation, scale, center, scaleOrientation, dest) {
        XML3D.math.mat4.identity(dest);
        if (center) {
            XML3D.math.mat4.translate(dest, dest, center);
        }
        if (scaleOrientation) {
            XML3D.math.mat4.fromRotationTranslation(TMP_MATRIX, [scaleOrientation[0], scaleOrientation[1], scaleOrientation[2], scaleOrientation[3]], [0, 0, 0])
            XML3D.math.mat4.multiply(dest, dest, TMP_MATRIX);
        }
        if (scale) XML3D.math.mat4.scale(dest, dest, XML3D.math.vec3.reciprocal(scale, TMP_VEC));
        if (scaleOrientation) {
            XML3D.math.mat4.fromRotationTranslation(TMP_MATRIX, [scaleOrientation[0], scaleOrientation[1], scaleOrientation[2], -scaleOrientation[3]], [0, 0, 0])
            XML3D.math.mat4.multiply(dest, dest, TMP_MATRIX);
        }
        if (rotation) {
            XML3D.math.mat4.fromRotationTranslation(TMP_MATRIX, [rotation[0], rotation[1], rotation[2], -rotation[3]], [0, 0, 0])
            XML3D.math.mat4.multiply(dest, dest, TMP_MATRIX);
        }
        if (center) XML3D.math.mat4.translate(dest, dest, XML3D.math.vec3.negate(TMP_VEC, center));
        if (translation) XML3D.math.mat4.translate(dest, dest, XML3D.math.vec3.negate(TMP_VEC, translation));
    };

    math.mat4.multiplyOffset = function (dest, destOffset, mat, offset1, mat2, offset2) {
        var a00 = mat2[offset2 + 0], a01 = mat2[offset2 + 1], a02 = mat2[offset2 + 2], a03 = mat2[offset2 + 3];
        var a10 = mat2[offset2 + 4], a11 = mat2[offset2 + 5], a12 = mat2[offset2 + 6], a13 = mat2[offset2 + 7];
        var a20 = mat2[offset2 + 8], a21 = mat2[offset2 + 9], a22 = mat2[offset2 + 10], a23 = mat2[offset2 + 11];
        var a30 = mat2[offset2 + 12], a31 = mat2[offset2 + 13], a32 = mat2[offset2 + 14], a33 = mat2[offset2 + 15];

        var b00 = mat[offset1 + 0], b01 = mat[offset1 + 1], b02 = mat[offset1 + 2], b03 = mat[offset1 + 3];
        var b10 = mat[offset1 + 4], b11 = mat[offset1 + 5], b12 = mat[offset1 + 6], b13 = mat[offset1 + 7];
        var b20 = mat[offset1 + 8], b21 = mat[offset1 + 9], b22 = mat[offset1 + 10], b23 = mat[offset1 + 11];
        var b30 = mat[offset1 + 12], b31 = mat[offset1 + 13], b32 = mat[offset1 + 14], b33 = mat[offset1 + 15];

        dest[destOffset + 0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
        dest[destOffset + 1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
        dest[destOffset + 2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
        dest[destOffset + 3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
        dest[destOffset + 4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
        dest[destOffset + 5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
        dest[destOffset + 6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
        dest[destOffset + 7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
        dest[destOffset + 8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
        dest[destOffset + 9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
        dest[destOffset + 10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
        dest[destOffset + 11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
        dest[destOffset + 12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
        dest[destOffset + 13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
        dest[destOffset + 14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
        dest[destOffset + 15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
    };

    math.quat.slerpOffset = function (quat, offset1, quat2, offset2, t, dest, destOffset, shortest) {
        if (!dest) {
            dest = quat;
        }

        var ix1 = offset1, iy1 = offset1 + 1, iz1 = offset1 + 2, iw1 = offset1 + 3;
        var ix2 = offset2, iy2 = offset2 + 1, iz2 = offset2 + 2, iw2 = offset2 + 3;
        var ixd = destOffset, iyd = destOffset + 1, izd = destOffset + 2, iwd = destOffset + 3;

        var cosAngle = quat[ix1] * quat2[ix2] + quat[iy1] * quat2[iy2] + quat[iz1] * quat2[iz2] + quat[iw1] * quat2[iw2];

        var c1, c2;

        // Linear interpolation for close orientations
        if ((1.0 - Math.abs(cosAngle)) < 0.01) {
            c1 = 1.0 - t;
            c2 = t;
        } else {
            // Spherical interpolation
            var angle = Math.acos(Math.abs(cosAngle));
            var sinAngle = Math.sin(angle);
            c1 = Math.sin(angle * (1.0 - t)) / sinAngle;
            c2 = Math.sin(angle * t) / sinAngle;
        }

        // Use the shortest path
        if (shortest && (cosAngle < 0.0))
            c1 = -c1;

        dest[ixd] = c1 * quat[ix1] + c2 * quat2[ix2];
        dest[iyd] = c1 * quat[iy1] + c2 * quat2[iy2];
        dest[izd] = c1 * quat[iz1] + c2 * quat2[iz2];
        dest[iwd] = c1 * quat[iw1] + c2 * quat2[iw2];
    };

    /**
     * Transforms the vec3 with a mat4.
     * 4th vector component is implicitly '0'
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to transform
     * @param {mat4} m matrix to transform with
     * @returns {vec3} out
     */
    math.vec3.transformDirection = function(out, a, m) {
        var x = a[0], y = a[1], z = a[2];
        out[0] = (m[0] * x + m[4] * y + m[8] * z);
        out[1] = (m[1] * x + m[5] * y + m[9] * z);
        out[2] = (m[2] * x + m[6] * y + m[10] * z);
        return out;
    };

    math.quat.setFromMat3 = function(m, dest) {
        var tr = m[0] + m[4] + m[8];

        if (tr > 0) {
            var s = Math.sqrt(tr + 1.0) * 2; // s=4*dest[3]
            dest[0] = (m[7] - m[5]) / s;
            dest[1] = (m[2] - m[6]) / s;
            dest[2] = (m[3] - m[1]) / s;
            dest[3] = 0.25 * s;
        } else if ((m[0] > m[4]) && (m[0] > m[8])) {
            var s = Math.sqrt(1.0 + m[0] - m[4] - m[8]) * 2; // s=4*qx
            dest[3] = (m[7] - m[5]) / s;
            dest[0] = 0.25 * s;
            dest[1] = (m[1] + m[3]) / s;
            dest[2] = (m[2] + m[6]) / s;
        } else if (m[4] > m[8]) {
            var s = Math.sqrt(1.0 + m[4] - m[0] - m[8]) * 2; // s=4*qy
            dest[3] = (m[2] - m[6]) / s;
            dest[0] = (m[1] + m[3]) / s;
            dest[1] = 0.25 * s;
            dest[2] = (m[5] + m[7]) / s;
        } else {
            var s = Math.sqrt(1.0 + m[8] - m[0] - m[4]) * 2; // s=4*qz
            dest[3] = (m[3] - m[1]) / s;
            dest[0] = (m[2] + m[6]) / s;
            dest[1] = (m[5] + m[7]) / s;
            dest[2] = 0.25 * s;
        }
    };

    math.quat.setFromBasis = function(X,Y,Z,dest) {
        var lx = 1.0 / XML3D.math.vec3.length(X);
        var ly = 1.0 / XML3D.math.vec3.length(Y);
        var lz = 1.0 / XML3D.math.vec3.length(Z);
        var m = XML3D.math.mat3.create();
        m[0] = X[0] * lx;
        m[1] = Y[0] * ly;
        m[2] = Z[0] * lz;
        m[3] = X[1] * lx;
        m[4] = Y[1] * ly;
        m[5] = Z[1] * lz;
        m[6] = X[2] * lx;
        m[7] = Y[2] * ly;
        m[8] = Z[2] * lz;
        XML3D.math.quat.setFromMat3(m,dest);
    };


};

},{}],40:[function(require,module,exports){
var NodeAdapter = require("../../../base/adapter.js").NodeAdapter;

var RenderAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
};
XML3D.createClass(RenderAdapter, NodeAdapter);

RenderAdapter.prototype.getShader = function () {
    return null;
};

RenderAdapter.prototype.getParentRenderAdapter = function () {
    return this.factory.getAdapter(this.node.parentNode, RenderAdapter);
};

/**
 * @param element
 */
RenderAdapter.prototype.initElement = function (element) {
    this.factory.getAdapter(element);
    this.initChildElements(element);
};

/**
 * @param {Element} element
 */
RenderAdapter.prototype.initChildElements = function (element) {
    var child = element.firstElementChild;
    while (child) {
        this.initElement(child);
        child = child.nextElementSibling;
    }
};


RenderAdapter.prototype.applyTransformMatrix = function (transform) {
    return transform;
};

RenderAdapter.prototype.getScene = function () {
    return this.factory.renderer.scene;
};

module.exports = RenderAdapter;

},{"../../../base/adapter.js":7}],41:[function(require,module,exports){
var RenderAdapter = require("./base.js");

//Adapter for <defs>
var DefsRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
};
XML3D.createClass(DefsRenderAdapter, RenderAdapter);

module.exports = DefsRenderAdapter;

},{"./base.js":40}],42:[function(require,module,exports){
var NodeAdapterFactory = require("../../../base/adapter.js").NodeAdapterFactory;
var DataAdapterFactory = require("../../../data/adapter/factory.js");
require("../../../base/formathandler.js").xml3dFormatHandler.registerFactoryClass(DataAdapterFactory);

/**
 * @constructor
 * @implements {XML3D.base.IFactory}
 * @extends XML3D.base.NodeAdapterFactory
 * @param {number} canvasId
 */
var RenderAdapterFactory = function (canvasId) {
    NodeAdapterFactory.call(this, "webgl", canvasId);
    this.type = "RenderAdapterFactory";
};
XML3D.createClass(RenderAdapterFactory, NodeAdapterFactory);
RenderAdapterFactory.prototype.aspect = "webgl";


var registry = {
        xml3d: require("./xml3d.js"),
        view: require("./view.js"),
        defs: require("./defs.js"),
        mesh: require("./mesh.js"),
        model: require("./model.js"),
        shader: require("./shader.js"),
        group: require("./group.js"),
        light: require("./light.js"),
        lightshader: require("./lightshader.js")
    };

/**
 * @param node
 * @return {XML3D.base.Adapter|null}
 */
RenderAdapterFactory.prototype.createAdapter = function (node) {
    var adapterConstructor = registry[node.localName];
    if (adapterConstructor !== undefined) {
        return new adapterConstructor(this, node);
    }
    return null;
};

RenderAdapterFactory.prototype.setScene = function (scene) {
    this.scene = scene;
};

RenderAdapterFactory.prototype.getScene = function () {
    return this.scene;
};

RenderAdapterFactory.prototype.setRenderer = function (renderer) {
    this.renderer = renderer;
};

RenderAdapterFactory.prototype.getRenderer = function () {
    return this.renderer;
};

// Export
module.exports = RenderAdapterFactory;

},{"../../../base/adapter.js":7,"../../../base/formathandler.js":9,"../../../data/adapter/factory.js":20,"./defs.js":41,"./group.js":43,"./light.js":44,"./lightshader.js":45,"./mesh.js":46,"./model.js":47,"./shader.js":48,"./view.js":50,"./xml3d.js":51}],43:[function(require,module,exports){
var TransformableAdapter = require("./transformable.js");
var Events = require("../../../interface/notification.js");

var GroupRenderAdapter = function (factory, node) {
    TransformableAdapter.call(this, factory, node, true, true);
    this.createRenderNode();
};

XML3D.createClass(GroupRenderAdapter, TransformableAdapter);

var p = GroupRenderAdapter.prototype;

p.createRenderNode = function () {
    //TODO: Shouldn't have to go through the renderer...
    var parent = this.getParentRenderAdapter();
    var parentNode = parent.getRenderNode && parent.getRenderNode();
    this.renderNode = this.getScene().createRenderGroup({
        parent: parentNode, visible: this.node.visible, name: this.node.id
    });
    this.updateLocalMatrix();
    this.updateShaderHandler();
    var bbox = XML3D.math.bbox.create();
    this.renderNode.setWorldSpaceBoundingBox(bbox);
};

p.notifyChanged = function (evt) {
    TransformableAdapter.prototype.notifyChanged.call(this, evt);
    if (evt.type !== Events.VALUE_MODIFIED) {
        return this.handleConnectedAdapterEvent(evt);
    }
};

p.handleConnectedAdapterEvent = function (evt) {
    switch (evt.type) {
        case Events.NODE_INSERTED:
            // This also initializes the children
            this.initElement(evt.mutation.target);
            break;
        case Events.THIS_REMOVED:
            this.dispose();
            break;
        case Events.ADAPTER_HANDLE_CHANGED:
            break;
        case Events.NODE_REMOVED:
            break;
        default:
            XML3D.debug.logWarning("Unhandled connected adapter event for " + evt.key + " in shader adapter");
    }
};

p.dispose = function () {
    // Dispose all children as well
    this.traverse(function (adapter) {
        if (adapter && adapter.destroy)
            adapter.dispose();
    });
    this.getRenderNode().remove();
    this.clearAdapterHandles();
};

/* Interface methods */
p.getWorldBoundingBox = function () {
    var bbox = XML3D.math.bbox.create();
    this.renderNode.getWorldSpaceBoundingBox(bbox);
    return XML3D.math.bbox.asXML3DBox(bbox);
};

//TODO: improve efficiency of this function once XML3D types are overhauled
p.getLocalBoundingBox = (function () {
    var localMat = XML3D.math.mat4.create();

    return function() {
        var bbox = new window.XML3DBox();
        if (!this.renderNode.visible) {
            return bbox;
        }
        Array.prototype.forEach.call(this.node.childNodes, function (c) {
            if (c.getLocalBoundingBox && c.visible)
                bbox.extend(c.getLocalBoundingBox());
        });
        this.renderNode.getLocalMatrix(localMat);
        var localBB = XML3D.math.bbox.fromXML3DBox(bbox);
        XML3D.math.bbox.transform(localBB, localMat, localBB);
        return XML3D.math.bbox.asXML3DBox(localBB);
    }
})();

p.getLocalMatrix = function () {
    var m = new window.XML3DMatrix();
    this.renderNode.getLocalMatrix(m._data);
    return m;
};

p.getWorldMatrix = function () {
    var m = new window.XML3DMatrix();
    this.renderNode.getWorldMatrix(m._data);
    return m;
};

module.exports = GroupRenderAdapter;

},{"../../../interface/notification.js":36,"./transformable.js":49}],44:[function(require,module,exports){
var TransformableAdapter = require("./transformable.js");
var Events = require("../../../interface/notification.js");
/**
 * Adapter for <light>
 * @constructor
 * @param {RenderAdapterFactory} factory
 * @param {Element} node
 */
var LightRenderAdapter = function (factory, node) {
    TransformableAdapter.call(this, factory, node, false, true);
    this.updateLightShader();
    this.createRenderNode();
};
XML3D.createClass(LightRenderAdapter, TransformableAdapter);

LightRenderAdapter.prototype.createRenderNode = function () {
    var parentAdapter = this.getParentRenderAdapter();
    var parentNode = parentAdapter.getRenderNode && parentAdapter.getRenderNode();
    var lightShader = this.getLightShader();
    this.renderNode = this.factory.getScene().createRenderLight({
        light: {
            type: lightShader ? lightShader.getLightType() : null, data: lightShader ? lightShader.getDataNode() : null
        },
        parent: parentNode,
        shader: lightShader,
        visible: !this.node.visible ? false : undefined,
        localIntensity: this.node.intensity
    });
};

LightRenderAdapter.prototype.notifyChanged = function (evt) {
    switch (evt.type) {
            case Events.NODE_REMOVED:
            return;
        case Events.THIS_REMOVED:
            this.dispose();
            return;
        case Events.ADAPTER_HANDLE_CHANGED:
            if (evt.key == "shader") {
                //The lightshader was destroyed, so this light is now invalid
                this.renderNode.remove();
                return;
            }
            break;
        case Events.VALUE_MODIFIED:
            this.valueModified(evt.mutation);
            break;
        case Events.ADAPTER_VALUE_CHANGED:
            this.renderNode.setLightType(evt.adapter.getLightType(), evt.adapter.getDataNode());
    }
};

LightRenderAdapter.prototype.valueModified = function (mutation) {
    var newValue = mutation.target.getAttribute(mutation.attributeName);
    switch (mutation.attributeName) {
        case "visible":
            this.renderNode.setLocalVisible(newValue && (newValue.toLowerCase() !== "false"));
            break;
        case "intensity":
            this.renderNode.setLocalIntensity(newValue);
            break;
        case "shader":
            this.renderNode.remove();
            this.updateLightShader();
            this.createRenderNode();
            break;
    }
};

LightRenderAdapter.prototype.updateLightShader = function () {
    var shaderHref = this.node.shader;
    if (!shaderHref) {
        var styleValue = this.node.getAttribute('style');
        if (styleValue) {
            var pattern = /shader\s*:\s*url\s*\(\s*(\S+)\s*\)/i;
            var result = pattern.exec(styleValue);
            if (result)
                shaderHref = result[1];
        }
    }
    this.connectAdapterHandle("shader", this.getAdapterHandle(shaderHref));
};

/**
 *
 */
LightRenderAdapter.prototype.getLightShader = function () {
    return this.getConnectedAdapter("shader");
};

LightRenderAdapter.prototype.dispose = function () {
    this.getRenderNode().remove();
    this.clearAdapterHandles();
};

/**
 * @return {XML3DMatrix}
 */
LightRenderAdapter.prototype.getWorldMatrix = function () {
    var m = new window.XML3DMatrix();
    this.renderNode.getWorldMatrix(m._data);
    return m;
};

// Export
module.exports = LightRenderAdapter;


},{"../../../interface/notification.js":36,"./transformable.js":49}],45:[function(require,module,exports){
var RenderAdapter = require("./base.js");
var Events = require("../../../interface/notification.js");
var Resource = require("../../../base/resourcemanager.js").Resource;

/**
 * Adapter for <lightshader>
 * @constructor
 * @param {RenderAdapterFactory} factory
 * @param {Element} node
 * @extends RenderAdapter
 */
var LightShaderRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
    this.dataAdapter = Resource.getAdapter(this.node, "data");
};
XML3D.createClass(LightShaderRenderAdapter, RenderAdapter, {
    getDataNode: function () {
        return this.dataAdapter.getXflowNode();
    }, getLightType: function () {
        var script = this.node.getAttribute("script");
        if (script.indexOf("urn:xml3d:lightshader:") === 0) {
            return script.substring(22, script.length);
        } else {
            XML3D.debug.logError("Unsupported light type " + script);
            return null;
        }
    }, notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.THIS_REMOVED:
                this.notifyOppositeAdapters();
                break;
            case Events.VALUE_MODIFIED:
                this.notifyOppositeAdapters(Events.ADAPTER_VALUE_CHANGED);
                break;
        }
    }
});

// Export
module.exports = LightShaderRenderAdapter;


},{"../../../base/resourcemanager.js":10,"../../../interface/notification.js":36,"./base.js":40}],46:[function(require,module,exports){
var TransformableAdapter = require("./transformable.js");
var Events = require("../../../interface/notification.js");
var Resource = require("../../../base/resourcemanager.js").Resource;

/**
 * @constructor
 */
var MeshRenderAdapter = function (factory, node) {
    TransformableAdapter.call(this, factory, node, true, true);
    this.createRenderNode();
};

XML3D.createClass(MeshRenderAdapter, TransformableAdapter, {

    createRenderNode: function () {
        var dataAdapter = Resource.getAdapter(this.node, "data");

        var parent = this.getParentRenderAdapter();
        var parentNode = parent.getRenderNode && parent.getRenderNode();

        this.renderNode = this.getScene().createRenderObject({
            parent: parentNode, node: this.node, object: {
                data: dataAdapter.getXflowNode(), type: this.getMeshType()
            }, name: this.node.id, visible: !this.node.visible ? false : undefined
        });
        this.updateLocalMatrix();
        this.updateShaderHandler();
    },

    getMeshType: function () {
        return this.node.hasAttribute("type") ? this.node.getAttribute("type") : "triangles";
    },

    /**
     * @param {Events.Notification} evt
     */
    notifyChanged: function (evt) {
        TransformableAdapter.prototype.notifyChanged.call(this, evt);
        switch (evt.type) {
            case  Events.NODE_INSERTED:
                return;
            case Events.THIS_REMOVED:
                this.dispose();
                return;
            case Events.NODE_REMOVED:
                // this.createPerObjectData();
                return;
            case Events.VALUE_MODIFIED:
                this.valueChanged(evt.mutation);
        }
    }, /**
     * @param {MutationEvent} evt
     */
    valueChanged: function (mutation) {
        var target = mutation.attributeName;
        switch (target) {
            case "src":
                // Handled by data component
                break;

            case "type":
                this.renderNode.setType(mutation.target.getAttribute("type"));
                break;
        }

    }, dispose: function () {
        this.getRenderNode().remove();
        this.clearAdapterHandles();
    }
});


// Interface methods

XML3D.extend(MeshRenderAdapter.prototype, {
    /**
     * @return {Window.XML3DBox}
     */
    getLocalBoundingBox: function () {
        if (this.renderNode) {
            var bbox = new XML3D.math.bbox.create();
            this.renderNode.getObjectSpaceBoundingBox(bbox);
            return XML3D.math.bbox.asXML3DBox(bbox);
        }

        return new window.XML3DBox();
    },

    /**
     * @return {Window.XML3DBox}
     */
    getWorldBoundingBox: function () {
        if (this.renderNode) {
            var bbox = new XML3D.math.bbox.create();
            this.renderNode.getWorldSpaceBoundingBox(bbox);
            return XML3D.math.bbox.asXML3DBox(bbox);
        }

        return new window.XML3DBox();
    },

    /**
     * @return {Window.XML3DMatrix}
     */
    getWorldMatrix: function () {
        var m = new window.XML3DMatrix(), obj = this.renderNode;
        if (obj) {
            obj.getWorldMatrix(m._data);
        }
        return m;
    }
});

// Export
module.exports = MeshRenderAdapter;


},{"../../../base/resourcemanager.js":10,"../../../interface/notification.js":36,"./transformable.js":49}],47:[function(require,module,exports){
var TransformableAdapter = require("./transformable.js");
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var Events = require("../../../interface/notification.js");
var Resource = require("../../../base/resourcemanager.js").Resource;
var AdapterHandle = require("../../../base/adapterhandle.js");

var ModelRenderAdapter = function (factory, node) {
    TransformableAdapter.call(this, factory, node, false, true);
    this.asset = null;
    this.postTransformXflowRequests = [];
    this.postTransformRenderGroups = [];
    this.createRenderNode();
    this._bindedRequestCallback = this.onXflowRequestChange.bind(this);
    this.transformFetcher.update();
};

var c_IDENTITY = XML3D.math.mat4.create();

XML3D.createClass(ModelRenderAdapter, TransformableAdapter, {

    createRenderNode: function () {
        var dataAdapter = Resource.getAdapter(this.node, "data");
        this.asset = dataAdapter.getAsset();

        this.asset.addChangeListener(this);

        var parent = this.getParentRenderAdapter();
        var parentNode = parent.getRenderNode && parent.getRenderNode();

        this.renderNode = this.getScene().createRenderGroup({
            parent: parentNode, visible: this.node.visible, name: this.node.id
        });
        this.renderNode.setLocalMatrix(c_IDENTITY);
        this.createModelRenderNodes();
    },

    clearModelRenderNodes: function () {
        this.clearAdapterHandles();
        this._subRenderNodes = [];
        var i = this.postTransformXflowRequests.length;
        while (i--) {
            this.postTransformXflowRequests[i].clear();
        }
        rec_removeRenderNodes(this.renderNode, true);
        this.postTransformXflowRequests.length = 0;
        this.postTransformRenderGroups.length = 0;
    },

    createModelRenderNodes: function () {
        this.clearModelRenderNodes();
        if (!this.asset.isSubtreeLoading()) {
            try {
                this.asset.checkValidity();
                var assetResult = this.asset.getResult();
                var dataTree = assetResult.getDataTree();
                rec_createRenderNodes(this, this.renderNode, dataTree);
            } catch (e) {
                XML3D.debug.logError("Asset Error: " + e.message, e.node || this.node);
                this.clearModelRenderNodes();
            }
        }
    },

    getMaterialConfiguration: function (shaderHref, index) {
        var result = null;
        if (shaderHref) {
            var adapterHandle = this.getAdapterHandle(shaderHref);
            this.connectAdapterHandle("shader_" + index, adapterHandle);

            switch (adapterHandle.status) {

                case AdapterHandle.STATUS.NOT_FOUND:
                    XML3D.debug.logError("Could not find <shader> of url '" + adapterHandle.url + "' ", this.node);
                    break;
                case AdapterHandle.STATUS.READY:
                    var adapter = adapterHandle.getAdapter();
                    if (adapter && adapter.getMaterialConfiguration) {
                        result = adapter.getMaterialConfiguration();
                    }
                    break;
                case AdapterHandle.STATUS.LOADING:
                    break;
            }

        }
        return result;
    },

    /**
     * @param evt
     */
    notifyChanged: function (evt) {
        TransformableAdapter.prototype.notifyChanged.call(this, evt);
        switch (evt.type) {
            case  Events.NODE_INSERTED:
                return;
            case Events.THIS_REMOVED:
                this.dispose();
                return;
            case Events.ADAPTER_HANDLE_CHANGED:
                var splits = evt.key.split("_");
                if (splits[0] == "shader") {
                    var renderNodeId = +splits[1];
                    // We identify the corresponding rendernode by the handler key
                    // This is a workaround that should be removed if there are
                    // custom callbacks for
                    var renderNode = this._subRenderNodes[renderNodeId];
                    XML3D.debug.assert(renderNode);
                    if (evt.handleStatus == AdapterHandle.STATUS.NOT_FOUND) {
                        renderNode.setMaterial(null);
                    } else {
                        var adapter = evt.adapter;
                        if (adapter && adapter.getMaterialConfiguration) {
                            renderNode.setMaterial(adapter.getMaterialConfiguration());
                        }
                    }
                    this.factory.renderer.requestRedraw("Material model changed.");
                }
        }
    },

    onAssetChange: function () {
         if (!this.renderNode) {
            //This model hasn't even been initialized yet so we defer building the render nodes to that step
            //This can happen for ex. when changing the "src" attribute before the model is appended into the DOM
            return;
        }

        this.createModelRenderNodes();
    },

    onXflowRequestChange: function (request) {
        var index = this.postTransformXflowRequests.indexOf(request);
        if (index != -1) {
            this.updatePostTransform(this.postTransformRenderGroups[index], request);
        }
    }, updatePostTransform: function (renderNode, xflowRequest) {
        var dataResult = xflowRequest.getResult();
        var transformData = (dataResult.getOutputData("transform") && dataResult.getOutputData("transform").getValue());
        if (!transformData) {
            XML3D.debug.logWarning("Post Transform entry does not contain any 'transform' value.", this.node);
            renderNode.setLocalMatrix(c_IDENTITY);
            return;
        }
        renderNode.setLocalMatrix(transformData);
    }, dispose: function () {
        this.asset.removeChangeListener(this);
        this.clearModelRenderNodes();
        this.getRenderNode().remove();
        this.clearAdapterHandles();
    }
});

function rec_removeRenderNodes(node, keepCurrentNode) {
    if (!node) {
        return;
    }
    if (!keepCurrentNode)
        node.remove();
    var children = node.getChildren();
    var i = children.length;
    while (i--) {
        rec_removeRenderNodes(children[i], false);
    }
}

function rec_createRenderNodes(adapter, parentNode, dataTreeNode) {

    if (dataTreeNode.postTransformXflowNode) {
        var request = new ComputeRequest(dataTreeNode.postTransformXflowNode, ["transform"], adapter._bindedRequestCallback);
        parentNode = adapter.getScene().createRenderGroup({
            parent: parentNode, visible: true, name: undefined
        });
        adapter.postTransformXflowRequests.push(request);
        adapter.postTransformRenderGroups.push(parentNode);
        adapter.updatePostTransform(parentNode, request);
    }

    var groupNode = adapter.getScene().createRenderGroup({
        parent: parentNode,
        visible: true,
        name: adapter.node.id
    });
    groupNode.setLocalMatrix(dataTreeNode.transform || c_IDENTITY);
    groupNode.setMaterial(adapter.getMaterialConfiguration(dataTreeNode.shader, adapter._subRenderNodes.length));
    adapter._subRenderNodes.push(groupNode);

    var meshSets = dataTreeNode.meshes, i;
    for (i = 0; i < meshSets.length; ++i) {
        var renderNode = adapter.getScene().createRenderObject({
            parent: groupNode,
            node: meshSets[i].refNode || adapter.node,
            object: {
                data: meshSets[i].xflowNode, type: meshSets[i].type
            },
            name: adapter.node.id,
            visible: true
        });
        renderNode.setLocalMatrix(meshSets[i].transform || c_IDENTITY);
        renderNode.setMaterial(adapter.getMaterialConfiguration(meshSets[i].shader, adapter._subRenderNodes.length));
        adapter._subRenderNodes.push(renderNode);
    }
    var groups = dataTreeNode.groups;
    for (i = 0; i < groups.length; ++i) {
        rec_createRenderNodes(adapter, groupNode, groups[i]);
    }
}


// Interface methods

XML3D.extend(ModelRenderAdapter.prototype, {
    /**
     * @return {Window.XML3DBox}
     */
    getLocalBoundingBox: function () {
        if (this.renderNode) {
            var bbox = new XML3D.math.bbox.create();
            this.renderNode.getObjectSpaceBoundingBox(bbox);
            return XML3D.math.bbox.asXML3DBox(bbox);
        }

        return new window.XML3DBox();
    },

    /**
     * @return {Window.XML3DBox}
     */
    getWorldBoundingBox: function () {
        if (this.renderNode) {
            var bbox = new XML3D.math.bbox.create();
            this.renderNode.getWorldSpaceBoundingBox(bbox);
            return XML3D.math.bbox.asXML3DBox(bbox);
        }

        return new window.XML3DBox();
    },

    /**
     * @return {Window.XML3DMatrix}
     */
    getWorldMatrix: function () {
        var m = new window.XML3DMatrix(), obj = this.renderNode;
        if (obj) {
            obj.getWorldMatrix(m._data);
        }
        return m;
    }
});

// Export
module.exports = ModelRenderAdapter;


},{"../../../base/adapterhandle.js":8,"../../../base/resourcemanager.js":10,"../../../interface/notification.js":36,"../../../xflow/interface/request.js":139,"./transformable.js":49}],48:[function(require,module,exports){
var RenderAdapter = require("./base.js");
var Events = require("../../../interface/notification.js");
var URI = require("../../../utils/uri.js").URI;
var Resource = require("../../../base/resourcemanager.js").Resource;
var AdapterHandle = require("../../../base/adapterhandle.js");

/**
 * @param factory
 * @param {Element} node
 * @extends RenderAdapter
 * @constructor
 */
var ShaderRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
    this._dataAdapter = Resource.getAdapter(this.node, "data");
    /** @type MaterialConfiguration | null **/
    this._materialConfiguration = null;
    this._materialModel = null;

    this.updateMaterialConfiguration();
};

XML3D.createClass(ShaderRenderAdapter, RenderAdapter);
XML3D.extend(ShaderRenderAdapter.prototype, {

    getMaterialConfiguration: function() {
        return this._materialConfiguration;
    },

    updateMaterialConfiguration: function () {
        // First find the model
        this.updateMaterialModel();
        if (!this._materialModel) {
            this._materialConfiguration = null;
        } else {
            this._materialConfiguration = this.getScene().createMaterialConfiguration(this._materialModel, this._dataAdapter.getXflowNode(), {name: this.node.id});
        }
        this.notifyOppositeAdapters();
    },

    updateMaterialModel: function () {
        this._materialModel = null;

        var uri = this.getShaderScriptURI();
        if (uri.scheme == "urn") {
            this.disconnectAdapterHandle("script");
            this._materialModel = { "type": "urn", "urn": uri };
            return;
        }

        this.connectAdapterHandle("script", this.getAdapterHandle(uri, "data", 0));
        var adapter = this.getConnectedAdapter('script');
        if (adapter && adapter.getScriptType) {
            this._materialModel = { type: adapter.getScriptType(), script: adapter.getScript() };
        }
    },

    getShaderScriptURI: function () {
        return new URI(this.node.getAttribute("script"));
    },

    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.VALUE_MODIFIED:
                var target = evt.mutation.attributeName;
                switch (target) {
                    case "script":
                        this.updateMaterialConfiguration();
                        break;
                    default:
                        XML3D.debug.logWarning("Unhandled mutation event in shader adapter for parameter '" + target + "'");
                        break;

                }
                break;
            case Events.ADAPTER_HANDLE_CHANGED:
                if (evt.handleStatus == AdapterHandle.STATUS.NOT_FOUND) {
                    XML3D.debug.logError("Could not find material for url '" + evt.url + "'");

                }
                this.updateMaterialConfiguration();
                break;
        }


    }
});

// Export
module.exports = ShaderRenderAdapter;


},{"../../../base/adapterhandle.js":8,"../../../base/resourcemanager.js":10,"../../../interface/notification.js":36,"../../../utils/uri.js":133,"./base.js":40}],49:[function(require,module,exports){
var RenderAdapter = require("./base.js");
var DOMTransformFetcher = require("../../../data/transform-fetcher.js");
var Events = require("../../../interface/notification.js");
var AdapterHandle = require("../../../base/adapterhandle.js");

var TransformableAdapter = function (factory, node, handleShader, handleTransform) {
    RenderAdapter.call(this, factory, node);
    this.renderNode = null;
    this.shaderHandler = null;
    this.handleShader = handleShader || false;
    if (handleTransform) {
        this.transformFetcher = new DOMTransformFetcher(this, "transform", "transform");
    }

};
XML3D.createClass(TransformableAdapter, RenderAdapter);

XML3D.extend(TransformableAdapter.prototype, {
    updateShaderHandler: function () {
        var shaderURI = getShaderURI(this.node);
        if (!shaderURI) {
            this.disconnectAdapterHandle("shader");
            this.shaderHandler = null;
        } else {
            this.shaderHandler = this.getAdapterHandle(shaderURI);
            this.connectAdapterHandle("shader", this.shaderHandler);
        }
        this.referencedShaderChanged();
    },

    referencedShaderChanged: function () {
        if (!this.shaderHandler) {
            this.getRenderNode().setMaterial(null);
            return;
        }
        var status = this.shaderHandler.status;
        if (status === AdapterHandle.STATUS.NOT_FOUND) {
            XML3D.debug.logError("Could not find element of url '" + this.shaderHandler.url + "' for shader", this.node);
            this.getRenderNode().setMaterial(null);
            return;
        }
        var adapter = this.shaderHandler.getAdapter();
        if (adapter && adapter.getMaterialConfiguration) {
            this.getRenderNode().setMaterial(adapter.getMaterialConfiguration());
        } else {
            this.getRenderNode().setMaterial(null);
        }
    },

    onDispose: function () {
        this.transformFetcher && this.transformFetcher.clear();
    }, onConfigured: function () {
    }, getRenderNode: function () {
        if (!this.renderNode) {
            this.renderNode = this.createRenderNode ? this.createRenderNode() : null;
            this.updateLocalMatrix();
        }
        return this.renderNode;
    }, updateLocalMatrix: function () {
        this.transformFetcher && this.transformFetcher.update();
    }, onTransformChange: function (attrName, matrix) {
        if (attrName == "transform") {
            this.renderNode.setLocalMatrix(matrix);
        }

    },


    notifyChanged: function (evt) {
        if (evt.type == Events.VALUE_MODIFIED) {
            var target = evt.mutation.attributeName;
            if (target == "transform") {
                this.transformFetcher && this.transformFetcher.update();
            } else if (target == "style") {
                this.transformFetcher && this.transformFetcher.updateMatrix();
            } else if (target == "visible") {
                var newValue = evt.mutation.target.getAttribute("visible");
                this.renderNode.setLocalVisible(newValue && (newValue.toLowerCase() !== "false"));
                this.factory.renderer.requestRedraw("Transformable visibility changed.");
            } else if (target == "shader" && this.handleShader) {
                this.updateShaderHandler();
                this.factory.renderer.requestRedraw("Transformable shader changed.");
            }
        } else if (evt.type == Events.ADAPTER_HANDLE_CHANGED) {
            var key = evt.key;
            if (key == "shader") {
                this.updateShaderHandler();
                this.factory.renderer.requestRedraw("Shader reference changed.");
            }
        }
    }
});

function getShaderURI(node) {
    var shaderHref = node.shader;
    if (shaderHref == "") {
        var styleValue = node.getAttribute('style');
        if (styleValue) {
            var pattern = /shader\s*:\s*url\s*\(\s*(\S+)\s*\)/i;
            var result = pattern.exec(styleValue);
            if (result)
                shaderHref = result[1];
        }
    }
    return shaderHref;
}

module.exports = TransformableAdapter;

},{"../../../base/adapterhandle.js":8,"../../../data/transform-fetcher.js":28,"../../../interface/notification.js":36,"./base.js":40}],50:[function(require,module,exports){
var TransformableAdapter = require("./transformable.js");
var DOMTransformFetcher = require("../../../data/transform-fetcher.js");
var Events = require("../../../interface/notification.js");

var ViewRenderAdapter = function (factory, node) {
    TransformableAdapter.call(this, factory, node, false, false);
    this.perspectiveFetcher = new DOMTransformFetcher(this, "perspective", "perspective", true);
    this.createRenderNode();
};
XML3D.createClass(ViewRenderAdapter, TransformableAdapter);
var p = ViewRenderAdapter.prototype;

p.createRenderNode = function () {
    var parent = this.getParentRenderAdapter();
    var parentNode = parent.getRenderNode ? parent.getRenderNode() : this.factory.renderer.scene.createRootNode();

    this.renderNode = this.factory.renderer.scene.createRenderView({
        position: this.node.position._data,
        orientation: this.node.orientation.toMatrix()._data,
        fieldOfView: this.node.fieldOfView,
        parent: parentNode
    });
    this.perspectiveFetcher.update();
};

/* Interface method */
p.getViewMatrix = function () {
    var m = new window.XML3DMatrix();
    this.renderNode.getWorldToViewMatrix(m._data);
    return m;
};

/**
 * returns view2world matrix
 * @return {window.XML3DMatrix}
 */
p.getWorldMatrix = function () {
    var m = new window.XML3DMatrix();
    this.renderNode.getViewToWorldMatrix(m._data);
    return m;
};

p.notifyChanged = function (evt) {
    switch (evt.type) {
        case Events.THIS_REMOVED:
            this.dispose();
            break;
        case Events.VALUE_MODIFIED:
            var target = evt.mutation.attributeName;

            switch (target) {
                case "orientation":
                    this.renderNode.updateOrientation(this.node.orientation.toMatrix()._data);
                    break;
                case "position":
                    this.renderNode.updatePosition(this.node.position._data);
                    break;
                case "perspective":
                    this.perspectiveFetcher.update();
                    break;
                case "fieldOfView":
                    this.renderNode.updateFieldOfView(this.node.fieldOfView);
                    break;
                default:
                    XML3D.debug.logWarning("Unhandled value changed event in view adapter for attribute:" + target);
            }
            break;
    }
    this.factory.getRenderer().requestRedraw("View changed");
};

p.onTransformChange = function (attrName, matrix) {
    TransformableAdapter.prototype.onTransformChange.call(this, attrName, matrix);
    if (attrName == "perspective") {
        this.renderNode.setProjectionOverride(matrix);
    }
}

p.dispose = function () {
    this.perspectiveFetcher.clear();
    this.getRenderNode().remove();
    this.clearAdapterHandles();
}

// Export
module.exports = ViewRenderAdapter;


},{"../../../data/transform-fetcher.js":28,"../../../interface/notification.js":36,"./transformable.js":49}],51:[function(require,module,exports){
var RenderAdapter = require("./base.js");
var Utils = require("../utils.js");
var Events = require("../../../interface/notification.js");
var dispatchCustomEvent = require("../../../utils/misc.js").dispatchCustomEvent;
var getOrCreateActiveView = require("../../../utils/misc.js").getOrCreateActiveView;
var Resource = require("../../../base/resourcemanager.js").Resource;

var XML3DRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
    this.fireLoadEventAfterDraw = false;
    this.firstLoadFired = false;
};
XML3D.createClass(XML3DRenderAdapter, RenderAdapter);

XML3D.extend(XML3DRenderAdapter.prototype, {
    updateActiveViewAdapter: function () {
        var href = this.node.getAttribute("activeView");
        if (href) {
            this.connectAdapterHandle("activeView", this.getAdapterHandle(href));
        } else {
            this.disconnectAdapterHandle("activeView");
        }
    }, setViewAdapter: function (adapter) {
        adapter = adapter || this.getConnectedAdapter("activeView");
        if (!(adapter && adapter.getRenderNode)) {
            var viewElement = getOrCreateActiveView(this.node);
            adapter = this.factory.getAdapter(viewElement);
        }
        this.factory.getScene().setActiveView(adapter.getRenderNode());
    }, dispose: function () {
        this.clearAdapterHandles();
    }
});

XML3DRenderAdapter.prototype.notifyChanged = function (evt) {

    switch (evt.type) {
        case Events.ADAPTER_HANDLE_CHANGED:
            this.setViewAdapter(evt.adapter);
            return;
        case Events.NODE_INSERTED:
            // This also initializes the children
            this.initElement(evt.mutation.target);
            return;
        case Events.NODE_REMOVED:
            // Handled in removed node
            return;
    }

    var target = evt.mutation.attributeName;
    if (target && (target.toLowerCase() === "activeview")) {
        this.updateActiveViewAdapter();
        this.setViewAdapter();
    }
};

/* Interface methods */

/*
 * This function is called when scene DOM is loaded and all adapters are attached
 */
XML3DRenderAdapter.prototype.onConfigured = function () {
    this.updateActiveViewAdapter();
    this.setViewAdapter();

    // emit load event when all resources currently loading are completed
    var callback = this.onLoadComplete.bind(this);
    // register callback for canvasId == 0 i.e. global resources
    Resource.addLoadCompleteListener(0, callback);
    // register callback for canvasId of this node
    Resource.addLoadCompleteListener(this.factory.canvasId, callback);
    this.onLoadComplete();
};

XML3DRenderAdapter.prototype.onLoadComplete = function (canvasId) {
    if (Resource.isLoadComplete(0) && Resource.isLoadComplete(this.factory.canvasId)) {
        this.fireLoadEventAfterDraw = true;
    }
};

XML3DRenderAdapter.prototype.onFrameDrawn = function () {
    if (this.fireLoadEventAfterDraw) {
        this.fireLoadEventAfterDraw = false;
        this.firstLoadFired = true;
        dispatchCustomEvent(this.node, 'load', false, true, null);
    }
};


XML3DRenderAdapter.prototype.getComplete = function () {
    if (this.fireLoadEventAfterDraw) return false;
    if (!this.firstLoadFired) return false;
    return Resource.isLoadComplete(0) && Resource.isLoadComplete(this.factory.canvasId);
};

XML3DRenderAdapter.prototype.getWorldBoundingBox = function () {
    var bbox = new window.XML3DBox();
    Array.prototype.forEach.call(this.node.childNodes, function (c) {
        if (c.getWorldBoundingBox)
            bbox.extend(c.getWorldBoundingBox());
    });
    return bbox;
};
//XML3D element is the root with no transform of its own so by definition it's always in world space
XML3DRenderAdapter.prototype.getLocalBoundingBox = XML3DRenderAdapter.prototype.getWorldBoundingBox;

XML3DRenderAdapter.prototype.getElementByPoint = function (x, y, hitPoint, hitNormal) {
    var relativeMousePos = Utils.convertPageCoords(this.node, x, y);

    var relX = relativeMousePos.x;
    var relY = relativeMousePos.y;

    var renderer = this.factory.getRenderer();
    var object = renderer.getRenderObjectFromPickingBuffer(relX, relY);
    if (object) {
        if (hitPoint) {
            var vec = renderer.getWorldSpacePositionByPoint(relX, relY, object);
            hitPoint.set(vec[0], vec[1], vec[2]);
        }
        if (hitNormal) {
            var vec = renderer.getWorldSpaceNormalByPoint(relX, relY, object);
            hitNormal.set(vec[0], vec[1], vec[2]);
        }
    } else {
        if (hitPoint) hitPoint.set(NaN, NaN, NaN);
        if (hitNormal) hitNormal.set(NaN, NaN, NaN);
    }
    return object ? object.node : null;
};

XML3DRenderAdapter.prototype.getRenderInterface = function () {
    return this.factory.getRenderer().getRenderInterface();
};

XML3DRenderAdapter.prototype.generateRay = function (x, y) {
    var relativeMousePos = Utils.convertPageCoords(this.node, x, y);
    return this.factory.getRenderer().generateRay(relativeMousePos.x, relativeMousePos.y);
};

XML3DRenderAdapter.prototype.getElementByRay = (function () {
    var c_viewMat = XML3D.math.mat4.create();
    var c_projMat = XML3D.math.mat4.create();

    return function (xml3dRay, hitPoint, hitNormal) {
        var renderer = this.factory.getRenderer();
        renderer.calculateMatricesForRay(xml3dRay, c_viewMat, c_projMat);
        var hitObject = renderer.getRenderObjectByRay(xml3dRay, c_viewMat, c_projMat);
        if (hitObject !== null && (hitPoint || hitNormal)) {
            if (hitPoint) {
                var vec = renderer.getWorldSpacePositionByRay(xml3dRay, hitObject, c_viewMat, c_projMat);
                hitPoint.set(vec[0], vec[1], vec[2]);
            }
            if (hitNormal) {
                var vec = renderer.getWorldSpaceNormalByRay(xml3dRay, hitObject, c_viewMat, c_projMat);
                hitNormal.set(vec[0], vec[1], vec[2]);
            }
        } else {
            if (hitPoint) hitPoint.set(NaN, NaN, NaN);
            if (hitNormal) hitNormal.set(NaN, NaN, NaN);
        }
        return hitObject !== null ? hitObject.node : null;
    }
})();

module.exports = XML3DRenderAdapter;



},{"../../../base/resourcemanager.js":10,"../../../interface/notification.js":36,"../../../utils/misc.js":131,"../utils.js":72,"./base.js":40}],52:[function(require,module,exports){
var MouseEvents = require("./events/mouse.js");
var TouchEvents = require("./events/touch.js");

var c_globalCanvasId = 0;

/**
 * @param {Element} xml3dElement
 * @constructor
 */
function AbstractCanvasHandler(xml3dElement, canvas) {
    this._xml3dElement = xml3dElement;
    this._canvas = canvas;
    this.id = ++c_globalCanvasId; // global canvas id starts at 1

    this._mouseHandler = new MouseEvents.MouseEventHandler(xml3dElement, this);
    this._registerCanvasListeners(this._mouseHandler, MouseEvents.EVENTS);
    if(this.hasTouchEvents()) {
        this._touchHandler = new TouchEvents.TouchEventHandler(xml3dElement, this);
        this._registerCanvasListeners(this._touchHandler, TouchEvents.EVENTS);
    }
}

/**
 * @returns {boolean}
 */
AbstractCanvasHandler.prototype.hasTouchEvents = function() {
    return 'ontouchstart' in window;
};

AbstractCanvasHandler.prototype.getCanvas = function() {
   return this._canvas;
};

AbstractCanvasHandler.prototype.dispatchEvent = function(event) {
    this._xml3dElement.dispatchEvent(event);
};

AbstractCanvasHandler.prototype._registerCanvasListeners = function (handler, events) {
    var canvas = this._canvas;
    events.forEach(function (name) {
        canvas.addEventListener(name, function (e) {
            handler[name] && handler[name].call(handler, e);
            e.stopPropagation();
        });
    });
};

AbstractCanvasHandler.prototype.dispatchCustomEvent = function(type, detail) {
    detail = detail || null;
    var event = document.createEvent('CustomEvent');
    event.initCustomEvent(type, true, true, detail);
    this._xml3dElement.dispatchEvent(event);
};


/**
 * The update event can be used by user to sync actions
 * with rendering
 */
AbstractCanvasHandler.prototype.dispatchUpdateEvent = function () {
    this.dispatchCustomEvent("update");
};


AbstractCanvasHandler.prototype.dispatchResizeEvent = function (dimensions) {
    this.dispatchCustomEvent("resize", dimensions);
};

/**
 * Dispatches a FrameDrawnEvent to listeners
 *
 * @param start
 * @param end
 * @param stats
 * @return
 */
AbstractCanvasHandler.prototype.dispatchFrameDrawnEvent = function (start, end, stats) {
    stats = stats || {
        count: {
            primitives: 0, objects: 0
        }
    };
    var data = {
        timeStart: start, timeEnd: end, renderTimeInMilliseconds: end - start, count: stats.count
    };
    this.dispatchCustomEvent("framedrawn", data);
};

module.exports = AbstractCanvasHandler;

},{"./events/mouse.js":54,"./events/touch.js":55}],53:[function(require,module,exports){
var RenderAdapterFactory = require("./adapter/factory.js");
var xml3dFormatHandler = require("../../base/formathandler.js").xml3dFormatHandler;

xml3dFormatHandler.registerFactoryClass(RenderAdapterFactory);

var factory = require("./renderer-factory.js");

var configure = function(xml3ds) {
    if (!(xml3ds instanceof Array))
        xml3ds = [xml3ds];

    xml3ds.forEach(function(xml3dElement) {
        XML3D.debug.logDebug("Configuring Renderer for", xml3dElement.id);
        var renderer = factory.createRenderer(xml3dElement)

    });
};

module.exports = configure;
},{"../../base/formathandler.js":9,"./adapter/factory.js":42,"./renderer-factory.js":58}],54:[function(require,module,exports){
var Options = require("../../../utils/options.js");

var OPTION_MOUSEMOVE_PICKING = "renderer-mousemove-picking";
var OPTION_MOVEMENT_AWARE_CLICK_HANDLER = "renderer-movement-aware-click-handler";
Options.register(OPTION_MOUSEMOVE_PICKING, true);
Options.register(OPTION_MOVEMENT_AWARE_CLICK_HANDLER, false);

var EVENTS = ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mousemove", "mouseout", "wheel"];

/**
 *
 * @param {Element} defaultTarget
 * @param {AbstractCanvasHandler} canvasHandler
 * @constructor
 */
var MouseEventHandler = function(defaultTarget, canvasHandler) {
    this._defaultTarget = defaultTarget;
    this._canvasHandler = canvasHandler;
    this._lastMousePosition =  {x: 0, y: 0};
};

var supportsEventConstructors = (function() {
    try {
        new MouseEvent("click", {});
        return true;
    } catch (e){
        return false;
    }
})();

MouseEventHandler.prototype =  {

    /**
     * @param {MouseEvent} event  The original event
     * @param {Element} target  target to dispatch on
     * @param {object?}     opt    Options
     */
    dispatchMouseEvent: function (event, target, opt) {
        opt = opt || {};
        target = target || this._defaultTarget;
        var x = opt.x !== undefined ? opt.x : event.clientX;
        var y = opt.y !== undefined ? opt.y : event.clientY;
        var noCopy = opt.noCopy || false;
        // Copy event to avoid DOM dispatch errors (cannot dispatch event more
        // than once)
        if (!noCopy) {
            event = this.copyMouseEvent(event);
        }
        this.initExtendedMouseEvent(event, x, y);

        target.dispatchEvent(event);
    },

    /**
     * @param {MouseEvent|WheelEvent} event the event to copy
     * @return {MouseEvent} the new event
     */
    copyMouseEvent: function (event) {
        var evt;
        if (supportsEventConstructors) {
            if (event.toString() === "[object WheelEvent]") {
                evt = new WheelEvent(event.type, event);
            } else {
                evt = new MouseEvent(event.type, event);
            }
        } else {
            //These event APIs are deprecated but still required by IE, which doesn't support event constructors yet
            if (event.toString() === "[object WheelEvent]") {
                evt = document.createEvent("WheelEvent");
                evt.initWheelEvent(event.type, event.bubbles, event.cancelable, event.view, event.detail,
                    event.screenX, event.screenY, event.clientX, event.clientY, event.button, event.relatedTarget, "",
                    event.deltaX, event.deltaY, event.deltaZ, event.deltaMode);
            } else {
                evt = document.createEvent("MouseEvent");
                evt.initMouseEvent(event.type, event.bubbles, event.cancelable, event.view, event.detail,
                    event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey,
                    event.shiftKey, event.metaKey, event.button, event.relatedTarget);
            }
        }
        if (event.dataTransfer)
            evt.data = {url: event.dataTransfer.getData("URL"), text: event.dataTransfer.getData("Text")};
        // override preventDefault to actually prevent the default of the original event
        evt.preventDefault = function () {
            event.preventDefault();
        };
        return evt;
    },

    createMouseEvent: function (type, opts) {
        opts = opts || {};
        var dict = {
            bubbles		: opts.bubbles !== undefined ? opts.bubbles : true,
            cancelable 	: opts.cancelable !== undefined ? opts.cancelable : true,
            view 		: opts.view || window,
            detail 		: opts.detail !== undefined ? opts.detail : 0,
            screenX		: opts.screenX !== undefined ? opts.screenX : 0,
            screenY		: opts.screenY !== undefined ? opts.screenY : 0,
            clientX		: opts.clientX !== undefined ? opts.clientX : 0,
            clientY		: opts.clientY !== undefined ? opts.clientY : 0,
            ctrl 		: opts.ctrl !== undefined ? opts.ctrl : false,
            alt 		: opts.alt !== undefined ? opts.alt : false,
            shift 		: opts.shift !== undefined ? opts.shift : false,
            meta 		: opts.meta !== undefined ? opts.meta : false,
            button 		: opts.button !== undefined ? opts.button : 0,
            relatedTarget : opts.relatedTarget
        };
        if (supportsEventConstructors) {
            return new MouseEvent(type, dict);
        } else {
            var evt = document.createEvent("MouseEvent");
            evt.initMouseEvent(type, dict.bubbles, dict.cancelable, dict.view, dict.detail,
                dict.screenX, dict.screenY, dict.clientX, dict.clientY, dict.ctrlKey, dict.altKey,
                dict.shiftKey, dict.metaKey, dict.button, dict.relatedTarget);
            return evt;
        }
    },

    /**
     * Adds position and normal attributes to the given event.
     *
     * @param {Event} event
     * @param {number} x
     * @param {number} y
     * @return {XML3DVec3}
     */
    initExtendedMouseEvent: function (event, x, y) {
        var handler = this._canvasHandler;

        (function () {
            var cachedPosition = undefined;
            var cachedNormal = undefined;

            event.__defineGetter__("normal", function () {
                if (cachedNormal !== undefined) return cachedNormal;
                var norm = (handler.getWorldSpaceNormalByPoint(x, y));
                cachedNormal = norm ? new window.XML3DVec3(norm[0], norm[1], norm[2]) : null;
                return cachedNormal;
            });
            event.__defineGetter__("position", function () {
                if (!cachedPosition) {
                    var pos = handler.getWorldSpacePositionByPoint(x, y);
                    cachedPosition = pos ? new window.XML3DVec3(pos[0], pos[1], pos[2]) : null;
                }
                return cachedPosition;
            });
        })();
    },

    /**
     * @param {MouseEvent} evt
     * @param {object?} opt
     */
    dispatchMouseEventOnPickedObject: function (evt, opt) {
        opt = opt || {};
        var pos = this.getMousePosition(evt);

        var picked = null;
        if (!opt.omitUpdate)
            picked = this._canvasHandler.getPickObjectByPoint(pos.x, pos.y);

        this.dispatchMouseEvent(evt, picked && picked.node, pos);
    },

    getMousePosition: function (evt) {
        return this._canvasHandler.getMousePosition(evt)
    },


    /**
     * @param {MouseEvent} evt
     */
    mouseup: function (evt) {
        this.dispatchMouseEventOnPickedObject(evt);
    },

    /**
     * @param {MouseEvent} evt
     */
    mousedown: function (evt) {
        this._lastMousePosition = this.getMousePosition(evt);
        this.dispatchMouseEventOnPickedObject(evt);
    },


    /**
     * @param {MouseEvent} evt
     */
    click: function (evt) {
        if (Options.getValue("renderer-movement-aware-click-handler") === true) {
            var pos = this.getMousePosition(evt);
            if (Math.abs(pos.x - this._lastMousePosition.x) > 4 || Math.abs(pos.y - this._lastMousePosition.y) > 4)
                return;
        }
        this.dispatchMouseEventOnPickedObject(evt);
    },

    /**
     * @param {MouseEvent} evt
     */
    dblclick: function (evt) {
        this.dispatchMouseEventOnPickedObject(evt);
    },

    /**
     * This method is called each time a mouseMove event is triggered on the
     * canvas.
     *
     * This method also triggers mouseover and mouseout events of objects in the
     * scene.
     *
     * @param {MouseEvent} evt
     */
    mousemove: function (evt) {
        var pos = this.getMousePosition(evt);

        var doMouseMovePick = Options.getValue(OPTION_MOUSEMOVE_PICKING);

        this.dispatchMouseEventOnPickedObject(evt, {omitUpdate: !doMouseMovePick});
        if (!doMouseMovePick)
            return;

        var curObj = this._canvasHandler.getPickedObject();

        // trigger mouseover and mouseout
        if (curObj !== this.lastPickObj) {
            if (this.lastPickObj) {
                // The mouse has left the last object
                this.dispatchMouseEvent(this.createMouseEvent("mouseout", {
                    clientX: pos.x, clientY: pos.y, button: evt.button
                }), this.lastPickObj);
                if (!curObj) { // Nothing picked, this means we enter the xml3d canvas
                    this.dispatchMouseEvent(this.createMouseEvent("mouseover", {
                        clientX: pos.x, clientY: pos.y, button: evt.button
                    }), this._defaultTarget);
                }
            }
            if (curObj) {
                // The mouse is now over a different object, so call the new
                // object's mouseover method
                this.dispatchMouseEvent(this.createMouseEvent("mouseover", {
                    clientX: pos.x, clientY: pos.y, button: evt.button
                }), curObj);
                if (!this.lastPickObj) { // Nothing was picked before, this means we leave the xml3d canvas
                    this.dispatchMouseEvent(this.createMouseEvent("mouseout", {
                        clientX: pos.x, clientY: pos.y, button: evt.button
                    }), this._defaultTarget);
                }
            }

            this.lastPickObj = curObj;
        }
    },

    /**
     * @param {MouseEvent} evt
     */
    mouseout: function (evt) {
        var pos = this.getMousePosition(evt);
        this.dispatchMouseEvent(evt, this.lastPickObj, pos);
    },

    /**
     * @param {MouseEvent} evt
     */
    mouseover: function (evt) {
        var doMouseMovePick = Options.getValue(OPTION_MOUSEMOVE_PICKING);
        this.dispatchMouseEventOnPickedObject(evt, {omitUpdate: !doMouseMovePick});
    },

    /**
     * @param {WheelEvent} evt
     */
    wheel: function (evt) {
        this.dispatchMouseEventOnPickedObject(evt, { type: "wheel" });
    }


};

module.exports = {
    EVENTS: EVENTS, MouseEventHandler: MouseEventHandler
};

},{"../../../utils/options.js":132}],55:[function(require,module,exports){
/**
 *
 * @param {Element} defaultTarget
 * @param {AbstractCanvasHandler} canvasHandler
 * @constructor
 */
var TouchEventHandler = function (defaultTarget, canvasHandler) {
    this._defaultTarget = defaultTarget;
    this._canvasHandler = canvasHandler;
};


var EVENTS = ["touchstart", "touchmove", "touchend", "touchcancel"];

TouchEventHandler.prototype = {

    copyTouchEvent: function (event, options) {
        var touchEventData = this.copyTouchEventData(event, options);
        return this.createTouchEvent(touchEventData);
    },


    copyTouchEventData: function (event, options) {
        return {
            type: options.type || event.type,
            timeStamp: Date.now(),
            bubbles: event.bubbles,
            cancelable: event.cancelable,
            detail: event.detail,
            screenX: event.screenX,
            screenY: event.screenY,
            pageX: event.pageX,
            pageY: event.pageY,
            clientX: event.clientX,
            clientY: event.clientY,
            ctrlKey: event.ctrlKey,
            altKey: event.altKey,
            shiftKey: event.shiftKey,
            metaKey: event.metaKey,
            scale: event.scale,
            rotation: event.rotation,
            view: event.view,
            touches: event.touches,
            changedTouches: event.changedTouches,
            targetTouches: event.targetTouches
        };
    },

    createTouchEvent: function (data) {
        var touchEvent;

        try {
            touchEvent = document.createEvent('TouchEvent');
        } catch (e) {
            XML3D.debug.logWarning("Create Touch Event failed, creating UI instead");
            touchEvent = document.createEvent('UIEvent');
        }

        if (touchEvent && touchEvent.initTouchEvent) {
            if (touchEvent.initTouchEvent.length == 0) { //chrome
                touchEvent.initTouchEvent(data.touches, data.targetTouches, data.changedTouches, data.type, data.view, data.screenX, data.screenY, data.clientX, data.clientY);
            } else if (touchEvent.initTouchEvent.length == 12) { //firefox
                touchEvent.initTouchEvent(data.type, data.bubbles, data.cancelable, data.view, data.detail, data.ctrlKey, data.altKey, data.shiftKey, data.metaKey, data.touches, data.targetTouches, data.changedTouches);
            } else { //iOS length = 18
                touchEvent.initTouchEvent(data.type, data.bubbles, data.cancelable, data.view, data.detail, data.screenX, data.screenY, data.pageX, data.pageY, data.ctrlKey, data.altKey, data.shiftKey, data.metaKey, data.touches, data.targetTouches, data.changedTouches, data.scale, data.rotation);
            }
        }
        return touchEvent;
    },

    /**
     * @param {Event} evt
     * @param {object?} opt
     */
    dispatchTouchEventOnPickedObject: function (evt, opt) {
        opt = opt || {};
        var touchEvent = this.copyTouchEvent(evt, opt);
        touchEvent.preventDefault = function () {
            evt.preventDefault();
        };
        this._defaultTarget.dispatchEvent(touchEvent);
    },

    touchstart: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    },

    touchend: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    },

    touchmove: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    },

    touchcancel: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    }

};


module.exports = {
    EVENTS: EVENTS, TouchEventHandler: TouchEventHandler
};

},{}],56:[function(require,module,exports){
function LightManager() {
    this._lights = [];
    this._models = {};

    /**
     * Updating light parameters can lead to updating the (lazy) scene structure, which
     * in turn updates the lights. If we are in updating the lights, flag is set to true.
     * @type {boolean}
     * @private
     */
    this._inUpdate = false;
}

LightManager.prototype = {
    add: function (light) {
        this._lights.push(light);
        this._addModel(light.model);
    },

    remove: function (light) {
        var index = this._lights.indexOf(light);
        if (index != -1) {
            this._lights.splice(index, 1);
        }
        this._removeModel(light.model);
    },

    fillGlobalParameters: function (globals, force) {
        for (var id in this._models) {
            var entry = this._models[id];
            /* Fill globals only if this was not already done before */
            if (entry.changed || force) {
                var prefix = id + "Light";
                for (var param in entry.parameters) {
                    var name = prefix + param.charAt(0).toUpperCase() + param.slice(1);
                    globals[name] = entry.parameters[param];
                }
                entry.changed = false;
            }
        }
    },

    lightValueChanged: function (light) {
        if (this._inUpdate)
            return;
        this._inUpdate = true;

        var lights = light ? [light] : this._lights;
        var that = this;

        lights.forEach(function(light) {
            var model = light.model;
            var entry = that.getModelEntry(model.id);
            var offset = entry.lightModels.indexOf(model);
            if (offset < 0) {
                //These changes are for a light that no longer exists so we can ignore them
                //This can happen for ex. during a delayed change notification that isn't fired until after a remove()
                return;
            }
            model.fillLightParameters(entry.parameters, offset);
            model.getLightData(entry.parameters, offset);
            entry.changed = true;
        });
        this._inUpdate = false;
    },

    getModelEntry: function (id) {
        return this._models[id];
    },

    getModels: function (id) {
        return Object.keys(this._models);
    },

    getModelCount: function (id) {
        var model = this.getModelEntry(id);
        return model ? model.lightModels.length : 0;
    },

    _addModel: function (model) {
        var entry = this._models[model.id];
        if (!entry) {
            entry = this._models[model.id] = {lightModels: [], parameters: {}};
        }
        entry.lightModels.push(model);
        this._lightStructureChanged(entry);
    },

    _removeModel: function (model) {
        var entry = this.getModelEntry(model.id);
        var index = entry.lightModels.indexOf(model);
        if (index != -1) {
            entry.lightModels.splice(index, 1);
        }
        this._lightStructureChanged(entry);
    },

    _lightStructureChanged: function (entry) {
        this._inUpdate = true;
        var length = entry.lightModels.length;
        if (!length) {
            entry.parameters = {};
            return;
        }
        var model = entry.lightModels[0];
        entry.parameters = model.allocateParameterArray(length);
        entry.lightModels.forEach(function (lightModel, offset) {
            lightModel.fillLightParameters(entry.parameters, offset)
            lightModel.getLightData(entry.parameters, offset);
        });
        entry.changed = true;
        this._inUpdate = false;

    }
};

module.exports = LightManager;

},{}],57:[function(require,module,exports){
var Frustum = require("../tools/frustum.js").Frustum;
var XC = require("../../../xflow/interface/constants.js");
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var InputNode = require("../../../xflow/interface/graph.js").InputNode;
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;

var PointLightData = {
    "intensity": {type: XC.DATA_TYPE.FLOAT3, 'default': [1, 1, 1]},
    "attenuation": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 1]},
    "position": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 0]},
    "shadowBias": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0001]},
    "direction": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, -1]},
    "castShadow": {type: XC.DATA_TYPE.BOOL, 'default': [false]},
    "on": {type: XC.DATA_TYPE.BOOL, 'default': [true]},
    "matrix": {type: XC.DATA_TYPE.FLOAT4X4, 'default': [1, 0, 0, 0,   0, 1, 0, 0,    0, 0, 1, 0,  0, 0, 0, 1]},
    "nearFar": {type: XC.DATA_TYPE.FLOAT2, 'default': [1.0, 100.0]}
};

var SpotLightData = {
    "intensity": {type: XC.DATA_TYPE.FLOAT3, 'default': [1, 1, 1]},
    "attenuation": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 1]},
    "position": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 0]},
    "direction": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, -1]},
    "falloffAngle": {type: XC.DATA_TYPE.FLOAT, 'default': [Math.PI / 4]},
    "softness": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0]},
    "shadowBias": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0001]},
    "castShadow": {type: XC.DATA_TYPE.BOOL, 'default': [false]},
    "matrix": {type: XC.DATA_TYPE.FLOAT4X4, 'default': [1, 0, 0, 0,   0, 1, 0, 0,    0, 0, 1, 0,  0, 0, 0, 1]},
    "on": {type: XC.DATA_TYPE.BOOL, 'default': [true]}
};

var DirectionalLightData = {
    "intensity": {type: XC.DATA_TYPE.FLOAT3, 'default': [1, 1, 1]},
    "direction": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, -1]},
    "shadowBias": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0001]},
    "position": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 0]},
    "castShadow": {type: XC.DATA_TYPE.BOOL, 'default': [false]},
    "on": {type: XC.DATA_TYPE.BOOL, 'default': [true]},
    "matrix": {type: XC.DATA_TYPE.FLOAT4X4, 'default': [1, 0, 0, 0,   0, 1, 0, 0,    0, 0, 1, 0,  0, 0, 0, 1]}
};


function createXflowData(config) {
    var data = new DataNode();
    for (var name in config) {
        var entry = config[name];
        createXflowValue(data, name, entry.type, entry['default']);
    }
    return data;
}

function createXflowValue(dataNode, name, type, value) {
    var buffer = new BufferEntry(type, new XC.TYPED_ARRAY_MAP[type](value));
    var inputNode = new InputNode();
    inputNode.data = buffer;
    inputNode.name = name;
    dataNode.appendChild(inputNode);
}

/**
 * Base class for light models
 * @param {string} id Unique id that identifies the light model
 * @param {RenderLight} light
 * @param {DataNode} dataNode
 * @param {Object} config Configuration that contains the light model's parameters and default values
 * @constructor
 */
var LightModel = function (id, light, dataNode, config) {
    this.id = id;
    this.light = light;
    this.dataNode = dataNode;
    this.configuration = config;
    this.parameters = Object.keys(config);
    /**
     * If the light has not data, just use the default parameters
     */
    if (dataNode) {
        dataNode.insertBefore(createXflowData(config), null);
    } else {
        dataNode = createXflowData(config);
    }

    // Horizontal opening angle of the light camera. Derived from falloffAngle in case of spot light
    this.fovy =  Math.PI/2.0;

    this.lightParameterRequest = new ComputeRequest(dataNode, this.parameters, this.lightParametersChanged.bind(this));
    this.lightParametersChanged(this.lightParameterRequest, null);
};

LightModel.prototype = {
    /**
     * Copies the light parameters in an array of the same size
     * @param {Object} target Name to typed array map containing the data
     * @param {number} offset Slot in the array to be filled
     */
    fillLightParameters: function (target, offset) {
        var result = this.lightParameterRequest.getResult();
        this.parameters.forEach(function (name) {
            var entry = result.getOutputData(name);
            var size = XC.DATA_TYPE_TUPLE_SIZE[entry.type];
            var value = entry.getValue();
            target[name].set(value.subarray(0, size), offset * size);
        });
        this.transformParameters(target, offset);
    },

    allocateParameterArray: function (size) {
        var parameterArrays = {};
        var config = this.configuration;
        this.parameters.forEach(function (name) {
            var type = config[name].type;
            var tupleSize = XC.DATA_TYPE_TUPLE_SIZE[type];
            parameterArrays[name] = new XC.TYPED_ARRAY_MAP[type](tupleSize * size);
        });
        return parameterArrays;
    },

    getParameter: function(name) {
        if(name in this.configuration) {
            // No other checks required because parameters are always defined
            return this.lightParameterRequest.getResult().getOutputData(name).getValue();
        }
        return null;
    },

    lightParametersChanged: function (request, changeType) {
        if (changeType) {
            this.light.lightValueChanged();
        }
    },

    _expandNearFar:function(nfobject){
        var expand = Math.max((nfobject.far - nfobject.near) * 0.30, 0.05);
        nfobject.near -= expand;
        nfobject.far  += expand;
    },

    getLightData: function (target, offset) {
        var matrix = target["matrix"].subarray(offset * 16, offset * 16 + 16);
        this.getLightViewProjectionMatrix(matrix);
    },

    getLightViewProjectionMatrix: function (target) {
        var LVM = XML3D.math.mat4.create();
        var LPM = XML3D.math.mat4.create();
        this.getLightViewMatrix(LVM);
        this.getLightProjectionMatrix(LPM);
        XML3D.math.mat4.multiply(target, LPM, LVM);
    },

    getLightProjectionMatrix: function (target) {
        this.light.getFrustum(1).getProjectionMatrix(target);
    },

    getLightViewMatrix: function (mat4) {
        var p_dir = this.getParameter("direction");
        var p_pos = this.getParameter("position");

        // Get the world matrix from the light in the transformation hierarchy
        // world => light
        this.light.getWorldMatrix(mat4);

        // Derive rotation from the direction and standard direction (-z => no rotation)
        var q_rot = XML3D.math.quat.rotationTo(XML3D.math.quat.create(),c_standardDirection, p_dir);
        // Create matrix from rotation and translation
        var trans = XML3D.math.mat4.fromRotationTranslation(XML3D.math.mat4.create(), q_rot, p_pos);
        // Add to world matrix
        XML3D.math.mat4.mul(mat4, mat4, trans);

        // Invert:  light => world
        XML3D.math.mat4.invert(mat4, mat4);
    }

};

var c_tmpWorldMatrix = XML3D.math.mat4.create();
var c_standardDirection = XML3D.math.vec3.fromValues(0,0,-1);


function transformPose(light, position, direction) {
    light.getWorldMatrix(c_tmpWorldMatrix);
    if (position) {
        XML3D.math.vec3.transformMat4(position, position, c_tmpWorldMatrix);
    }
    if (direction) {
        XML3D.math.vec3.transformDirection(direction, direction, c_tmpWorldMatrix);
        XML3D.math.vec3.normalize(direction, direction);
    }
}

function transformDefault(target, offset, light) {
    var color = target["intensity"].subarray(offset * 3, offset * 3 + 3);
    XML3D.math.vec3.scale(color, color, light.localIntensity);
    target["on"][offset] = light.visible;
}


/**
 * Implement XML3D's predefined point light model urn:xml3d:lightshader:point
 * @param {DataNode} dataNode
 * @param {RenderLight} light
 * @extends LightModel
 * @constructor
 */
var PointLightModel = function (dataNode, light) {
    LightModel.call(this, "point", light, dataNode, PointLightData);
};

XML3D.createClass(PointLightModel, LightModel, {
    getFrustum: function (aspect, sceneBoundingBox) {
        var orthogonal = false;
        var entry = this.light.scene.lights.getModelEntry(this.id);

        if (XML3D.math.bbox.isEmpty(sceneBoundingBox)) {
            entry.parameters["nearFar"][0] = 1.0;
            entry.parameters["nearFar"][1] = 110.0;
            return new Frustum(1.0, 110.0, 0, this.fovy, aspect, orthogonal)
        }


        var t_mat = XML3D.math.mat4.create();
        this.getLightViewMatrix(t_mat);
        XML3D.math.bbox.transform(sceneBoundingBox, t_mat, sceneBoundingBox);

        var nf = {
            near: -sceneBoundingBox[5], far: -sceneBoundingBox[2]
        };
        // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
        this._expandNearFar(nf);

        entry.parameters["nearFar"][0] = 1.0;
        entry.parameters["nearFar"][1] = nf.far;

        return new Frustum(1.0, nf.far, 0, this.fovy, aspect, orthogonal);
    },

    transformParameters: function (target, offset) {
        var position = target["position"].subarray(offset * 3, offset * 3 + 3);
        transformPose(this.light, position, null);
        transformDefault(target, offset, this.light);
    }
});




/**
 * Implement XML3D's predefined spot light model urn:xml3d:lightshader:spot
 * @param {DataNode} dataNode
 * @param {RenderLight} light
 * @extends LightModel
 * @constructor
 */
var SpotLightModel = function (dataNode, light) {
    LightModel.call(this, "spot", light, dataNode, SpotLightData);
};


XML3D.createClass(SpotLightModel, LightModel, {
    getFrustum: function (aspect, sceneBoundingBox) {

        if (XML3D.math.bbox.isEmpty(sceneBoundingBox)) {
            return new Frustum(1.0, 110.0, 0, this.fovy, aspect, false)
        }


        var t_mat = XML3D.math.mat4.create();
        this.getLightViewMatrix(t_mat);
        XML3D.math.bbox.transform(sceneBoundingBox, t_mat, sceneBoundingBox);

        var nf = {
            near: -sceneBoundingBox[5], far: -sceneBoundingBox[2]
        };
        // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
        this._expandNearFar(nf);

        return new Frustum(1.0, nf.far, 0, this.fovy, aspect, false);
    },

    transformParameters: function (target, offset) {
        var position = target["position"].subarray(offset * 3, offset * 3 + 3);
        var direction = target["direction"].subarray(offset * 3, offset * 3 + 3);
        // Transform position and direction from object to world space
        transformPose(this.light, position, direction);
        transformDefault(target, offset, this.light);
    },

    lightParametersChanged: function (request, changeType) {
        this.fovy = this.getParameter("falloffAngle")[0] * 2;
        LightModel.prototype.lightParametersChanged.call(this, request, changeType);
    }
});




/**
 * Implement XML3D's predefined spot light model urn:xml3d:lightshader:directional
 * @param {DataNode} dataNode
 * @param {RenderLight} light
 * @extends LightModel
 * @constructor
 */
var DirectionalLightModel = function (dataNode, light) {
    LightModel.call(this, "directional", light, dataNode, DirectionalLightData);
};

XML3D.createClass(DirectionalLightModel, LightModel, {
    getFrustum: function(aspect, sceneBoundingBox) {
        var orthogonal = true;

        if (XML3D.math.bbox.isEmpty(sceneBoundingBox)) {
            return new Frustum(1.0, 110.0, 0, this.fovy, aspect, orthogonal)
        }

        var t_mat = XML3D.math.mat4.create();
        this.getLightViewMatrix(t_mat);
        XML3D.math.bbox.transform(sceneBoundingBox, t_mat, sceneBoundingBox);

        var nf = {  near: -sceneBoundingBox[5],
                    far:  -sceneBoundingBox[2]};
        // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
        this._expandNearFar(nf);

        return new Frustum(1.0, nf.far, 0, this.fovy, aspect, orthogonal);
    },

    transformParameters: function (target, offset) {
        var direction = target["direction"].subarray(offset * 3, offset * 3 + 3);
        transformPose(this.light, null, direction);
        transformDefault(target, offset, this.light);
    },



    getLightViewMatrix: function (mat4) {
        var manager = this.light.scene.lights;
        var entry = manager.getModelEntry(this.id);
        var p_dir = entry.parameters["direction"];
        var p_pos = entry.parameters["position"];

        var bb = new XML3D.math.bbox.create();
        this.light.scene.getBoundingBox(bb);
        var bbSize = XML3D.math.vec3.create();
        var bbCenter = XML3D.math.vec3.create();
        var off = XML3D.math.vec3.create();
        XML3D.math.bbox.center(bbCenter, bb);
        XML3D.math.bbox.size(bbSize, bb);
        var d = XML3D.math.vec3.len(bbSize); //diameter of bounding sphere of the scene
        XML3D.math.vec3.scale(off, p_dir, -0.55 * d); //enlarge a bit on the radius of the scene
        p_pos = XML3D.math.vec3.add(p_pos, bbCenter, off);
        entry.parameters["position"] = p_pos;


        //create new transformation matrix depending on the updated parameters
        XML3D.math.mat4.identity(mat4);
        var lookat_mat = XML3D.math.mat4.create();
        var top_vec = XML3D.math.vec3.fromValues(0.0, 1.0, 0.0);
        if ((p_dir[0] == 0.0) && (p_dir[2] == 0.0)) //check if top_vec colinear with direction
            top_vec = XML3D.math.vec3.fromValues(0.0, 0.0, 1.0);
        var up_vec = XML3D.math.vec3.create();
        var dir_len = XML3D.math.vec3.len(p_dir);
        XML3D.math.vec3.scale(up_vec, p_dir, -XML3D.math.vec3.dot(top_vec, p_dir) / (dir_len * dir_len));
        XML3D.math.vec3.add(up_vec, up_vec, top_vec);
        XML3D.math.vec3.normalize(up_vec, up_vec);
        XML3D.math.mat4.lookAt(lookat_mat, XML3D.math.vec3.fromValues(0.0, 0.0, 0.0), p_dir, up_vec);
        XML3D.math.mat4.invert(lookat_mat, lookat_mat);
        XML3D.math.mat4.translate(mat4, mat4, p_pos);
        XML3D.math.mat4.multiply(mat4, mat4, lookat_mat);

        var bb = new XML3D.math.bbox.create();
        this.light.scene.getBoundingBox(bb);
        XML3D.math.bbox.transform(bb, mat4, bb);
        var bbSize = XML3D.math.vec3.create();
        XML3D.math.bbox.size(bbSize, bb);
        var max = (bbSize[0] > bbSize[1]) ? bbSize[0] : bbSize[1];
        max = 0.55 * (max);//enlarge 10percent to make sure nothing gets cut off
        this.fovy = Math.atan(max)*2.0;

        entry.parameters["direction"] = p_dir;
        entry.parameters["position"]  = p_pos;

        XML3D.math.mat4.invert(mat4, mat4);
    }

});

module.exports = {
    PointLightModel: PointLightModel, SpotLightModel: SpotLightModel, DirectionalLightModel: DirectionalLightModel

};

},{"../../../xflow/interface/constants.js":136,"../../../xflow/interface/data.js":137,"../../../xflow/interface/graph.js":138,"../../../xflow/interface/request.js":139,"../tools/frustum.js":70}],58:[function(require,module,exports){
var GLRenderer = require("../webgl/renderer.js");
var GLCanvasHandler = require("../webgl/canvas-handler.js");

var RendererFactory = function () {
    this.createRenderer = function (xml3dElement) {
        var canvas = xml3dElement._configured.canvas;
        var canvasHandler = new GLCanvasHandler(xml3dElement, canvas);
        var renderer = new GLRenderer(xml3dElement, canvasHandler);
        canvasHandler.setRenderer(renderer);
        window.requestAnimationFrame(canvasHandler.tick);
        return renderer;
    }
};
module.exports = new RendererFactory();








},{"../webgl/canvas-handler.js":80,"../webgl/renderer.js":112}],59:[function(require,module,exports){
module.exports = {
    NODE_TYPE: {
        GROUP: "group", OBJECT: "object", LIGHT: "light", VIEW: "view"
    },

    EVENT_TYPE: {
        VIEW_CHANGED: "view_changed",
        LIGHT_STRUCTURE_CHANGED: "light_structure_changed",
        LIGHT_VALUE_CHANGED: "light_value_changed",
        SCENE_SHAPE_CHANGED: "scene_shape_changed",
        SCENE_STRUCTURE_CHANGED: "scene_structure_changed",
        DRAWABLE_STATE_CHANGED: "drawable_state_changed"

    }
};

},{}],60:[function(require,module,exports){
var EventDispatcher = require("../../../contrib/EventDispatcher.js");

var DrawableClosure = function (context, type) {
    this.context = context;
    this._type = type;
    this._valid = false;
};

DrawableClosure.TYPES = {
    MESH: "mesh", VOLUME: "volume"
};

DrawableClosure.READY_STATE = {
    COMPLETE: "complete", INCOMPLETE: "incomplete"
};

XML3D.createClass(DrawableClosure, EventDispatcher, {
    getType: function () {
        return this._type;
    }, isValid: function () {
        return this._valid;
    }, setShaderComposer: function (shaderComposer) {
        // implemented by subclass
    }, update: function (scene) {
        // implemented by subclass
    }
});

module.exports = DrawableClosure;


},{"../../../contrib/EventDispatcher.js":11}],61:[function(require,module,exports){
var uniqueObjectId = require("../../webgl/base/utils.js").getUniqueCounter();
/**
 * Connects a material model with a set of default parameters defined by
 * an Xflow DataNode. The MaterialConfiguration is immutable
 *
 * @param model The material model
 * @param {Xflow.DataNode} dataNode  The material parameters of this node
 * @param {{}} opt
 * @constructor
 */
var MaterialConfiguration = function(model, dataNode, opt) {
    opt = opt || {};

    this.id = uniqueObjectId();

    /**
     * @type {{type: string}}
     */
    this.model = model;

    /**
     * Data Node of the renderObject
     * @type {Xflow.DataNode}
     */
    this.dataNode = dataNode;

    /**
     * A name for debug purposes
     * @type {string|null}
     */
    this.name = opt.name || null;
};

module.exports = MaterialConfiguration;

},{"../../webgl/base/utils.js":79}],62:[function(require,module,exports){
var EventDispatcher = require("../../../contrib/EventDispatcher.js");

/**
 * @extends {EventDispatcher}
 * @constructor
 */
var Pager = function () {
    /** @type Array<Float32Array> */
    this.pages = [];
    /** @type number */
    this.nextOffset = 0;
    /** @type Array<*> */
    this.freeEntries = [];
    // Add a first page
    this.addPage();
};

XML3D.createClass(Pager, EventDispatcher, {
    addPage: function () {
        var page = new Float32Array(Pager.PAGE_SIZE);
        this.pages.push(page);
        this.nextOffset = 0;
        XML3D.debug.logInfo("Adding page", this.pages.length, "(", Pager.PAGE_SIZE * Float32Array.BYTES_PER_ELEMENT * this.pages.length / 1024, "kB)");
    },

    getPageEntry: function (size) {
        if (!size)
            throw new Error("No size given for page entry");
        return this.reusePageEntry(size) || this.createPageEntry(size);
    },

    /**
     * @param {number} size Requested size in number of floats
     * @returns {{ page: Float32Array, offset: number, size: number }}
     */
    reusePageEntry: function (size) {
        var sameSizeEntries = this.freeEntries[size];
        if (sameSizeEntries && sameSizeEntries.length) {
            return sameSizeEntries.pop();
        }
        return null;
    },

    /**
     * @param {number} size  Size in number of floats
     * @returns {{ page: Float32Array, offset: number, size: number }}
     */
    createPageEntry: function (size) {
        if (this.nextOffset + size > Pager.PAGE_SIZE) {
            this.addPage();
            return this.getPageEntry(size);
        }
        var page = this.pages[this.pages.length - 1];
        var localOffset = this.nextOffset;
        this.nextOffset += size;
        return {page: page, offset: localOffset, size: size};
    },

    /**
     *
     * @param {{ page: Float32Array, offset: number, size: number }} entryInfo
     */
    freePageEntry: function (entryInfo) {
        var sameSizeEntries = this.freeEntries[entryInfo.size];
        if (!sameSizeEntries) {
            sameSizeEntries = this.freeEntries[entryInfo.size] = [];
        }
        sameSizeEntries.push(entryInfo);
    }
});
Pager.PAGE_SIZE = 1 << 12;

module.exports = Pager;


},{"../../../contrib/EventDispatcher.js":11}],63:[function(require,module,exports){
var RenderNode = require("./rendernode.js");
var Constants = require("./constants.js");

var NODE_TYPE = Constants.NODE_TYPE;
var EVENT_TYPE = Constants.EVENT_TYPE;

/** @const */
var WORLD_MATRIX_OFFSET = 0;
/** @const */
var LOCAL_MATRIX_OFFSET = WORLD_MATRIX_OFFSET + 16;
/** @const */
var WORLD_BB_OFFSET = LOCAL_MATRIX_OFFSET + 16;
/** @const */
var ENTRY_SIZE = WORLD_BB_OFFSET + 6;

/**
 *
 * @constructor
 * @extends {RenderNode}
 */
var RenderGroup = function (scene, pageEntry, opt) {
    RenderNode.call(this, NODE_TYPE.GROUP, scene, pageEntry, opt);
    opt = opt || {};

    /**
     * The material attached to this group
     * @type {MaterialConfiguration|null}
     */
    this._material = opt.material || null;
    this.boundingBoxDirty = false;
    this.setWorldSpaceBoundingBox(XML3D.math.bbox.EMPTY_BOX);
};
RenderGroup.ENTRY_SIZE = ENTRY_SIZE;

XML3D.createClass(RenderGroup, RenderNode);

XML3D.extend(RenderGroup.prototype, {
    getLocalMatrix: function (dest) {
        var o = this.offset + LOCAL_MATRIX_OFFSET;
        for (var i = 0; i < 16; i++, o++) {
            dest[i] = this.page[o];
        }
    },

    setLocalMatrix: function (source) {
        var o = this.offset + LOCAL_MATRIX_OFFSET;
        for (var i = 0; i < 16; i++, o++) {
            this.page[o] = source[i];
        }
        this.setTransformDirty();
        this.setBoundingBoxDirty();
    },

    getWorldSpaceBoundingBox: function (bbox) {
        if (this.boundingBoxDirty) {
            this.updateWorldSpaceBoundingBox();
        }
        var o = this.offset + WORLD_BB_OFFSET;
        bbox[0] = this.page[o];
        bbox[1] = this.page[o + 1];
        bbox[2] = this.page[o + 2];
        bbox[3] = this.page[o + 3];
        bbox[4] = this.page[o + 4];
        bbox[5] = this.page[o + 5];
    },

    setWorldSpaceBoundingBox: function (bbox) {
        var o = this.offset + WORLD_BB_OFFSET;
        this.page[o] = bbox[0];
        this.page[o + 1] = bbox[1];
        this.page[o + 2] = bbox[2];
        this.page[o + 3] = bbox[3];
        this.page[o + 4] = bbox[4];
        this.page[o + 5] = bbox[5];
    },


    updateWorldSpaceBoundingBox: (function () {
        var childBB = XML3D.math.bbox.create();

        return function () {
            var localBB = XML3D.math.bbox.create();

            for (var i = 0, j = this.children.length; i < j; i++) {
                var obj = this.children[i];
                if (obj.isVisible()) {
                    obj.getWorldSpaceBoundingBox(childBB);
                    XML3D.math.bbox.extendWithBox(localBB, childBB);
                }
            }
            this.setWorldSpaceBoundingBox(localBB);
            this.boundingBoxDirty = false;
        }
    })(),

    addChild: function (child) {
        this.children.push(child);
        this.setBoundingBoxDirty();
        this.scene.dispatchEvent({type: EVENT_TYPE.SCENE_STRUCTURE_CHANGED, newChild: child});
    },

    removeChild: function (child) {
        var index = this.children.indexOf(child);
        if (index != -1) {
            this.children.splice(index, 1);
        }
        this.scene.dispatchEvent({type: EVENT_TYPE.SCENE_STRUCTURE_CHANGED, removedChild: child});
    },

    getChildren: function () {
        return this.children;
    },

    updateWorldMatrix: function (source) {
        var page = this.page;
        var offset = this.offset;
        XML3D.math.mat4.multiplyOffset(page, offset + WORLD_MATRIX_OFFSET, page, offset + LOCAL_MATRIX_OFFSET, source, 0);
        this.transformDirty = false;
    },

    setTransformDirty: function () {
        if (this.transformDirty) {
            //We can be sure all child nodes are already set to transformDirty from here
            //return;
        }
        this.transformDirty = true;
        this.children.forEach(function (obj) {
            obj.setTransformDirty();
        });
    },

    /**
     * @param {MaterialConfiguration|null} material
     */
    setMaterial: function (material) {
        if(this._material === material)
            return;
        this._material = material;
        this.children.forEach(function (obj) {
            obj.parentMaterialChanged && obj.parentMaterialChanged();
        });
    },

    parentMaterialChanged: function () {
        if (this._material) {
            // Local material overrides anything coming from upstream
            return;
        }
        this.children.forEach(function (obj) {
            obj.parentMaterialChanged && obj.parentMaterialChanged();
        });
    },

    /**
     * @returns {MaterialConfiguration}
     */
    getMaterial: function () {
        return this._material || this.parent.getMaterial();
    },

    setBoundingBoxDirty: function () {
        this.boundingBoxDirty = true;
        if (this.parent) {
            this.parent.setBoundingBoxDirty();
        }
    },

    setLocalVisible: function (newVal) {
        this.localVisible = newVal;
        this.setVisible(this.parent && this.parent.isVisible() && newVal);
        this.setBoundingBoxDirty();
    },

    findRayIntersections: (function () {
        var bbox = XML3D.math.bbox.create();

        return function (ray, intersections) {
            this.getWorldSpaceBoundingBox(bbox);
            if (XML3D.math.bbox.intersects(bbox, ray)) {
                for (var i = 0; i < this.children.length; i++) {
                    this.children[i].findRayIntersections(ray, intersections);
                }
            }
        }
    })()

});

// Export
module.exports = RenderGroup;


},{"./constants.js":59,"./rendernode.js":65}],64:[function(require,module,exports){
var RenderNode = require("./rendernode.js");
var Constants = require("./constants.js");
var LightModels = require("../lights/light-models.js");

var NODE_TYPE = Constants.NODE_TYPE;
var EVENT_TYPE = Constants.EVENT_TYPE;

var tmp_worldMatrix = XML3D.math.mat4.create();

var SHADOWMAP_OFFSET_MATRIX = new Float32Array([0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0]);

/** @const */
var CLIPPLANE_NEAR_MIN = 1.0;

/** @const */
var ENTRY_SIZE = 16;

var c_BoundingBox = new XML3D.math.bbox.create();


function createLightModel(type, data, light) {
    switch (type) {
        case "point":
            return new LightModels.PointLightModel(data, light);
        case "spot":
            return new LightModels.SpotLightModel(data, light);
        case "directional":
            return new LightModels.DirectionalLightModel(data, light);
        default:
            XML3D.debug.logWarning("Unknown light model: ", type, ". Using directional instead.");
            return new LightModels.DirectionalLightModel(data, light);
    }
}

/**
 * @constructor
 * @param {Scene} scene
 * @param {Object} pageEntry
 * @param {Object} opt
 * @extends {RenderNode}
 */
var RenderLight = function (scene, pageEntry, opt) {
    RenderNode.call(this, NODE_TYPE.LIGHT, scene, pageEntry, opt);
    opt = opt || {};
    var light = opt.light || {};
    this.userData = null;
    this.localIntensity = opt.localIntensity !== undefined ? opt.localIntensity : 1.0;
    this.setLightType(light.type, light.data);
};
RenderLight.ENTRY_SIZE = ENTRY_SIZE;

XML3D.createClass(RenderLight, RenderNode);
XML3D.extend(RenderLight.prototype, {

    setLightType: function (modelId, data) {
        modelId = modelId || "directional";
        if (this.model) {
            if (this.model.id == modelId) {
                return; // Nothing changed
            }
            this.scene.lights.remove(this);
            this.lightStructureChanged(true);
        }
        this.model = createLightModel(modelId, data, this);
        this.scene.lights.add(this);
        this.lightStructureChanged(false);
    },

    getFrustum: function (aspect) {
        this.scene.getBoundingBox(c_BoundingBox);
        return this.model.getFrustum(aspect, c_BoundingBox);
    },

    lightValueChanged: function () {
        if (this.model) { // FIXME: Complex dependency
            this.scene.dispatchEvent({type: EVENT_TYPE.LIGHT_VALUE_CHANGED, light: this});
        }
    },

    lightStructureChanged: function (removed) {
        this.scene.dispatchEvent({type: EVENT_TYPE.LIGHT_STRUCTURE_CHANGED, light: this, removed: removed});
    },

    updateWorldMatrix: function () {
        if (this.parent) {
            this.parent.getWorldMatrix(tmp_worldMatrix);
            this.setWorldMatrix(tmp_worldMatrix);
            // We change position / direction of the light
            this.lightValueChanged();
        }
    },

    setTransformDirty: function () {
        this.updateWorldMatrix();
    },


    setVisible: function (newVal) {
        var visible = (this.localVisible && newVal);
        if (this.visible != visible) {
            this.visible = visible;
            this.lightValueChanged();
        }
    },

    setLocalIntensity: function (intensity) {
        this.localIntensity = intensity;
        this.lightValueChanged();
    },

    remove: function () {
        this.parent.removeChild(this);
        this.scene.lights.remove(this);
        this.lightStructureChanged(true);
    },


    getWorldSpaceBoundingBox: function (bbox) {
        XML3D.math.bbox.empty(bbox);
    }
});

module.exports = RenderLight;



},{"../lights/light-models.js":57,"./constants.js":59,"./rendernode.js":65}],65:[function(require,module,exports){
/** @const */
var WORLD_MATRIX_OFFSET = 0;

/**
 * @constructor
 * @param type
 * @param {Scene} scene
 * @param {Object} pageEntry
 * @param {Object} opt
 */
var RenderNode = function (type, scene, pageEntry, opt) {
    opt = opt || {};

    var visible = (opt.visible !== false);

    this.scene = scene;
    this.type = type;
    this.name = opt.name || "";
    this.page = pageEntry.page;
    this.offset = pageEntry.offset;
    this.entrySize = pageEntry.size;
    this.transformDirty = true;
    this.children = [];
    this.setParent(opt.parent || scene.rootNode);
    // The global visibility depends on visibility of parents
    this.visible = undefined;
    // and will be evaluated by setLocalVisible
    this.setLocalVisible(visible);
};

XML3D.extend(RenderNode.prototype, {

    getChildren: function () {
        return this.children;
    },

    getParent: function () {
        return this.parent;
    },

    setParent: function (parent) {
        this.parent = parent;
        if (parent && parent.addChild) {
            parent.addChild(this);
        }
        // Reevaluate visibility, which might change due to
        // invisibility of parent
        this.setLocalVisible(this.localVisible);
    },

    traverse: function (callback) {
        callback(this);
        this.children.forEach(function (child) {
            child.traverse(callback);
        })
    },

    getWorldMatrix: function (dest) {
        if (this.transformDirty) {
            this.parent.getWorldMatrix(dest);
            this.updateWorldMatrix(dest);
        }
        var o = this.offset + WORLD_MATRIX_OFFSET;
        for (var i = 0; i < 16; i++, o++) {
            dest[i] = this.page[o];
        }
    },

    setWorldMatrix: function (source) {
        var o = this.offset + WORLD_MATRIX_OFFSET;
        for (var i = 0; i < 16; i++, o++) {
            this.page[o] = source[i];
        }
        this.transformDirty = false;
        if (this.setBoundingBoxDirty) {
            this.setBoundingBoxDirty();
        }
    },

    isVisible: function () {
        return this.visible;
    },

    setTransformDirty: function () {
        this.transformDirty = true;
    },

    setLocalVisible: function (newVal) {
        this.localVisible = newVal;
        this.setVisible(this.parent && this.parent.isVisible() && newVal);
    },

    setVisible: function (newVal) {
        var downstream = newVal;
        if (this.localVisible === false) {
            downstream = false;
        }
        if (this.visible === downstream) {
            return
        }
        this.visible = downstream;
        this.children.forEach(function (obj) {
            obj.setVisible(downstream);
        });
    },

    remove: function () {
        this.parent.removeChild(this);
        this.scene.freePageEntry({page: this.page, offset: this.offset, size: this.entrySize});
    },

    findRayIntersections: function (/* ray, closestIntersection*/) {
        //This function is overridden by groups and drawables
    }

});

module.exports = RenderNode;

},{}],66:[function(require,module,exports){
var SystemNotifier = require("../../webgl/system/system-notifier.js");
var RenderNode = require("./rendernode.js");
var DrawableClosure= require("./drawableclosure.js");
var C = require("./constants.js");
var Scene= require("./scene.js");
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;

/**
 * @interface
 */
var IRenderObject = function () {
};
IRenderObject.prototype.getModelViewMatrix = function () {
};
IRenderObject.prototype.getModelViewProjectionMatrix = function () {
};
IRenderObject.prototype.getModelMatrixN = function () {
};
IRenderObject.prototype.getModelViewMatrixN = function () {
};
IRenderObject.prototype.getObjectSpaceBoundingBox = function () {
};
IRenderObject.prototype.getWorldSpaceBoundingBox = function () {
};
IRenderObject.prototype.updateWorldSpaceMatrices = function () {
};
IRenderObject.prototype.isVisible = function () {
};
IRenderObject.prototype.setTransformDirty = function () {
};
IRenderObject.prototype.setShader = function () {
};
IRenderObject.prototype.hasTransparency = function () {
};

// Entry:
/** @const */
var WORLD_MATRIX_OFFSET = 0;
/** @const */
var LOCAL_MATRIX_OFFSET = WORLD_MATRIX_OFFSET + 16;
/** @const */
var OBJECT_BB_OFFSET = LOCAL_MATRIX_OFFSET + 16;
/** @const */
var WORLD_BB_OFFSET = OBJECT_BB_OFFSET + 6;
/** @const */
var MODELVIEW_MATRIX_OFFSET = WORLD_BB_OFFSET + 6;
/** @const */
var MODELVIEWPROJECTION_MATRIX_OFFSET = MODELVIEW_MATRIX_OFFSET + 16;
/** @const */
var MODEL_MATRIX_N_OFFSET = MODELVIEWPROJECTION_MATRIX_OFFSET + 16;
/** @const */
var MODELVIEW_MATRIX_N_OFFSET = MODEL_MATRIX_N_OFFSET + 16;
/** @const */
var ENTRY_SIZE = MODELVIEW_MATRIX_N_OFFSET + 16;

//noinspection JSClosureCompilerSyntax,JSClosureCompilerSyntax
/**
 * Represents a renderable object in the scene.
 * The RenderObject has these responsibilities:
 *  1. Keep track of the transformation hierarchy and bounding boxes
 *  2. Connect the DrawableClosure with the ShaderClosure
 *
 *  The {@link DrawableClosure} is a DrawableObject plus it's data
 *  The {@link ShaderClosure} is a ProgramObject plus it's data
 *  The concrete ShaderClosure can vary per DrawableObject and change
 *  due to scene or object changes. Thus we have to keep track of the
 *  related {@link IShaderComposer}.
 *
 * @constructor
 * @implements {IRenderObject}
 * @param {Scene} scene
 * @param {Object} pageEntry
 * @param {Object} opt
 */
var RenderObject = function (scene, pageEntry, opt) {
    RenderNode.call(this, C.NODE_TYPE.OBJECT, scene, pageEntry, opt);
    opt = opt || {};

    /**
     * Keep reference to DOM Element need e.g. for picking
     * @type {Element}
     */
    this.node = opt.node;

    /**
     * Object related data
     * @type {{data: DataNode|null, type: string}}
     */
    this.object = opt.object || {data: null, type: "triangles"};

    /**
     * Can we rely on current WorldMatrix?
     * @type {boolean}
     */
    this.transformDirty = true;

    /**
     * Can we rely on current Bounding Boxes?
     * @type {boolean}
     */
    this.boundingBoxDirty = true;

    this.transformDataRequest = this.createTransformRequest();

    /**
     * The drawable closure transforms object data and type into
     * a drawable entity
     * @type {DrawableClosure}
     */
    this.drawable = this.createDrawable();

    this._material = opt.material || null;
    this._actualMaterial = null;
    this.initMaterial();

    /** {Object?} **/
    this.override = null;


};
RenderObject.ENTRY_SIZE = ENTRY_SIZE;

RenderObject.IDENTITY_MATRIX = XML3D.math.mat4.create();

XML3D.createClass(RenderObject, RenderNode, {
    createTransformRequest: function () {
        if (!this.object.data)
            return null;
        var request = new ComputeRequest(this.object.data, ["meshTransform"], this.onTransformDataChange.bind(this));
        return request;
    },

    createDrawable: function () {
        var result = this.scene.createDrawable(this);
        if (result) {
            var that = this;
            result.addEventListener(C.EVENT_TYPE.DRAWABLE_STATE_CHANGED, function (evt) {
                if (evt.newState === DrawableClosure.READY_STATE.COMPLETE) {
                    that.scene.moveFromQueueToReady(that);
                } else if (evt.newState === DrawableClosure.READY_STATE.INCOMPLETE && evt.oldState === DrawableClosure.READY_STATE.COMPLETE) {
                    that.scene.moveFromReadyToQueue(that);
                }
            });
            result.updateTypeRequest();
            result.calculateBoundingBox();
            result.addEventListener(C.EVENT_TYPE.SCENE_SHAPE_CHANGED, function (evt) {
                that.scene.dispatchEvent({type: C.EVENT_TYPE.SCENE_SHAPE_CHANGED})
            })
        }
        return result;
    },

    setType: function (type) {
        this.object.type = type;
        // TODO: this.typeChangedEvent
    },

    getType: function () {
        return this.object.type;
    },

    getDataNode: function () {
        return this.object ? this.object.data : null;
    },

    getLocalMatrix: function (dest) {
        var o = this.offset + LOCAL_MATRIX_OFFSET;
        for (var i = 0; i < 16; i++, o++) {
            dest[i] = this.page[o];
        }
    },

    setLocalMatrix: function (source) {
        var o = this.offset + LOCAL_MATRIX_OFFSET;
        for (var i = 0; i < 16; i++, o++) {
            this.page[o] = source[i];
        }
        this.setTransformDirty();
        this.setBoundingBoxDirty();
    },

    dispose: function () {
        this.transformDataRequest && this.transformDataRequest.clear();
        this.scene.remove(this);
    }, onTransformDataChange: function () {
        this.setTransformDirty();
    },

    getModelViewMatrix: function (target) {
        var o = this.offset + MODELVIEW_MATRIX_OFFSET;
        for (var i = 0; i < 16; i++, o++) {
            target[i] = this.page[o];
        }
    },

    getModelMatrixN: function (target) {
        var o = this.offset + MODEL_MATRIX_N_OFFSET;
        target[0] = this.page[o];
        target[1] = this.page[o + 1];
        target[2] = this.page[o + 2];
        target[3] = this.page[o + 4];
        target[4] = this.page[o + 5];
        target[5] = this.page[o + 6];
        target[6] = this.page[o + 8];
        target[7] = this.page[o + 9];
        target[8] = this.page[o + 10];
    },

    getModelViewMatrixN: function (target) {
        var o = this.offset + MODELVIEW_MATRIX_N_OFFSET;
        target[0] = this.page[o];
        target[1] = this.page[o + 1];
        target[2] = this.page[o + 2];
        target[3] = this.page[o + 4];
        target[4] = this.page[o + 5];
        target[5] = this.page[o + 6];
        target[6] = this.page[o + 8];
        target[7] = this.page[o + 9];
        target[8] = this.page[o + 10];
    },


    getModelViewProjectionMatrix: function (dest) {
        var o = this.offset + MODELVIEWPROJECTION_MATRIX_OFFSET;
        for (var i = 0; i < 16; i++, o++) {
            dest[i] = this.page[o];
        }
    },

    updateWorldSpaceMatrices: function (view, projection) {
        if (this.transformDirty) {
            this.updateWorldMatrix();
        }
        this.updateModelViewMatrix(view);
        this.updateModelMatrixN();
        this.updateModelViewMatrixN();
        this.updateModelViewProjectionMatrix(projection);
    },

    updateWorldMatrix: (function () {
        var tmp_mat = XML3D.math.mat4.create();
        return function () {
            this.parent.getWorldMatrix(tmp_mat);
            var page = this.page;
            var offset = this.offset;
            XML3D.math.mat4.multiplyOffset(tmp_mat, 0, page, offset + LOCAL_MATRIX_OFFSET, tmp_mat, 0);
            if (this.transformDataRequest) {
                var result = this.transformDataRequest.getResult();
                var transformData = result.getOutputData("meshTransform");
                if (transformData && transformData.getValue()) {
                    XML3D.math.mat4.multiply(tmp_mat, tmp_mat, transformData.getValue());
                }
            }
            this.setWorldMatrix(tmp_mat);
            this.boundingBoxDirty = true;
            this.transformDirty = false;
        }
    })(),

    /** Relies on an up-to-date transform matrix **/
    updateModelViewMatrix: function (view) {
        if (this.transformDirty) {
            this.updateWorldMatrix();
        }
        var page = this.page;
        var offset = this.offset;
        XML3D.math.mat4.multiplyOffset(page, offset + MODELVIEW_MATRIX_OFFSET, page, offset + WORLD_MATRIX_OFFSET, view, 0);
    },

    updateModelMatrixN: (function () {
        var c_tmpMatrix = XML3D.math.mat4.create();
        return function () {
            this.getWorldMatrix(c_tmpMatrix);
            var normalMatrix = XML3D.math.mat4.invert(c_tmpMatrix, c_tmpMatrix);
            normalMatrix = normalMatrix ? XML3D.math.mat4.transpose(normalMatrix, normalMatrix) : RenderObject.IDENTITY_MATRIX;
            var o = this.offset + MODEL_MATRIX_N_OFFSET;
            for (var i = 0; i < 16; i++, o++) {
                this.page[o] = normalMatrix[i];
            }
        }
    })(),

    /** Relies on an up-to-date view matrix **/
    updateModelViewMatrixN: (function () {
        var c_tmpMatrix = XML3D.math.mat4.create();
        return function () {
            this.getModelViewMatrix(c_tmpMatrix);
            var normalMatrix = XML3D.math.mat4.invert(c_tmpMatrix, c_tmpMatrix);
            normalMatrix = normalMatrix ? XML3D.math.mat4.transpose(normalMatrix, normalMatrix) : RenderObject.IDENTITY_MATRIX;
            var o = this.offset + MODELVIEW_MATRIX_N_OFFSET;
            for (var i = 0; i < 16; i++, o++) {
                this.page[o] = normalMatrix[i];
            }
        }
    })(),


    /** Relies on an up-to-date view matrix **/
    updateModelViewProjectionMatrix: function (projection) {
        var page = this.page;
        var offset = this.offset;
        XML3D.math.mat4.multiplyOffset(page, offset + MODELVIEWPROJECTION_MATRIX_OFFSET, page, offset + MODELVIEW_MATRIX_OFFSET, projection, 0);
    },

    setTransformDirty: function () {
        this.transformDirty = true;
        this.setBoundingBoxDirty();
        this.scene.dispatchEvent({type: C.EVENT_TYPE.SCENE_SHAPE_CHANGED});
        this.scene.requestRedraw("Transformation changed");
    },

    setObjectSpaceBoundingBox: function (box) {
        var o = this.offset + OBJECT_BB_OFFSET;
        this.page[o] = box[0];
        this.page[o + 1] = box[1];
        this.page[o + 2] = box[2];
        this.page[o + 3] = box[3];
        this.page[o + 4] = box[4];
        this.page[o + 5] = box[5];
        this.setBoundingBoxDirty();
    },

    getObjectSpaceBoundingBox: function (box) {
        var o = this.offset + OBJECT_BB_OFFSET;
        box[0] = this.page[o];
        box[1] = this.page[o + 1];
        box[2] = this.page[o + 2];
        box[3] = this.page[o + 3];
        box[4] = this.page[o + 4];
        box[5] = this.page[o + 5];
    },

    setBoundingBoxDirty: function () {
        this.boundingBoxDirty = true;
        this.parent.setBoundingBoxDirty();
    },

    setWorldSpaceBoundingBox: function (bbox) {
        var o = this.offset + WORLD_BB_OFFSET;
        this.page[o] = bbox[0];
        this.page[o + 1] = bbox[1];
        this.page[o + 2] = bbox[2];
        this.page[o + 3] = bbox[3];
        this.page[o + 4] = bbox[4];
        this.page[o + 5] = bbox[5];
    },

    getWorldSpaceBoundingBox: function (bbox) {
        if (this.boundingBoxDirty) {
            this.updateWorldSpaceBoundingBox();
        }
        var o = this.offset + WORLD_BB_OFFSET;
        bbox[0] = this.page[o];
        bbox[1] = this.page[o + 1];
        bbox[2] = this.page[o + 2];
        bbox[3] = this.page[o + 3];
        bbox[4] = this.page[o + 4];
        bbox[5] = this.page[o + 5];

    },

    updateWorldSpaceBoundingBox: (function () {
        var c_box = new XML3D.math.bbox.create();
        var c_trans = new XML3D.math.mat4.create();

        return function () {
            this.getObjectSpaceBoundingBox(c_box);
            this.getWorldMatrix(c_trans);
            XML3D.math.bbox.transform(c_box, c_trans, c_box);
            this.setWorldSpaceBoundingBox(c_box);
            this.boundingBoxDirty = false;
        }
    })(),

    setLocalVisible: function (newVal) {
        this.localVisible = newVal;
        this.setVisible(this.parent && this.parent.isVisible() && newVal);
        this.setBoundingBoxDirty();
    },

    getProgram: function () {
        return this.drawable.getProgram();
    },

    hasTransparency: function () {
        var program = this.getProgram();
        return program ? program.hasTransparency() : false;
    },

    updateForRendering: function () {
        SystemNotifier.setNode(this.node);
        try {
            this.drawable && this.drawable.update(this.scene);
        } catch (e) {
            XML3D.debug.logError("Mesh Error: " + e.message, this.node);
        }
        SystemNotifier.setNode(null);
    },

    findRayIntersections: (function () {
        var bbox = XML3D.math.bbox.create();
        var opt = {dist: 0};

        return function (ray, intersections) {
            this.getWorldSpaceBoundingBox(bbox);
            if (XML3D.math.bbox.intersects(bbox, ray, opt)) {
                intersections.push(this);
            }
        }
    })(),

        /**
     * @param {MaterialConfiguration|null} material
     */
    setMaterial: function (material) {
        if(this._material === material) {
            return;
        }
        this._material = material;
        if (material) {
            this._actualMaterial = material;
        } else {
            this._actualMaterial = this.parent.getMaterial();
        }
        this.materialChanged();
    },

    parentMaterialChanged: function () {
        if (this._material) {
            // Local material overrides the change from above
            return;
        }
        this.initMaterial();
    },

    initMaterial: function () {
        if (this._material) {
            this._actualMaterial = this._material;
        } else {
            this._actualMaterial = this.parent.getMaterial();
        }
        this.materialChanged();
    },

    materialChanged: function() {
        XML3D.debug.logDebug("material changed", this._actualMaterial);
        if (this.drawable) {
            var composer = this.scene.shaderFactory.createComposerFromMaterialConfiguration(this._actualMaterial);
            this.drawable.setShaderComposer(composer);
        }
    }

});


// Export
module.exports = RenderObject;


},{"../../../xflow/interface/request.js":139,"../../webgl/system/system-notifier.js":118,"./constants.js":59,"./drawableclosure.js":60,"./rendernode.js":65,"./scene.js":68}],67:[function(require,module,exports){
var RenderNode = require("./rendernode.js");
var Constants = require("./constants.js");
var Frustum = require("../tools/frustum.js").Frustum;

var NODE_TYPE = Constants.NODE_TYPE;
var EVENT_TYPE = Constants.EVENT_TYPE;

    /** @const */
    var VIEW_TO_WORLD_MATRIX_OFFSET = 0;
    /** @const */
    var WORLD_TO_VIEW_MATRIX_OFFSET = 16;
    /** @const */
    var PROJECTION_MATRIX_OFFSET = 32;
    /** @const */
    var ENTRY_SIZE = PROJECTION_MATRIX_OFFSET + 16;

    /** @const */
    var CLIPPLANE_NEAR_MIN = 0.01;

    /** @const */
    var DEFAULT_FIELDOFVIEW = 45 / 180 * Math.PI;

    /**
     *
     * @constructor
     * @extends {RenderNode}
     */
    var RenderView = function(scene, pageEntry, opt) {
        RenderNode.call(this, NODE_TYPE.VIEW, scene, pageEntry, opt);
        opt = opt || {};
        this.position = opt.position || XML3D.math.vec3.create();
        this.orientation = opt.orientation || XML3D.math.mat4.create();
        this.fieldOfView = opt.fieldOfView !== undefined ? opt.fieldOfView : DEFAULT_FIELDOFVIEW;
        this.worldSpacePosition = XML3D.math.vec3.create();
        this.projectionOverride = opt.projectionOverride;
        this.viewDirty = true;
        this.projectionDirty = true;
        this.frustum = new Frustum(1, 100000, 0, this.fieldOfView, 1);
        this.lastAspectRatio = 1;
    };
    RenderView.ENTRY_SIZE = ENTRY_SIZE;

    XML3D.createClass(RenderView, RenderNode);

    XML3D.extend(RenderView.prototype, {
        getFrustum: function() {
            return this.frustum;
        },

        updateViewMatrix: (function() {
            var tmp_mat4 = XML3D.math.mat4.create();
            var tmp_parent = XML3D.math.mat4.create();

            return function () {
                XML3D.math.mat4.identity(tmp_mat4);
                tmp_mat4[12] = this.position[0];
                tmp_mat4[13] = this.position[1];
                tmp_mat4[14] = this.position[2];
                // tmp = T * O
                XML3D.math.mat4.multiply(tmp_mat4, tmp_mat4, this.orientation);
                this.parent.getWorldMatrix(tmp_parent);
                XML3D.math.mat4.multiply(tmp_mat4, tmp_parent, tmp_mat4);
                XML3D.math.vec3.set(this.worldSpacePosition, tmp_mat4[12], tmp_mat4[13], tmp_mat4[14]);
                this.setViewToWorldMatrix(tmp_mat4);
                XML3D.math.mat4.invert(tmp_mat4, tmp_mat4);
                this.setWorldToViewMatrix(tmp_mat4);
                this.viewDirty = false;
            }
        })(),

        updateProjectionMatrix: (function() {
            var tmp = XML3D.math.mat4.create();

            return function(aspect) {
                if (this.projectionOverride) {
                    this.setProjectionMatrix(this.projectionOverride);
                    // TODO: Correctly compute frustrum from projection matrix (if possible)
                    this.frustum.setFrustum(1, 100000, 0, this.fieldOfView, 1);
                    return;
                }

                var clipPlane = this.getClippingPlanes(),
                    near = clipPlane.near,
                    far = clipPlane.far,
                    fovy = this.fieldOfView;

                // Calculate perspective projectionMatrix
                XML3D.math.mat4.perspective(tmp, fovy, aspect, near, far);
                // Set projectionMatrix
                this.setProjectionMatrix(tmp);
                // Update Frustum
                this.frustum.setFrustum(near, far, 0, fovy, aspect);

                this.lastAspectRatio = aspect;
            }
        })(),

        getClippingPlanes: (function() {
            var t_mat = XML3D.math.mat4.create();
            var bb = new XML3D.math.bbox.create();

            return function() {
                this.scene.getBoundingBox(bb);
                if (XML3D.math.bbox.isEmpty(bb)) {
                    return { near: 1, far: 10 };
                }
                this.getWorldToViewMatrix(t_mat);
                XML3D.math.bbox.transform(bb, t_mat, bb);

                var near = -bb[5],
                    far = -bb[2],
                    expand = Math.max((far - near) * 0.005, 0.05);

                // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
                far += expand;
                near -= expand;

                return {near: Math.max(near, expand, CLIPPLANE_NEAR_MIN), far: far};
            }
        })(),

        /**
         * @param {Float32Array} source
         * @param {number} offset
         */
        setMatrix: function(source, offset) {
            var o = this.offset + offset;
            for(var i = 0; i < 16; i++, o++) {
                this.page[o] = source[i];
            }
        },

        setWorldToViewMatrix: function(source) {
            this.setMatrix(source, WORLD_TO_VIEW_MATRIX_OFFSET);
        },

        setViewToWorldMatrix: function(source) {
            this.setMatrix(source, VIEW_TO_WORLD_MATRIX_OFFSET);
        },

        setProjectionMatrix: function(source) {
            var o = this.offset + PROJECTION_MATRIX_OFFSET;
            for(var i = 0; i < 16; i++, o++) {
                this.page[o] = source[i];
            }
            this.projectionDirty = false;
        },

        setProjectionOverride: function(projAdapter) {
            this.projectionOverride = projAdapter;
            this.setProjectionDirty();
            this.scene.requestRedraw("Projection changed");
        },

        setTransformDirty: function() {
            this.viewDirty = true;
            this.setProjectionDirty();
            this.scene.requestRedraw("Transformation changed");
        },

        setProjectionDirty: function() {
            this.projectionDirty = true;
        },

        updatePosition: function(newPos) {
            this.setTransformDirty();
            this.position[0] = newPos[0];
            this.position[1] = newPos[1];
            this.position[2] = newPos[2];
        },

        updateOrientation: function(newOrientation) {
            this.setTransformDirty();
            for (var i = 0; i < 16; i++) {
                this.orientation[i] = newOrientation[i];
            }
        },

        updateFieldOfView: function(newFov) {
            this.setTransformDirty();
            this.fieldOfView = newFov;
        },

        getViewToWorldMatrix: function (dest) {
            if (this.viewDirty) {
                this.updateViewMatrix();
            }
            var o = this.offset + VIEW_TO_WORLD_MATRIX_OFFSET;
            for (var i = 0; i < 16; i++, o++) {
                dest[i] = this.page[o];
            }
        },

        getWorldToViewMatrix: function (dest) {
            if (this.viewDirty) {
                this.updateViewMatrix();
            }
            var o = this.offset + WORLD_TO_VIEW_MATRIX_OFFSET;
            for (var i = 0; i < 16; i++, o++) {
                dest[i] = this.page[o];
            }
        },

        getProjectionMatrix: function(dest, aspect) {
                if (this.projectionDirty || aspect != this.lastAspectRatio) {
                    this.updateProjectionMatrix(aspect);
                }
                var o = this.offset + PROJECTION_MATRIX_OFFSET;
                for(var i = 0; i < 16; i++, o++) {
                    dest[i] = this.page[o];
                }
        },

        getWorldSpacePosition: function() {
            return this.worldSpacePosition;
        },

        getWorldSpaceBoundingBox: function(bbox) {
            XML3D.math.bbox.empty(bbox);
        }
    });

    // Export
    module.exports = RenderView;


},{"../tools/frustum.js":70,"./constants.js":59,"./rendernode.js":65}],68:[function(require,module,exports){
var Pager = require("./pager.js");
var RenderObject = require("./renderobject.js");
var RenderView = require("./renderview.js");
var RenderGroup = require("./rendergroup.js");
var RenderLight = require("./renderlight.js");
var MaterialConfiguration = require("./material-configuration.js");
var LightManager = require("../lights/light-manager.js");
var C = require("./constants.js");
var InputNode = require("../../../xflow/interface/graph.js").InputNode;
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var XC = require("../../../xflow/interface/constants.js");
var URI = require("../../../utils/uri.js").URI;

/**
 *
 * @constructor
 * @extends Pager
 */
var Scene = function () {
    Pager.call(this);

    this.boundingBox = new XML3D.math.bbox.create();
    this.lights = new LightManager();

    /** @type RenderView */
    this.activeView = null;

    /** @type MaterialConfiguration */
    this._defaultMaterial = null;

    this.rootNode = this.createRootNode();
};
XML3D.createClass(Scene, Pager);


XML3D.extend(Scene.prototype, {
    /**
     * @returns {RenderView}
     */
    getActiveView: function () {
        return this.activeView;
    }, /**
     * @param {RenderView} view
     */
    setActiveView: function (view) {
        if (view != this.activeView) {
            if (!view)
                throw new Error("Active view must not be null");
            this.activeView = view;
            this.dispatchEvent({type: C.EVENT_TYPE.VIEW_CHANGED, newView: this.activeView});
        }
    },
    /**
     * @param {object?} opt
     * @returns {RenderObject}
     */
    createRenderObject: function (opt) {
        var pageEntry = this.getPageEntry(RenderObject.ENTRY_SIZE);
        return new RenderObject(this, pageEntry, opt);
    },

    createRenderGroup: function (opt) {
        var pageEntry = this.getPageEntry(RenderGroup.ENTRY_SIZE);
        return new RenderGroup(this, pageEntry, opt);
    },

    createRenderView: function (opt) {
        var pageEntry = this.getPageEntry(RenderView.ENTRY_SIZE);
        return new RenderView(this, pageEntry, opt);
    },

    createRenderLight: function (opt) {
        var pageEntry = this.getPageEntry(RenderLight.ENTRY_SIZE);
        return new RenderLight(this, pageEntry, opt);
    },

    createMaterialConfiguration: function(model, data, opt) {
        return new MaterialConfiguration(model, data, opt);
    },

    createRootNode: function () {
        var pageEntry = this.getPageEntry(RenderGroup.ENTRY_SIZE);
        var root = new RenderGroup(this, pageEntry, {
            material: this.getDefaultMaterial()
        });
        root.setWorldMatrix(XML3D.math.mat4.create());
        root.setLocalMatrix(XML3D.math.mat4.create());
        root.transformDirty = false;
        root.visible = true;
        return root;
    },

    updateBoundingBox: function () {
        if (this.rootNode.boundingBoxDirty) {
            // TODO: There should always be an active view
            this.activeView && this.activeView.setProjectionDirty();
        }
        this.rootNode.getWorldSpaceBoundingBox(this.boundingBox);
    },

    getBoundingBox: function (bb) {
        this.updateBoundingBox();
        XML3D.math.bbox.copy(bb, this.boundingBox);
    },

    createDrawable: function (/*obj*/) {
        throw new Error("Scene::createDrawable not implemented");
    },

    requestRedraw: function (/*reason*/) {
        throw new Error("Scene::requestRedraw not implemented");
    },

    traverse: function (callback) {
        this.rootNode.traverse(callback);
    },

    /**
     * Returns all objects intersected by the given ray, based on their bounding boxes
     * @param ray
     * @returns {Array} An array of RenderObjects that were hit by this ray
     */
    findRayIntersections: function (ray) {
        var intersections = [];
        this.rootNode.findRayIntersections(ray, intersections);
        return intersections;
    },

    getDefaultMaterial: function() {
        if(!this._defaultMaterial) {
            var inputNode = new InputNode();
            inputNode.data = new BufferEntry(XC.DATA_TYPE.FLOAT3, new Float32Array([1, 0, 0]));
            inputNode.name = "diffuseColor";

            var data = new DataNode(false);
            data.appendChild(inputNode);

            this._defaultMaterial = this.createMaterialConfiguration(
                {"type": "urn", "urn": new URI("urn:xml3d:shader:matte")},
                data,
                {name: "default"}
            );
        }
        return this._defaultMaterial;
    }

});

module.exports = Scene;

},{"../../../utils/uri.js":133,"../../../xflow/interface/constants.js":136,"../../../xflow/interface/data.js":137,"../../../xflow/interface/graph.js":138,"../lights/light-manager.js":56,"./constants.js":59,"./material-configuration.js":61,"./pager.js":62,"./rendergroup.js":63,"./renderlight.js":64,"./renderobject.js":66,"./renderview.js":67}],69:[function(require,module,exports){
var DataChangeNotifier = require("../../../xflow/interface/data.js").DataChangeNotifier;

/**
 *
 * @constructor
 */
var DataChangeListener = function () {
    DataChangeNotifier.addListener(this.dataEntryChanged);
};

/**
 *
 * @param {Xflow.DataEntry} entry
 * @param {Xflow.DATA_ENTRY_STATE} notification
 */
DataChangeListener.prototype.dataEntryChanged = function (entry, notification) {
    if (entry.userData.webglData) {
        for (var i in entry.userData.webglData) {
            var oldChanged = entry.userData.webglData[i].changed;
            entry.userData.webglData[i].changed = Math.max(oldChanged, notification);
        }
    }
};

module.exports = DataChangeListener;

},{"../../../xflow/interface/data.js":137}],70:[function(require,module,exports){
var vec3 = XML3D.math.vec3;
var tmp1 = vec3.create();
var tmp2 = vec3.create();


/**
 *
 * @param {number} nearPlane
 * @param {number} farPlane
 * @param {number} fovx
 * @param {number} fovy
 * @param {number} aspect
 * @param {boolean} orthographic
 * @constructor
 */
var Frustum = function (nearPlane, farPlane, fovx, fovy, aspect, orthographic) {
    /**
     *
     * @type {boolean}
     */
    if (typeof(orthographic) === "undefined")
        this.orthographic = false; else
        this.orthographic = orthographic;
    this.setFrustum(nearPlane, farPlane, fovx, fovy, aspect, this.orthographic);
};

XML3D.extend(Frustum.prototype, {
    setFrustum: function (nearPlane, farPlane, fovx, fovy, aspect, orthographic) {
        if (fovx && fovy)
            throw new Error("fovx and fovy cannot both be non-zero.");

        if (fovx) {
            this.right = nearPlane * Math.tan(fovx / 2);
            this.left = -this.right;
            this.top = ((this.right - this.left) / aspect) / 2;
            this.bottom = -this.top;
        } else {
            this.top = nearPlane * Math.tan(0.5 * fovy);
            this.bottom = -this.top;
            this.right = (this.top - this.bottom) * aspect / 2;
            this.left = -this.right;
        }
        this.nearPlane = nearPlane;
        this.farPlane = farPlane;

        if (typeof(orthographic) === "undefined")
            this.orthographic = false; else
            this.orthographic = orthographic;

    }, getProjectionMatrix: function (matrix) {
        var limitMax = Number.MAX_VALUE;
        var rightPlusLeft = this.right + this.left;
        var rightMinusLeft = this.right - this.left;

        var topPlusBottom = this.top + this.bottom;
        var topMinusBottom = this.top - this.bottom;

        var farPlusNear = this.farPlane + this.nearPlane;
        var farMinusNear = this.farPlane - this.nearPlane;

        if ((Math.abs(rightMinusLeft) < 1 && Math.abs(rightPlusLeft) > limitMax * Math.abs(rightMinusLeft)) || (Math.abs(topMinusBottom) < 1 && Math.abs(topPlusBottom) > limitMax * Math.abs(topMinusBottom)) || (Math.abs(farMinusNear) < 1 && Math.abs(farPlusNear) > limitMax * Math.abs(farMinusNear))) {
            throw new Error("Bad viewing frustum: projection matrix cannot be computed.");
        }

        var A, B, C, D, E, F;

        if (this.orthographic) {
            var tx = -rightPlusLeft / rightMinusLeft;
            var ty = -topPlusBottom / topMinusBottom;
            var tz = -farPlusNear / farMinusNear;

            if ((Math.abs(rightMinusLeft) < 1 && 2 > limitMax * Math.abs(rightMinusLeft)) || (Math.abs(topMinusBottom) < 1 && 2 > limitMax * Math.abs(topMinusBottom)) || (Math.abs(farMinusNear) < 1 && 2 > limitMax * Math.abs(farMinusNear))) {
                throw new Error("Bad viewing frustum:  projection matrix cannot be computed.");
            }

            A = 2 / rightMinusLeft;
            B = 2 / topMinusBottom;
            C = -2 / farMinusNear;

            XML3D.math.mat4.identity(matrix);
            matrix[0] = A;
            matrix[5] = B;
            matrix[10] = C;
            matrix[12] = tx;
            matrix[13] = ty;
            matrix[14] = tz;
            matrix[15] = 1.0;
        } else {
            A = rightPlusLeft / rightMinusLeft;
            B = topPlusBottom / topMinusBottom;
            C = -farPlusNear / farMinusNear;

            var farTimesNear = -2 * this.farPlane * this.nearPlane;
            if (Math.abs(farMinusNear) < 1 && Math.abs(farTimesNear) > limitMax * Math.abs(farMinusNear)) {
                throw new Error("Bad viewing frustum: projection matrix cannot be computed.");
            }

            D = farTimesNear / farMinusNear;

            var twoTimesNear = 2 * this.nearPlane;

            if ((Math.abs(rightMinusLeft) < 1 && Math.abs(twoTimesNear) > limitMax * Math.abs(rightMinusLeft)) || (Math.abs(topMinusBottom) < 1 && Math.abs(twoTimesNear) > limitMax * Math.abs(topMinusBottom))) {
                throw new Error("Bad viewing frustum: projection matrix cannot be computed.");
            }

            E = twoTimesNear / rightMinusLeft;
            F = twoTimesNear / topMinusBottom;

            XML3D.math.mat4.identity(matrix);
            matrix[0] = E;
            matrix[5] = F;
            matrix[8] = A;
            matrix[9] = B;
            matrix[10] = C;
            matrix[11] = -1;
            matrix[14] = D;
            matrix[15] = 0;
        }
    },

    getPlanes: (function () {

        var c_a = vec3.create();
        var c_b = vec3.create();
        var c_c = vec3.create();
        var c_d = vec3.create();

        var c_e = vec3.create();
        var c_f = vec3.create();
        var c_g = vec3.create();
        var c_o = vec3.create();


        return function (p, M) {
            var a = vec3.transformMat4(c_a, [this.left, this.bottom, -this.nearPlane], M);
            var b = vec3.transformMat4(c_b, [this.left, this.top, -this.nearPlane], M);
            var c = vec3.transformMat4(c_c, [this.right, this.top, -this.nearPlane], M);
            var d = vec3.transformMat4(c_d, [this.right, this.bottom, -this.nearPlane], M);
            var e, f, g, h, o;
            if (!this.orthographic) {
                var s = this.farPlane / this.nearPlane;
                var farLeft = s * this.left;
                var farRight = s * this.right;
                var farTop = s * this.top;
                var farBottom = s * this.bottom;
                e = vec3.transformMat4(c_e, [farLeft, farBottom, -this.farPlane], M);
                f = vec3.transformMat4(c_f, [farLeft, farTop, -this.farPlane], M);
                g = vec3.transformMat4(c_g, [farRight, farTop, -this.farPlane], M);
                o = vec3.transformMat4(c_o, [0, 0, 0], M);
                p[0].setFromPoints(o, c, b);
                p[1].setFromPoints(o, d, c);
                p[2].setFromPoints(o, a, d);
                p[3].setFromPoints(o, b, a);
                p[4].setFromPoints(a, d, c);
                p[5].setFromPoints(e, f, g);
            } else {
                e = vec3.transformMat4(c_e, [this.left, this.bottom, -this.farPlane], M);
                f = vec3.transformMat4(c_f, [this.left, this.top, -this.farPlane], M);
                g = vec3.transformMat4(c_g, [this.right, this.top, -this.farPlane], M);
                h = vec3.transformMat4(c_o, [this.right, this.bottom, -this.farPlane], M);
                p[0].setFromPoints(c, g, f);
                p[1].setFromPoints(d, h, g);
                p[2].setFromPoints(a, e, h);
                p[3].setFromPoints(b, f, e);
                p[4].setFromPoints(a, d, c);
                p[5].setFromPoints(e, f, g);
            }
        };
    }())


});


var Plane = function () {
    this.distance = 0;
    this.normal = vec3.create();
};

XML3D.extend(Plane.prototype, {
    setFromPoints: function (point1, point2, point3) {
        vec3.cross(this.normal, vec3.sub(tmp2, point3, point1), vec3.sub(tmp1, point2, point1));
        vec3.normalize(this.normal, this.normal);
        this.distance = -vec3.dot(this.normal, point1);
    }, set: function (x, y, z, distance) {
        vec3.set(this.normal, x, y, z);
        vec3.normalize(this.normal, this.normal);
        this.distance = distance;
    }
});

var FrustumTest = function (frustum, cameraMatrix) {
    this.frustumPlanes = [new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()];
    if (frustum && cameraMatrix) {
        this.set(frustum, cameraMatrix);
    }
};


XML3D.extend(FrustumTest.prototype, {
    /**
     *
     * @param {Frustum} frustum
     * @param {mat4} matrix
     */
    set: function (frustum, matrix) {
        frustum.getPlanes(this.frustumPlanes, matrix);

    }, /**
     * @param bbox
     * @returns {boolean}
     */
    isBoxVisible: (function () {

        return function (bbox) {
            if (XML3D.math.bbox.isEmpty(bbox))
                return false;


            for (var i = 0; i < this.frustumPlanes.length; i++) {
                var plane = this.frustumPlanes[i];
                var normal = plane.normal;
                var bbx = normal[0] >= 0.0 ? bbox[3] : bbox[0];
                var bby = normal[1] >= 0.0 ? bbox[4] : bbox[1];
                var bbz = normal[2] >= 0.0 ? bbox[5] : bbox[2];

                // Compute the distance
                var distance = bbx * normal[0] + bby * normal[1] + bbz * normal[2] + plane.distance;

                // if highest point is below plane then all below.
                if (distance < 0.0) {
                    return false;
                }
            }
            return true;
        }
    }())

});

module.exports = {
    Plane: Plane,
    Frustum: Frustum,
    FrustumTest: FrustumTest
};

},{}],71:[function(require,module,exports){
/**
 *
 * @constructor
 */
var ObjectSorter = function () {

};

var c_bbox = XML3D.math.bbox.create();
var c_center = XML3D.math.vec3.create();

XML3D.extend(ObjectSorter.prototype, {
    /**
     * @param {GLScene} scene
     * @param {Float32Array?} viewMatrix Matrix to apply to objects world space extend before sorting
     */
    sortScene: function (scene, viewMatrix) {
        var sourceObjectArray = scene.ready, opaque = {}, transparent = [];

        var transparentArray = [], obj;
        for (var i = 0, l = sourceObjectArray.length; i < l; i++) {
            obj = sourceObjectArray[i];
            if (obj.inFrustum === false) {
                continue;
            }
            if (obj.hasTransparency()) {
                transparentArray.push(obj);
            } else {
                var program = obj.getProgram();
                opaque[program.id] = opaque[program.id] || [];
                opaque[program.id].push(obj);
            }
        }

        // Sort opaque objects from front to back in order
        // to have earlier z-fails
        for (var progId in opaque) {
            var withinShader = opaque[progId];
            var sortedArray = new Array(withinShader.length);
            for (i = 0; i < withinShader.length; i++) {
                obj = withinShader[i];
                obj.getWorldSpaceBoundingBox(c_bbox);
                XML3D.math.bbox.center(c_center, c_bbox);
                viewMatrix && XML3D.math.vec3.transformMat4(c_center, c_center, viewMatrix);
                sortedArray[i] = {
                    obj: obj, depth: c_center[2]
                };
            }
            sortedArray.sort(function (a, b) {
                return b.depth - a.depth;
            });
            opaque[progId] = sortedArray.map(function(e) { return e.obj; });
        }

        //Sort transparent objects from back to front
        var tlength = transparentArray.length;
        if (tlength > 1) {
            for (i = 0; i < tlength; i++) {
                obj = transparentArray[i];
                obj.getWorldSpaceBoundingBox(c_bbox);
                XML3D.math.bbox.center(c_center, c_bbox);
                viewMatrix && XML3D.math.vec3.transformMat4(c_center, c_center, viewMatrix);
                transparentArray[i] = [obj, c_center[2]];
            }

            transparentArray.sort(function (a, b) {
                return a[1] - b[1];
            });

            for (i = 0; i < tlength; i++) {
                transparent[i] = transparentArray[i][0];
            }
        } else if (tlength == 1) {
            transparent[0] = transparentArray[0];
        }
        return {
            opaque: opaque, transparent: transparent
        }
    }

});


module.exports = ObjectSorter;



},{}],72:[function(require,module,exports){
/** Calculate the offset of the given element and return it.
 *
 *  @param {Object} element
 *  @return {{top:number, left:number}} the offset
 *
 *  This code is taken from http://javascript.info/tutorial/coordinates .
 *  We don't want to do it with the offsetParent way, because the xml3d
 *  element is actually invisible and thus offsetParent will return null
 *  at least in WebKit. Also it's slow. So we use getBoundingClientRect().
 *  However it returns the box relative to the window, not the document.
 *  Thus, we need to incorporate the scroll factor. And because IE is so
 *  awesome some workarounds have to be done and the code gets complicated.
 */
function calculateOffset(element) {
    var box = element.getBoundingClientRect();
    var body = document.body;
    var docElem = document.documentElement;

    // get scroll factor (every browser except IE supports page offsets)
    var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
    var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;

    // the document (`html` or `body`) can be shifted from left-upper corner in IE. Get the shift.
    var clientTop = docElem.clientTop || body.clientTop || 0;
    var clientLeft = docElem.clientLeft || body.clientLeft || 0;

    var top = box.top + scrollTop - clientTop;
    var left = box.left + scrollLeft - clientLeft;

    // for Firefox an additional rounding is sometimes required
    return {top: Math.round(top), left: Math.round(left)};
}


module.exports = {

    /** Convert a given mouse page position to be relative to the given target element.
     *  Most probably the page position are the MouseEvent's pageX and pageY attributes.
     *
     *  @param {!Object} xml3dEl the xml3d element to which the coords need to be translated
     *  @param {!number} pageX the x-coordinate relative to the page
     *  @param {!number} pageY the y-coordinate relative to the page
     *  @return {{x: number, y: number}} the converted coordinates
     */
    convertPageCoords: function (xml3dEl, pageX, pageY) {
        var off = calculateOffset(xml3dEl);

        return {x: pageX - off.left, y: pageY - off.top};
    }
};

},{}],73:[function(require,module,exports){
var TextureManager = require("texture-manager").SimpleTextureManager;
var GLTexture = require("./texture.js").GLTexture;
var GLCubeMap = require("./texture.js").GLCubeMap;
var GLCanvasTarget = require("./rendertarget.js").GLCanvasTarget;
var ProgramFactory = require("./../shader/programfactory.js");
var XC = require("../../../xflow/interface/constants.js");

var CONTEXT_OPTIONS = {
    alpha: true, premultipliedAlpha: false, antialias: true, stencil: true, preserveDrawingBuffer: true
};

/**
 * @param {HTMLCanvasElement!} canvas
 */
function getContextForCanvas(canvas) {
    try {
        return canvas.getContext('experimental-webgl', CONTEXT_OPTIONS);
    } catch (e) {
        return null;
    }
}

/**
 * Context that includes all GL related resources / handlers
 * @param {HTMLCanvasElement!} canvas
 * @param {number} id
 * @constructor
 */
var GLContext = function (canvas, id) {
    this.gl = getContextForCanvas(canvas);
    this.id = id;
    this.canvasTarget = new GLCanvasTarget(this, canvas.clientWidth, canvas.clientHeight);
    this.programFactory = new ProgramFactory(this);
    this.textureManager = new TextureManager({ units: this.gl.getParameter(WebGLRenderingContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS )});
    this.stats = {
        materials: 0, meshes: 0
    };
    this.extensions = populateExtensions(this.gl);

};

var EXTENSIONS = GLContext.EXTENSIONS = {};
EXTENSIONS.STANDARD_DERIVATES = 'OES_standard_derivatives';
EXTENSIONS.MULTIPLE_RENDER_TARGETS = 'WEBGL_draw_buffers';
EXTENSIONS.DEPTH_TEXTURE = 'WEBGL_depth_texture';
EXTENSIONS.FLOAT_COLOR_BUFFER = 'WEBGL_color_buffer_float';
EXTENSIONS.FLOAT_TEXTURES = 'OES_texture_float';
EXTENSIONS.UINT32_INDICES = 'OES_element_index_uint';

XML3D.extend(GLContext.prototype, {
    getXflowEntryWebGlData: function (entry) {
        return getXflowEntryWebGlData(entry, this.id);
    },

    requestRedraw: function (reason) {
        //handler.redraw(reason, forcePicking);
    },

    handleResizeEvent: function (width, height) {
        this.canvasTarget = new GLCanvasTarget(this, width, height);
    },

    getStatistics: function () {
        return this.stats;
    },

    getExtensionByName: function (name) {
        return this.extensions[name];
    } ,

    createTexture: function() {
        return new GLTexture(this);
    } ,
    createCubeMap: function() {
        return new GLCubeMap(this);
    }
});


function getXflowEntryWebGlData(entry, canvasId){
    if(!entry) return null;
    if(!entry.userData.webglData)
        entry.userData.webglData = {};
    if(!entry.userData.webglData[canvasId])
        entry.userData.webglData[canvasId] = {
            changed : XC.DATA_ENTRY_STATE.CHANGED_NEW
        };
    return entry.userData.webglData[canvasId];
}

/**
 * @param {WebGLRenderingContext} gl
 * @returns {{}}
 */
function populateExtensions(gl) {
    var result = {};
    for (var name in EXTENSIONS) {
        var extensionName = EXTENSIONS[name];
        var ext = gl.getExtension(extensionName);
        if (!ext) {
            XML3D.debug.logInfo(extensionName, "is not supported on your graphics card");
        } else {
            result[extensionName] = ext;
        }
    }
    return result;
}

module.exports = GLContext;



},{"../../../xflow/interface/constants.js":136,"./../shader/programfactory.js":116,"./rendertarget.js":77,"./texture.js":78,"texture-manager":3}],74:[function(require,module,exports){
var FullscreenQuad = function (context) {
    this.gl = context.gl;
    this.createGLAssets();
};

XML3D.extend(FullscreenQuad.prototype, {

    createGLAssets: function () {
        var gl = this.gl;
        this.posBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0]), gl.STATIC_DRAW);
    },

    draw: function (program) {
        var gl = this.gl;
        var posAttr = program.attributes["position"];
        gl.enableVertexAttribArray(posAttr.location);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
        gl.vertexAttribPointer(posAttr.location, 3, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        gl.disableVertexAttribArray(posAttr.location);
    }

});

module.exports = FullscreenQuad;


},{}],75:[function(require,module,exports){


/**
 *
 * @param context
 * @param type
 * @constructor
 */
var GLMesh = function (context, type) {
    this.context = context;
    this.glType = getGLTypeFromString(type);
    this.buffers = {};
    this.uniformOverride = {};
    this.minIndex = 0;
    this.maxIndex = 0;
    this.isIndexed = false;
    this.vertexCount = null;
    this.minAttributeCount = -1;
    this.context.getStatistics().meshes++;
    this.multiDraw = (this.glType == WebGLRenderingContext.LINE_STRIP || this.glType == WebGLRenderingContext.TRIANGLE_STRIP);
};

XML3D.extend(GLMesh.prototype, {
    setIndexRange: function (minIndex, maxIndex) {
        this.minIndex = minIndex;
        this.maxIndex = maxIndex;
    },

    checkBufferCompatible: function (name, xflowDataBuffer) {
        var cnt = xflowDataBuffer.getIterateCount();
        this.minAttributeCount = (this.minAttributeCount == -1 ? cnt : Math.min(this.minAttributeCount, cnt));

        if (this.isIndexed) {
            if (cnt <= this.maxIndex) {
                throw new Error("Index range of [" + this.minIndex + ", " + this.maxIndex + "] " + " goes beyond element count " + cnt + " of attribute '" + name + "'");
            }
        } else if (this.vertexCount !== null) {
            if (cnt < this.vertexCount)
                throw new Error("VertexCount " + this.vertexCount + " is larger than element count " + cnt + " of attribute '" + name + "'");
        }
    },

    removeBuffer: function (name) {
        delete this.buffers[name];
    },

    setBuffer: function (name, buffer) {
        this.buffers[name] = buffer;
        this.isIndexed = this.isIndexed || name == "index";
    },

    clear: function () {
        this.buffers = {};
        this.uniformOverride = {};
        this.minIndex = this.maxIndex = 0;
        this.isIndexed = false;
        this.minAttributeCount = -1;
    },

    setUniformOverride: function (name, value) {
        if (value === undefined)
            delete this.uniformOverride[name];
        this.uniformOverride[name] = value;
    },

    setVertexCount: function (vertexCount) {
        this.vertexCount = vertexCount;
    },

    isReadyToRender: function () {
        return this.minAttributeCount > 0;
    },

    /**
     * @returns {number}
     */
    getElementCount: function () {
        try {
            return this.buffers.index.length;
        } catch (e) {
            //XML3D.debug.logError("Could not calculate element count.", e);
            return 0;
        }
    }, /**
     * @returns {number}
     */
    getVertexCount: function () {
        try {
            return (this.vertexCount != null ? this.vertexCount : this.minAttributeCount );
        } catch (e) {
            //XML3D.debug.logError("Could not calculate vertex count.", e);
            return 0;
        }
    },

    /**
     * @param {AbstractShaderClosure} program
     * @private
     */
    _bindVertexBuffers: function(program) {
        var gl = this.context.gl, sAttributes = program.attributes, buffers = this.buffers, i, name;

        var keys = Object.keys(sAttributes);
        var keyLength = keys.length;

        for (i = 0; i < keyLength; i++) {
            name = keys[i];
            var buffer = buffers[name];
            var location = sAttributes[name].location;

            if (!buffer) {
                continue;
            }
            gl.enableVertexAttribArray(location);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(location, buffer.tupleSize, buffer.glType, false, 0, 0);
        }
    },

    _unbindVertexBuffers: function (program) {
        var gl = this.context.gl, sAttributes = program.attributes;
        for (var name in sAttributes) {
            var shaderAttribute = sAttributes[name];
            gl.disableVertexAttribArray(shaderAttribute.location);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    },

    /**
     * @param {AbstractShaderClosure} program
     * @returns {number}
     */
    draw: function (program) {
        var gl = this.context.gl, sAttributes = program.attributes, buffers = this.buffers, triCount = 0, offset, j;

        //Bind vertex buffers
        this._bindVertexBuffers(program);

        //Draw the object
        if (this.isIndexed) {
            var indexBuffer = buffers.index;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer);

            if (this.multiDraw && this.vertexCount) {
                offset = 0;
                for (j = 0; j < this.vertexCount.length; j++) {
                    var count = this.vertexCount[j];
                    gl.drawElements(this.glType, count, indexBuffer.glType, offset * indexBuffer.bytesPerElement);
                    offset += count;
                }
            } else {
                gl.drawElements(this.glType, this.getElementCount(), indexBuffer.glType, 0);
            }
            triCount = this.getElementCount() / 3;
        } else { // not indexed
            if (this.multiDraw && this.vertexCount) {
                offset = 0;
                for (j = 0; j < this.vertexCount.length; j++) {
                    var count = this.vertexCount[j];
                    gl.drawArrays(this.glType, offset, count);
                    offset += count;
                }
            } else {
                gl.drawArrays(this.glType, 0, this.getVertexCount());
                triCount = this.getVertexCount();
            }
        }

        //Unbind vertex buffers
        this._unbindVertexBuffers(program);


        if (program.undoUniformVariableOverride)
            program.undoUniformVariableOverride(this.uniformOverride);

        return triCount;
    }


});

/**
 * @param {string} typeName
 */
var getGLTypeFromString = function (typeName) {
    var GL = window.WebGLRenderingContext;
    if (typeName && typeName.toLoweGLase)
        typeName = typeName.toLowerCase();
    switch (typeName) {
        case "triangles":
            return GL.TRIANGLES;
        case "tristrips":
            return GL.TRIANGLE_STRIP;
        case "points":
            return GL.POINTS;
        case "lines":
            return GL.LINES;
        case "linestrips":
            return GL.LINE_STRIP;
        default:
            throw new Error("Unknown primitive type: " + typeName);
    }
};

module.exports = GLMesh;

},{}],76:[function(require,module,exports){

var utils = require("./utils.js");
var SystemNotifier = require("../system/system-notifier.js");

//noinspection JSValidateJSDoc
/**
 * @param {WebGLRenderingContext} gl
 * @param {Number} type
 * @param {string} shaderSource
 * @return {WebGLShader}
 */
var createWebGLShaderFromSource = function (gl, type, shaderSource) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);

    if (gl.getShaderParameter(shader, WebGLRenderingContext.COMPILE_STATUS) == 0) {
        var message = gl.getShaderInfoLog(shader);
        var errorString = "";
        if (type == WebGLRenderingContext.VERTEX_SHADER)
            errorString = "Vertex shader failed to compile: \n"; else
            errorString = "Fragment shader failed to compile: \n";

        errorString += message + "\n--------\n";
        errorString += "Shader Source:\n--------\n";
        errorString += XML3D.debug.formatSourceCode(shaderSource);
        gl.getError();
        SystemNotifier.sendEvent('glsl', {
                glslType: "compile_error",
                shaderType: type == WebGLRenderingContext.VERTEX_SHADER ? "vertex" : "fragment",
                code: shaderSource,
                message: message
            });

        throw new Error(errorString)
    }
    return shader;
};

//noinspection JSValidateJSDoc
/**
 * @param {WebGLRenderingContext} gl
 * @param vertexSources
 * @param fragmentSources
 * @returns {WebGLProgram}
 */
var createProgramFromSources = function (gl, vertexSources, fragmentSources) {
    var shd, s, src;
    var shaders = [];
    for (s in vertexSources) {
        src = vertexSources[s];
        shd = createWebGLShaderFromSource(gl, WebGLRenderingContext.VERTEX_SHADER, src);
        shaders.push(shd);
    }
    for (s in fragmentSources) {
        src = fragmentSources[s];
        shd = createWebGLShaderFromSource(gl, WebGLRenderingContext.FRAGMENT_SHADER, src);
        shaders.push(shd);
    }
    return createProgramFromShaders(gl, shaders);
};

//noinspection JSValidateJSDoc
/**
 * @param {WebGLRenderingContext} gl
 * @param {Object} shaders
 * @return {WebGLProgram}
 */
var createProgramFromShaders = function (gl, shaders) {
    var program = gl.createProgram();
    for (var s in shaders) {
        var shader = shaders[s];
        gl.attachShader(program, shader);
    }
    gl.linkProgram(program);
    if (gl.getProgramParameter(program, WebGLRenderingContext.LINK_STATUS) == 0) {
        var message = gl.getProgramInfoLog(program);
        var errorString = "Shader linking failed: \n";
        errorString += message;
        errorString += "\n--------\n";
        gl.getError();
        SystemNotifier.sendEvent('glsl', {glslType: "link_error", message: message});
        throw new Error(errorString);
    }
    return program;
};

var tally = function (gl, handle, programObject) {
    var i;
    // Tally shader attributes
    var numAttributes = gl.getProgramParameter(handle, gl.ACTIVE_ATTRIBUTES);
    for (i = 0; i < numAttributes; i++) {
        var att = gl.getActiveAttrib(handle, i);
        if (!att)
            continue;
        var attInfo = {};
        attInfo.name = att.name;
        attInfo.size = att.size;
        attInfo.glType = att.type;
        attInfo.location = gl.getAttribLocation(handle, att.name);
        programObject.attributes[att.name] = attInfo;
    }


    // Tally shader uniforms and samplers
    var numUniforms = gl.getProgramParameter(handle, gl.ACTIVE_UNIFORMS);
    for (i = 0; i < numUniforms; i++) {
        var uni = gl.getActiveUniform(handle, i);
        if (!uni)
            continue;
        var uniInfo = {};
        uniInfo.name = uni.name;
        uniInfo.size = uni.size;
        uniInfo.glType = uni.type;
        uniInfo.location = gl.getUniformLocation(handle, uni.name);

        var name = uniInfo.name;

        // Remove array identifier from name, this is handled by size
        if (name.substring(name.length - 3) == "[0]") {
            name = name.substring(0, name.length - 3); // Remove [0]
        }

        if (uni.type == gl.SAMPLER_2D || uni.type == gl.SAMPLER_CUBE) {
            // Set all texture units to 0, needs to be Int32Array
            uniInfo.cachedUnits = new Int32Array(uniInfo.size);
            uniInfo.textures = [];
            // Caches this information
            utils.setUniform(gl, uniInfo, uniInfo.cachedUnits);

            programObject.samplers[name] = uniInfo;
        } else
            programObject.uniforms[name] = uniInfo;
    }

};

var uniqueObjectId = utils.getUniqueCounter();

/**
 * @constructor
 * @param {WebGLRenderingContext} gl
 * @param {{ fragment: string, vertex: string }} sources
 */
var ProgramObject = function (gl, sources) {
    this.gl = gl;
    this.sources = sources;

    this.id = uniqueObjectId();
    this.attributes = {};
    this.uniforms = {};
    this.samplers = {};
    this.handle = null;

    this.create();
};

XML3D.extend(ProgramObject.prototype, {
    create: function () {
        XML3D.debug.logDebug("Create shader program: ", this.id);
        this.handle = createProgramFromSources(this.gl, [this.sources.vertex], [this.sources.fragment]);
        if (!this.handle)
            return;
        SystemNotifier.sendEvent('glsl', {glslType: "success"});
        this.bind();
        tally(this.gl, this.handle, this);
    },

    bind: function () {
        if (!this.handle) {
            XML3D.debug.logError("Trying to bind invalid GLProgram.");
        }
        this.gl.useProgram(this.handle);

        /**
         * Some of the dependent textures may have changed their texture units
         */
        for (var name in this.samplers) {
            var sampler = this.samplers[name];
            if(sampler.textures.length) {
                this.setSamplerFromTextures(sampler);
            }
        }
    },

    unbind: function () {
    }, isValid: function () {
        return !!this.handle;
    }, setUniformVariables: function (envNames, sysNames, inputCollection) {
        var i, base, override, name;
        if (envNames && inputCollection.envBase) {
            i = envNames.length;
            base = inputCollection.envBase;
            override = inputCollection.envOverride;
            while (i--) {
                name = envNames[i];
                this.setUniformVariable(name, override && override[name] !== undefined ? override[name] : base[name]);
            }
        }
        if (sysNames && inputCollection.sysBase) {
            i = sysNames.length;
            base = inputCollection.sysBase;
            while (i--) {
                name = sysNames[i];
                this.setUniformVariable(name, base[name]);
            }
        }
    }, setUniformVariable: function (name, value) {
        if (value === undefined) return;
        if (this.uniforms[name]) {
            utils.setUniform(this.gl, this.uniforms[name], value);
        } else if (this.samplers[name]) {
            this.setUniformSampler(this.samplers[name], value);
        }
    },

    /**
     * Sets the texture units from the textures associated with the sampler
     * @param sampler
     * @returns {boolean}
     */
    setSamplerFromTextures: function (sampler) {
        var textures = sampler.textures;
        var cachedUnits = sampler.cachedUnits;
        var textureUnitsChanged = false;

        for (var i = 0, ii = textures.length; i < ii; i++) {
            var unit = textures[i].unit;

            // If texture is not bound to a texture unit (-1), bind it now
            if (unit == -1) {
                unit = textures[i]._bind();
            }
            if (unit != cachedUnits[i]) {
                cachedUnits[i] = unit;
                textureUnitsChanged = true;
            }
        }
        if (textureUnitsChanged) {
            XML3D.debug.logDebug("Setting new texture units:", sampler.name, cachedUnits);
            utils.setUniform(this.gl, sampler, cachedUnits);
        }
    },

    setSamplerFromArray: function(sampler, arr) {
        var cachedUnits = sampler.cachedUnits;
        var textureUnitsChanged = false;

       for (var i = 0, ii = arr.length; i < ii; i++) {
            var unit = arr[i];
            if (unit != cachedUnits[i]) {
                cachedUnits[i] = unit;
                textureUnitsChanged = true;
            }
        }
        if (textureUnitsChanged) {
            utils.setUniform(this.gl, sampler, cachedUnits);
            XML3D.debug.logDebug("Setting global texture units:", sampler.name, cachedUnits, this.id);
        }
    },

    /**
     *
     * @param {Object} sampler
     * @param {Array.<GLTexture>|Int32Array} value
     */
    setUniformSampler: function (sampler, value) {
        XML3D.debug.assert(value && sampler);
        // Textures are always an array value
        XML3D.debug.assert(Array.isArray(value), "Program::setUniformSampler: Unexpected value.");
        // We have at least one entry
        XML3D.debug.assert(value.length, "Program::setUniformSampler: No entry in value.");

        /**
         * Value can either be an array of GLTextures that know their current texture unit,
         * otherwise a typed array containing the texture units we have to bind.
         * @type {boolean}
         */
        var hasTextures = value[0].unit != undefined;

        if(hasTextures) {
            sampler.textures = value;
            this.setSamplerFromTextures(sampler);
        } else {
            this.setSamplerFromArray(sampler, value);
        }
    }
});

module.exports = ProgramObject;


},{"../system/system-notifier.js":118,"./utils.js":79}],77:[function(require,module,exports){
/**
 * @interface
 */
var IRenderTarget = function () {
};
IRenderTarget.prototype.bind = function () {
};
IRenderTarget.prototype.unbind = function () {
};
IRenderTarget.prototype.getWidth = function () {
};
IRenderTarget.prototype.getHeight = function () {
};
IRenderTarget.prototype.getScale = function () {
};
IRenderTarget.prototype.resize = function (width, height) {
};

/**
 * Wrapper to handle screen context as render target
 * @constructor
 * @param {GLContext} context
 * @param {Number} width
 * @param {Number} height
 * @implements IRenderTarget
 */
var GLCanvasTarget = function (context, width, height) {
    this.context = context;
    this.width = width;
    this.height = height;
};

var empty = function () {
};

XML3D.extend(GLCanvasTarget.prototype, {
    getWidth: function () {
        return this.width;
    }, getHeight: function () {
        return this.height;
    }, getScale: function () {
        return 1;
    }, bind: empty, unbind: empty, resize: empty
});

/**
 * @param context
 * @param opt
 * @constructor
 * @implements IRenderTarget
 */
var GLRenderTarget = function (context, opt) {
    this.context = context;
    this.width = opt.width || 800;
    this.height = opt.height || 600;
    this.scale = opt.scale || 1;
    this.opt = this.fillOptions(opt);
    this.handle = null;
    this.colorTarget = {handle: null, isTexture: false};
    this.depthTarget = {handle: null, isTexture: false};
    this.stencilTarget = {handle: null, isTexture: false};
    this.valid = false;
};

XML3D.extend(GLRenderTarget.prototype, {
    getWidth: function () {
        return this.width;
    }, getHeight: function () {
        return this.height;
    }, getScale: function () {
        return this.scale;
    }, bind: function () {
        var created = false;
        if (!this.handle) {
            this.createFrameBuffer(this.opt.colorFormat, this.opt.depthFormat, this.opt.stencilFormat);
            created = true;
        }
        if (this.valid) {
            var gl = this.context.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);
            // Set default viewport
            created && gl.viewport(0, 0, this.width, this.height);
        }
    }, unbind: function () {
        var gl = this.context.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }, resize: function (width, height) {
        this.dispose();
        this.width = width;
        this.height = height;
        this.bind();
    }, createFrameBuffer: function (colorFormat, depthFormat, stencilFormat) {
        var gl = this.context.gl;

        this.handle = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);
        colorFormat && this.createColorTarget(colorFormat);
        depthFormat && this.createDepthTarget(depthFormat);
        stencilFormat && this.createStencilTarget(stencilFormat);
        this.checkStatus();
    }, createColorTarget: function (colorFormat) {
        var gl = this.context.gl;
        if (this.opt.colorAsRenderbuffer) {
            var ct = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, ct);
            gl.renderbufferStorage(gl.RENDERBUFFER, colorFormat, this.width, this.height);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, ct);

            this.colorTarget = {
                handle: ct, isTexture: false
            };
        } else {
            //opt.generateMipmap = opt.generateColorsMipmap;
            var ctex = this.context.createTexture();
            ctex.createTex2DFromData(colorFormat, this.width, this.height, gl.RGBA, this.opt.colorType || gl.UNSIGNED_BYTE, this.opt);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, ctex.handle, 0);
            this.colorTarget = {
                handle: ctex, isTexture: true
            };
        }
    }, createDepthTarget: function (depthFormat) {
        var gl = this.context.gl;
        this.opt.isDepth = true;
        if (this.opt.depthAsRenderbuffer) {
            var dt = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, dt);
            gl.renderbufferStorage(gl.RENDERBUFFER, depthFormat, this.width, this.height);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, dt);

            this.depthTarget = {
                handle: dt, isTexture: false
            }
        } else {
            //opt.generateMipmap = opt.generateDepthMipmap;
            var dtex = this.context.createTexture();
            dtex.createTex2DFromData(depthFormat, this.width, this.height, gl.DEPTH_COMPONENT, gl.FLOAT, this.opt);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, dtex.handle, 0);

            this.depthTarget = {
                handle: dtex, isTexture: true
            }
        }
    }, createStencilTarget: function (stencilFormat) {
        var gl = this.context.gl;
        if (this.opt.stencilAsRenderbuffer) {
            var st = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, st);
            gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, this.width, this.height);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, st);

            this.stencilTarget = {
                handle: st, isTexture: false
            }
        } else {
            //opt.generateMipmap = opt.generateStencilMipmap;
            var stex = this.context.createTexture();
            stex.createTex2DFromData(stencilFormat, this.width, this.height, gl.STENCIL_COMPONENT, gl.UNSIGNED_BYTE, this.opt);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.TEXTURE_2D, stex.handle, 0);

            this.stencilTarget = {
                handle: stex, isTexture: true
            }
        }
    }, checkStatus: function () {
        var gl = this.context.gl;

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);
        //Finalize framebuffer creation
        var fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

        switch (fbStatus) {
            case gl.FRAMEBUFFER_COMPLETE:
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                break;
            case gl.FRAMEBUFFER_UNSUPPORTED:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
                break;
            default:
                XML3D.debug.logError("Incomplete framebuffer: " + fbStatus);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        this.valid = (fbStatus == gl.FRAMEBUFFER_COMPLETE);
        return this.valid;
    }, fillOptions: function (options) {
        var gl = this.context.gl;
        var opt = {
            wrapS: gl.CLAMP_TO_EDGE,
            wrapT: gl.CLAMP_TO_EDGE,
            minFilter: gl.NEAREST,
            magFilter: gl.NEAREST,
            depthMode: gl.LUMINANCE,
            depthCompareMode: gl.COMPARE_R_TO_TEXTURE,
            depthCompareFunc: gl.LEQUAL,
            colorsAsRenderbuffer: false,
            depthAsRenderbuffer: false,
            stencilAsRenderbuffer: false,
            isDepth: false
        };

        for (var item in options) {
            opt[item] = options[item];
        }
        return opt;
    }, dispose: function () {
        if (!this.handle)
            return;

        var gl = this.context.gl;
        gl.deleteFramebuffer(this.handle);

        if (this.colorTarget !== null) {
            if (this.colorTarget.isTexture)
                this.colorTarget.handle.dispose(); else
                gl.deleteRenderBuffer(this.colorTarget.handle);
        }
        if (this.depthTarget !== null) {
            if (this.depthTarget.isTexture)
                this.depthTarget.handle.dispose(); else
                gl.deleteRenderBuffer(this.depthTarget.handle);
        }
        if (this.stencilTarget !== null) {
            if (this.stencilTarget.isTexture)
                this.stencilTarget.handle.dispose(); else
                gl.deleteRenderBuffer(this.stencilTarget.handle);
        }
    }
});

var GLScaledRenderTarget = function (context, maxDimension, opt) {
    GLRenderTarget.call(this, context, opt);
    this.scaleToMaxDimension(maxDimension);
};

XML3D.createClass(GLScaledRenderTarget, GLRenderTarget);
XML3D.extend(GLScaledRenderTarget.prototype, {
    scaleToMaxDimension: function (maxDimension) {
        var hDiff = this.height - maxDimension;
        var wDiff = this.width - maxDimension;

        if (hDiff > 0 || wDiff > 0) {
            var scale;
            if (hDiff > wDiff) {
                scale = maxDimension / this.height;
            } else {
                scale = maxDimension / this.width;
            }
            this.width = Math.floor(this.width * scale);
            this.height = Math.floor(this.height * scale);
            this.scale = scale;
        }
    }
});


    /**
     * @param context
     * @param opt
     * @constructor
     * @implements IRenderTarget
     */
    var GLCubeMapRenderTarget = function (context, opt) {
        var gl = context.gl;
        this.context = context;
        this.width = opt.width || 800;
        this.height = this.width;
        this.scale = opt.scale || 1;
        this.opt = this.fillOptions(opt);
        this.handle = null;
        this.ctex = null;
        this.dtex = null;
        this.stex = null;
        this.colorTarget = null;
        this.depthTarget =  null;
        this.stencilTarget = null;
        this.valid = false;
        this.glSides = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                        gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                        gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];
        this.framebuffers = [];
    };

    XML3D.extend(GLCubeMapRenderTarget.prototype, {
        getWidth: function() {
            return this.width;
        },
        getHeight: function() {
            return this.height;
        },
        getScale: function() {
            return this.scale;
        },
        bind: function (side) {
            var created = false;
            if (this.framebuffers.length <= 0) {
                this.createFrameBuffers(this.opt.colorFormat, this.opt.depthFormat, this.opt.stencilFormat);
                created = true;
            }
            if (this.valid) {
                var gl = this.context.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[side]);
                // Set default viewport
                created && gl.viewport(0, 0, this.width, this.height);
            }
        },
        unbind: function () {
            var gl = this.context.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        },
        resize: function(width, height) {
            this.dispose();
            this.width = width;
            this.height = height;
            this.bind();
        },
        createFrameBuffers: function (colorFormat, depthFormat, stencilFormat) {
            var gl = this.context.gl;

            if(colorFormat) { //TODO check if renderbuffers instead of textures...
                this.ctex = this.context.createCubeMap();
                this.ctex.createTex2DFromData(colorFormat, this.width, this.height, gl.RGBA, this.opt.colorType || gl.UNSIGNED_BYTE, this.opt);
                this.colorTarget = { handle: this.ctex,  isTexture: true};
            }
            if(depthFormat) {
                this.opt.isDepth = true;

                if (this.opt.depthAsRenderbuffer) {
                } else {
                    this.dtex = this.context.createCubeMap();
                    this.dtex.createTex2DFromData(depthFormat, this.width, this.height, gl.DEPTH_COMPONENT, gl.FLOAT, this.opt);
                    this.depthTarget = { handle: this.dtex,  isTexture: true};
                }
            }
            if(stencilFormat) {
                this.stex = this.context.createCubeMap();
                this.stex.createTex2DFromData(stencilFormat, this.width, this.height, gl.STENCIL_COMPONENT, gl.UNSIGNED_BYTE, this.opt);
                this.stencilTarget = { handle: this.stex, isTexture: true};
            }

            for(var i = 0; i < this.glSides.length; ++i) {
                this.framebuffers[i] = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[i]);
                colorFormat && this.createColorTarget(colorFormat, i);
                depthFormat && this.createDepthTarget(depthFormat, i);
                stencilFormat && this.createStencilTarget(stencilFormat, i);
                this.checkStatus(i);
            }
        },
        createColorTarget: function (colorFormat, side) {
            var gl = this.context.gl;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this.glSides[side], this.ctex.handle, 0);
        },
        createDepthTarget: function (depthFormat, side) {
            var gl = this.context.gl;

            if (this.opt.depthAsRenderbuffer) {
                if (!this.dtex) this.dtex = [];
                this.dtex[side] = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, this.dtex[side]);
                gl.renderbufferStorage(gl.RENDERBUFFER, depthFormat, this.width, this.height);
                gl.bindRenderbuffer(gl.RENDERBUFFER, null);

                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.dtex[side]);
                if (!this.depthTarget) this.depthTarget = [];
                this.depthTarget[side] = {
                    handle: this.dtex[side],
                    isTexture: false
                }
            }
            else
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT0, this.glSides[side], this.dtex.handle, 0);
        },
        createStencilTarget: function (stencilFormat, side) {
            var gl = this.context.gl;

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, this.glSides[side], this.stex.handle, 0);
        },
        checkStatus: function (side) {
            var gl = this.context.gl;

            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[side]);
            //Finalize framebuffer creation
            var fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

            switch (fbStatus) {
                case gl.FRAMEBUFFER_COMPLETE:
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                    break;
                case gl.FRAMEBUFFER_UNSUPPORTED:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
                    break;
                default:
                    XML3D.debug.logError("Incomplete framebuffer: " + fbStatus);
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            this.valid = (fbStatus == gl.FRAMEBUFFER_COMPLETE);
            return this.valid;
        },
        fillOptions: function (options) {
            var gl = this.context.gl;
            var opt = {
                wrapS: gl.CLAMP_TO_EDGE,
                wrapT: gl.CLAMP_TO_EDGE,
                minFilter: gl.NEAREST,
                magFilter: gl.NEAREST,
                depthMode: gl.LUMINANCE,
                depthCompareMode: gl.COMPARE_R_TO_TEXTURE,
                depthCompareFunc: gl.LEQUAL,
                colorsAsRenderbuffer: false,
                depthAsRenderbuffer: false,
                stencilAsRenderbuffer: false,
                isDepth: false
            };

            for (var item in options) {
                opt[item] = options[item];
            }

            return opt;
        },
        dispose: function () {
            if (this.framebuffers.length <= 0)
                return;

            var gl = this.context.gl;
            for(var side in this.framebuffers)
                gl.deleteFramebuffer(this.framebuffers[side]);

            if (this.colorTarget.handle !== null) {
                    this.colorTarget.handle.dispose();
            }
            if (this.depthTarget !== null) {
                this.depthTarget.handle.dispose();
            }
            if (this.stencilTarget !== null) {
                    this.stencilTarget.handle.dispose();
            }

            this.framebuffers = [];
        }
    });

module.exports = {
    GLCanvasTarget: GLCanvasTarget,
    GLRenderTarget: GLRenderTarget,
    GLScaledRenderTarget: GLScaledRenderTarget,
    GLCubeMapRenderTarget: GLCubeMapRenderTarget
};



},{}],78:[function(require,module,exports){
var utils = require("./utils.js");
var StateMachine = require("../../../contrib/state-machine.js");
var SamplerConfig = require("../../../xflow/interface/data.js").SamplerConfig;
var XC = require("../../../xflow/interface/constants.js");
var uniqueObjectId = utils.getUniqueCounter();

//noinspection JSValidateJSDoc
/**
 * @param {GLContext} context
 * @constructor
 */
var GLTexture = function (context) {
    SamplerConfig.call(this);

    /**
     * @type {GLContext}
     */
    this.context = context;

    /**
     * @type {number}
     */
    this.id = uniqueObjectId();

    /**
     * Unit the texture is currently bound to (or -1 if bound to no unit)
     * @type {number}
     */
    this.unit = -1;

    this.setDefaults();

    this.width = 0;
    this.height = 0;
    this.handle = null;

    this.textureType = context.gl.TEXTURE_2D;

    this.textureUnitCallback = this.lostTextureUnit.bind(this);
};

XML3D.createClass(GLTexture, SamplerConfig);

GLTexture.State = {
    NONE: "none", LOADING: "loading", READY: "ready", ERROR: "error"
};


var getOrCreateFallbackTexture = (function () {

    var c_fallbackTexture = null;

    return function (context) {
        if (!c_fallbackTexture) {
            c_fallbackTexture = new GLTexture(context);
            var size = 16;
            var texels = new Uint8Array(size * size * 3);
            for (var i = 0; i < texels.length; i++) {
                texels[i] = 128;
            }
            c_fallbackTexture.createTex2DFromData(WebGLRenderingContext.RGB, size, size, WebGLRenderingContext.RGB, WebGLRenderingContext.UNSIGNED_BYTE, {
                texels: texels, wrapS: WebGLRenderingContext.REPEAT, wrapT: WebGLRenderingContext.REPEAT, minFilter: WebGLRenderingContext.LINEAR, magFilter: WebGLRenderingContext.LINEAR
            });
        }
        return c_fallbackTexture;
    }
}());

var isPowerOfTwo = function (dimension) {
    return (dimension & (dimension - 1)) == 0;
};
var nextHighestPowerOfTwo = function (x) {
    --x;
    for (var i = 1; i < 32; i <<= 1) {
        x = x | x >> i;
    }
    return x + 1;
};

/**
 * Scale up the texture to the next highest power of two dimensions.
 * @returns {HTMLCanvasElement}
 */
var scaleImage = function (image, width, height) {
    /**
     * @type {HTMLCanvasElement}
     */
    var canvas = document.createElement("canvas");
    canvas.width = nextHighestPowerOfTwo(width);
    canvas.height = nextHighestPowerOfTwo(height);

    var context = canvas.getContext("2d");
    if (image instanceof HTMLElement) {
        context.drawImage(image, 0, 0, canvas.width, canvas.height);
    } else {
        var tmpCanvas = document.createElement("canvas");
        tmpCanvas.width = width;
        tmpCanvas.height = height;
        var tmpContext = tmpCanvas.getContext("2d");
        var imageData = tmpContext.createImageData(width, height);
        imageData.data.set(image.data);
        tmpContext.putImageData(imageData, 0, 0);

        context.drawImage(tmpCanvas, 0, 0, canvas.width, canvas.height);
    }

    return canvas;
};

var glTextureFormatFromXflow = function (format, gl) {
    switch (format) {
        case XC.TEXTURE_FORMAT.ALPHA:
            return gl.ALPHA;
        case XC.TEXTURE_FORMAT.RGB:
            return gl.RGB;
        case XC.TEXTURE_FORMAT.RGBA:
            return gl.RGBA;
        case XC.TEXTURE_FORMAT.LUMINANCE:
            return gl.LUMINANCE;
        case XC.TEXTURE_FORMAT.LUMINANCE_ALPHA:
            return gl.LUMINANCE_ALPHA;
        default:
            throw new Error("Unsupported Texture Format!");
    }
};

var glTextureTypeFromXflow = function (type, gl) {
    switch (type) {
        case XC.TEXTURE_TYPE.FLOAT:
            return gl.FLOAT;
        case XC.TEXTURE_TYPE.UBYTE:
            return gl.UNSIGNED_BYTE;
        case XC.TEXTURE_TYPE.USHORT_4_4_4_4:
            return gl.UNSIGNED_SHORT_4_4_4_4;
        case XC.TEXTURE_TYPE.USHORT_5_5_5_1:
            return gl.UNSIGNED_SHORT_5_5_5_1;
        case XC.TEXTURE_TYPE.USHORT_5_6_5:
            return gl.GL_UNSIGNED_SHORT_5_6_5;
        default:
            throw new Error("Unsupported Texture Type!");
    }
};

XML3D.extend(GLTexture.prototype, {
    /**
     * @param {Xflow.TextureEntry} textureEntry
     */
    updateFromTextureEntry: function (textureEntry) {
        if (!textureEntry.isLoading()) {
            this.set(textureEntry.getSamplerConfig());
            var img = textureEntry.asGLTextureValue();
            if (!img)
                return this.failed();
            this.createOrUpdateTexture(img);
        } else {
            this.loads();
        }
    }, /**
     * We need to scale texture when one of the wrap modes is not CLAMP_TO_EDGE and
     * one of the texture dimensions is not power of two.
     * Otherwise rendered texture will be just black.
     * @param {number} width
     * @param {number} height
     * @returns {boolean}
     */
    needsScale: function (width, height) {
        return (this.generateMipMap || this.wrapS != WebGLRenderingContext.CLAMP_TO_EDGE || this.wrapT != WebGLRenderingContext.CLAMP_TO_EDGE) && (!isPowerOfTwo(width) || !isPowerOfTwo(height))
    },


    _bind: function () {
        var gl = this.context.gl;
        var textureManager = this.context.textureManager;
        var unit = this.unit = textureManager.bind(this.id, { dispose: this.textureUnitCallback });
        if (unit == -2) {
            XML3D.debug.logError("All available texture units are full.");
        } else {
            gl.activeTexture(WebGLRenderingContext.TEXTURE0 + unit);
            gl.bindTexture(this.textureType, this.handle);
        }
        return unit;
    },

    unbind: function (unit) {
        // Do nothing, texture manager will handle this
    },

    destroy: function () {
        var gl = this.context.gl;
        var textureManager = this.context.textureManager;
        textureManager.dispose(this.id);
        gl.deleteTexture(this.handle);
    },

    canBind: function () {
        return this.current == GLTexture.State.READY;
    },

    createOrUpdateTexture: function (texelSource) {

        if (!this.handle) {
            this.handle = this.context.gl.createTexture();
        }

        this.updateTextureFromData(texelSource);
    },

    updateTextureFromData: function (texelSource) {
        var gl = this.context.gl;
        this._bind();

        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_S, this.wrapS);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_T, this.wrapT);
        gl.texParameteri(this.textureType, gl.TEXTURE_MIN_FILTER, this.minFilter);
        gl.texParameteri(this.textureType, gl.TEXTURE_MAG_FILTER, this.magFilter);

        var type = glTextureTypeFromXflow(texelSource.texelType, gl);
        var format = glTextureFormatFromXflow(texelSource.texelFormat, gl);

        var width = texelSource.width;
        this.width = width;
        var height = texelSource.height;
        this.height = height;

        if (this.generateMipMap && this.needsScale(width, height)) {
            if (type === gl.FLOAT)
                throw new Error("Should generate MipMaps but texture data is float and not power of two in size!");
            else
                texelSource = scaleImage(texelSource, width, height);
        }

        if (texelSource instanceof HTMLElement) {
            gl.texImage2D(gl.TEXTURE_2D, 0, format, format, type, texelSource);
        } else {
            if (texelSource.data instanceof Uint8ClampedArray) {
                // WebGL does not support Uint8ClampedArray, which is (correctly) used by async. Xflow. We just build a new view
                // on top of the underlying array buffer which should be relatively fast
                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, new Uint8Array(texelSource.data.buffer));
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, texelSource.data);
            }
        }

        if (this.generateMipMap)
            gl.generateMipmap(this.textureType);

        this.created();
    },

    createTex2DFromData: function (internalFormat, width, height, sourceFormat, sourceType, opt) {
        var gl = this.context.gl;

        var opt = opt || {};
        var texels = opt.texels;

        if (!texels) {
            if (sourceType == gl.FLOAT) {
                texels = new Float32Array(width * height * 4);
            } else {
                texels = new Uint8Array(width * height * 4);
            }
        }
        this.width = width;
        this.height = height;
        this.handle = gl.createTexture();
        this._bind();

        // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_S, opt.wrapS);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_T, opt.wrapT);
        gl.texParameteri(this.textureType, gl.TEXTURE_MIN_FILTER, opt.minFilter);
        gl.texParameteri(this.textureType, gl.TEXTURE_MAG_FILTER, opt.magFilter);

        if (!opt.isDepth) {
            if (texels instanceof Uint8ClampedArray) {
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, sourceFormat, sourceType, new Uint8Array(texels.buffer));
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, sourceFormat, sourceType, texels);
            }
        } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, sourceFormat, sourceType, null);
        }

        if (opt.generateMipmap) {
            gl.generateMipmap(this.textureType);
        }
        this.created();
    },

    lostTextureUnit: function() {
        this.unit = -1;
    }

});

StateMachine.create({
    target: GLTexture.prototype,
    initial: GLTexture.State.NONE,
    events: [{name: 'created', from: '*', to: GLTexture.State.READY}, {
        name: 'failed', from: '*', to: GLTexture.State.ERROR
    }, {name: 'loads', from: '*', to: GLTexture.State.LOADING}]
});

//noinspection JSValidateJSDoc
/**
 * @param {GLContext} context
 * @constructor
 */
var GLCubeMap = function (context) {
    GLTexture.call(this, context, context.gl.TEXTURE_CUBE_MAP);
    var gl = context.gl;
    this.textureType = context.gl.TEXTURE_CUBE_MAP;
    this.glSides = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];

};
XML3D.createClass(GLCubeMap, GLTexture, {
    updateTextureFromData: function (texelSource) {
        debug.log("updateTextureFromData not implemented for CubeMapping!");
    },

    createTex2DFromData: function (internalFormat, width, height, sourceFormat, sourceType, opt) {
        var gl = this.context.gl;

        var opt = opt || {};
        var texels = opt.texels;

        if (!texels) {
            if (sourceType == gl.FLOAT) {
                texels = new Float32Array(width * height * 4);
            } else {
                texels = new Uint8Array(width * height * 4);
            }
        }
        this.width = width;
        this.height = height;
        this.handle = gl.createTexture();
        this._bind();

        // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_S, opt.wrapS);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_T, opt.wrapT);
        gl.texParameteri(this.textureType, gl.TEXTURE_MIN_FILTER, opt.minFilter);
        gl.texParameteri(this.textureType, gl.TEXTURE_MAG_FILTER, opt.magFilter);

        for(var i = 0; i < this.glSides.length; ++i) {
            if (!opt.isDepth) {
                if (texels instanceof Uint8ClampedArray) {
                    gl.texImage2D(this.glSides[i], 0, internalFormat, width, height, 0, sourceFormat, sourceType, new Uint8Array(texels.buffer));
                } else {
                    gl.texImage2D(this.glSides[i], 0, internalFormat, width, height, 0, sourceFormat, sourceType, texels);
                }
            } else {
                gl.texImage2D(this.glSides[i], 0, internalFormat, width, height, 0, sourceFormat, sourceType, null);
            }
        }

        if (opt.generateMipmap) {
            gl.generateMipmap(this.textureType);
        }
        this.created();
    }
});

GLCubeMap.State = {
    NONE: "none", LOADING: "loading", READY: "ready", ERROR: "error"
};

StateMachine.create({
    target: GLCubeMap.prototype,
    initial: GLCubeMap.State.NONE,
    events: [{name: 'created', from: '*', to: GLCubeMap.State.READY}, {
        name: 'failed', from: '*', to: GLCubeMap.State.ERROR
    }, {name: 'loads', from: '*', to: GLCubeMap.State.LOADING}]
});


module.exports = {
    GLTexture: GLTexture,
    GLCubeMap: GLCubeMap
};



},{"../../../contrib/state-machine.js":14,"../../../xflow/interface/constants.js":136,"../../../xflow/interface/data.js":137,"./utils.js":79}],79:[function(require,module,exports){
require("../../../utils/array.js");

module.exports = {
    /**
     * Set uniforms for active program
     * @param {WebGLRenderingContext} gl
     * @param u
     * @param value
     * @param {boolean=} transposed
     */
    setUniform: function (gl, u, value, transposed) {

        //noinspection FallthroughInSwitchStatementJS
        switch (u.glType) {
            case 35670: //gl.BOOL
                if (value && value.length !== undefined) {
                    // Transform a Unit8Array into a JS Array
                    gl.uniform1iv(u.location, Array.prototype.map.call(value, function(v) { return v; }));
                } else {
                    gl.uniform1i(u.location, value || 0);
                }
                break;
            case 5124:  //gl.INT
            case 35678: //gl.SAMPLER_2D
            case 35680: //gl.SAMPLER_CUBE
                if (value && value.length !== undefined) {
                    gl.uniform1iv(u.location, value);
                } else {
                    gl.uniform1i(u.location, value || 0);
                }
                break;

            case 35671: // gl.BOOL_VEC2
            case 35667:
                gl.uniform2iv(u.location, value);
                break; // gl.INT_VEC2

            case 35672: // gl.BOOL_VEC3
            case 35668:
                gl.uniform3iv(u.location, value);
                break; // gl.INT_VEC3

            case 35673: // gl.BOOL_VEC4
            case 35669:
                gl.uniform4iv(u.location, value);
                break; // gl.INT_VEC4

            case 5126:
                if (value.length != null)
                    gl.uniform1fv(u.location, value); else
                    gl.uniform1f(u.location, value);
                break; // gl.FLOAT
            case 35664:
                gl.uniform2fv(u.location, value);
                break; // gl.FLOAT_VEC2
            case 35665:
                gl.uniform3fv(u.location, value);
                break; // gl.FLOAT_VEC3
            case 35666:
                gl.uniform4fv(u.location, value);
                break; // gl.FLOAT_VEC4

            case 35674:
                gl.uniformMatrix2fv(u.location, transposed || false, value);
                break;// gl.FLOAT_MAT2
            case 35675:
                gl.uniformMatrix3fv(u.location, transposed || false, value);
                break;// gl.FLOAT_MAT3
            case 35676:
                gl.uniformMatrix4fv(u.location, transposed || false, value);
                break;// gl.FLOAT_MAT4

            default:
                XML3D.debug.logError("Unknown uniform type " + u.glType);
                break;
        }
    },

    getUniqueCounter: function () {
        var c_counter = 0;
        return function () {
            return c_counter++;
        }
    },

    checkError: function (gl, text) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            var textErr = "" + error;
            switch (error) {
                case 1280:
                    textErr = "1280 ( GL_INVALID_ENUM )";
                    break;
                case 1281:
                    textErr = "1281 ( GL_INVALID_VALUE )";
                    break;
                case 1282:
                    textErr = "1282 ( GL_INVALID_OPERATION )";
                    break;
                case 1283:
                    textErr = "1283 ( GL_STACK_OVERFLOW )";
                    break;
                case 1284:
                    textErr = "1284 ( GL_STACK_UNDERFLOW )";
                    break;
                case 1285:
                    textErr = "1285 ( GL_OUT_OF_MEMORY )";
                    break;
            }
            var msg = "GL error " + textErr + " occured.";
            if (text !== undefined)
                msg += " " + text;
            XML3D.debug.trace(msg);
        }
    },

    supported: function () {
        var canvas = document.createElement("canvas");
        try {
            return !!(window.WebGLRenderingContext && (canvas.getContext('experimental-webgl')));
        } catch (e) {
            return false;
        }
    }

};


},{"../../../utils/array.js":127}],80:[function(require,module,exports){
var AbstractCanvasHandler = require("../renderer/canvas-handler.js");
var Options = require("../../utils/options.js");
var xml3dFormatHandler = require("../../base/formathandler.js").xml3dFormatHandler;

var MAXFPS = 30;

var OPTION_CONTINUOUS = "renderer-continuous";
Options.register(OPTION_CONTINUOUS, false);

/**
 * GLCanvasHandler class.
 * Registers and handles the events that happen on the canvas element.
 *
 * @param xml3dElem
 *            the root xml3d node, containing the XML3D scene structure
 * @constructor
 * @extends AbstractCanvasHandler
 */
function GLCanvasHandler(xml3dElem, canvas) {
    AbstractCanvasHandler.call(this, xml3dElem, canvas);
    this.renderInterface = {};

    this.lastPickObj = null;

    this.lastKnownDimensions = {width: canvas.width, height: canvas.height};
    this.initialize();
}

XML3D.createClass(GLCanvasHandler, AbstractCanvasHandler);

GLCanvasHandler.prototype.setRenderer = function (renderer) {
    this.renderer = renderer;
};

GLCanvasHandler.prototype.initialize = function () {
     this.configureCanvas();

    // This function is called at regular intervals by requestAnimFrame to
    // determine if a redraw
    // is needed
    var that = this;
    this.tick = function () {

        if(!that.renderer)
            return;

        XML3D.updateXflowObserver();
        XML3D.flushDOMChanges();

        if (that.canvasSizeChanged() || that.renderer.needsRedraw() || Options.getValue(OPTION_CONTINUOUS)) {
            that.dispatchUpdateEvent();
            that.draw();
        }

        window.requestAnimFrame(that.tick, MAXFPS);
    };

      // Block the right-click context menu on the canvas unless it's explicitly toggled
    var cm = this._xml3dElement.getAttribute("contextmenu");
    if (!cm || cm == "false") {
        this._canvas.addEventListener("contextmenu", function (e) {
            e.preventDefault && e.preventDefault();
            e.stopPropagation && e.stopPropagation();
        }, false);
    }
};

GLCanvasHandler.prototype.configureCanvas = function () {
    var xml3dElement = this._xml3dElement;
    var canvas = this._canvas;

    var parent = xml3dElement.parentNode;
    // Place xml3dElement inside an invisble div
    var hideDiv = parent.ownerDocument.createElement('div');
    hideDiv.style.display = "none";
    parent.insertBefore(hideDiv, xml3dElement);
    hideDiv.appendChild(xml3dElement);

    // Create canvas and append it where the xml3d element was before
    parent.insertBefore(canvas, hideDiv);

    var style = canvas.ownerDocument.defaultView.getComputedStyle(xml3dElement);
    if (!canvas.style.backgroundColor) {
        var bgcolor = style.getPropertyValue("background-color");
        if (bgcolor && bgcolor != "transparent")
            canvas.style.backgroundColor = bgcolor;
    }
    // Need to be set for correct canvas size
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    return canvas;
};

/**
 * Binds the picking buffer and passes the request for a picking pass to the
 * renderer
 *
 * @param {number} canvasX
 * @param {number} canvasY
 * @return {Drawable|null} newly picked object
 */
GLCanvasHandler.prototype.getPickObjectByPoint = function (canvasX, canvasY) {
    // TODO
    //if (!this.renderOptions.pickingEnabled)
    //    return null;
    return this.renderer.getRenderObjectFromPickingBuffer(canvasX, canvasY);
};

/**
 *
 * @returns {HTMLElement}
 */
GLCanvasHandler.prototype.getPickedObject = function() {
    return this.renderer.pickedObject ? this.renderer.pickedObject.node : null;
};

/**
 * @param {number} canvasX
 * @param {number} canvasY
 * @return {vec3|null} The world space normal on the object's surface at the given coordinates
 */
GLCanvasHandler.prototype.getWorldSpaceNormalByPoint = function (canvasX, canvasY) {
    return this.renderer.getWorldSpaceNormalByPoint(canvasX, canvasY);
};

/**
 * @param {number} canvasX
 * @param {number} canvasY
 * @return {vec3|null} The world space position on the object's surface at the given coordinates
 */
GLCanvasHandler.prototype.getWorldSpacePositionByPoint = function (canvasX, canvasY) {
    return this.renderer.getWorldSpacePositionByPoint(canvasX, canvasY);
};

GLCanvasHandler.prototype.canvasSizeChanged = function () {
    var canvas = this._canvas;
    if (canvas.clientWidth !== this.lastKnownDimensions.width || canvas.clientHeight !== this.lastKnownDimensions.height) {

        this.lastKnownDimensions.width = canvas.width = canvas.clientWidth;
        this.lastKnownDimensions.height = canvas.height = canvas.clientHeight;
        this.renderer.handleResizeEvent(canvas.width, canvas.height);
        this.dispatchResizeEvent({width: canvas.width, height: canvas.height});
        return true;
    }
    return false;
};

var c_timer = window.performance || Date;

/**
 * Called by tick() to redraw the scene if needed
 */
GLCanvasHandler.prototype.draw = function () {
    XML3D.flushDOMChanges();
    try {
        var start = c_timer.now();
        var stats = this.renderer.renderToCanvas();
        var end = c_timer.now();


        var factory = xml3dFormatHandler.getFactory("webgl", this.id);
        var xml3dAdapter = factory.getAdapter(this._xml3dElement);
        xml3dAdapter.onFrameDrawn();
        this.dispatchFrameDrawnEvent(start, end, stats);

    } catch (e) {
        XML3D.debug.logException(e);
    }

};

GLCanvasHandler.prototype.getMousePosition = function (evt) {
    var rct = this._canvas.getBoundingClientRect();
    return {
        x: (evt.clientX - rct.left), y: (evt.clientY - rct.top)
    };
};

module.exports =  GLCanvasHandler;


},{"../../base/formathandler.js":9,"../../utils/options.js":132,"../renderer/canvas-handler.js":52}],81:[function(require,module,exports){
var GLProgramObject = require("../base/program.js");
var XflowUtils= require("../xflow/utils.js");

/**
 * A ShaderClosure connects a mesh-specific GLProgram with it's Xflow data
 * @param {GLContext} context
 * @constructor
 */
var AbstractShaderClosure = function (context) {
    /**
     * @private
     * @type {GLProgramObject|null}
     */
    this.program = null;
    this.context = context;
    /**
     * A flag used by shadercomposer to sort out obsolete shaderclosures
     * @type {boolean}
     */
    this.obsolete = false;
    this.id = "";

    this.uniformCollection = {
        envBase: {}, envOverride: null, sysBase: null
    };

    /**
     * Stores, if the underlying shader has semi-transparencies
     * and thus needs to considered for alpha-blending
     * @type {boolean}
     */
    this.isTransparent = false;

    /**
     * The source of a shader
     * @private
     * @type {{vertex: string, fragment: string}}
     */
    this.source = {
        vertex: "", fragment: ""
    }
};

Object.defineProperties(AbstractShaderClosure.prototype, {
        attributes: {
            writeable: false, get: function () {
                return this.program ? this.program.attributes : {}
            }
        }, uniforms: {
            writeable: false, get: function () {
                return this.program ? this.program.uniforms : {}
            }
        }, samplers: {
            writeable: false, get: function () {
                return this.program ? this.program.samplers : {}
            }
        }
    });
XML3D.createClass(AbstractShaderClosure, null, {

    equals: function (that) {
        return this.source.vertex === that.source.vertex && this.source.fragment === that.source.fragment;
    },

    hasTransparency: function () {
        return this.isTransparent;
    },

    compile: function () {
        if (!this.source.fragment || !this.source.vertex) {
            XML3D.debug.logError("No source found for shader", this);
            return;
        }

        var programObject = new GLProgramObject(this.context.gl, this.source);
        this.program = programObject;
        this.id = programObject.id;
    },

    bind: function () {
        this.program.bind();
    },

    unbind: function () {
        this.program.unbind();
    },

    isValid: function () {
        return this.program.isValid();
    },

    /**
     * @param {Xflow.ComputeResult} xflowResult
     */
    updateUniformsFromComputeResult: function (xflowResult) {
        var map = xflowResult.getOutputMap();

        var envBase = this.uniformCollection.envBase = {};
        this.setDefaultUniforms(this.uniformCollection.envBase);

        for (var name in map) {
            envBase[name] = XflowUtils.getGLUniformValueFromXflowDataEntry(map[name], this.context);
        }
        var names = Object.keys(envBase);
        this.setUniformVariables(names, null, this.uniformCollection);

        this.isTransparent = this.getTransparencyFromInputData(map);
    },

    setUniformVariables: function (envNames, sysNames, uniformCollection) {
        this.program.setUniformVariables(envNames, sysNames, uniformCollection);
    },

    setSystemUniformVariables: function (sysNames, sysValues) {
        this.uniformCollection.sysBase = sysValues;
        this.setUniformVariables(null, sysNames, this.uniformCollection);
    },

    changeUniformVariableOverride: function (prevOverride, newOverride) {
        var overrideNames = prevOverride ? Object.keys(prevOverride) : [];
        if (newOverride) overrideNames.push.apply(overrideNames, Object.keys(newOverride));
        this.uniformCollection.envOverride = newOverride;
        this.setUniformVariables(overrideNames, null, this.uniformCollection);
    }
});

module.exports = AbstractShaderClosure;


},{"../base/program.js":76,"../xflow/utils.js":119}],82:[function(require,module,exports){
var GLScene = require("../scene/glscene.js");
var GLLights = require("../scene/gllights.js");
var MaterialEvents = require("../materials/events.js");
var EventDispatcher = require("../../../contrib/EventDispatcher.js");
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var XC = require("../../../xflow/interface/constants.js");

/**
 * @interface
 */
var IShaderComposer = function () {
};

/**
 * @enum
 */
IShaderComposer.UpdateState = {
    SHADER_UPDATED: 1, SHADER_COMPILED: 2, SHADER_UNCHANGED: 3
};

IShaderComposer.State = {
    OK: 1, NO_SCRIPT: 2, NO_PROGRAM: 3
};

/**
 * @param {scene} scene
 * @param {{}=} opt
 */
IShaderComposer.prototype.update = function (scene, opt) {
};

/**
 *
 * @returns AbstractShaderClosure|null
 */
IShaderComposer.prototype.getShaderClosure = function (scene) {
    return null;
};

/**
 * @returns {Array.<string>}
 */
IShaderComposer.prototype.getRequestFields = function () {
    return [];
};

/**
 * @returns {{}}
 */
IShaderComposer.prototype.getShaderAttributes = function () {
    return {};
};

/**
 * @constructor
 */
var AbstractShaderComposer = function (context, shaderInfo) {
    this.context = context;
    this.shaderClosures = [];
    this.dataChanged = false;
    this.updateLightValues = false;
    this.request = null;
};

XML3D.createClass(AbstractShaderComposer, EventDispatcher, {

    // Implemented by subclass
    setShaderInfo: null,


    updateRequest: function (xflowDataNode) {
        if (this.request) this.request.clear();

        this.request = new ComputeRequest(xflowDataNode, this.getRequestFields(), this.onShaderRequestChange.bind(this));
        this.setShaderRecompile();
    },

    onShaderInfoChanged: function (shaderInfo) {
        this.setShaderInfo(shaderInfo);
        this.setShaderRecompile();
        this.context.requestRedraw("Shader script changed");
    },

    onShaderRequestChange: function (request, changeType) {
        this.dataChanged = true;
        if (changeType == XC.RESULT_STATE.CHANGED_STRUCTURE)
            this.setShaderRecompile();
        this.context.requestRedraw("Shader data changed");
    },

    /**
     * @param {Scene} scene
     * @param {{}=} opt
     */
    update: function (scene, opt) {
        opt = opt || {};
        var that = this;

        // Clean up shaderClosures that are not used!
        var i = this.shaderClosures.length;
        while (i--) {
            if (this.shaderClosures[i].obsolete) this.shaderClosures.splice(i, 1);
        }

        if (!this.shaderClosures.length)
            return;

        if (this.dataChanged) {
            var result = this.getShaderDataResult();
            this.shaderClosures.forEach(function (shader) {
                that.updateClosureFromComputeResult(shader, result);
            });
            this.dataChanged = false;
        }

        if (this.updateLightValues) {
            this.shaderClosures.forEach(function (shader) {
                that.updateClosureFromLightParameters(shader, scene);
            });
        }
    },

    /**
     * @param {AbstractShaderClosure} shaderClosure
     * @param {Xflow.ComputeResult} result
     */
    updateClosureFromComputeResult: function (shaderClosure, result) {
        if (!result || !result.getOutputMap) {
            return;
        }
        shaderClosure.bind();
        shaderClosure.updateUniformsFromComputeResult(result);
    },

    updateClosureFromLightParameters: function (shaderClosure, scene) {
        shaderClosure.bind();
        shaderClosure.setSystemUniformVariables(GLLights.ALL_PARAMETERS, scene.systemUniforms);
    },

    updateSystemUniforms: function (names, scene) {
        this.shaderClosures.forEach(function (shader) {
            shader.bind();
            shader.setSystemUniformVariables(names, scene.systemUniforms);
        });
    },


    createShaderClosure: function () {
        throw new Error("AbstractComposer::createShaderClosure needs to be overridden");
    },

    createObjectDataRequest: function (objectDataNode, callback) {
        throw new Error("AbstractComposer::createObjectDataRequest needs to be overridden");
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        throw new Error("AbstractComposer::distributeObjectShaderData needs to be overridden");
    },

    getShaderClosure: function (scene, vsRequest) {
        var shader = this.createShaderClosure();

        try {
            shader.createSources(scene, this.getShaderDataResult(), vsRequest)
        } catch (e) {
            throw new Error("Shader: " + e.message)
        }

        for (var i = 0; i < this.shaderClosures.length; i++) {
            if (this.shaderClosures[i].equals(shader)) {
                this.shaderClosures[i].obsolete = false;
                return this.shaderClosures[i];
            }
        }

        this.initializeShaderClosure(shader, scene);
        return shader;
    },

    initializeShaderClosure: function (shaderClosure, scene) {
        shaderClosure.compile();

        scene.dispatchEvent({type: MaterialEvents.MATERIAL_INITIALIZED});
        this.updateClosureFromComputeResult(shaderClosure, this.getShaderDataResult());
        this.updateClosureFromLightParameters(shaderClosure, scene);
        this.shaderClosures.push(shaderClosure);
    },

    setShaderRecompile: function () {

        for (var i = 0; i < this.shaderClosures.length; ++i) {
            this.shaderClosures[i].obsolete = true;
        }
        this.dispatchEvent({type: MaterialEvents.MATERIAL_STRUCTURE_CHANGED});
        this.dataChanged = true;
        this.updateLightValues = true;
    },


    /**
     * @returns {Xflow.ComputeResult|null}
     */
    getShaderDataResult: function () {
        return this.request ? this.request.getResult() : null;
    }


});


/**
 * @implements IShaderComposer
 * @constructor
 */
var DefaultComposer = function (context) {
    this.context = context;
};
XML3D.createClass(DefaultComposer, AbstractShaderComposer, {
    update: function () {
    },

    getShaderClosure: function (scene, vsRequest) {
        return this.context.programFactory.getFallbackProgram();
    },

    getShaderAttributes: function () {
        return {color: null, normal: null /* for picking */};
    },

    getRequestFields: function () {
        return ["diffuseColor", "useVertexColor"];
    },

    createObjectDataRequest: function (objectDataNode, callback) {
        return new ComputeRequest(objectDataNode, ["position", "color", "normal", "diffuseColor", "useVertexColor"], callback);
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        var result = objectRequest.getResult();

        var dataMap = result.getOutputMap(), requestFields = this.getRequestFields();
        for (var name in dataMap) {
            if (requestFields.indexOf(name) != -1)
                uniformCallback(name, dataMap[name]); else
                attributeCallback(name, dataMap[name]);
        }
    }
});


module.exports = {
    AbstractShaderComposer: AbstractShaderComposer,
    DefaultComposer: DefaultComposer
}


},{"../../../contrib/EventDispatcher.js":11,"../../../xflow/interface/constants.js":136,"../../../xflow/interface/request.js":139,"../materials/events.js":83,"../scene/gllights.js":114,"../scene/glscene.js":115}],83:[function(require,module,exports){
module.exports = {
    MATERIAL_STRUCTURE_CHANGED: "material_structure_changed",
    MATERIAL_INITIALIZED: "material_initialized"
};

},{}],84:[function(require,module,exports){
var AbstractShaderClosure = require("./../abstractshaderclosure.js");
var JSShaderComposer = require("./jsshadercomposer.js");
var SystemNotifier = require("../../system/system-notifier.js");
var getJSSystemConfiguration = require("./jssystemconfiguration.js");
var XC = require("../../../../xflow/interface/constants.js");
var Options = require("../../../../utils/options.js");

var c_SystemUpdate = {
    "pointLightOn": {
        staticValue: "MAX_POINTLIGHTS",
        staticSize: ["pointLightOn", "pointLightAttenuation", "pointLightIntensity", "pointLightPosition", "pointLightCastShadow", "pointLightShadowBias", "pointLightShadowMap", "pointLightMatrix", "pointLightNearFar"]
    }, "directionalLightOn": {
        staticValue: "MAX_DIRECTIONALLIGHTS",
        staticSize: ["directionalLightOn", "directionalLightIntensity", "directionalLightDirection", "directionalLightCastShadow", "directionalLightShadowBias", "directionalLightShadowMap", "directionalLightMatrix"]
    }, "spotLightOn": {
        staticValue: "MAX_SPOTLIGHTS",
        staticSize: ["spotLightOn", "spotLightAttenuation", "spotLightIntensity", "spotLightPosition", "spotLightDirection", "spotLightCosFalloffAngle", "spotLightCosSoftFalloffAngle", "spotLightCastShadow", "spotLightShadowBias", "spotLightShadowMap", "spotLightMatrix"]
    }
};

var c_jsShaderCache = {};


function convertEnvName(name) {
    return ("_env_" + name).replace(/_+/g, "_");
}

function addDefaultChanneling(vsConfig, inputName) {
    var outputName = convertEnvName(inputName);
    vsConfig.channelAttribute(inputName, outputName, null);
}


function channelVsAttribute(vsConfig, inputName, spaceInfo) {
    if (!spaceInfo || !spaceInfo[inputName]) {
        addDefaultChanneling(vsConfig, inputName);
        return;
    }

    var i = spaceInfo[inputName].length;
    while (i--) {
        var entry = spaceInfo[inputName][i];
        var outputName = convertEnvName(entry.name), code = null;
        switch (entry.space) {
            case Shade.SPACE_VECTOR_TYPES.OBJECT:
                break;
            case Shade.SPACE_VECTOR_TYPES.VIEW_POINT:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT4X4, "modelViewMatrix", true);
                code = outputName + " = ( modelViewMatrix * vec4(#I{" + inputName + "}, 1.0) ).xyz;";
                break;
            case Shade.SPACE_VECTOR_TYPES.VIEW_NORMAL:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT3X3, "modelViewMatrixN", true);
                code = outputName + " = normalize( modelViewMatrixN * #I{" + inputName + "} );";
                break;
            case Shade.SPACE_VECTOR_TYPES.WORLD_POINT:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT4X4, "modelMatrix", true);
                code = outputName + " = ( modelMatrix * vec4(#I{" + inputName + "}, 1.0) ).xyz;";
                break;
            case Shade.SPACE_VECTOR_TYPES.WORLD_NORMAL:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT3X3, "modelMatrixN", true);
                code = outputName + " = normalize( modelMatrixN * #I{" + inputName + "} );";
                break;
            default:
                throw new Error("Can't handle Space Type: " + entry.space);
        }
        vsConfig.channelAttribute(inputName, outputName, code);
    }
}


/**
 * @param {XC.DATA_TYPE} xflowType
 */
var convertXflow2ShadeType = function (xflowType, source) {
    var result = {}
    switch (xflowType) {
        case XC.DATA_TYPE.BOOL:
            result.type = Shade.TYPES.BOOLEAN;
            break;
        case XC.DATA_TYPE.INT:
            result.type = Shade.TYPES.INT;
            break;
        case XC.DATA_TYPE.FLOAT:
            result.type = Shade.TYPES.NUMBER;
            break;
        case XC.DATA_TYPE.FLOAT2:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.FLOAT2;
            break;
        case XC.DATA_TYPE.FLOAT3:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.FLOAT3;
            break;
        case XC.DATA_TYPE.FLOAT4:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.FLOAT4;
            break;
        case XC.DATA_TYPE.FLOAT3X3:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.MATRIX3;
            break;
        case XC.DATA_TYPE.FLOAT4X4:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.MATRIX4;
            break;
        case XC.DATA_TYPE.TEXTURE:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.TEXTURE;
            break;
        case XC.DATA_TYPE.UNKNOWN:
        default:
            throw new Error("Unknown Xflow DataType: " + xflowType);
    }
    result.source = source;
    return result;
}

/**
 * @param context
 * @param sourceTemplate
 * @param dataCallback
 * @constructor
 */
var JSShaderClosure = function (context, sourceTemplate, extractedParams) {
    AbstractShaderClosure.call(this, context);
    this.sourceTemplate = sourceTemplate;
    this.extractedParams = extractedParams;
    this.uniformSetter = function () {
    };
    this.uniformConverter = [];
};

XML3D.createClass(JSShaderClosure, AbstractShaderClosure, {
    /**
     *
     * @param {GLScene} scene
     * @param {Xflow.ComputeResult} shaderResult
     * @param objectData
     */
    createSources: function (scene, shaderResult, vsRequest) {

        var vsDataResult = vsRequest.getResult();

        var contextData = {
            "this": getJSSystemConfiguration(this.context),
            "global.shade": [{"extra": {"type": "object", "kind": "any", "global": true, "info": {}}}]
        };

        var systemUniforms = scene.systemUniforms, systemInfo = contextData["this"].info;
        for (var systemSource in c_SystemUpdate) {
            var entry = c_SystemUpdate[systemSource];
            var length = systemUniforms[systemSource] && systemUniforms[systemSource].length;
            systemInfo[entry.staticValue].staticValue = length;
            for (var i = 0; i < entry.staticSize.length; ++i)
                systemInfo[entry.staticSize[i]].staticSize = length;
        }

        var contextInfo = contextData["global.shade"][0].extra.info;

        var shaderEntries = shaderResult && shaderResult.getOutputMap(), vsShaderOutput = vsDataResult && vsDataResult.outputNames;

        for (var i = 0; i < this.extractedParams.length; ++i) {
            var paramName = this.extractedParams[i];
            if (vsShaderOutput && vsShaderOutput.indexOf(paramName) != -1) {
                contextInfo[paramName] = convertXflow2ShadeType(vsDataResult.getOutputType(paramName), vsDataResult.isOutputUniform(paramName) ? Shade.SOURCES.UNIFORM : Shade.SOURCES.VERTEX);
            } else if (shaderEntries && shaderEntries[paramName]) {
                contextInfo[paramName] = convertXflow2ShadeType(shaderEntries[paramName].type, Shade.SOURCES.UNIFORM);
            }
        }
        XML3D.debug.logDebug("CONTEXT:", contextData);

        var options = {
            propagateConstants: true,
            validate: true,
            sanitize: true,
            transformSpaces: Options.getValue("shadejs-transformSpaces"),
            extractUniformExpressions: Options.getValue("shadejs-extractUniformExpressions")
        };
        var compileOptions = {
            useStatic: true, uniformExpressions: options.uniformExpressions
        };
        var implementation = scene.deferred ? "xml3d-glsl-deferred" : "xml3d-glsl-forward";

        var jsShaderKey = implementation + ";" + JSON.stringify(options) + ";" + JSON.stringify(contextInfo) + ";" + this.sourceTemplate;

        var cacheEntry;
        if (!(cacheEntry = c_jsShaderCache[jsShaderKey])) {
            try {
                var workSet = new Shade.WorkingSet();
                workSet.parse(this.sourceTemplate, {loc: true});
                workSet.analyze(contextData, implementation, options);
                var spaceInfo = workSet.getProcessingData('spaceInfo');
                var glslShader = workSet.compileFragmentShader(compileOptions);

                cacheEntry = {
                    source: glslShader.source, uniformSetter: glslShader.uniformSetter, spaceInfo: spaceInfo
                }

                this.uniformSetter = glslShader.uniformSetter;
                this.source = {
                    fragment: glslShader.source, vertex: this.createVertexShader(vsRequest, vsDataResult, spaceInfo)
                }
                if (scene.deferred) {
                    cacheEntry.signatures = workSet.getProcessingData("colorClosureSignatures");
                }
                if (Options.getValue("shadejs-cache"))
                    c_jsShaderCache[jsShaderKey] = cacheEntry;
            } catch (e) {
                SystemNotifier.sendEvent('shadejs', {
                    shadejsType: "error", event: e, code: this.sourceTemplate
                });

                var errorMessage = "Shade.js Compile Error:\n" + e.message + "\n------------\n" + "Shader Source:" + "\n------------\n" + XML3D.debug.formatSourceCode(this.sourceTemplate);
                throw new Error(errorMessage);
            }
        }
        this.source = {
            fragment: cacheEntry.source, vertex: this.createVertexShader(vsRequest, vsDataResult, cacheEntry.spaceInfo)
        }
        this.uniformSetter = cacheEntry.uniformSetter;
        if (scene.deferred) {
            scene.colorClosureSignatures.push.apply(scene.colorClosureSignatures, cacheEntry.signatures);
        }

        // TODO: Handle errors.
        XML3D.debug.logDebug(this.source.vertex);
        XML3D.debug.logDebug(this.source.fragment);

        SystemNotifier.sendEvent('shadejs', {
            shadejsType: "success", vertexShader: this.source.vertex, fragmentShader: this.source.fragment
        });

        return true;
    },

    createVertexShader: function (vsRequest, vsDataResult, spaceInfo) {
        var vsConfig = vsRequest.getConfig();
        var names = vsDataResult.outputNames;
        for (var i = 0; i < names.length; ++i) {
            channelVsAttribute(vsConfig, names[i], spaceInfo);
        }
        vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT4X4, "modelViewProjectionMatrix", true);
        vsConfig.addCodeFragment("gl_Position = modelViewProjectionMatrix * vec4(#I{position}, 1.0);");
        return vsRequest.getVertexShader().getGLSLCode();
    },

    setUniformVariables: function (envNames, sysNames, inputCollection) {
        this.uniformSetter(envNames, sysNames, inputCollection, this.program.setUniformVariable.bind(this.program));
    },

    getTransparencyFromInputData: function (dataMap) {
        // TODO: Compute Transparency
        return false;
    },

    /* Default values are compiled into shade.js */
    setDefaultUniforms: function () {
    }

});
module.exports = JSShaderClosure;


},{"../../../../utils/options.js":132,"../../../../xflow/interface/constants.js":136,"../../system/system-notifier.js":118,"./../abstractshaderclosure.js":81,"./jsshadercomposer.js":85,"./jssystemconfiguration.js":86}],85:[function(require,module,exports){
var AbstractShaderComposer = require("./../abstractshadercomposer.js").AbstractShaderComposer;
var JSShaderClosure = require("./jsshaderclosure.js");
var VSConfig = require("../../../../xflow/processing/vs-connect.js").VSConfig;
var VertexShaderRequest = require("../../../../xflow/interface/request.js").VertexShaderRequest;
var XC = require("../../../../xflow/interface/constants.js");

/**
 *
 * @param {GLContext} context
 * @param {MaterialConfiguration} config
 * @extends AbstractShaderComposer
 * @constructor
 */
var JSShaderComposer = function (context, config) {
    AbstractShaderComposer.call(this, context, config);

    if (!window.Shade)
        throw new Error("shade.js library not found");

    this.context = context;

    /** @type string*/
    this.sourceTemplate = config.model.script;

    /**
     * @private
     * @type {Array.<string>}
     */
    this.extractedParams = [];

    /**
     * @private
     * @type {Xflow.ComputeRequest|null}
     */
    this.request = null;

    this.setShaderInfo(config);
};

JSShaderComposer.convertSysName = function (name) {
    return name;
};

XML3D.createClass(JSShaderComposer, AbstractShaderComposer, {
    setShaderInfo: function (config) {
        try {
            this.extractedParams = Shade.extractParameters(this.sourceTemplate, {implementation: "xml3d-glsl-forward"}).shaderParameters;
            // FIXME: Shader.js should always request position (in case
        } catch (e) {
            // We ignore errors here. They will reoccur when updating connected mesh closures
            this.extractedParams = [];
        }
        if (this.extractedParams.indexOf("position") == -1) this.extractedParams.push("position");

        // The composer is interested in changes of all possible shader parameters (extracted)
        // the instances (closures) will only set those, that occur in the instance
        if (this.extractedParams.length) {
            this.updateRequest(config.dataNode);
        }
    },

    getRequestFields: function () {
        return this.extractedParams;
    },

    getShaderAttributes: function () {
        return {color: null, normal: null, texcoord: null};
    },

    createShaderClosure: function () {
        return new JSShaderClosure(this.context, this.sourceTemplate, this.extractedParams);
    },

    createObjectDataRequest: function (objectDataNode, callback) {

        var vsConfig = new VSConfig();
        var names = this.extractedParams.slice();
        //if(names.indexOf("position") == -1) names.push("position");
        vsConfig.addAttribute(XC.DATA_TYPE.FLOAT3, "position", true);
        for (var i = 0; i < names.length; ++i) {
            var name = names[i];
            if (name == "position") continue;
            var xflowInfo = objectDataNode.getOutputChannelInfo(name);
            if (xflowInfo) {
                vsConfig.addAttribute(xflowInfo.type, name, true);
            }
        }
        return new VertexShaderRequest(objectDataNode, vsConfig, callback);
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        var vertexShader = objectRequest.getVertexShader();
        var inputNames = vertexShader.inputNames;
        var i, name, entry;

        for (i = 0; i < inputNames.length; ++i) {
            name = inputNames[i];
            entry = vertexShader.getInputData(name);
            if (vertexShader.isInputUniform(name))
                uniformCallback(name, entry); else
                attributeCallback(name, entry);
        }
        var outputNames = vertexShader.outputNames;
        for (i = 0; i < outputNames.length; ++i) {
            name = outputNames[i];
            if (vertexShader.isOutputFragmentUniform(name)) {
                uniformCallback(vertexShader.getOutputSourceName(name), vertexShader.getUniformOutputData(name));
            }
        }
    }

});


module.exports = JSShaderComposer;



},{"../../../../xflow/interface/constants.js":136,"../../../../xflow/interface/request.js":139,"../../../../xflow/processing/vs-connect.js":186,"./../abstractshadercomposer.js":82,"./jsshaderclosure.js":84}],86:[function(require,module,exports){
var GLContext = require("../../base/context.js");
var singleton = null;

var SYSTEM_CONTEXT_TEMPLATE = {
    "type": "object", "kind": "any", "info": {
        "coords": {"type": "object", "kind": "float3", "source": "uniform"},
        "cameraPosition": {"type": "object", "kind": "float3", "source": "uniform"},
        "viewMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "viewInverseMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelViewMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelViewProjectionMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelMatrixN": {"type": "object", "kind": "matrix3", "source": "uniform"},
        "modelViewMatrixN": {"type": "object", "kind": "matrix3", "source": "uniform"},

        "MAX_POINTLIGHTS": {"type": "int", "source": "constant", "staticValue": 5},
        "pointLightOn": {"type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"},
        "pointLightAttenuation": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightIntensity": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightPosition": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightCastShadow": {
            "type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightShadowBias": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightShadowMap": {
            "type": "array", "elements": {"type": "object", "kind": "texture"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightMatrix": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },
        "pointLightProjection": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },
        "pointLightNearFar": {
            "type": "array",
            "elements": {"type": "object", "kind": "float2"},
            "staticSize": 5,
            "source": "uniform"
        },

        "MAX_DIRECTIONALLIGHTS": {"type": "int", "source": "constant", "staticValue": 5},
        "directionalLightOn": {"type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"},
        "directionalLightIntensity": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightDirection": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightCastShadow": {
            "type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightShadowBias": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightShadowMap": {
            "type": "array", "elements": {"type": "object", "kind": "texture"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightMatrix": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },

        "MAX_SPOTLIGHTS": {"type": "int", "source": "constant", "staticValue": 5},
        "spotLightOn": {"type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"},
        "spotLightAttenuation": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightIntensity": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightPosition": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightDirection": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightCosFalloffAngle": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightCosSoftFalloffAngle": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightCastShadow": {
            "type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightShadowBias": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightShadowMap": {
            "type": "array", "elements": {"type": "object", "kind": "texture"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightMatrix": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },
        "ssaoMap": {"type": "object", "kind": "texture", "source": "uniform"},
        "environment": {"type": "object", "kind": "texture", "source": "uniform"}
    }
};

function createSystemConfiguration(context) {
    var result = SYSTEM_CONTEXT_TEMPLATE;
    var ext = context.getExtensionByName(GLContext.EXTENSIONS.STANDARD_DERIVATES);
    if (ext) {
        result.info.fwidth = {type: Shade.TYPES.FUNCTION};
        result.info.dx = {type: Shade.TYPES.FUNCTION};
        result.info.dy = {type: Shade.TYPES.FUNCTION};
    }
    return result;
}


module.exports = function (context) {
    if (!singleton) {
        singleton = createSystemConfiguration(context);
    }
    return singleton;
};




},{"../../base/context.js":73}],87:[function(require,module,exports){
var JSShaderComposer = require("./js/jsshadercomposer.js");
var URNShaderComposer = require("./urn/urnshadercomposer.js");
var DefaultComposer = require("./abstractshadercomposer.js").DefaultComposer;

/**
 * @param {GLContext} context
 * @constructor
 */
var ShaderComposerFactory = function (context) {
    this.context = context;
    /** @type {Object.<number, IShaderComposer>} */
    this.composers = {};
    this.defaultComposer = new DefaultComposer(context);
    this.lightValuesDirty = true;
};


XML3D.extend(ShaderComposerFactory.prototype, {
    /**
     *
     * @param {MaterialConfiguration} materialConfiguration
     * @returns {IShaderComposer}
     */
    createComposerFromMaterialConfiguration: function (materialConfiguration) {
        if (!materialConfiguration) {
            return this.defaultComposer;
        }
        var result = this.composers[materialConfiguration.id];
        if (!result) {
            try {
                var modelType = materialConfiguration.model.type;
                switch (modelType) {
                    case "urn":
                        result = new URNShaderComposer(this.context, materialConfiguration);
                        break;
                    case "text/javascript":
                    case "application/javascript":
                    case "text/shade-javascript":
                        result = new JSShaderComposer(this.context, materialConfiguration);
                        break;
                    default:
                        XML3D.debug.logError("Can not create shader of type:", modelType, materialConfiguration.model)
                }

            } catch (e) {
                XML3D.debug.logError("No shader could be created for '" + materialConfiguration.name + "':", e.message);
                result = this.defaultComposer;
            }
            if (result) {
                this.composers[materialConfiguration.id] = result;
                this.context.getStatistics().materials++;
            }
            return result || this.defaultComposer;
        }
        return result;
    },

    getTemplateById: function (id) {
        return this.composers[id];
    },

    update: function (scene) {
        for (var i in this.composers) {
            this.composers[i].update(scene, {updateLightValues: this.lightValuesDirty});
        }
        this.lightValuesDirty = false;
    },

    setLightStructureDirty: function () {
        this.setShaderRecompile();
    },

    setShaderRecompile: function () {
        for (var i in this.composers) {
            this.composers[i].setShaderRecompile();
        }
    },

    updateSystemUniforms: function (names, scene) {
        for (var i in this.composers) {
            this.composers[i].updateSystemUniforms(names, scene);
        }
    },

    setLightValueChanged: function () {
        for (var i in this.composers) {
            this.composers[i].updateLightValues = true;
        }
    }

});

module.exports = ShaderComposerFactory;



},{"./abstractshadercomposer.js":82,"./js/jsshadercomposer.js":85,"./urn/urnshadercomposer.js":96}],88:[function(require,module,exports){
var EVENT_TYPE = require("../../renderer/scene/constants.js").EVENT_TYPE;
var Targets = require("../base/rendertarget");

var LightPass = require("../render-passes/light-pass");
var PointLightPass = require("../render-passes/pointlight-pass");

/**
 * @param {GLContext} context
 * @param {GLScene} scene
 * @constructor
 */
var ShadowMapService = function (context, scene) {
    this.context = context;
    scene.addEventListener(EVENT_TYPE.LIGHT_STRUCTURE_CHANGED, this.onLightStructureChanged.bind(this));
    scene.addEventListener(EVENT_TYPE.LIGHT_VALUE_CHANGED, this.onLightValueChanged.bind(this));
    scene.addEventListener(EVENT_TYPE.SCENE_SHAPE_CHANGED, this.onSceneShapeChanged.bind(this));

    this.shadowMapInfos = [];
    this.dirty = true;
};

XML3D.extend(ShadowMapService.prototype, {
    onLightStructureChanged: function (event) {
        var light = event.light, remove = light.removed, shadowMapInfos = this.shadowMapInfos;
        if (remove) {
            removeLight(shadowMapInfos, light);
        } else {
            if (lightNeedsShadowMap(light)) {
                addLight(shadowMapInfos, light);
                this.requestRendering("light added");
            }
        }
    },

    onLightValueChanged: function () {
        this.requestRendering("light value changed");
    },

    onSceneShapeChanged: function () {
        this.requestRendering("scene shape changed");
    },

    requestRendering: function(reason) {
        this.dirty = true;
    },

    updateForRendering: function() {
        if(this.dirty) {
            var shadowMaps = this.shadowMapInfos;
            for (var i = 0; i < shadowMaps.length; i++) {
                shadowMaps[i].pass.renderScene();
            }
            this.dirty = false;
        }
    },

    fillGlobalParameters: function(globals) {
        var shadowUnits = mergeShadowParameters(this.shadowMapInfos)
        XML3D.extend(globals, shadowUnits);
    }

});

function lightNeedsShadowMap(light) {
    return !!light.model.getParameter("castShadow")[0];
}

function addLight(shadowMapInfos, light) {
    var context = light.scene.context;
    var passInfo = createPassInfo(light, context);
    shadowMapInfos.push(passInfo);
}


function removeLight(shadowMapInfos, light) {
    for (var i = 0; i < shadowMapInfos.length; i++) {
        if (shadowMapInfos[i].light === light) {
            shadowMapInfos.splice(index, 1);
            // TODO: Free pass and other resources, free texture slot
            return;
        }
    }
}

function createPassInfo(light, context) {
    var size = Math.max(context.canvasTarget.width, context.canvasTarget.height) * 2;
    var params = {
        width: size,
        height: size,
        colorFormat: context.gl.RGBA,
        depthFormat: context.gl.DEPTH_COMPONENT16,
        stencilFormat: null,
        depthAsRenderbuffer: true
    };

    var pass = light.model.id == "point" ? createPointLightPass(light, context, params) : createLightPass(light, context, params);
    pass.init(context);

    // Bind target in order to create texture map
    pass.output.bind();

    // TODO: Better way to fix the texture unit?
    var unitEntry = context.textureManager.getEntry(pass.output.colorTarget.handle.id);
    unitEntry.fixed = true;

    pass.output.unbind();

    return {
        light: light, pass: pass, slot: unitEntry.slot
    };
}


function createLightPass(light, context, params) {
    var lightFramebuffer = new Targets.GLRenderTarget(context, params);
    return new LightPass({context: context}, lightFramebuffer, light);
}

function createPointLightPass(light, context, params) {
    var lightFramebuffer = new Targets.GLCubeMapRenderTarget(context, params);
    return new PointLightPass({context: context}, lightFramebuffer, light);
}

function mergeShadowParameters(shadowMapInfos) {
    var result = {};
    ["spot", "point", "directional"].forEach(function(model) {
        var sameModel = shadowMapInfos.filter(function(info) { return info.light.model.id == model; })
        result[model + "LightShadowMap"] = sameModel.map(function (info) {
            return info.slot;
        });
    });
    return result;
}

module.exports = ShadowMapService;

},{"../../renderer/scene/constants.js":59,"../base/rendertarget":77,"../render-passes/light-pass":102,"../render-passes/pointlight-pass":106}],89:[function(require,module,exports){
XML3D.shaders.register("diffuse", {

    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec3 color;",
        "attribute vec2 texcoord;",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat3 modelViewMatrixN;",
        "uniform vec3 eyePosition;",

        "void main(void) {",
        "    vec3 pos = position;",
        "    vec3 norm = normal;",

        "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);",
        "    fragNormal = normalize(modelViewMatrixN * norm);",
        "    fragVertexPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;",
        "    fragEyeVector = normalize(fragVertexPosition);",
        "    fragTexCoord = texcoord;",
        "    fragVertexColor = color;",
        "}"
    ].join("\n"),

    fragment : [
        "uniform float ambientIntensity;",
        "uniform vec3 diffuseColor;",
        "uniform vec3 emissiveColor;",
        "uniform float transparency;",
        "uniform mat4 viewMatrix;",
        "uniform bool useVertexColor;",

        "#if HAS_EMISSIVETEXTURE",
        "uniform sampler2D emissiveTexture;",
        "#endif",
        "#if HAS_DIFFUSETEXTURE",
        "uniform sampler2D diffuseTexture;",
        "#endif",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "#if MAX_POINTLIGHTS > 0",
        "uniform vec3 pointLightAttenuation[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightPosition[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightIntensity[MAX_POINTLIGHTS];",
        "uniform bool pointLightOn[MAX_POINTLIGHTS];",
        "#endif",

        "#if MAX_DIRECTIONALLIGHTS > 0",
        "uniform vec3 directionalLightDirection[MAX_DIRECTIONALLIGHTS];",
        "uniform vec3 directionalLightIntensity[MAX_DIRECTIONALLIGHTS];",
        "uniform bool directionalLightOn[MAX_DIRECTIONALLIGHTS];",
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "uniform vec3 spotLightAttenuation[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightPosition[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightIntensity[MAX_SPOTLIGHTS];",
        "uniform bool spotLightOn[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightDirection[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosFalloffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosSoftFalloffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightSoftness[MAX_SPOTLIGHTS];",
        "#endif",

        "void main(void) {",
        "  float alpha =  max(0.0, 1.0 - transparency);",
        "  vec3 objDiffuse = diffuseColor;",
        "  if(useVertexColor)",
        "    objDiffuse *= fragVertexColor;",
        "  #if HAS_DIFFUSETEXTURE",
        "    vec4 texDiffuse = texture2D(diffuseTexture, fragTexCoord);",
        "    alpha *= texDiffuse.a;",
        "    objDiffuse *= texDiffuse.rgb;",
        "  #endif",
        "  if (alpha < 0.05) discard;",

        "  #if HAS_EMISSIVETEXTURE",
        "    vec3 color = emissiveColor * texture2D(emissiveTexture, fragTexCoord).rgb + (ambientIntensity * objDiffuse);",
        "  #else",
        "    vec3 color = emissiveColor + (ambientIntensity * objDiffuse);",
        "  #endif",

        "  #if MAX_POINTLIGHTS > 0",
        "    for (int i=0; i<MAX_POINTLIGHTS; i++) {",
        "      if (!pointLightOn[i])",
        "         continue;",
        "      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
        "      vec3 L = lPosition.xyz - fragVertexPosition;",
        "      float dist = length(L);",
        "      L = normalize(L);",
        "      float atten = 1.0 / (pointLightAttenuation[i].x + pointLightAttenuation[i].y * dist + pointLightAttenuation[i].z * dist * dist);",
        "      vec3 Idiff = pointLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "      color = color + atten*Idiff;",
        "    }",
        "  #endif",

        "#if MAX_DIRECTIONALLIGHTS > 0",
        "  for (int i=0; i<MAX_DIRECTIONALLIGHTS; i++) {",
        "      if (!directionalLightOn[i])",
        "         continue;",
        "    vec4 lDirection = viewMatrix * vec4(directionalLightDirection[i], 0.0);",
        "    vec3 L =  normalize(-lDirection.xyz);",
        "    vec3 Idiff = directionalLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "    color = color + Idiff;",
        "  }",
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "  for (int i=0; i<MAX_SPOTLIGHTS; i++) {",
        "      if (!spotLightOn[i])",
        "         continue;",
        "    vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
        "    vec3 L = lPosition.xyz - fragVertexPosition;",
        "    float dist = length(L);",
        "    L = normalize(L);",
        "    float atten = 1.0 / (spotLightAttenuation[i].x + spotLightAttenuation[i].y * dist + spotLightAttenuation[i].z * dist * dist);",
        "    vec3 Idiff = spotLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "    vec4 lDirection = viewMatrix * vec4(-spotLightDirection[i], 0.0);",
        "    vec3 D = normalize(lDirection.xyz);",
        "    float angle = dot(L, D);",
        "    if(angle > spotLightCosFalloffAngle[i]) {",
        "       float softness = 1.0;",
        "       if (angle < spotLightCosSoftFalloffAngle[i])",
        "           softness = (angle - spotLightCosFalloffAngle[i]) /  (spotLightCosSoftFalloffAngle[i] -  spotLightCosFalloffAngle[i]);",
        "       color += atten * softness * Idiff;",
        "    }",
        "  }",
        "#endif",

        "  gl_FragColor = vec4(color, alpha);",
        "}"
    ].join("\n"),

    addDirectives: function(directives, lights, params) {
        ["point", "directional", "spot"].forEach(function (type) {
            var numLights = lights.getModelCount(type);
            directives.push("MAX_" + type.toUpperCase() + "LIGHTS " + numLights);
        });
        directives.push("HAS_DIFFUSETEXTURE " + ('diffuseTexture' in params ? "1" : "0"));
        directives.push("HAS_EMISSIVETEXTURE " + ('emissiveTexture' in params ? "1" : "0"));
    },
    hasTransparency: function(params) {
        return params.transparency && params.transparency.getValue()[0] > 0.001;
    },
    uniforms: {
        diffuseColor    : [1.0, 1.0, 1.0],
        emissiveColor   : [0.0, 0.0, 0.0],
        transparency    : 0.0,
        ambientIntensity: 0.0,
        useVertexColor : false
    },
    samplers: {
        diffuseTexture : null,
        emissiveTexture : null
    },
    attributes: {
        normal : {
            required: true
        },
        texcoord: null,
        color: null
    }
});

},{}],90:[function(require,module,exports){
XML3D.shaders.register("matte", {

    vertex: [
        "attribute vec3 position;",
        "attribute vec3 color;",

        "varying vec3 fragVertexColor;",

        "uniform mat4 modelViewProjectionMatrix;",

        "void main(void) {",
        "   fragVertexColor = color;",
        "   gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment: [
        "uniform vec3 diffuseColor;",
        "uniform bool useVertexColor;",

        "varying vec3 fragVertexColor;",

        "void main(void) {",
        "    vec3 color = diffuseColor;",
        "    if (useVertexColor)",
        "       color *=  fragVertexColor;",
        "    gl_FragColor = vec4(color, 1.0);",
        "}"
    ].join("\n"),

    uniforms: {
        diffuseColor : [1.0, 1.0, 1.0],
        useVertexColor: false
    },
    attributes: {
        color: null,
        normal: null // For picking
    }
});

XML3D.shaders.register("flat", XML3D.shaders.getScript("matte"));

},{}],91:[function(require,module,exports){
XML3D.shaders.register("phong", {

    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec3 color;",
        "attribute vec2 texcoord;",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "#if (HAS_POINTLIGHT_SHADOWMAPS || HAS_DIRECTIONALLIGHT_SHADOWMAPS || HAS_SPOTLIGHT_SHADOWMAPS)",
        "varying vec3 fragWorldPosition;", //needed by any of the light types
        "#endif",

        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat3 modelViewMatrixN;",
        "uniform vec3 eyePosition;",

        "void main(void) {",
        "    vec3 pos = position;",
        "    vec3 norm = normal;",
        "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);",
        "    fragNormal = normalize(modelViewMatrixN * norm);",
        "    fragVertexPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;",
        "    fragEyeVector = normalize(fragVertexPosition);",
        "    fragTexCoord = texcoord;",
        "    fragVertexColor = color;",
        "#if (HAS_POINTLIGHT_SHADOWMAPS || HAS_DIRECTIONALLIGHT_SHADOWMAPS || HAS_SPOTLIGHT_SHADOWMAPS)",
        "    fragWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;",
        "#endif",
        "}"
    ].join("\n"),

    fragment : [
        "uniform float ambientIntensity;",
        "uniform vec3 diffuseColor;",
        "uniform vec3 emissiveColor;",
        "uniform float shininess;",
        "uniform vec3 specularColor;",
        "uniform float transparency;",
        "uniform mat4 viewMatrix;",
        "uniform bool useVertexColor;",
		"uniform vec3 coords;",

        "#if HAS_EMISSIVETEXTURE",
        "uniform sampler2D emissiveTexture;",
        "#endif",
        "#if HAS_DIFFUSETEXTURE",
        "uniform sampler2D diffuseTexture;",
        "#endif",
        "#if HAS_SPECULARTEXTURE",
        "uniform sampler2D specularTexture;",
        "#endif",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "#if (HAS_POINTLIGHT_SHADOWMAPS || HAS_DIRECTIONALLIGHT_SHADOWMAPS || HAS_SPOTLIGHT_SHADOWMAPS)",
        "varying vec3 fragWorldPosition;",  //if there is Shadow we need world position and unpacking function
        "float unpackDepth( const in vec4 rgba_depth ) {",
        "  const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
        "  float depth = dot( rgba_depth, bit_shift );",
        "  return depth;",
        "}",
        "#endif",

        "#if MAX_POINTLIGHTS > 0",
        "uniform vec3 pointLightAttenuation[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightPosition[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightIntensity[MAX_POINTLIGHTS];",
        "uniform bool pointLightOn[MAX_POINTLIGHTS];",
        "uniform bool pointLightCastShadow[MAX_POINTLIGHTS];",
            "#if HAS_POINTLIGHT_SHADOWMAPS",
            "uniform samplerCube pointLightShadowMap[MAX_POINTLIGHTS];",
            "uniform float pointLightShadowBias[MAX_POINTLIGHTS];",
            "uniform vec2 pointLightNearFar[MAX_POINTLIGHTS];",
            "float vecToDepth(vec3 vec, float n, float f){",
                "vec3 absVec = abs(vec);" +
                "float maxComp = max(absVec.x, max(absVec.y, absVec.z));",
                "float res = (f+n)/(f-n)-(2.0*f*n)/(f-n)/maxComp;",
                "return res*0.5+0.5;",
            "}",
            "#endif",
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "uniform vec3 spotLightAttenuation[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightPosition[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightIntensity[MAX_SPOTLIGHTS];",
        "uniform bool spotLightOn[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightDirection[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosFalloffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosSoftFalloffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightSoftness[MAX_SPOTLIGHTS];",
        "uniform bool spotLightCastShadow[MAX_SPOTLIGHTS];",
            "#if HAS_SPOTLIGHT_SHADOWMAPS",
            "uniform mat4 spotLightMatrix[ MAX_SPOTLIGHTS ];",//used for shadowmapcoord calculation
            "uniform sampler2D spotLightShadowMap[MAX_SPOTLIGHTS];",
            "uniform float spotLightShadowBias[MAX_SPOTLIGHTS];",
            "#endif",
        "#endif",


        "#if MAX_DIRECTIONALLIGHTS > 0",
        "uniform vec3 directionalLightDirection[MAX_DIRECTIONALLIGHTS];",
        "uniform vec3 directionalLightIntensity[MAX_DIRECTIONALLIGHTS];",
        "uniform bool directionalLightOn[MAX_DIRECTIONALLIGHTS];",
        "uniform bool directionalLightCastShadow[MAX_DIRECTIONALLIGHTS];",
            "#if HAS_DIRECTIONALLIGHT_SHADOWMAPS",
            "uniform mat4 directionalLightMatrix[MAX_DIRECTIONALLIGHTS];",
            "uniform sampler2D directionalLightShadowMap[MAX_DIRECTIONALLIGHTS];",
            "uniform float directionalLightShadowBias[MAX_DIRECTIONALLIGHTS];",
            "#endif",
        "#endif",


		"uniform sampler2D ssaoMap;",

        "void main(void) {",
        //calculate shadowmap coords (vector for pointlight)
        "#if MAX_POINTLIGHTS > 0 && HAS_POINTLIGHT_SHADOWMAPS",
        "    vec3 pointLightShadowMapDirection[MAX_POINTLIGHTS];",
        "    for(int i = 0; i < MAX_POINTLIGHTS; i++) {",
        "       pointLightShadowMapDirection[i] = fragWorldPosition - pointLightPosition[i];",
        "    }",
        "#endif",
        "#if MAX_SPOTLIGHTS > 0 && HAS_SPOTLIGHT_SHADOWMAPS",
        "    vec4 spotLightShadowMapCoord[MAX_SPOTLIGHTS];",
        "    for(int i = 0; i < MAX_SPOTLIGHTS; i++) {",
        "      spotLightShadowMapCoord[i] = spotLightMatrix[i] * vec4(fragWorldPosition, 1.0);",
        "    }",
        "#endif",
        "#if MAX_DIRECTIONALLIGHTS > 0 && HAS_DIRECTIONALLIGHT_SHADOWMAPS",
        "    vec4 directionalLightShadowMapCoord[MAX_DIRECTIONALLIGHTS];",
        "    for(int i = 0; i < MAX_DIRECTIONALLIGHTS; i++) {",
        "      directionalLightShadowMapCoord[i] = directionalLightMatrix[i] * vec4(fragWorldPosition, 1.0);",
        "    }",
        "#endif",

        "  float alpha =  max(0.0, 1.0 - transparency);",
        "  vec3 objDiffuse = diffuseColor;",
        "  if(useVertexColor)",
        "    objDiffuse *= fragVertexColor;",
        "  #if HAS_DIFFUSETEXTURE",
        "    vec4 texDiffuse = texture2D(diffuseTexture, fragTexCoord);",
        "    alpha *= texDiffuse.a;",
        "    objDiffuse *= texDiffuse.rgb;",
        "  #endif",
        "  if (alpha < 0.05) discard;",
        "  #if HAS_EMISSIVETEXTURE",
        "    vec3 color = emissiveColor * texture2D(emissiveTexture, fragTexCoord).rgb + (ambientIntensity * objDiffuse);",
        "  #else",
        "    vec3 color = emissiveColor + (ambientIntensity * objDiffuse);",
        "  #endif",
        "  vec3 objSpecular = specularColor;",
        "  #if HAS_SPECULARTEXTURE",
        "    objSpecular = objSpecular * texture2D(specularTexture, fragTexCoord).rgb;",
        "  #endif",
		"  #if HAS_SSAOMAP",
		"	 float ssao = 1.0 - texture2D(ssaoMap, gl_FragCoord.xy / coords.xy).r;",
        "  #endif",

        "  float shadowInfluence = 0.0;", //used for sampling shadow

		"#if MAX_POINTLIGHTS > 0",
        "  for (int i = 0; i < MAX_POINTLIGHTS; i++) {",
        "    shadowInfluence = 1.0;",
        "    if(pointLightOn[i]){",
        "   #if HAS_POINTLIGHT_SHADOWMAPS",
        "       if(pointLightCastShadow[i]){",
        "           shadowInfluence = 0.0;",
        "           float lsDepth = vecToDepth(pointLightShadowMapDirection[i], pointLightNearFar[i].x, pointLightNearFar[i].y );",
        "		    float depth = unpackDepth( textureCube(pointLightShadowMap[i], pointLightShadowMapDirection[i])) +  pointLightShadowBias[i];",
        "           if(lsDepth < depth)",
        "               shadowInfluence = 1.0;",
        "       }",
        "       if(shadowInfluence > 0.0){",
        "   #endif",
        "       vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
        "       vec3 L = lPosition.xyz - fragVertexPosition;",
        "       float dist = length(L);",
        "       L = normalize(L);",
        "       vec3 R = normalize(reflect(L,fragNormal));",
        "       float atten = 1.0 / (pointLightAttenuation[i].x + pointLightAttenuation[i].y * dist + pointLightAttenuation[i].z * dist * dist);",
        "       vec3 Idiff = pointLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
		"   #if HAS_SSAOMAP",
		"       Idiff *= ssao;",
		"   #endif",
        "       vec3 Ispec = pointLightIntensity[i] * objSpecular * pow(max(dot(R,fragEyeVector),0.0), shininess*128.0);",
        "       color = color + (atten*shadowInfluence*(Idiff + Ispec));",
        "   #if HAS_POINTLIGHT_SHADOWMAPS",
        "       }",  //pointlight visible
        "   #endif",
        "     }", //pointLight on
        "  }", //pointLight loop
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "  for (int i=0; i<MAX_SPOTLIGHTS; i++) {",
        "    shadowInfluence = 1.0;",
        "    if(spotLightOn[i]) {",
        "  #if HAS_SPOTLIGHT_SHADOWMAPS",
        "       if(spotLightCastShadow[i]){",
        "           shadowInfluence = 0.0;",
        "           vec4 lspos = spotLightShadowMapCoord[i];",
        "			vec3 perspectiveDivPos = lspos.xyz / lspos.w * 0.5 + 0.5;",
        "			float lsDepth = perspectiveDivPos.z;",
        "			vec2 lightuv = perspectiveDivPos.xy;",
        "			float depth = unpackDepth(texture2D(spotLightShadowMap[i], lightuv)) + spotLightShadowBias[i];",
        "           if(lsDepth < depth)",
        "               shadowInfluence = 1.0;",
        "       }",
        "       if(shadowInfluence > 0.0){",
        "  #endif",
        "       vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
        "       vec3 L = lPosition.xyz - fragVertexPosition;",
        "       float dist = length(L);",
        "       L = normalize(L);",
        "       vec3 R = normalize(reflect(L,fragNormal));",
        "       float atten = 1.0 / (spotLightAttenuation[i].x + spotLightAttenuation[i].y * dist + spotLightAttenuation[i].z * dist * dist);",
        "       vec3 Idiff = spotLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "   #if HAS_SSAOMAP",
        "	    Idiff *= ssao;",
        "   #endif",
        "       vec3 Ispec = spotLightIntensity[i] * objSpecular * pow(max(dot(R,fragEyeVector),0.0), shininess*128.0);",
        "       vec4 lDirection = viewMatrix * vec4(-spotLightDirection[i], 0.0);",
        "       vec3 D = normalize(lDirection.xyz);",
        "       float angle = dot(L, D);",
        "       if(angle > spotLightCosFalloffAngle[i]) {",
        "           float softness = 1.0;",
        "           if (angle < spotLightCosSoftFalloffAngle[i])",
        "               softness = (angle - spotLightCosFalloffAngle[i]) /  (spotLightCosSoftFalloffAngle[i] -  spotLightCosFalloffAngle[i]);",
        "           color += atten*softness*shadowInfluence*(Idiff + Ispec);",
        "       }",
        "   #if HAS_SPOTLIGHT_SHADOWMAPS",
        "       }", //light visible if shadow enabled
        "   #endif",
        "   } ", // spotlight on
        "  }", // light loop
        "#endif",

        "#if MAX_DIRECTIONALLIGHTS > 0",
        "  for (int i=0; i<MAX_DIRECTIONALLIGHTS; i++) {",
        "   shadowInfluence = 1.0;",
        "   if(directionalLightOn[i]){",
        "   #if HAS_DIRECTIONALLIGHT_SHADOWMAPS",
        "       if(directionalLightCastShadow[i]){",
        "           shadowInfluence = 0.0;",
        "           vec4 lspos = directionalLightShadowMapCoord[i];",
        "           vec3 orthogonalDivPos = lspos.xyz / lspos.w *0.5 + 0.5;",
        "           float lsDepth = orthogonalDivPos.z;",
        "           vec2 lightuv = orthogonalDivPos.xy;",
        "               float depth = unpackDepth(texture2D(directionalLightShadowMap[i], lightuv))+directionalLightShadowBias[i];",
        "               if(lsDepth < depth) shadowInfluence = 1.0;",
        "       }",
        "       if(shadowInfluence > 0.0){",
        "   #endif",
        "       vec4 lDirection = viewMatrix * vec4(directionalLightDirection[i], 0.0);",
        "       vec3 L =  normalize(-lDirection.xyz);",
        "       vec3 R = normalize(reflect(L,fragNormal));",
        "       vec3 Idiff = directionalLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
		"   #if HAS_SSAOMAP",
		"       Idiff *= ssao;",
		"   #endif",
        "       vec3 Ispec = directionalLightIntensity[i] * objSpecular * pow(max(dot(R,fragEyeVector),0.0), shininess*128.0);",
        "       color = color + shadowInfluence*((Idiff + Ispec));",
        "   #if HAS_DIRECTIONALLIGHT_SHADOWMAPS",
        "       }", //light visible
        "   #endif",
        "   }", //dirLight on
        "  }", // dirLight loop
        "#endif",
        "  gl_FragColor = vec4(color, alpha);",
        "}"
    ].join("\n"),

    addDirectives: function (directives, lights, params) {
        ["point", "directional", "spot"].forEach(function (type) {
            var numLights = lights.getModelCount(type);
            var castShadows = false;
            if(numLights) {
                castShadows = Array.prototype.some.call(lights.getModelEntry(type).parameters["castShadow"], function (value) {
                    return value;
                });
            }
            directives.push("MAX_" + type.toUpperCase() + "LIGHTS " + numLights);
            directives.push("HAS_" + type.toUpperCase() + "LIGHT_SHADOWMAPS " + (castShadows ? 1 : 0));
        });

        directives.push("HAS_DIFFUSETEXTURE " + ('diffuseTexture' in params ? "1" : "0"));
        directives.push("HAS_SPECULARTEXTURE " + ('specularTexture' in params ? "1" : "0"));
        directives.push("HAS_EMISSIVETEXTURE " + ('emissiveTexture' in params ? "1" : "0"));
        directives.push("HAS_SSAOMAP " + (XML3D.options.getValue("renderer-ssao") ? "1" : "0"));
    },
    hasTransparency: function(params) {
        return params.transparency && params.transparency.getValue()[0] > 0.001;
    },
    uniforms: {
        diffuseColor    : [1.0, 1.0, 1.0],
        emissiveColor   : [0.0, 0.0, 0.0],
        specularColor   : [0.0, 0.0, 0.0],
        transparency    : 0.0,
        shininess       : 0.2,
        ambientIntensity: 0.0,
        useVertexColor : false
    },

    samplers: {
        diffuseTexture : null,
        emissiveTexture : null,
        specularTexture : null,
        directionalLightShadowMap : null,
        spotLightShadowMap : null,
        pointLightShadowMap : null,
		ssaoMap: null
    },

    attributes: {
        normal : {
            required: true
        },
        texcoord: null,
        color: null
    }
});

},{}],92:[function(require,module,exports){
XML3D.shaders.register("point", {

    vertex : [
        "attribute vec3 position;",
        "attribute vec3 color;",
        "attribute vec2 texcoord;",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat3 modelViewMatrixN;",
        "uniform vec3 eyePosition;",
        "uniform vec3 coords;",
        "uniform float pointSize;",

        "void main(void) {",
        "    vec3 pos = position;",

        "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);",
        "    fragVertexPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;",
        "    fragEyeVector = normalize(fragVertexPosition);",
        "    fragTexCoord = texcoord;",
        "    fragVertexColor = color;",
        "    vec4 pos2 = vec4(fragVertexPosition, 1.0); pos2.x += pointSize;",
        "    gl_PointSize = distance( gl_Position.xy, (projectionMatrix * pos2).xy ) * coords.x / gl_Position.w;",
        "}"
    ].join("\n"),

    fragment : [
        "uniform vec3 diffuseColor;",
        "uniform float transparency;",
        "uniform mat4 viewMatrix;",
        "uniform bool useVertexColor;",
        "uniform vec2 texCoordOffset;",
        "uniform vec2 texCoordSize;",

        "#if HAS_DIFFUSETEXTURE",
        "uniform sampler2D diffuseTexture;",
        "#endif",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "void main(void) {",
        "  float alpha =  max(0.0, 1.0 - transparency);",
        "  vec3 objDiffuse = diffuseColor;",
        "  if(useVertexColor)",
        "    objDiffuse *= fragVertexColor;",
        "  #if HAS_DIFFUSETEXTURE",
        "    vec2 texCoord = fragTexCoord + texCoordOffset + gl_PointCoord*texCoordSize;",
        "    texCoord.y = 1.0 - texCoord.y;",
        "    vec4 texDiffuse = texture2D(diffuseTexture, texCoord);",
        "    alpha *= texDiffuse.a;",
        "    objDiffuse *= texDiffuse.rgb;",
        "  #endif",
        "  if (alpha < 0.05) discard;",
        "  gl_FragColor = vec4(objDiffuse, alpha);",
        "}"
    ].join("\n"),
    addDirectives: function(directives, lights, params) {
        directives.push("HAS_DIFFUSETEXTURE " + ('diffuseTexture' in params ? "1" : "0"));
    },
    hasTransparency: function(params) {
        return params.transparency && params.transparency.getValue()[0] > 0.001;
    },
    uniforms: {
        diffuseColor: [1.0, 1.0, 1.0],
        texCoordOffset: [0, 0],
        texCoordSize: [1, 1],
        transparency: 0.0,
        useVertexColor: false,
        pointSize: 1.0
    },
    samplers: {
        diffuseTexture: null
    },
    attributes: {
        texcoord: null,
        color: null
    }
});

},{}],93:[function(require,module,exports){
var ShaderDescriptor = function () {
    this.uniforms = {};
    this.samplers = {};
    this.attributes = {};
    this.name = "";
    this.fragment = "";
    this.vertex = "";
};
ShaderDescriptor.prototype.addDirectives = function () {
};
ShaderDescriptor.prototype.hasTransparency = function () {
    return false;
};

module.exports = ShaderDescriptor;

},{}],94:[function(require,module,exports){
var c_globalScripts = {};

module.exports = {

    register: function (name, script) {
        c_globalScripts[name] = script;
        script.name = name;
    },

    getScript: function (script) {
        return c_globalScripts[script];
    }
};

},{}],95:[function(require,module,exports){
var AbstractShaderClosure = require("./../abstractshaderclosure.js");
var SystemNotifier = require("../../system/system-notifier.js");

/**
 * A ShaderClosure connects a mesh-specific GLProgram with it's Xflow data
 * @param {GLContext} context
 * @param descriptor
 * @constructor
 */
var ShaderClosure = function (context, descriptor) {
    AbstractShaderClosure.call(this, context);
    this.descriptor = descriptor;
};

XML3D.createClass(ShaderClosure, AbstractShaderClosure);

XML3D.extend(ShaderClosure.prototype, {

    setDefaultUniforms: function (dest) {
        XML3D.extend(dest, this.descriptor.uniforms);
    },

    createSources: function (scene, shaderData, vsRequest) {

        var objectData = vsRequest && vsRequest.getResult();
        var directives = [];

        var inputData = {};
        shaderData && XML3D.extend(inputData, shaderData.getOutputMap());
        objectData && XML3D.extend(inputData, objectData.getOutputMap());


        for (var attrName in this.descriptor.attributes) {
            var entry = this.descriptor.attributes[attrName];
            if (entry && entry.required && !inputData[attrName]) {
                throw new Error("Mesh is missing '" + attrName + "' attribute.");
            }
        }

        this.descriptor.addDirectives(directives, scene.lights || {}, inputData);
        this.source = {
            fragment: this.addDirectivesToSource(directives, this.descriptor.fragment),
            vertex: this.addDirectivesToSource(directives, this.descriptor.vertex)
        };

        SystemNotifier.sendEvent('urnshader', {
            urnshaderType: "code", vertexShader: this.source.vertex, fragmentShader: this.source.fragment
        });

        return true;
    },

    addDirectivesToSource: function (directives, source) {
        var header = "";
        directives.forEach(function (v) {
            header += "#define " + v + "\n";
        });
        return header + "\n" + source;
    },

    getTransparencyFromInputData: function (dataMap) {
        return this.descriptor.hasTransparency(dataMap);
    }
});

module.exports = ShaderClosure;


},{"../../system/system-notifier.js":118,"./../abstractshaderclosure.js":81}],96:[function(require,module,exports){
var AbstractShaderComposer = require("../abstractshadercomposer.js").AbstractShaderComposer;
var URNShaderClosure= require("./urnshaderclosure.js");
var ShaderDescriptor = require("./shader-descriptor.js");
var ComputeRequest = require("../../../../xflow/interface/request.js").ComputeRequest;
var addFragmentShaderHeader = require("../../shader/shader-utils.js").addFragmentShaderHeader;
require("./diffuse.js");
require("./phong.js");
require("./matte.js");
require("./point.js");
require("./utility.js");

/**
 * @param {string} path
 * @returns {*}
 */
var getShaderDescriptor = function (path) {
    var shaderName = path.substring(path.lastIndexOf(':') + 1);
    return XML3D.shaders.getScript(shaderName);
};


/**
 * @implements {IShaderComposer}
 * @extends AbstractShaderComposer
 * @constructor
 */
var URNShaderComposer = function (context, materialConfiguration) {
    AbstractShaderComposer.call(this, context, materialConfiguration);
    this.descriptor = null;
    this.setMaterialConfiguration(materialConfiguration);
};

XML3D.createClass(URNShaderComposer, AbstractShaderComposer, {
    /**
     *
     * @param {MaterialConfiguration} materialConfiguration
     */
    setMaterialConfiguration: function (materialConfiguration) {
        var shaderScriptURI = materialConfiguration.model.urn;
        this.setShaderScript(shaderScriptURI);

        if (this.descriptor) {
            materialConfiguration.dataNode && this.updateRequest(materialConfiguration.dataNode);

            this.descriptor.fragment = addFragmentShaderHeader(this.descriptor.fragment);
        }
    },

    setShaderScript: function (uri) {

        if (!uri) {
            XML3D.debug.logError("Shader has no script attached: ", this.adapter.node);
            return;
        }
        if (uri.scheme != "urn") {
            XML3D.debug.logError("Shader script reference should start with an URN: ", this.adapter.node);
            return;
        }
        var descriptor = getShaderDescriptor(uri.path);
        if (!descriptor) {
            throw new Error("Unknown URN: " + uri);
        }

        this.descriptor = new ShaderDescriptor();
        XML3D.extend(this.descriptor, descriptor);
    },

    getRequestFields: function () {
        return Object.keys(this.descriptor.uniforms).concat(Object.keys(this.descriptor.samplers));
    },

    /**
     * Get the attributes required by the shader
     * @returns {Object<string, *>}
     */
    getShaderAttributes: function () {
        return this.descriptor.attributes;
    },

    createShaderClosure: function () {
        return new URNShaderClosure(this.context, this.descriptor);
    },

    createObjectDataRequest: function (objectDataNode, callback) {
        var requestNames = ["position"];
        requestNames.push.apply(requestNames, Object.keys(this.descriptor.attributes));
        requestNames.push.apply(requestNames, Object.keys(this.descriptor.uniforms));
        requestNames.push.apply(requestNames, Object.keys(this.descriptor.samplers));
        return new ComputeRequest(objectDataNode, requestNames, callback);
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        var result = objectRequest.getResult();

        var dataMap = result.getOutputMap();
        for (var name in dataMap) {

            if (name == "position" || this.descriptor.attributes[name] !== undefined)
                attributeCallback(name, dataMap[name]); else if (this.descriptor.uniforms[name] !== undefined || this.descriptor.samplers[name] !== undefined) {
                uniformCallback(name, dataMap[name]);
            }
        }
    }

});

module.exports = URNShaderComposer;



},{"../../../../xflow/interface/request.js":139,"../../shader/shader-utils.js":117,"../abstractshadercomposer.js":82,"./diffuse.js":89,"./matte.js":90,"./phong.js":91,"./point.js":92,"./shader-descriptor.js":93,"./urnshaderclosure.js":95,"./utility.js":97}],97:[function(require,module,exports){
XML3D.shaders.register("pickobjectid", {
    vertex : [
        "attribute vec3 position;",
        "uniform mat4 modelViewProjectionMatrix;",

        "void main(void) {",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "uniform vec3 id;",

        "void main(void) {",
        "    gl_FragColor = vec4(id, 0.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.shaders.register("pickedposition", {
    vertex : [
        "attribute vec3 position;",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform vec3 bbox[2];",  // min = bbox[0], max = bbox[1]

        "varying vec3 worldCoord;",

        "void main(void) {",
        "    worldCoord = (modelMatrix * vec4(position, 1.0)).xyz;",
        "    vec3 diff = bbox[1] - bbox[0];",
        "    worldCoord = worldCoord - bbox[0];",
        "    worldCoord = worldCoord / diff;",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 worldCoord;",

        "void main(void) {",
        "    gl_FragColor = vec4(worldCoord, 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});


XML3D.shaders.register("pickedNormals", {
    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat3 modelViewMatrixN;",

        "varying vec3 fragNormal;",

        "void main(void) {",
        "    fragNormal = normalize(modelViewMatrixN * normal);",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 fragNormal;",

        "void main(void) {",
        "    gl_FragColor = vec4((fragNormal+1.0)/2.0 * (254.0 / 255.0), 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.shaders.register("light-depth", {

    vertex: [
        "attribute vec3 position;",
        "varying vec4 worldPosition;",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",

        "void main(void) {",
        "   worldPosition = modelMatrix * vec4(position, 1.0);",
        "   gl_Position   = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment: [
        "varying vec4 worldPosition;",
        "uniform mat4 viewMatrix;",

        "vec4 pack_depth( const in float depth ) {",
        "const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
        "const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
        "vec4 res = fract( depth * bit_shift );",
        "res -= res.xxyz * bit_mask;",
        "return res;",
        "}",


        "void main(void) {",
        "    gl_FragColor = pack_depth( gl_FragCoord.z );",
        "}"
    ].join("\n"),

    uniforms: {}
});

XML3D.shaders.register("render-normal", {
    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat3 modelMatrixN;",

        "varying vec3 fragNormal;",

        "void main(void) {",
        "    fragNormal = modelMatrixN * normal;",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 fragNormal;",

        "void main(void) {",
        "   gl_FragColor = vec4((normalize(fragNormal) + 1.0) / 2.0, 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.shaders.register("render-position", {
    vertex : [
        "attribute vec3 position;",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",

        "varying vec3 worldCoord;",

        "void main(void) {",
        "    worldCoord = (modelMatrix * vec4(position, 1.0)).xyz;",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 worldCoord;",

        "void main(void) {",
        "    gl_FragColor = vec4(worldCoord, 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.shaders.register("boxblur", {
    vertex: [
        "attribute vec3 position;",

        "void main(void) {",
        "   gl_Position = vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment: [
        "uniform sampler2D sInTexture;",
        "uniform vec2 canvasSize;",
        "uniform vec2 blurOffset;",

        "const float blurSize = 1.0/512.0;",

        "void main(void) {",
        "   vec2 texcoord = (gl_FragCoord.xy / canvasSize.xy);",
        "   vec4 sum = vec4(0.0);",
        "   float blurSizeY = blurOffset.y / canvasSize.y;",
        "   float blurSizeX = blurOffset.x / canvasSize.x;",

        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y - 1.5*blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y - 2.0*blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y - blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y + blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y + 2.0*blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y + 1.5*blurSizeY));",

        "   sum += texture2D(sInTexture, vec2(texcoord.x - 1.5*blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x - 2.0*blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x - blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x + blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x + 2.0*blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x + 1.5*blurSizeX, texcoord.y));",

        "   gl_FragColor = sum / 12.0;",
        "}"
    ].join("\n"),

    uniforms: {
        canvasSize : [512, 512],
        blurOffset : [1.0, 1.0]
    },

    samplers: {
        sInTexture : null
    }
});

XML3D.shaders.register("ssao", {
    vertex : [
        "attribute vec2 position;",

        "void main(void) {",
        "    gl_Position = vec4(position, 0.0, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "#ifdef GL_ES",
        "precision highp float;",
        "#endif",

        "uniform vec2 canvasSize;",
        "uniform sampler2D sPositionTex;",
        "uniform sampler2D sNormalTex;",
        "uniform sampler2D sRandomNormals;",
        "uniform vec2 uRandomTexSize;",
        "uniform float uSampleRadius;",
        "uniform float uScale;",
        "uniform float uBias;",
        "uniform float uIntensity;",
        "uniform vec2 uConstVectors[4];",
        "uniform mat4 viewMatrix;",

        "vec3 getPosition(vec2 uv) {",
        "return texture2D(sPositionTex, uv).xyz;",
        "}",

        "float calcAmbientOcclusion(vec2 screenUV, vec2 uvOffset, vec3 origin, vec3 cnorm) {",
        "   vec3 diff = getPosition(screenUV + uvOffset) - origin;",
        "   vec3 v = normalize(diff);",
        "   float dist = length(diff) * uScale;",
        "   return max(0.0, dot(cnorm, v) - uBias) * (1.0/(1.0 + dist)) * uIntensity;",
        "}",

        "void main(void) {",
        "   vec2 screenUV = gl_FragCoord.xy / canvasSize.xy;",
        "   vec2 rand = normalize(texture2D(sRandomNormals, gl_FragCoord.xy / uRandomTexSize).xy * 2.0 - 1.0 );",
        "   vec3 norm = normalize(texture2D(sNormalTex, screenUV).xyz * 2.0 - 1.0 );",
        "   vec3 origin = getPosition(screenUV);",
        "   float radius = uSampleRadius / (viewMatrix * vec4(origin, 1.0)).z;",
        "   float ao = 0.0;",

        "   const int iterations = 4;",
        "   for (int i = 0; i < iterations; ++i) {",
        "       vec2 coord1 = reflect(uConstVectors[i], rand) * radius;",
        "       vec2 coord2 = vec2(coord1.x*0.707 - coord1.y*0.707, coord1.x*0.707 + coord1.y*0.707);",
        "       ao += calcAmbientOcclusion(screenUV, coord1*0.25, origin, norm);",
        "       ao += calcAmbientOcclusion(screenUV, coord2*0.5, origin, norm);",
        "       ao += calcAmbientOcclusion(screenUV, coord1*0.75, origin, norm);",
        "       ao += calcAmbientOcclusion(screenUV, coord2, origin, norm);",
        "   }",
        "   ao /= (float(iterations) * 4.0);",
        "   gl_FragColor = vec4(ao, ao, ao, 1.0);",
        "}"
    ].join("\n"),

    uniforms: {
        canvasSize      : [512, 512],
        uConstVectors   : [1,0, -1,0, 0,1, 0,-1],
        uRandomTexSize  : [64,64],
        uSampleRadius   : 0.9,
        uScale          : 0.9,
        uBias           : 0.2,
        uIntensity      : 1.0
    },

    samplers: {
        sPositionTex   : null,
        sNormalTex     : null,
        sRandomNormals : null
    },

    attributes: {
    }
});

},{}],98:[function(require,module,exports){
// Note: This context should only be used to access GL constants
var GL = window.WebGLRenderingContext;
var ForwardRenderTree = require("./render-trees/forward.js");

/**
 *
 * @param {GLContext} context
 * @param {Scene} scene
 * @constructor
 */
var GLRenderInterface = function (context, scene) {
    this.context = context;
    this.scene = scene;
    this.options = {
        pickingEnabled: true,
        mouseMovePickingEnabled: true,
        glBlendFuncSeparate: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA]
    };
    this.renderPipeline = null;
};

XML3D.extend(GLRenderInterface.prototype, {
    getRenderPipeline: function () {
        return (this.renderPipeline = this.renderPipeline || new ForwardRenderTree(this.context));
    },

    setRenderPipeline: function (pipeline) {
        //TODO cleanup old pipeline
        this.renderPipeline = pipeline;
        this.context.requestRedraw("Pipeline changed");
    },

    getRenderOptions: function () {
        return this.options;
    }
});

module.exports = GLRenderInterface;


},{"./render-trees/forward.js":111}],99:[function(require,module,exports){
/**
 * @constructor
 */
var BaseRenderPass = function (renderInterface, output, opt) {
    this.renderInterface = renderInterface;
    this.output = output;
    opt = opt || {};
    this.inputs = opt.inputs || {};
    this.id = opt.id || "";
    this.prePasses = [];
    this.postPasses = [];
    this.processed = false;
};

XML3D.extend(BaseRenderPass.prototype, {
    addPrePass: function (pass) {
        if (this.prePasses.indexOf(pass) === -1) {
            this.prePasses.push(pass);
            pass.postPasses.push(this);
        }
    },

    removePrePass: function (pass) {
        var idx = this.prePasses.indexOf(pass);
        if (idx !== -1) {
            this.prePasses.splice(idx, 1);
            pass.postPasses.splice(pass.postPasses.indexOf(this), 1);
        }
    },

    clearPrePasses: function () {
        var i = this.prePasses.length;
        while (i--)
            this.removePrePass(this.prePasses[i]);
    },

    setProcessed: function (processed) {
        if (this.processed && !processed) {
            var i = this.postPasses.length;
            while (i--)
                this.postPasses[i].setProcessed(false);
        }
        this.processed = processed;
    },

    renderTree: function (scene) {
        if (this.processed)
            return;
        this.processed = true;
        var i = this.prePasses.length;
        while (i--)
            this.prePasses[i].renderTree(scene);
        this.render(scene);
    },

    /**
     * Reads pixels from the pass's target
     *
     * @param {number} glX OpenGL Coordinate in the target
     * @param {number} glY OpenGL Coordinate in the target
     * @returns {Uint8Array} pixel data
     */
    readPixelDataFromBuffer: (function () {
        var c_data = new Uint8Array(8);

        return function (glX, glY, target) {
            var gl = this.renderInterface.context.gl;
            var scale = target.getScale();
            var x = glX * scale;
            var y = glY * scale;

            target.bind();
            try {
                gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, c_data);
                target.unbind();
                return c_data;
            } catch (e) {
                XML3D.debug.logException(e);
                target.unbind();
                return null;
            }
        }
    }())

});

module.exports = BaseRenderPass;


},{}],100:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var FullscreenQuad = require("../base/fullscreenquad.js");

var BoxBlurPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    this._program = this.renderInterface.context.programFactory.getProgramByName("boxblur");
    this._screenQuad = new FullscreenQuad(this.renderInterface.context);
    this._uniformsDirty = true;
};

XML3D.createClass(BoxBlurPass, BaseRenderPass);

XML3D.extend(BoxBlurPass.prototype, {
    render: (function () {
        return function () {
            var gl = this.renderInterface.context.gl;
            var target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.disable(gl.DEPTH_TEST);

            this._program.bind();
            this._setNonVolatileShaderUniforms();

            this._screenQuad.draw(this._program);

            this._program.unbind();
            target.unbind();
        }
    }()),

    _setNonVolatileShaderUniforms: (function () {
        var uniforms = {};
        var uniformNames = ["canvasSize", "sInTexture", "blurOffset"];

        return function () {
            if (!this._uniformsDirty)
                return;

            var program = this._program;
            var target = this.output;

            uniforms["canvasSize"] = [target.width, target.height];
            uniforms["sInTexture"] = [this.inputs.buffer.colorTarget.handle];
            uniforms["blurOffset"] = [1.0, 1.0];
            program.setSystemUniformVariables(uniformNames, uniforms);

//                this._uniformsDirty = false;
        }
    })()
});

module.exports = BoxBlurPass;


},{"../base/fullscreenquad.js":74,"./base.js":99}],101:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");
var ObjectSorter = require("../../renderer/tools/objectsorter.js");

var ForwardRenderPass = function (renderInterface, output, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this.sorter = new ObjectSorter();
    this.lastRenderStats = {};
};

XML3D.createClass(ForwardRenderPass, SceneRenderPass);

XML3D.extend(ForwardRenderPass.prototype, {


    render: (function () {
        /**
         * @type Float32Array
         */
        var c_worldToViewMatrix = XML3D.math.mat4.create();
        var c_viewToWorldMatrix = XML3D.math.mat4.create();
        var c_projectionMatrix = XML3D.math.mat4.create();
        var c_programSystemUniforms = ["viewMatrix", "viewInverseMatrix", "projectionMatrix", "cameraPosition", "coords", "ssaoMap", "width"];

        return function (scene) {
            var gl = this.renderInterface.context.gl, count = {
                    objects: 0,
                    primitives: 0
                }, target = this.output, systemUniforms = scene.systemUniforms, width = target.getWidth(), height = target.getHeight(), aspect = width / height;

            target.bind();
            this.setGLStates();
            gl.viewport(0, 0, width, height);

            scene.updateReadyObjectsFromActiveView(aspect);
            scene.getActiveView().getWorldToViewMatrix(c_worldToViewMatrix);
            scene.getActiveView().getViewToWorldMatrix(c_viewToWorldMatrix);
            scene.getActiveView().getProjectionMatrix(c_projectionMatrix, aspect);

            var sorted = this.sorter.sortScene(scene, c_worldToViewMatrix);

            systemUniforms["viewMatrix"] = c_worldToViewMatrix;
            systemUniforms["viewInverseMatrix"] = c_viewToWorldMatrix;
            systemUniforms["projectionMatrix"] = c_projectionMatrix;
            systemUniforms["cameraPosition"] = scene.getActiveView().getWorldSpacePosition();
            systemUniforms["coords"] = [target.width, target.height, 1];

            if (this.inputs.ssaoMap)
                systemUniforms["ssaoMap"] = [this.inputs.ssaoMap.colorTarget.handle];

            //Render opaque objects
            for (var program in sorted.opaque) {
                this.renderObjectsToActiveBuffer(sorted.opaque[program], scene, target, systemUniforms, c_programSystemUniforms, {
                    transparent: false,
                    stats: count
                });
            }

            //Render transparent objects
            for (var k = 0; k < sorted.transparent.length; k++) {
                var objectArray = [sorted.transparent[k]];
                this.renderObjectsToActiveBuffer(objectArray, scene, target, systemUniforms, c_programSystemUniforms, {
                    transparent: true,
                    stats: count
                });
            }
            scene.lights.changed = false;
            target.unbind();
            this.lastRenderStats.count = count;
        }
    }()),

    getRenderStats: function () {
        return this.lastRenderStats;
    }

});


module.exports = ForwardRenderPass;


},{"../../renderer/tools/objectsorter.js":71,"./scene-pass.js":107}],102:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");
var ObjectSorter = require("../../renderer/tools/objectsorter.js");

/**
 * @param {GLRenderInterface} renderInterface
 * @param {string} output
 * @param {RenderLight} light
 * @param {*} opt
 * @extends {SceneRenderPass}
 * @constructor
 */
var LightPass = function (renderInterface, output, light, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this.light = light;
    this.program = null;
};

XML3D.createClass(LightPass, SceneRenderPass, {

    init: function (context) {
        this.sorter = new ObjectSorter();
        this.program = context.programFactory.getProgramByName("light-depth");
    },

    renderScene: function() {
        this.render(this.light.scene);
    },

    render: (function () {
        var c_viewMat_tmp = XML3D.math.mat4.create();
        var c_projMat_tmp = XML3D.math.mat4.create();
        var c_programSystemUniforms = ["viewMatrix", "projectionMatrix"];

        return function (scene) {
            var gl = this.renderInterface.context.gl, target = this.output, width = target.getWidth(), height = target.getHeight(), aspect = width / height, frustum = this.light.getFrustum(aspect), program = this.program;

            target.bind();
            gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
            gl.viewport(0, 0, width, height);
            gl.enable(gl.DEPTH_TEST);

            var count = {objects: 0, primitives: 0};

            this.light.model.getLightViewMatrix(c_viewMat_tmp);
            frustum.getProjectionMatrix(c_projMat_tmp, aspect);

            scene.updateReadyObjectsFromMatrices(c_viewMat_tmp, c_projMat_tmp);
            var objects = this.sorter.sortScene(scene);

            var parameters = {};
            parameters["viewMatrix"] = c_viewMat_tmp;
            parameters["projectionMatrix"] = c_projMat_tmp;

            //Render opaque objects
            for (var shader in objects.opaque) {
                this.renderObjectsToActiveBuffer(objects.opaque[shader], scene, target, parameters, c_programSystemUniforms, {
                    transparent: false, stats: count, program: program
                });
            }

            // Do not render transparent objects (considered to not throw shadows
            target.unbind();
            return {count: count};
        }
    }())
});

module.exports = LightPass;


},{"../../renderer/tools/objectsorter.js":71,"./scene-pass.js":107}],103:[function(require,module,exports){
var BaseRenderPass = require("./base.js");

var PickNormalRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
};

XML3D.createClass(PickNormalRenderPass, BaseRenderPass, {
    render: (function () {
        var c_modelViewProjectionMatrix = XML3D.math.mat4.create();
        var c_worldMatrix = XML3D.math.mat4.create();
        var c_normalMatrix3 = XML3D.math.mat3.create();
        var c_uniformCollection = {
                envBase: {},
                envOverride: null,
                sysBase: {}
            }, c_systemUniformNames = ["modelViewProjectionMatrix", "modelViewMatrixN"];

        return function (object, viewMatrix, projMatrix) {
            var gl = this.renderInterface.context.gl, target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);

            if (viewMatrix && projMatrix) {
                object.updateModelViewMatrix(viewMatrix);
                object.updateModelViewProjectionMatrix(projMatrix);
            }

            object.getModelViewProjectionMatrix(c_modelViewProjectionMatrix);

            object.getWorldMatrix(c_worldMatrix);
            if (!XML3D.math.mat3.normalFromMat4(c_normalMatrix3, c_worldMatrix)) {
                XML3D.math.mat3.identity(c_normalMatrix3);
            }
            ;

            var program = this.renderInterface.context.programFactory.getPickingNormalProgram();
            program.bind();

            c_uniformCollection.sysBase["modelViewProjectionMatrix"] = c_modelViewProjectionMatrix;
            c_uniformCollection.sysBase["modelViewMatrixN"] = c_normalMatrix3;

            program.setUniformVariables(null, c_systemUniformNames, c_uniformCollection);
            object.mesh.draw(program);

            program.unbind();
            target.unbind();
        }
    }()), /**
     * Read normal from picking buffer
     * @param {number} glX OpenGL Coordinate of color buffer
     * @param {number} glY OpenGL Coordinate of color buffer
     * @returns {Object} Vector with normal data
     */
    readNormalFromPickingBuffer: (function () {
        var c_pickVector = XML3D.math.vec3.create();
        var c_one = XML3D.math.vec3.fromValues(1, 1, 1);

        return function (glX, glY) {
            var data = this.readPixelDataFromBuffer(glX, glY, this.output);
            if (!data) {
                return null;
            }
            c_pickVector[0] = data[0] / 254;
            c_pickVector[1] = data[1] / 254;
            c_pickVector[2] = data[2] / 254;

            // TODO: Optimize (2 Float arrays created)
            return XML3D.math.vec3.subtract(XML3D.math.vec3.create(), XML3D.math.vec3.scale(XML3D.math.vec3.create(), c_pickVector, 2.0), c_one);
        }
    }())
});


module.exports = PickNormalRenderPass;


},{"./base.js":99}],104:[function(require,module,exports){
var BaseRenderPass = require("./base.js");

var PickObjectRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
};
XML3D.createClass(PickObjectRenderPass, BaseRenderPass);

XML3D.extend(PickObjectRenderPass.prototype, {
    render: (function () {
        var c_mvp = XML3D.math.mat4.create(), c_uniformCollection = {
                envBase: {},
                envOverride: null,
                sysBase: {}
            }, c_systemUniformNames = ["id", "modelViewProjectionMatrix"];

        return function (objects, viewMatrix, projMatrix) {
            var gl = this.renderInterface.context.gl, target = this.output;
            target.bind();

            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);
            gl.viewport(0, 0, target.getWidth(), target.getHeight());
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            var program = this.renderInterface.context.programFactory.getPickingObjectIdProgram();
            program.bind();
            for (var j = 0, n = objects.length; j < n; j++) {
                var obj = objects[j];
                var mesh = obj.mesh;

                if (!obj.isVisible())
                    continue;

                if (viewMatrix && projMatrix) {
                    obj.updateModelViewMatrix(viewMatrix);
                    obj.updateModelViewProjectionMatrix(projMatrix);
                }

                obj.getModelViewProjectionMatrix(c_mvp);

                var objId = j + 1;
                var c1 = objId & 255;
                objId = objId >> 8;
                var c2 = objId & 255;
                objId = objId >> 8;
                var c3 = objId & 255;

                c_uniformCollection.sysBase["id"] = [c3 / 255.0, c2 / 255.0, c1 / 255.0];
                c_uniformCollection.sysBase["modelViewProjectionMatrix"] = c_mvp;

                program.setUniformVariables(null, c_systemUniformNames, c_uniformCollection);
                mesh.draw(program);
            }
            program.unbind();
            target.unbind();
        };
    }()),

    /**
     * Reads pixels from the screenbuffer to determine picked object or normals.
     *
     * @param {number} x Screen Coordinate of color buffer
     * @param {number} y Screen Coordinate of color buffer
     * @param {Array} objects List of objects that were rendered in the previous picking pass
     * @returns {RenderObject|null} Picked Object
     */
    getRenderObjectFromPickingBuffer: function (x, y, objects) {
        var data = this.readPixelDataFromBuffer(x, y, this.output);

        if (!data)
            return null;

        var result = null;
        var objId = data[0] * 65536 + data[1] * 256 + data[2];

        if (objId > 0) {
            var pickedObj = objects[objId - 1];
            result = pickedObj;
        }
        return result;
    }
});

module.exports = PickObjectRenderPass;


},{"./base.js":99}],105:[function(require,module,exports){
var BaseRenderPass = require("./base.js");

var PickPositionRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    this.objectBoundingBox = XML3D.math.bbox.create();
};
XML3D.createClass(PickPositionRenderPass, BaseRenderPass, {
    render: (function () {

        var c_modelMatrix = XML3D.math.mat4.create();
        var c_modelViewProjectionMatrix = XML3D.math.mat4.create(), c_uniformCollection = {
                envBase: {},
                envOverride: null,
                sysBase: {}
            }, c_systemUniformNames = ["bbox", "modelMatrix", "modelViewProjectionMatrix"];

        return function (obj, viewMatrix, projMatrix) {
            var gl = this.renderInterface.context.gl, target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);

            if (viewMatrix && projMatrix) {
                obj.updateModelViewMatrix(viewMatrix);
                obj.updateModelViewProjectionMatrix(projMatrix);
            }
            obj.getWorldMatrix(c_modelMatrix);

            obj.getObjectSpaceBoundingBox(this.objectBoundingBox);
            XML3D.math.bbox.transform(this.objectBoundingBox, c_modelMatrix, this.objectBoundingBox);

            var program = this.renderInterface.context.programFactory.getPickingPositionProgram();
            program.bind();
            obj.getModelViewProjectionMatrix(c_modelViewProjectionMatrix);

            c_uniformCollection.sysBase["bbox"] = this.objectBoundingBox;
            c_uniformCollection.sysBase["modelMatrix"] = c_modelMatrix;
            c_uniformCollection.sysBase["modelViewProjectionMatrix"] = c_modelViewProjectionMatrix;

            program.setUniformVariables(null, c_systemUniformNames, c_uniformCollection);
            obj.mesh.draw(program);

            program.unbind();
            target.unbind();
        };
    }()),

    readPositionFromPickingBuffer: (function () {

        var c_vec3 = XML3D.math.vec3.create();

        return function (x, y) {
            var data = this.readPixelDataFromBuffer(x, y, this.output);
            if (data) {

                c_vec3[0] = data[0] / 255;
                c_vec3[1] = data[1] / 255;
                c_vec3[2] = data[2] / 255;

                var size = XML3D.math.bbox.size(XML3D.math.vec3.create(), this.objectBoundingBox);
                size = XML3D.math.vec3.mul(size, c_vec3, size);
                XML3D.math.vec3.add(size, this.objectBoundingBox, size);
                return size;
            } else {
                return null;
            }
        }
    }())
});

module.exports = PickPositionRenderPass;


},{"./base.js":99}],106:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");
var ObjectSorter = require("../../renderer/tools/objectsorter.js");

/**
 * @param {GLRenderInterface} renderInterface
 * @param {string} output
 * @param {RenderLight} light
 * @param {*} opt
 * @extends {SceneRenderPass}
 * @constructor
 */
var PointLightPass = function (renderInterface, output, light, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this.light = light;
    this.program = null;
};

XML3D.createClass(PointLightPass, SceneRenderPass, {

    init: function (context) {
        this.sorter = new ObjectSorter();
        this.program = context.programFactory.getProgramByName("light-depth");
    },

    renderScene: function() {
        this.render(this.light.scene);
    },

    render: (function () {
        var c_viewMat_tmp = XML3D.math.mat4.create();
        var c_projMat_tmp = XML3D.math.mat4.create();
        var c_programSystemUniforms = ["viewMatrix", "projectionMatrix"];

        return function (scene) {

            var gl = this.renderInterface.context.gl, target = this.output, width = target.getWidth(), height = target.getHeight(), aspect = width / height, frustum = this.light.getFrustum(aspect), program = this.program;
            for (var side = 0; side < target.glSides.length; side++) {
                //calculate rotationmatrix for that face
                var mat_rot = XML3D.math.mat4.create();
                XML3D.math.mat4.identity(mat_rot);

                if (side == 0) { //look into +x o
                    mat_rot[0] = 0;
                    mat_rot[1] = 0;
                    mat_rot[2] = -1;
                    mat_rot[4] = 0;
                    mat_rot[5] = -1;
                    mat_rot[6] = 0;
                    mat_rot[8] = -1;
                    mat_rot[9] = 0;
                    mat_rot[10] = 0;

                } else if (side == 1) { //look into -x
                    mat_rot[0] = 0;
                    mat_rot[1] = 0;
                    mat_rot[2] = 1;
                    mat_rot[4] = 0;
                    mat_rot[5] = -1;
                    mat_rot[6] = 0;
                    mat_rot[8] = 1;
                    mat_rot[9] = 0;
                    mat_rot[10] = 0;

                } else if (side == 2) { //look into +y
                    mat_rot[0] = 1;
                    mat_rot[1] = 0;
                    mat_rot[2] = 0;
                    mat_rot[4] = 0;
                    mat_rot[5] = 0;
                    mat_rot[6] = -1;
                    mat_rot[8] = 0;
                    mat_rot[9] = 1;
                    mat_rot[10] = 0;

                } else if (side == 3) { //look into -y
                    mat_rot[0] = 1;
                    mat_rot[1] = 0;
                    mat_rot[2] = 0;
                    mat_rot[4] = 0;
                    mat_rot[5] = 0;
                    mat_rot[6] = 1;
                    mat_rot[8] = 0;
                    mat_rot[9] = -1;
                    mat_rot[10] = 0;

                } else if (side == 4) { //look into +z
                    mat_rot[0] = 1;
                    mat_rot[1] = 0;
                    mat_rot[2] = 0;
                    mat_rot[4] = 0;
                    mat_rot[5] = -1;
                    mat_rot[6] = 0;
                    mat_rot[8] = 0;
                    mat_rot[9] = 0;
                    mat_rot[10] = -1;

                } else if (side == 5) { //look into -z
                    mat_rot[0] = -1;
                    mat_rot[1] = 0;
                    mat_rot[2] = 0;
                    mat_rot[4] = 0;
                    mat_rot[5] = -1;
                    mat_rot[6] = 0;
                    mat_rot[8] = 0;
                    mat_rot[9] = 0;
                    mat_rot[10] = 1;
                }

                target.bind(side);

                gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
                gl.viewport(0, 0, width, height);
                gl.enable(gl.DEPTH_TEST);

                var count = {objects: 0, primitives: 0};

                this.light.model.getLightViewMatrix(c_viewMat_tmp);
                //rotate for the apropriate side of the cubemap
                XML3D.math.mat4.mul(c_viewMat_tmp, mat_rot, c_viewMat_tmp);

                frustum.getProjectionMatrix(c_projMat_tmp, aspect);

                scene.updateReadyObjectsFromMatrices(c_viewMat_tmp, c_projMat_tmp);
                var objects = this.sorter.sortScene(scene);

                var parameters = {};
                parameters["viewMatrix"] = c_viewMat_tmp;
                parameters["projectionMatrix"] = c_projMat_tmp;

                //Render opaque objects
                for (var shader in objects.opaque) {
                    this.renderObjectsToActiveBuffer(objects.opaque[shader], scene, target, parameters, c_programSystemUniforms, {
                        transparent: false,
                        stats: count,
                        program: program
                    });
                }

                // Do not render transparent objects (considered to not throw shadows
                target.unbind();
            }
            return {count: count};
        }
    }())
});


module.exports = PointLightPass;


},{"../../renderer/tools/objectsorter.js":71,"./scene-pass.js":107}],107:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var Options = require("../../../utils/options.js");

var OPTION_FACECULLING = "renderer-faceculling";
var OPTION_FRONTFACE = "renderer-frontface";

Options.register(OPTION_FACECULLING, "none");
Options.register(OPTION_FRONTFACE, "ccw");

/**
 * @constructor
 */
var SceneRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    /**
     * @type {function}
     */
    this.setFaceCulling = getGlobalFaceCullingSetter(Options.getValue(OPTION_FACECULLING));
    /**
     * @type {function}
     */
    this.setFrontFace = getGlobalFrontFaceSetter(Options.getValue(OPTION_FRONTFACE));

    var that = this;
    Options.addObserver(OPTION_FACECULLING, function (key, value) {
        that.setFaceCulling = getGlobalFaceCullingSetter(value);
    });
    Options.addObserver(OPTION_FRONTFACE, function (key, value) {
        that.setFrontFace = getGlobalFrontFaceSetter(value);
    });
};

XML3D.createClass(SceneRenderPass, BaseRenderPass, {
    setGLStates: function () {
        var gl = this.renderInterface.context.gl;
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
        this.setFaceCulling(gl);
        this.setFrontFace(gl);
        gl.enable(gl.DEPTH_TEST);
    }, /**
     * @param Array
     */
    renderObjectsToActiveBuffer: (function () {
        var tmpModelMatrix = XML3D.math.mat4.create();
        var tmpModelMatrixN = XML3D.math.mat3.create();
        var tmpModelView = XML3D.math.mat4.create();
        var tmpModelViewProjection = XML3D.math.mat4.create();
        var tmpModelViewN = XML3D.math.mat3.create();
        var c_objectSystemUniforms = ["modelMatrix", "modelMatrixN", "modelViewMatrix", "modelViewProjectionMatrix", "modelViewMatrixN"];

        return function (objectArray, scene, target, systemUniforms, sceneParameterFilter, opt) {
            var objCount = 0;
            var primitiveCount = 0;
            var stats = opt.stats || {};
            var transparent = opt.transparent === true || false;
            var gl = this.renderInterface.context.gl;
            var program = opt.program || objectArray[0].getProgram();

            if (objectArray.length == 0) {
                return stats;
            }

            if (transparent) {
                gl.enable(gl.BLEND);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            }

            // At this point, we guarantee that the RenderObject has a valid shader
            program.bind();

            //Set global data that is shared between all objects using this shader
            program.setSystemUniformVariables(sceneParameterFilter, systemUniforms);

            var prevOverride = null;

            for (var i = 0, n = objectArray.length; i < n; i++) {
                var obj = objectArray[i];
                if (!obj.isVisible())
                    continue;

                var mesh = obj.mesh;
                XML3D.debug.assert(mesh, "We need a mesh at this point.");

                obj.getWorldMatrix(tmpModelMatrix);
                systemUniforms["modelMatrix"] = tmpModelMatrix;

                obj.getModelMatrixN(tmpModelMatrixN);
                systemUniforms["modelMatrixN"] = tmpModelMatrixN;

                obj.getModelViewMatrix(tmpModelView);
                systemUniforms["modelViewMatrix"] = tmpModelView;

                obj.getModelViewProjectionMatrix(tmpModelViewProjection);
                systemUniforms["modelViewProjectionMatrix"] = tmpModelViewProjection;

                obj.getModelViewMatrixN(tmpModelViewN);
                systemUniforms["modelViewMatrixN"] = tmpModelViewN;

                program.setSystemUniformVariables(c_objectSystemUniforms, systemUniforms);

                program.changeUniformVariableOverride(prevOverride, mesh.uniformOverride);
                prevOverride = mesh.uniformOverride;

                primitiveCount += mesh.draw(program);
                objCount++;

                if (transparent) {
                    gl.disable(gl.BLEND);
                }

            }
            program.changeUniformVariableOverride(prevOverride, null);

            program.unbind();
            stats.objects += objCount;
            stats.primitives += primitiveCount;
            return stats;
        }
    }())


});

function getGlobalFrontFaceSetter(mode) {
    if (mode.toLowerCase() == "cw") {
        return function (gl) {
            gl.frontFace(gl.CW);
        };
    }
    return function (gl) {
        gl.frontFace(gl.CCW);
    };
}

function getGlobalFaceCullingSetter(mode) {
    //noinspection FallthroughInSwitchStatementJS
    switch (mode.toLowerCase()) {
        case "back":
            return function (gl) {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.BACK);
            };
            break;
        case "front":
            return function (gl) {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.FRONT);
            };
            break;
        case "both":
            return function (gl) {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.FRONT_AND_BACK);
            };
            break;
        case "none":
        default:
            return function (gl) {
                gl.disable(gl.CULL_FACE);
            };
    }
}

module.exports = SceneRenderPass;

},{"../../../utils/options.js":132,"./base.js":99}],108:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var VertexAttributePass = require("./vertexattribute-pass.js");
var GLRenderTarget = require("../base/rendertarget.js").GLRenderTarget;
var FullscreenQuad = require("../base/fullscreenquad.js");
var Options = require("../../../utils/options.js");

var base64RandomNormals = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAnRxJREFUeNoE4XeMpnmCGOb90pvDl3N9lau6qrs6T3dP3tmd3b3bS7yjjqIYZJKwLMKWLcuCSdiwDMg2LEA2DQMGBFiwqT8s+cR4PpG35OaZ2cnTuatD5fjl/L05/IKfB/7D/zX/AfZcU/p/LrtXs1qhr11w9vf7071c7r8KJne98t8ORl+ykvdurNrJl9M0e2h/2OCN5f7PuKXtZr1jHjrJX79KD5j57apf7OunMPgwNMgIWBLnCLC62FOFmOLlCH57HtXqalaHsJmkj6R3i/4/i9Wdq3T1WPw3c/4/rfMxV54tUQZA13Ljnvp3j+S2q+zeTe4eSv9dMt/ck//4J+y4b/vLaeM5/IuF9GOorNQnn9UForgmwDevjdYr7x8epbSo/6NScuOedcvBnxrJ33HoEKq/Mbg+VM5x8LeptKEPP8fVp4UoU0iAHR5fSitutjEnhXooQhykWDg4n4kjRxrNyGs/eZ7t/NXZsh6JRZx+Z0srEEwp3MvE/+Ew/MeuphH0H1Ym51eU/1sr2kGFxUPywoj/QW3WiTP/9UVy5WlsmKpb1wwdIwQcn92RBYQgV2KkQom6JvolgECaU5EbgQ2ZWSfSkBjiAt4bFcyXg8cL9ptbrGQnpaGSpxIVQunirlRmGKxVo9OempmTPU8da/DqwAifMSbocUNcV0GdBd/E5kyniwymCjhNAb4NLSisC5COJDykl2VtpsVE524TVRfRQOfVkxgC8tL1t/JYCUynSlMF6gyZHr3W0cHA+fqrfLQNyvm4VALLA7M7Fotd/TzhVSRZBR/qvHxNT66AiYUziJf6SmkvKLdFV8OjAum/7a5lpJKGx3O8ZAK3EiLO8q56OZXzZ3LTlS9nzLGU20lCLbBHRNOIghzrbNFGLA3Os5Xd2KHgxYIMMUhW0/JjfJpDB6ZdXedBCCZYdSRoV3EuAWoFNruSwzQwYWVDmywS3VRro8Qbp22F46YCFKSmvJuRQQ7iP0z+0zfUPNRRZaqv/BypL9PRSCTXZF0Rd7vuGdBfGSK5Jsg32tWv/flr5HgMRvJhC+oG+UE0SVN9iHDYoa2M0OfY2IBTGVFbbGuirIaHE/UsobUzUs6yaA9IXOrvJ24Rb/XSyoLwvgmPR0n0Ql6LsBEow98AoCmtPmEHsPFTFJ7xbEUGmjhqw+ayADeg+yFJB7JGUNxRmoU434VfKCyVdDohxbbMLjWikLsxRhh8onCQosZArvf9he78eES/ktNRNdkqKllXyvbgwqm/d1ToPBeF71B7N8mFyj0neBVB9E18oxWwzyP3i4h+K7oX+tkCszA2Y/W+m3hc+iLvr04VUYAOxU2KUAhAG/UQ96GWIKyl6sKAhDGscCB6XGGsdUWjVwG5ygZFqXIHOTUi26hsQGCCNEHpPiajqi7e+OpUrU0TtS63BmJhXXozgbU19lal1+TrvzqfSOf4e5ni4lby38dyAnjlBu2H0MMs2FfpqvCvhZsJ1o6UuSaCeryiS+ctdn4kqh/C6gz2fBIOKFNwrwRCQXPLyg2bebfJqyz7Qz+ZnOh/QdrvnFfVCm4paGUlncbQXsL1nPpEFU8o+EHK1hfxZ9n0Rjm67+HLut5+HgOPgnUUX4FKI3Cz7pWDnNFl+8/TbgIlJhdVmbjs/hgvZeL52zr692liwPncUXpG5UAWrxMzjg8Xi5cyu7WukgTGClUQzFxQHKt+LDGb9+oW4DBeBgcgSmeo0NF2Ih4+EOCAZJDiTtLsr4B3DZWpeLXI9C55i5DJDMJLgoW4zIBlKIqLqbcjxeU0ewCTxygNxNoSSX3gzuLllmhruFAmTRbNR4CM3gZ8qLtRmoNy5n4a2mwcA3EgeS15vqFiLSguRdpBSSn6rou1XGTN1PG5jC7TpXYyXVf2ZbA4U662/X/znLGQ0l8noaVklzWrgKKnUrgIVvpYs+CbS6rdksGV0B+K5JCY52GwpFnl6CMq/tlZ9Aojto6kba8z0PQ++r7POhy2XO/dc6Uw6/8yUGYoOSrkqwX16mqcX5N3x/iFRKp92jzIPh/PdiBTNtHZW+JmotoZ7mRYHLGcDzsjab9Jf0KSGiTgwiw+0dW+17dV66YeXUvqQqgJ9HeVZlueTbxQpUYOjLbxaFGaXetZttslSW5mXf188aTF9csEa9osD5Z0Mq9yOSLGBKqCV06k5AqNdnFf54CI2xaYeVC6jI+bSn+Bfz/LbSym98XU5aUArD1yQT+ZZJTTLF6vqB/OJkFeIoPd+E7e1Dja3UjHh7LeELdPw18h+aKXuJ2CdE3TqWzNZO8Z2r2uEy0oatAU4o4C5Tz6KlXOXoY3UilNhP5A11UxOBOUCBdxKQfiPXDuircMPrkGD3mi5+L6vrXQFrrB5RLu0OhFrrR543Itql1MQRpFW4GUS4W6TMlzgAWAHJB3ZSm28t1sOo2kAPoS7BYIArxSRvANH3dBGiVlqCiGmMwxXY58yPgplh6xUgzzZtgrmeRnvM3yByFrXJF3NElbSx1Cws2kO8O/04fmC++/V1jDVtUdeyRTU4dH2D+DeuYXtS6rybtJIUM45zUJ0fvqywm4mmfsHP4LNXy3YNYpPwuQtO+h1xAn7Fpe/q6GBpe45IQXEunHNAWifZm9Wp5Bbj4dQdXmsz+RoYHVoVJ9Ced77KBWtH44I0t/zI0Tpn5JkzEbRfE7h/JUx7abhCX8BGe8Mcx7ZMeDZpx+eYaDtlSvSysiSmX0zTW1m4nKkqRmw+ww8vKyvqf9LvL+0ShKwvhPg1xwj/RmsWohJSbAQ1uvdfraOVszIpOsfhiABBzXk0Uo1pec9ihJdq3iU8PRAG8m2bdnSWChU2QPQdKA4VJcdeT2CfPCcP3XkGcIxUgUEVuBVoP1tKTv6FEbZV/IDQmKkJ5dx2aLsEVxMEi/LwHTD/9iCdlXYZ0LeonHg1R8DpcDVMp6B+vZYlVkDd7qIzgDo3MwK1AQSzIT2eOECyAPE3xNneeAUmSrXRgMwB7nN8ckgNFQI1sNtv+BGbticCvBYykKkwIl5YwY5UT+kbTXD8+IVFb0YCI3zllURlMTVSuzsBBk5IxyKF1WYSaLCH1pxFlw9Vb6PNLSN7Ffk0eLoFhI+5j2taQkUE3i/kARtmAdYfWJ9Eh4CGp1ATCgmG/vq3zIDkJJJ6Qw98KMUDEp2Ho3kYNvxWqWjM/Y50W6M1BW2tOvdCmwOKsznUg5Jqq/UXsHKIbylYI8iFngxtOiFByDZMvwgLKTIO2p8+Zz5l6F9ia6V4HHI9ItAr6IBAMLxWgvVA7HfGWWteqxHnN1C784YQ9uQIwE3wIYMFDA9WvBianM+079yAQzHi0idJuXejIbiVFWC7aTgRytvMlcf52c6FJY4RlDsUKxBoPdht66wrYvpJMEKF9G9TCZQBzfNGmd3gzIdy18UEiu21yXyLGVVhBfLsXyWPEmMDiWXqtgjcB1Vz0Q3odTvNigJ5s4mICjh2n6tFRbBrWGD4vi512IvrNI5uc+XTQ678iJGRmbaKWX/NxDUCMrETw6Z42RGNrydAX87pQqR+Q3TnAsqSur/GRBvhzHd79RS4f9U6iwH+eaJltW2XPZmOTPt+SSNwDTgVTKMeBiEwDtJpdN6Fpe2KO3upnZ1+o8jrbxzCnJR0q6M4Ymhwc6LMwYyaJXz5TsXVDapOYNaF6a4gS8iIKrGY28FQmZU5Uu9NT4THpJo2ZRrrpi/FK2Q14toM4GE1goLxAtopGv2jXITmS3qOk0/ngvkKb+Ly4Usm2tJ1R0418QpX8W/U1Jk4LkuKGgFTaIA4NJjXH4hmgnayyrimItsc7wL2qooVnZVf5vy6PNebZcmXl6Lq174kJXsAh9Fj9VtSmTJskgBVwk9wURiB2bYlaOxlq+b0IQgW1OxSWYB/PzV5AsmNeCaU3JviQx4b9rjS+F8RjzDYA34/wE1nva/nP3A1lbzhDHT3gOd2fJyFCuotmrTDYexR2h7e+J23UlUxf8er6Jwb8y3BqRd2znWALKVL9DpUsPy/U04rC34FXOTLsLjng2yvmlQJXGsNaJowmdFMjFTSNZ6VMVqBEu9VU6RTFL4yvkLIQGE7HOc9uzilY6uXAziZFq8iFMPzjS8lHaSmE9ryRnIjRhaoDwDh2OscqQdc40CQ6gUCmTQunS04rn6UKqGnLy6vu1wWz2ICaA0va2ERbj9XN9wsR0GRWawTGEpZfaSht5Mi8S1t1Hbi+mBdRqSNIDL8vS9lQLPkMb/fRsrdDO+u++KU0DOlCxWUPNCbLNNEnAeEl9vUgSja4NybtfsfkxaLF4tKHChlg23fPt3PgScoscKHDrI0JUBigjd0Typqw8PY0Wf81OfpOe38revpEcRwp5A6UNmGXEicXs2Sh9UIveRrrEzC81uBumCe25Rr6Ekhx/IUGtpZQUyfWysikbh9jxZCDgrC4JSWSQes1N+mM5eu5nbBhqqbUF4D1MIvWVLkKd5yPD1VBeYnDbyU1UN0B6GyAKTh+KbN2Wq3Hj+iS3yCZvhPE1VAOgKSkpcoChuZ+O0/S0qmxdQemp0jyi8jx52lS0DbE1ByclmVww9A7tMAJMKpmxbUzzUwim/JChlYazPyS+RjINeu7IakiktmTn+eJMECqezRDjbC3m0ZBFIZ53QRtrSyNv1UMOT1unkNRQcx4HHEYoTQK4OAwNkT7CRrsY3UgkXEuicgBuM/JaNU+1+WUaT4Gfk9O7ifQOvf9GunzGvv65OV3HugFI9qErLDLeTD5YMFuefBzD+0BUUqV7F1jfsmYteX0IpzdQcsKop2BPUj9KOhN1fY70N/RXw/AGMlYWKbTghRKXPb0agRUgC1U4Y84kOJmxhaE0wkJaYZsVZXAJ2557xrXiQrjJEi+UfnPCM5eSOueHkrxew5LLXgk2AKhQIdkcoS+T8VjxPyOlDQgxMNbR0lDNTd1vEqu7lb5/m36p8e7UX8V606HdVWmGSVSgicp3Eq5g8kZHg4GSnXP9Nvx1mAGC/u6FOiPwzSlfODfhKGneB8eh7Mn8wS9jkYiUCyUL2pIsraKNPJ3Y6lPE/YTfvDAhEXxZazTBJRdkKmkO4AaxIhakEB1GdhZ28sb5jWCJq/ld8OwvYQNp9T9EuXyypjsj1zqO/eMlQ26jnEFK30wGxPosnVan+UWhEP5AKbSgk8bQNFYr+LuXrnVu3xPpnJNXRXh7KUbX9MJYX7wMjr+iEEaxayfL6G4Y/mVFmadpLsO/64pMDr53IAU6wq/TnEGfUMireO0Zi9xE703mN0vnLvr4B/OMZQvAg5Ho9JXqLK3uuS9HxAiZKlgA4Nklv1ZW8r4It+R4wEa32RWZxAxGPVH7MuIqhkzEZaXvEwVy8QLuvyOJKTYgDcZErPkVOerowOvImx212hudzTIa5LM5d6bJxhfBLhHrGdPYYt9OxPVhmsVM6rjzca4fRzt3c3ZNuK7UhUn7upTJxbirDA6xq4DgPVctBQsr+HJudhKIsklEkkXLYAFS97hUEtYlcre0VzWyKCUwwqNv2MfNuJfXfAyf/RMvrpKsna4TvrsAL47Axix+PkuTD8zF5cRAkn/GBAPkIjSADhnnu3240xCNd6XSIZ9l8PmRqL1P6QmZIGEeygulsU8K/3olXeiI0kykGsrfoh0X+lwAJCwFNCZe7zGdjKLp3eqwQasPouyuaim6lxjTUFAmvN9YVhObVJu6fOsVLwgHAuE1zaCM35IYp9I4J6wwNhTtq9b01mpOj0C6wophEm9it2/S55RCuHQ+z2+p/yx1QRnp+2beI4YlS+c07avRBZVVgqPUMigFsBFEraLer9HfL2J6nD1PHTSHCwVUNaXyXbrLjJULC0zYN2y2w8B8nei5pKJSeC4rn2Ec046Eu4t0fASKx/maFMOZ/LQkGg8VeYm5IbabSbxBsw79wIv/7VDae+LXDSJ7CawZvk7qa1B0+RMoWor/ZqOA1gI9Zvnv0GYheJ61/7IR3+bSu/vmo+NwImISXo2yZnCtnSldoIO2aMvJTxR4iGV6ixGHXFRgtktqvxNMUtxdmlQ5K4sg62gv7Wh+bl/LKfgh8vJx5jHWm8zfzClbYdAH2T2C/1t+voZXQ56WxKTLvGu0O9M4BdlILiKMl1CvYDfN+a1E+oQGT5ZQtjJPYuJ35Cylq8IeZOJgwrdjuXLgj+zsuRAfvE2/w/IszFcXomyKtrg6/xZkj3xvHjlCvJjrzbp6g6f/LCumKsE3kq6myiSwOsocwcyH/qKvEDN9NIc3eQz1pDtFf+Ot2aNW2eklUiL2O/pJxq+60uphnERiUtDkNT6XQtTGzUBuc1wfuOo888yL3jlSZhN6sMeX7pEon0i/z+Spfhomcl281c0dxuD8i6hWSSeWDH9oGUFwMkALgbkwBbk8F6diWEz7n7gfG7mycL/Ik6mRkl4pMGfyCpXUBFxCpjxE+r049xSfZVC4H2v3ZEdlnR7o1LVSX0gtg3SUcj/9JmOtHaclSVx0ZjAvhgV5XpJQ3R/ZSX6oLK3DUyIbBkAxSF8LrU7mQ4abVBUgDOjOAVdmSWcfT+8UuxZAGR5daAvn6rgLo8U0JaiuorPXnKapPQdzVYW+uPXGC3UcdiaZv5M/nUh+c1r92twYh24YRylrrZtxE5sPkrrPzQAbz/nsYaazrFqyyBygSwROF627WHy3x+cea9rpaWzpl6mehdEoLRbMQcTcmSieKSqB0mYUfJy+0kIFwpW+jriS7dO2gqyr2vo5Q0DuH4UsL2sT9vAr9IMlrX6tXxeZ1lIaPM9667S/x6/+oTSxaWp7OZmfnHH9GFZ/MxCTtCdJ8k42myLf1o+hXLPCD8/kR78d4t9t/+/zT7nahrNFqaPQmqZ5Z7IJxeowfg3BRYJkDWdbsv5Ygq+kyYzIBDUs1kpRri5Xivz0lq5jtcHhqxYBz0nupTr1sHLHi29NNwOlMkmPM/JFPsIR2vqS0kNxNIrfi2gAyecQbEJUC3nrjAwuo/yeWE74qE9OILiSYxzKXZLcPGJkFR2r8uJN5mJtb1tmAzQ5p2bb3Fxm5H4c/gFNf0QGN6MklvMjbaHN6Ujd3O31T5Jfn44+nBs6FWcxlw9ouQ+8Pp/ytGrq/QYkH8RX1XBcs3sKRDahRVjgGE2pZ6rzmSrP1XRfmwegYaDNIJ1PRBoTpCM+5fOKRFREbxP7hJEube8ZpaPY+yVFTyelFxRMyXlFvlCYkU9DX84o5EYxgdeU6IFNl6x4G7QMWjFVRYPdBXy1EhmoQOYyGi8ZqQL9FFQ72KhAGjJ4D0RE4hatXcrsZdoTdDrhyX09WIofhBT64MIKa9fATI0VhRtL5rgvG6ekmmHOPp+YPPqviV6sKCxlGQhCUXkDfIV3lrRIgzUi8WJoc56/QkefaPlBys7n8rpZXFOg4O55qozY4UhrRhTE6i7iqC2rV1mu5Ly85WSltHpRlM/l/nkaPsJg03jOyV07KZ4VRhc806cXtqxgUfsTdCYVaTy1WuK0TOQDtqqi50LgDLktyd+cxIqm1D3SK8l56i8fmoNhkmZAbo2gdfxsyt46FtmE/8oNFkzDKoPRogzW4KQPGxW6eCN9aaY5T12ZS+qKjB0+ZPBKg4Z6rn1Fhxy1eFr7BvGeJPY1TQWeyhwFaDfHDcqLlv7rr/RZOb0OlEEA/ITgrRj/L3v4w//4/yTrMCe48yo90hMu4coO7MrAFkDX4PQSbwdUTPhsSxtj4A1FfUgmBmlZad3RtXO109c2Q1gsRWgqZRMaDsVzOYYAbzssKSnpFXC8HWmbeB0qwIC+IuQJjIUS9clFKjUV2Lg/3fsBBCW8ACQVCCVLRIrPhq5qK5kCHt8DlECR59K5Ec+M+XO7gpHh40BGKMH+FA4u0eKukp3gWpeVB+5XEuyui9pHw9FiwKv0fQ88d/WVRJSW+D9fGm3ck+9i6h7Cs70x/TJZlu0oVDK2MM/R/szNHZGtIN3rcM2WqxZ/vomcrFj3ke2xICGbQfj5FO/poJwFwkxvvYLwCutr0vR7fpXiaDNlp/q1PjiYkYuGVynJtTdsMGTGcRopysmedmMoiq/j52U97rAPHY6/mn/leE4rX05yZGkOwEnaH1B+Q0dZ7lsJkCU5gWMfLz1JxBKcPiBLc/yrYTobRe9xK1tMOxeyIcuzTqpwUFWRGzLqim3UP2D64XXj/Tk52wSzKQYKaHVB0zHkhaSngeIRTwaRYUoOI7UyM6bk9X13LRTIV/Q9LauzQYYYhSR3DZC+PsxTVYYkgtoM+RfifAVtPktAjFtPU/ttvO7ipUzybRedFd2/QnUa8SMF07fyXhJVeuTo/7E8s9HvO6FTAedpdHeHpyPJp2E8LtuWs/2u9dLJXAasl5MpAlcizypo6gnwvfi5beSycMuOnwWKZ3hXc/baPPjWM954wcY1sOiTx9NUG6k1E7Nq5DNsyiI9M0aQF38KlSNv3B1fbpDNXPmeyfeykmfxuiNdJLwVBuwmZVdSpeCoJ6oyEItXNYsJsD9FX81IbjGId5jQATAHoCUDV56M8I12osRs9sY/IJlIiL+94eUahtNHV724uwtOElfVJLitCgVwAJvHiUioh7XuDatb86+mWnomLnX2Vk7M5vj4PGmekuJVsfAgyvTU5zGIY3YlBFKP73V4H2a+57DzJD2TEMmL4jH0ZanJwPSr8DlJ76YKXSEHcqIbSr0RnBjZToeudoTw2SuARR1VJaOTJdUwfUsJplN5ErjKXDaYpLdZWkQdbKxYcFD1Jgm+ni6k/zZ9vpNfeH9QsqjaylU+jV924DArz+4g6V1ITK7P0jkQo65UmoK0LSYhyxbDcM0wZOytzntTYMiR9KXS3EuSOnkigZVbUX5PYxmwkE/m/2M8MYtaGLSPk/HILK7ycynhedA40OZC2d831hue1jE2fKTknEfvcAzDm6+LV76j+F7u/3hpqH4xmZ4btYm+2JLDrlhktJ3X+B+hUQV0Mu6/ux/2nMKL09nHHgqrmldVmxC/GQU0ImuySJdQoSLOPpS/w2E+h94ZsFaVHBRmb9lo45LOJ/ipGsRVVKmkKMeqLTI7Y1GK8yY81Wkuo18r+0+uai5D97T0CMi9lNuboOZhywE9IMYLuI4kcMChUGxLnKzHm+dELkKB0DjLR2fhzpRkJokU8U976LKR3n07q+5gW1fFVfyFnVwDODqW0x5s+qTtJFJP9N3s9EwrMnlJUNWUJnXJTdEsn4YxQgDVHGnL9w9tedjnt0ZSLgG/QkJQWHxs+a5USNX1OVi+GP/LVspTfMVQZgKuumlUhG80QhQ+OdNMKK2WwDON6i3lbou3hqjFUyJIiQEZ4DmEKSGyKwPHyG/Mk98Zk29C3/5OvtbNoECYWZh6AusQFqCt06gvSZcoDuCxVuQa2FjNizjuLnMa8bIPyUS0cHA9MSSLS0q6dQg+2xN8mjolZWimaQ1qbbicDL69sDHy54fBq2bhe1cpqkeyrM8JKCRAraA9P/094Vk0c1iNeYkOC6koeZZAxR3oDzKsS9gRgylILbS7IVYlsejp2o20Y8NTwGtdtWTbjsvkkFTvcuVvhisTGbzA5/vhW+tofo59Oc7b9JLICuOaAtcWDDRln+y1y5X8tTxHTTpZoD2KMhf6zn/Fp4NZRoC9K0VYtTYW6RtdFjUyGMj8OJFXdFkGqgfbB9E7SbhQ9Dq+zi1+70t7ceL7Kv68ocsLuKSSks0CyF0f3fsGXqb0cJxka7g5QV6J+w7SopTm5V0GTIbMPuJ7eSlvEOd3U2Og15/5zyCo9kj9utzNsJAj7SV9PYFQhitLmbDOiZ2majhMySSETY0vPphSFccRlwJ5H2DTJMtDz14rxCN6+QEqDkjiaJCL+Tsa+GvIci34VFv6wps+dcOFvPs2H647OUVpOkQLyZia/YitWLLPQKdPN4L84k8Tv6CWYzhfRD0RvWWRgxx8TedXkLV6AX1F7nXgSpWbXOyXhL4MR6tUyAk/zpWeIDZKtJosKQLGUGBwZhO7GYV1fzoySiGEHqZcoogf97WSKhXHjHNSThi9Z77AWjomZhZJCjhVJH0jWRJJ8JaovDBaInRiYzXD+IynK+rr7TpaGJViTW9hNTYihGYSqxqQEB7NoYLx5lPvyDYP7OSPfyzRC9h+wnoz7+Vi9vY1YE+guAArYXq2JH8r+O2hQpa51VSIXKCgjHGXzBPoP6OL1EldPrhWmC+HVl6MntleC2YDpFoUYNwjOMgaJpeVcy6NuOSw03tW8e7kju58BaPhbq2OADshL3ZIscLqSqxL+NlWlGsYkmP+AnG7nmzP7RAA0Ed3zsPzRSsM2V3BfvYauRprCl0u0b6G95fBdUjlq9q+C6YOtWdqmOJlEvf6OAyY9G1qpIkFJc+QSF4bq4YFQP4tCmLkJODsuSgVgRrjyVORE2S4mk8Vsbrm9lRFwazxRLeB6Mrw5oRRIr2w8MfvX1431CMp1I/L80AKhhgAkTCcOjhzhaeXamEYkYGwmTgV2tM0vTotswm5aKOP12afKtlxEKylWdrDKxfcfjNJRJwWSH8r/FYy318Pt7Zxb2RIHmKYz+rMhHiY4PgsubYqZyxKKjK0TCbfSyRXo1nBOyBpQqCTvB+xPp8dBQtxJrkOkqxgyxxegKwHXADSDiw6QhlEc4NcmvDqKX0CFiMD3Ezg7GmsKGhBx2cuT/5M+d7E+TeO7GyJtXdnb+4SN4q3XtSiA0qPZ6uG7BTlb3xRhKRxMZoIDSowZ9DpChgZESm5Yc9cOlHPA3xOolWoGaP0IKsYb7Msl8yIuFC/yEdrM6W0y8OA5TVx8kIaO2kD43CRtEu8NJGzGL2JuHHEy1l01slkiNhuFyhPhjoRfZCnHi2ox0b43helVqyMcfSxQiY5ODvhywfSZJZ2riryevo2QfGOMjkWi99LvpvBEzr/4y8KiIl9QvdnuWUoxl6uH7O8QZrrPM3nWZ0eBhj5cf5TIuW4cx9OrKCch9EbqZKDykZCbUrPtcuxmHqYlP7fvsbobtaYVuN7RcNxefUMXN60wIZSfxBrPyvyCXvoJ/eAvPOYjx2+X0r0VZzI2AJkq6+6EzQlCQvgi2mazeDfIeGb31cuh/g6568HfGEcN5qx9EqO+85f/LQir6lvR2DnZPgl1MyKOakrZzVgm3x5CgcVM/KolSHsWxofkn1FoEr+do0VafDaMlgsChTWUTxti8MhqKwqBku7FQzmRFqM2IKYcDQMsDkAO1kYUHCR90WKakW0PuPnBBlTWQ3B6WmqVKRcTgptgIZiVgaQk0I/HUzmIc5dq4M3UiyPUALIsEjfj+kjVT1NgkZPVXM0K8cv1+THmQSRqBGiQiV2QzkQ1FVx8YSvTdGn7XnnSl5f47Ub01MDZyfah29yB2mATnH5hBUNNZuVg3VxlvAVhyTnslVhRQt5GUDMdSNWcMsEWi3VfD4VpNIHLw9Q3jXeWXM/eYspe3JwHmlvOlIa7JqZFKlrrjbMS1ICpnfhYRHLtlgd09OYRN+lupnsFhW1QbfO5+0Dc3jF8Oth7nox6KfHkngrD4gk8I6qct3T2LV99rOAVR7xJTN9rJsZObn6CvX9FEOWkyHbd45rVvyWliuypddabkZhyGZ5Qo8cPE58wQ6rylnR+2iYRyXmYpKu+EYhOjFS49wuTtXTCW0gYp0F2X0uCiBNefSO1NLYW1bSOdKea3FWk2YrAK6LHNJGBJK+MOdyz1TUSBTWwJShopySQzTsJAtn4RuUucQgu6j0pHTHlYmXzlJiQcRGXJITVlPi63hK4n4olVumAIrkow01SW5pk1rMAS5fyOrDeH7OcVMZ2HBTZtorNm/Hej8g2b85GmGpGzDJVwgghEvVD8IXI+O33F2cajfL/KQuLFOpL+ejtdwwH+b3jepXwZOzhFiK1jBQla3opMtweRctTZJv5uoldH6cy6tqyje1s2vzM0lvrrXunhR7r0X/s7B2RX/1ABs43DojB1zRXVFfk48XlUsjeWuqFDh9fE17N5Mep2TUh4ohGSFonPBch8bjZLBoWHUMb9nRBR4WRJoJlQyFPT4MpPRUiJfmJRCVDLo5dn7DjR5zcpqZNCRRUgoCehHwkzhBkA2losFsUyq+FsO2GVZwQ7f2UriTgHepcVrgm68ZI+QhFX8kB4dEvxjNBwXDWUHrfTDuAO8swBYqxm7bUUw3znH6eKvgYrAWWs4B7U6TnSoSABlVGGTh2I5yjrwcszMFDP49IY8Ujrg5xI4BcYxKO3hwPU/mn1dchIqY1Y9gZAknRtY1qXSOZg3jBJEIJ5lm2KDgbGkaM1yfa7k64/8jgBRpqyc/PRL7++4foyytCLMJyj+MXkVW9lgjfXCQKeZ/f+TOw4uCWvOUIoENTWtfYfMJ03+jcQGUcmLeTDI9skDS3iM0LTAZCOc2GLgxkOGHu/FfVqVXnvP+GYi7wW4xs3THOL2adt34ej11G9BRKOkTdqxIFOgmD++L4iUKIXJPqGRxOOFRU0AdaTC1q3I4gd1mcuufJ1ZvcpgwZ6dm2tJS1+3thgd5+XoMU4xeZKSrOWVyyGGccgpmNMENnuvzy2VZTjlrw6MKaw6wet8w5nieM8ZZXI41A6QXEecpv/MMuO34jSFeUFu9IuQAWM/ZUkscKqGW4uWCmH0FA1VcsCTSxTs5rFWZKZIoRWTiImyCLMJEB17AIyjcAbY5xx3UdtlmIPewrHAgf6kdKSCvoNV6lPgK10WQYK0CskwpztPpa2SP4/i5/rwQ1ksmyILzMgpOsqWJ6R4oRiJuLvt+FRwqbPuhRs+j9tAPb9m7c3Bbg+QsfZjH2YBkFvnoCTZtKHfiUVHrpm4WKeU7wZhnYapqrug8hLEKlFP9dV6IDFv0JBzIsxS7EgI+z9jUhSh3F7FmmEio2taSPnJfg4sq34RwEcrJ92Qr1s5qKQzQD1OweA3uo6rHoyKTz30y8kNdQ0SR2isQRKAaqpcKlXNkpSR+c4mXqdiRQIREKSSnU85XMKyHJTnWe9I0lGwTF94XpYn6qi+mvaT4WpqXANmSjTW45MOqx7sI7WnJj0bxRJIv43jCjHQgGQFlicB/4+7/ru9A/yxZ3sCtCrJtRHzhYxQURcbHaY/3Okm5TFIB/RJYjkUfkO4ZXmmjPOFdGfUy/k1XthELPbivKDPI366p8gFXHkbpv+2PDwN6yeUxAoHai+WNb0WV0FNJ6vxIckqkxiWrQQumGH4UeTYkmwkZqltMTHw0elukZbAUaCUgXi9KnavTGlAgkEaU4jKR5zAfE9gChg9Jj/a6KZyjaix6gFBZ5BMJ7huFF3h0ydX7Ml0RnY1AS6W3VkfO1XC3PLNy0C4JW+Z+g/VCuJSF5Ui8KCaORpabKYxxbwDXBPZHJLR54xmcGqiEwGUCs+dUbaVHNgeOpH2H848x2BNToqctLhdkuZ7Ml7gNteJpHJ8nOpaVPO+oIAWoyWmmQsJtdKZCf4HLWFJW2WrZscspfpD7B4d5uKzKpU705DyWkVwhgseg5bMHk0TE4inzbnoSV/FukFQ8Uumlrkn8BphyrHWh+QxppqQWufITt3udXyx53NWbebgNgqBUaHOYpWhoY61PoyWJFkj8Y298M2muOSDQogK9ciamNvn2V6zqG5WvsbEGIozaH4VdD8oCvTUCR0BJW3iLyd16AusxbFIu0BpHrZmYKPx9QTNeennpG8PYdeALGt08hJVvJy8PYzOj6ovSfg5I5yTFWJ3hUgdf/oWs/gvKnsvsQF1m8LBlshCtTLHn47nAAoGAYT1Gm32onNBOhwaYKE2IQ4gdkG+ltSVxVFOOq94a0EoQcJukd/HpQqrZRO9iFJBYA9nl8IZML4Fx+GyIxlKpL8wiOjRQz6ZmLV2SkBEprU5y51kiEvmTJEPE31USHOUxxWdSMkSZPExSMNqiD35K7Rz7ckKNq8bsdTrygSxz6aYYCgkBYfdAqAOL85mBnwf8T7sBfyW9HIb1bLZRxqMF0PiTgFoRYMw+ruhH8mXEi69S8h5+/tLEm372N/WFEbd7cXLuqBiaQrwp8m2hOxGeA6BSJBJYEqRY94eKfjAV4JB4HS2nwpIAyREtzeYnJaulxWKZZIQo5wruodtryIhHCzmhBZDmM28aYDULJ22mYdw4wJeE50C0eVU9XSu3eaBFxM2BkZwqyxFLIDIpHsvAJYuvpWgJOBWQ2RYrL8gThR8IvnM/SUIScTCVGIDRR59m7X50qKLGDWlkijQFVxupCPHpCIALrBYMWnMzPw61u4UO5mRXXupHF5c8U1NaL5VKEecu6esCL47GI6X0SJ3hzN/8X/lz8D0kRI4qwADfJke9uDiRa4vwbEVRCmpcF3RJ0e+xXpMaCmlgxhXYiaCigxWa0hUy6rLrMJ30xedXoVpSSobkHfME2DyVF2M1y8ARgMUVdmUMDp8kwVfDzLck1xPrSXjmYPFOpv+uJu4pPgPyonolTh/PmXiC7Ei2zkTuIBm9ggHHjSLqBDzAYLHN1DXsrquKwMyFY4eUPozJA2/2A+ZXEMhK7+A0u8x+raot7m6FOmuA0gzlW3Fw6FsOOGiY2UUQYDyXmdDlbsVfdjXFJ1FXy/Xl9BIaPUpeR60QqTVsboXeXHH2EmmkrbYEF+SoKxkR+d7h4NLBn8Lxtp1x26gfpHeOZUmGExtmBVJ6DLr4lChgxY8BUNaT+5H7qJB5lk4fMN2UhGLDKEcaP4InW9JuYUIW/4twpqAn9dwGos1qGgTx83V55oXXHkTZi8x4I83/CoMq7F+QaoClMQvbM91QyjELLfXLJTUs8fotwioJM3FGdeEIb71Gj7akw4dJcUnN9ahWgPfm/CiEXGZ3EPtpSR9HXBNgmDGqNTCtiCkAxbF0eZDEaQpHHl83TnPJzhWkhsiKQaoroAVSBFUK/Qx3q6hoxTMC1wdgnJEP+47imBkSN6y48dx47rA9U7lZTPJNcBkncSZCc5KucHMDVCaZmcZ6jF2dweU2eYS9wktuy9Jld6ZeLfga3ICpjwjclEsxOh7w57+NfnBDbVRpqwhmF4ILSAeQcVEdiuLNeLqQnyG/OkjYpTR6krYzEg9AIQuXDxzSc74NwJt9+PZSzcyieIVFTfeO4c+HRjsWaYZmVbF+qBzrxDiQf+Qu4g/+t/9XmDFz/TQpKtE6zv4kHCNNwtLFvhrq+J04flOQrD4EkUh9Vm/KtQL2bdXFxMvJ+8tRvgbXq6GDpT5ByUkOHihXY65dAHlCwePBVFEiiWgGjAWabxLtD3z2PeDfkBaaulEQcYgepeLkInj/CjNUY1KGN1TRyWhdGi6eqc3DUALoUR9rBWS3eIrQYJRQQjYO+GCf2DZI6rC9wJNzHM2lmwdQ0/gehpu6WO7OHh/bx5Fj0kwxwcVCMs+zasXnFj9+jutVONSgsx09GODa7uA1T2k3JiXDiAXEyHWEmoExwcqI9V9HzFHWfKnDOMuRJTudWNhjaAfNvgSZw8Hso4yNAUpN1S2iYZWvSWBT8ZKCFVh25LCz4ZTOhd1G1RFuXxpnU7Y0lII+ylBpcxJ99VIqvkxujx0iJVDJg4sfy6iUNiDKMPzWMWj12bPhJCNVuk0FrIV3VfRVooYOjmrcybPKnF2W4KU+B6FQjsrzl7Lhcb2Ilto8zqODCpGWeXY5mbUrQym91QaZZvhMgRWTtSEGjFeyzBUJSeH90D01shfV9KJB00q6BcQZhcoZL1xqSY9KlJ0jU5nTq3XYTgCwAPHBrJNEWXJLiffz2i5PFpfgyht4cRB3GNd/hGcFD06MaUUdx2lVWDe+YPb58FMJJbb0t24qU6g3azDKJLHK755kmtbw9Q8Wjpa7+qSIJAA8rGqiHcISANUKSE3tDZO8DsMEWxSRgSDjdCHkk5DvbVTgPi1b2ckBFjcg+MjHLbXSI7lu1L9iTLeiSsJ6+/kjf1LyzQ2HfeOosx3wvSY6i6nzStRa0rwoXXWg/h7uSxK+F/0vVt64ylB68nIqhL3zkJWKiYfUpzsp7KPrfTb7Fc84uHsmZpBn9+CYa7ot3ELSPVM2D3Obr9M9ANYFgxC2A6Ha+MRj5WVmC+GszdWJ4Zuil0pJJtk80mePtM4bnIuNnCRsxMGafwSl+jdm5s+CZy+Boec0QxQ0ZpRRUsOr19JXy0Cp40wMnzTT+wVxWYfWOboTBKND+t2QKfupeamuXDoRkXoRnTL1eB79TyYj0gP/hFPb0xZyWpg3nG09qUibEA41Mt0Kxww0BvLiIO1rRvoH4xnXr2vy/BlvV6FVF9c4jVvg+Xlib+PVKaxdxIMXk7YXh5isqpAY6NyU6qpws8pBxa2OjJwnxt+hJEAbe2Ggy7tAFjVR073Miv+y5qo1/GEmOb2DXlizRUPauYQBVUAMiIJKiKoXtP0oJvQ/h9c/k1/9wpkq/dpTNb5jDq9wmA0WOGqm6sjhvIjdLRKkILcZy4+Ipwj2FOefmORkynLypKmsRxwkvN3j/DrZeuxqZ8Gjn83NbG6jnl8FbFJQnil0Z6qXUfQFIkZJbnwW9Fw6BCC7k29K8mgVJLjA7Qg+pL2+XpQEb/IoAmoE4Cslj6HNk1kpVfrKxlhq+3E3wfEtK2PAgR1f/02ybc8/werRW8kfpah+JF+ouTiBEEUbfXKr6TzZNoc8llLUGisDQ7A97eopvXm0/zjIfbqpgyemBvCVVnqYkxZasPgkmiUiMUFWkfbO6ZaQr/1EfDHMSwLULEmKYztNCxPp5ybOVOgayiQfAnwKWQjNmSg34W6VvFDnHx/ZsypEY1JMMmkCpZI3CaGxZ95uR62J1F2AZAHbCC2nTjdWunWVlLomuN0n75sEKvGBqoTsuK9SVVzp6jXMIhuuGUR0BXkySb+WX5cEKJFcSV4Nks31Ao54O2QFCRnraPlAHMzhqa5Zf8VMZ7YhqS6DbI3BEOIUGgG0VFqZKIPzKBWwIKO9jNR6E8McEHlZ/TjIjUnXgZvPPaRi8HnEVs0xk7Q6HJhCyaPqpcaJ8FVY/SNMTdYrj2gKN8fm1Qfc8XOHqa/WUKObzIEyzoD8Qqyv0P1x+JNT0H7K1w+jKhenedatocyafHU+ymeTJyE7KIz/4Jt6uULmkC0I3MKUQ9L4m7xdDM1MSH5dTVbiUTmqfnzJesXgda5P5ZoWpSWeN3kSwsyFcuU8aVsKvS8cRQwgUVyeSrTyhspvwIXL1QLK9tlZwXYQf5+okRNCzmNFkBYv5MXjRm7ho9GOERD5Z9B/P8O2YzWVrAWqPUaZ/XTwGUu0NLsuTi/w3MY0AdrvFbNHXEYCfhUPfozJQpqzvMK/srr7wayokQVppxLZx3Cwg8CHPUMKcue1yaUyJ2y7kry3Kyt58SqxJxt8ea4nV+h0yU+JW3AUxwNPO86Pv7XXZMg2eEOWjxycBDRK2aWl5C0RKCBp4d97MfVT+DhLbabxSFJfFkAkIMPmYtfNAw59ZVjc6I8kKfP/AnRTMd45NYYxD7JRbVNM3rGdCWYDgaKETkT2Dp3fQ5GeFmlU+pkEL+mXnC2VSW0LFe+AYEq8L6SFxJwR8WUQy//crKiZbpAuW8LdQiWA6pX4X53zkqr80KPthvrCjjazyGBwQsT6eXp334xPRlISvtgqozG4YUrDPW9aoPHdcvB9zBSAu1z6Lci13PNC9hAVzC2XEAl+9a3+6g0pqdb3EqwLNyzp5wvpPaZgPRg3JXPNzRuRqaaze9Z8TyNHcv6n4cSUSFnfuju/V7KePktm/9/x7IMSXsUDKRn/l6ZWLmYrZJ7nowFYOqVoFvwroFd3tI1r8aXqJ2PN6Oo3HpqzbRDuwoUd2OqK/BqnA4zeigWUpVV/8XmJpyD6POUGGrqs8rE5U3CqTpSBjKC0NKcXFPk5oIzA57mMcaJfM0w3C8UdUOioUBXtiGY0PFXJnMLK+lz3pWRdGp5Dscc5Qf395U55Vp4tLGwEwy0S2pElx5cBniT47qWsF/EYwHdizzvTuklcZiJoygtJcvAdfci4XVbXc5AjkNg8uRG6kyhzni1+On9e0GBWut5gRduY4/zJxnQxzTZK4Ztb2Xqba2+SV8+1+rsExbz41+N4rlzMuN2SzFEOv/9/+N/QLVY0lEgBsiNV6nS8AweL3opQyh499OVLyPFeNvfIEsdaqSHyZYihehhGQQbdyNIciffLxsWmRN9N5HX/ZkzsPfzMm/uKUqoge0CW0sS5qbpX5H457l2QrIpuPYXBIxG9nqYTaaQiycJigefPSMHlflcWXQL3LPiCuQxHBfK2HJ/VlYtr4cbyuG2I+XNyJZZxLFomXHqSmHP4y3P5WlezxzjV5Sbyv/Gk6cNwy9MUhs4gRgwuPFL6R2rsSjVG4iowJM2ZSp2p+u5XKNHVZyGsCTl8rgeHaDOSyVYkN1Nvy3NMta7iZYwOEQ5ien0evUowbaolC50Shl1QT8TuGcq+gCsz4RoKyhAlh/DNxP2+O/hg3MLwaoNYkYwLTDXIQ52WZcWUQTDFhVgmMfKWkm4lQolMZkfqpBrlTVofyqU6P6rJZ4AvfVGsjeKBLA+NVJ7JO7NIscATJsEh+PiEehvgqYlyDL36XF8p0+bH/sh03HZ++YmR8+PkI6L37LPIze9mF7PCyNJvJKMbsGainPZY9lDOUWeqG5f/UW7OhFX32aHhUt5kiSfwYw7WY0BkoJawtswnMUpM4R3ww09Sm9V/7Kc9joc9Hy1qlT4PF5QQiMYY0xw8nSVJQ7nz7WypkH1U97GE7KPokqa4qKAsojloJ8DRRQR4tBmFmaTQMUhO7pyh4kwsePQc8qAGlcPUfwp7k1gxVXNLUm5Fg02QBrB0oYKFeN1Vvs2F3T7+XSo9z6OXHDZdSFWpb4LkgdMcyQfnyvQXUvmd0kktaEKx8caYXiI3hVv5lKna9HY8oTBp8LXf8rMpYn/Jry2YrgTwvdp/VvwyLfRkd8wnNeQNpYrA9RhIReBkMKtDeYREXk4QzjLk7CfNefqmqJ3E3vcllcRAUcHPeyD+WvrRSzw8pfGSlmmGrikNGV24xFdA6nXBb+fC0qQGBmpA8Iy525p+LzqwY5ai4kT1U3j3G17iyRMqj27H7y3G4zVxWmNLl1g8SgJXOV+h68QshMAJgbGMoxQPdRRlUf7txFuAeBOkTe42eW4l3mr4j67JnZz/70I0V9RLBiQONxltUfKGxdcjPO6K0YnSvFBhpJgmgwDJFM4MfHqF2StiOY8wJlZRdSn42k5MqF3Jem0VsXWnYLIIY+nUiAOoITzThKKC7YQmEv7a8xovje99ffGkq7xSgsWZRv4iZAcynOAmTmmGdM+AN+XeKypc8k4f6WX+pKlIS4rZorgTkNwfMnBpuo+ojeDkGZNiGudJr4Zqi4mDhNaSyhogMT9pgrLKtNu4owEP+0uesjgLTjw9cnn+SZAaJMzh8e/gnkYrQr4/FiG1xjk+hRJ4V1ofkkuYtg/w+1IQCPDLJyLf0RKLAQCWUhDHiC9IaBZLicj9WdzH6BTH9ZKx7AxTZP9r7AJD/L1p9MlIT3xqeaj/HjcMBlXqdLRlxtdn8X9jwoTxD7sqFvj6L6VPzPizqnnvB32LK4UXGe1VdBDTatNACnBlsdwH5wDJLg/nxJHhxu3gywwthFLpUHM1rt2OZ1lWPtP8S+n5QUjn+eutZDojj1P27g5GCn80Cq7UrWwPSwjEXarRlBdEOKHGKsqfoaorocNJQlnzUfuymJuUbfQ9xXoPVvMJ7aj6rmDP+2c3ytMSvfF+UsrJ88gkS3NQtNyH960O5+tPxcTER1G8mWjKCzIqoCuxsGrppyOiclBBdKSAs4orde0PxsR5kihxrG7iywXpPs4MA3DY9t8XhkNAJycWCgJCSUgsHqHagLXbwXmRvLVBnOsoHQlA4WYPa+P0acJzaZK9T+IZDtdRX1a2ryoIinmWGx5MV1N4DNCU+Cpq/FH6MkFgAMiADLMJAqSGRfUgupB12veXFgxnDIaFzNVkVI0zX7cHNw6z5QwkhsA/oYW+dSrcO465XpXO66yS4SxCpQlTuujFoXaZ8T6Ya4bP/ddUKUrZRMrq/LnHXJP6tlgr+LvCvAxiEGMLsaKuTU64YGKWR+pHYI3FmZ7MNvBoVUgize6bSc8id8OVof31VAQ4/fs8PpsoX52Bv5IwFKWTZm4wSVuSV/5pXv2AqjmX6GMIB1iz4FYbzLelIBGSTdwTbrW9+ankqvKClixNQYvS/2EBZXPy1e9KbEgjSUjXJFDne9WwpLtZkMw7Vu1A5RFwUq4bouKBiSXi5xw7sSGYVtGHOHgN9GwpeL+ZvjkzJ5fwrsqfF3A1wh0XzTakW7Wgukp2WdJJ43fLqFtAsczWuJ10wLmMonNYybNpiOZJUnsmpYy7BZzTo3ZTnU6TUkExAcblRPwNJgLq7Cf8CyYS3Cyms7rl++IGsw8cnjri/VH6ZQQ1FW7l2VmA2ShtdtPMYnpkY/sjrLzmfgqHDBfvCgej8ZDpmcR4Ox5Qt5UX9lhuYLT6BTznuFeMY4Ut2+Hduf5mzJ/0VmpvOfJHl2mg1U/tzfFYGxef2kcX6nWaFUzhV8JpUJQ/WZSXPMWWpPZFWqAYhDLpfZaaNzQGAF9G1OQTLdmcKU2ROk0DMBDa0pQB1pSWDvE8TNIgrXhsF5DujnytGQ4W/VHHEDPbdtVmG3CGZw73izw6IdlzNzS1SY6sfEQX39BHEXJbbsuTuy/InbxaVvF6Ji7xuDfhxWZubcY5QuPP1HMLDpOokrW8c3xZYstd2rT4MweNOXcPk3hNvVWjmpD2LWZ0OHTjaV5Jx4AY0DiAnSWc3bfqM9CIcnmPBTlyILObIT09U2TAGpb4ukSLsZTuSIUXgKVC7YQ3RPSbOT7NU5qHUoNXMky9n2xPxKuJ9U1nupFkqhEOYqkTm8wIcKKPypGJRO1Hs/0wM99Ltj+xhpIqtsSmhPF+enZudK8YayVgOoJPoaUT3dfyWdq1BcqmajuezvSzQXTHklSIPSuxvjP985TINaWL8djmazV//NwKdJDp8c7bMJuKmyF+zSjIgdJGN/ieFF4QfKybFZpNpccwNA910tfqI6jN+RsI/noyEJ71/xuFJDVDG5u3oAhwr0lXA6zVYnEO4nexJGTOAOSQ12lfEZqHl7tWwYVDhg7a8e0b8jtK8qyvHfWD9UMxWtO9nLJR8u+MyGSKHtdZJcfPFSQksFoH2Yw0mMDZjC+NJtmYH4IeMOtgCfieAiJgmSStI0MRVkx9WRtKsa6B+pkSYzGwYO1HdILhyXeZ22Iq2xbPMaLD8SAFXWmlALLCOcGm0Pk2wACCY26DGJiBmvwUMKzNijibo7at6lNOdHQi+NUTgUrsfFOeAZ75OlpVmayCzu8rE22an+rHj4n/S/92DL0iamcVewzPigS70l1NzV66YSSIc+wf78dBWW2XLKUCSAyDTbh1RFuOAnqpZKALKPTflPJ5UDKhpML5GE1CyBB0bb42hott9+Vx+uUigDaQNvG0LtUBrvdoKMihJlAbW/suX8dKFWVTYz6gMkIXVeIeosJNrmTCzEbivMqtUO56yomWUFcpAtjSibVBMudh+1jM9vCCHV9U7SmdWZYU+8ptNTk5Vy5kcF1JJ9eVKZHz5Xgc0spvRfgGFKbeMpJf4Givandr8XAL5KJkkarsBcEA4Ej0D2nRgkWCknUwXQGTxRYZ4O3vMmcH4sLyZ4FeuQGzuaQy0mELjHss+hFHSbqaqNKMDEMxwkz0udQTqkkWMf3EEuNjqGUwrbJKPdQsfXIszlNYixXd5XdgZinHW9uGh8G4SgyZIYM7Q74iVKNFVcwbdYV4L/dPNyw3az5o2ps02dXE0UisjYXFaGtZ0ROxcJG4A/c80MJFVKUyOo2qkLR1MHTpgiHlyonayE/9QVqRwiWqKsliy7LO4uErOqqwTVsX9+Q3il4LgHiu+gfDAoOOqQAEXwws2zevlqQXNcgTBHzQfxncz+Etdf7YUV9uku111ZWFv4dXUff8XNH6wcKn4nmRlqi1jd2nPu7WjGkFajvOCodRS3KKWPUSLQvCFB9X5vlF8/fONLwfuYcuKWqHEr+yILUg3iuLsq2wnHAXY1EQZG5eV2GzGUwsXT2GXYIrr/VuhWx9J7QyG8b02m/IJAYb/Si6I88RM8sY9UBsoL4UWFOVByi5olzrep/3cfFX5E/fch4/0IdVh6nCHGk/fCpOBvLUENkVMAgVH0NA4owBLJ3nUwjuKCNfIfRXVaWFgxEfdUFxBs0DUZ9F/DZxC4TW4+K+gt6RGZeRxuElkwTwbyohRGwi9C4HAEg2ty2mjsm3cq7fB40GvHcUmvXkn0CrVZ98rCmFWfhzy1zjYvPv+GdfNJaPokcvu1hVzntJ9kb1RjYhEdB9vqBjv2CdcMQmVlPHZ+Nk9Yp0s+4CaMTnyu6iRDbztb7R2Z+UJHZUzb5aSt/LkcQB8z83KzNRUMH95VgxRb+UoTWahSj7ioS95CBE0YPidVO8rIhHVJQb8TKHvhJAiuQYub8tFg/S1Ge9O/KaxGZ1+cBLryH84JBHGfIqg9wrINMB8XF6bd57+OeDo3y60Gwe/8DmerrjWpXeNNPShkdxEnpBTe2pUuISdybbv8g0Lj3U6YaEn8hGfzvjcG2NiLABoz28mgH+CE7qMGjwUX5KqloomAWfy0UuhstYusmuXZC9uXI6oX/Spg8zSgIAueFUf5spnrKO4yxZeCcIvsait4jydYWGiM2RkVfMMfAPUzcnz4lwPmJ6xBZjY3BEar4SCxStp4nCF/+gXU4o8zJEIHrOp3WncC52uvB4DAcVXimQXCi6m9IW569p+tW/jf5aWXcs4t8Wq5VpkJ06QC6PLdpS+yFctZExEMF+Kst4dBen9fg8IRXERD3QZ5axl5X26a216GRBf6lQp0u6Z8n1uVR7CD6fBrKEYVXdmQsgJWMCmw150AF+hmSupCORFr0oTq0Di8xZihSQux7wNY1lCs5ZrjpMEo//LAKbRVoyQQqwfVWPejCb5ctdexTE33Tk/dXoxkfkylfIy5eFglNbuWxO7l5o6g365RRlGrgwp8e6nIUAHmiBpeD/fPAPSg+zB/0gI5lyR4w9tKjCwyIY1IO7y4lbF50UkL72B+c9LYY/p15azFzPs33bbMnzDZi5pnnPF9T+sreQI8iUU4boHaHIjM4U/JSsP5/FO8avwGzb1Cr/WJzMi4GtoCtdUwYeI/GRdm2Erib9PZZ5Hbo3F+VhAexbwdUAS2NdjjCiOK0ivchOvyycHMjlT/IfyGw+V7+KQuNSLVIIr2DpThL3ifGGZAfI0SV5Kjc/4RdTjBelWg4cvSCtN9GiKkdVtDAQjf32pOV2YOpq6MaathU67UB+jCJRJGUTTkco6sEFQvRGEpbhLvQNKJUlshZ7qhXtrQixFV1COp+m7xwYi0MRyJLfYOKal5RgoEkVXxkhkUCwnRfwXgh+PG99kHglmTnK5sNYO0wfXsykulEjUrTIPCgghFIXE0NPxy683AmrWQ6rqPAGG2FUvVBel4XDrWCBAMoVB80/JFUn1LgdY9697gs8L+9a8DvWzVpzGdmnmVWQzgDrqPjga8EG0nXZeyYZs9XMOMSM8uwJrmjp7ovgk33/w8KGQXkwSmrTkEvxpKB4Baj3gPhno1iVqE5bPzAUBOQ/YPBz4gxA7wvcWKPf2GzchHAXmoxeHRF/UUwhhtmk+0ouj6AWi5eYX30FqxPXLRpmjPhJSp2omYVP3gPHGl2KcHmHig8LvAz8Fg07fF6A9izSpjo5cIozMhfA9aK0LF0sqmqeZ3Cy2LfSiUh8PKgYfmBXW+iGxMJB2slE8OkoZuljVTcxrubUCQV3isnZBn564ldH8v5X4dZGZiGjRiUDF2ne4rn/AOW+4hqT5t9OO40qCrGSgozBp2VBXpsL7oekbhv8RIAULmXFK1sZdNgSNfaOWdURcxN7JT4zcFwPNgh6c568uChcU7gxUTsWfKhoiZGu+FLUos8tfNtJ0/PQ6zqvV4uPr8Z/9HY8OrNFylbOvfo17xXCPRYAXlrqBNOcFjIwXLLcumg0qBRaaB9eJElxDqcv2fowrL+Cv5G95pbVuEOeLkH5FdIXxZmlKcuBOdDPwsQ+VRd+CaUTB9/KhgjQRTHsk/UP4cigiDBrrA01xctE2hR6c75ywKwi3cWmtzZcKRpOTAbfUONavLEE/6mSgBH8u176eWp7LTf+p/OTnNJYM7LLonxCrdZwpCidt7OrC6yXSOE0/t6ZMl2zFMLDu9j1QCYDyQTTOL1konZTK+S52ss6XbDPiU+AYrI1Dks81W+mIQeTJZ4aAvkgx0Eyg0NFYPv//J/2F4Y5GyJHt8/lZZgKGTZN0EFwXAGZAo5CYJyL1+eKiazGXB5JZHKCqm3t4zdn3XPyb9goC8zbCwnKw8MrSWGLLuyk85vFy7o0NKNEku/O4TTSi7uixvxXx+ac0nXPsHUwLErGNVw26dfr9IQkfwz9Bon+uR3o60qhIKey3PDis6yiDLlxBz2cCrMgbe6hM4HWpyBdoOee2F5Aqoxb78pzC2wP2OyIO7NUWtQKn8ONp+D1d3RoaA5B+ZaxMCLUQhjCM5ccPOFvDc3cmMRzZpX1bk6ebYdaGVRuB6AoFafGnMJDJbSaWt2B9hUg1vWzK5pHxR0tiPPIrZNbDD5dxvPrgC8EopzeTliqw+4CPy/55WZy9bU6DHBK4PRBEBfjYkczfy2877inmhSpIgvtNzIeg+sXzrTN9y8dvPL3/yPUybx3mdclnO/BzDz97pD7VTk/gUIg3QGuARQLARNGY6wD6J/LcoqMECxtJ7Vp8lkonL3RNZrTOmz3COHIWC16/vb8pZVUXmfWPhVnbSQovrbDxDL8xW2aF/ZyDzZcX9oPd0/T6ZmY+LI5VGsaxDE89U2rRXgeXN0MlzbcP8tHpjA/aAdfObCUla8Ok/3LdNaBfKqqYwJTHBSEueyXjtV1xf9M4MudqOYYVyw/0JXflthaSwJ7QFCU4WC+ypdhjCvgxSTO2OoqZaU6uuzIr4tcvNZpV2q+scsJaFai9g3lzEp32gr/ZjKGGqwgdS08oQJWiR4DN89LTTqAZIKpvmcAis2u0pymyZF8dC6sx3qjm8IEHeZ4yJDd1RZDvsF957rxTALjug8n0oIi2xrMl8Gsrg0WJfynW//3tZ+JN996wR7/KHFeBfpIFtcb4ARBkyDHFRmAzIzwTzmIAW1xkcP6SNihMDWobye/XiOhJq0aNjGwBaXxXjge2NKpVQv1fB/mzx1/Ro89H942w8XUKjG7AIuS4mzIo2uq/Ba27kOeyMMwrRE5veeEVShM3D+gTaHkA/4CaNVbqWEoJ2VujuWfjC8OQO63jdkHBW3RY1+MowmHWyeKPmbRGm4vQrsI1edk4VboXElP3u5lt3CxpBhjUpimj05Tr6mV9dRfhSSVQAnEGxHJI+4RfCwyU3gRcVSQNvPTg7Elv0HXzt1uydyDMfeJ2ZUrY4J94k+wLcNWli1H2PdI/zReBEpZYbNlUOwzeMj357Mb143Dt/ie6izHxuYYRBaEWxQZ/PUUWqfy0li+szuePHO+kTV6S5CtgKy8CC2dPq4YqIz1fJiV0Dim7UOkE4htkF5njgNIgqp1rKe8JRMwYLiIlfO4/RrDFWN9TX75Vrcf0FUQxaF2VFCqbdDHKPdVZH2M/buWWwvEmdoNAD6zs12UeJCXuF6NpXoQCngRYGUR3m2g7xx+5XXpnhY+VoVpSvaY7RfsJDODoW4UwquB4RggWdWyGcIHwp2gZuDGGA+HTpnoaon/hVDcNL29b1jj8Mln2Z4mrki5lXkKEuH03d2sDDjjIWz76nKWDzwYOyjra1Et5Rqy34PKGZFScepyqZ6vbXmldSQAIYiaPhy7SQlJMoXeOV4YJPtTcvEc3WtS19OmWYx7/I2Bf/DKKaveI567uEd/acPbLhp2sqEPfA3OUpgfybmEbiL5jRf6GvvrvKs68b/57nTji+wHqkwyTZhBnFzyY80djo2MxDQHekU4W031AsUT+T5O92fK4UZyj0HZAN4xMXPCKiCqok8kOfsC3owbR3N/p2FkClxpgHAFpAyWl0EwQhON77wwzqz49MQvyplyiXWySJRT+UA9uJDzDvnQTvZsPA2QnaXeHvKKSrWFCgTuYqwMYBNlBk/ZHFlr/fgiEf37NnfRdlAYT2jvillYSkYzxgScETLpsZqm5k02+lvCDWjVwxs/dy4nPE554Y+y/kJS5or2c9rrB7igkg2ZQzDf42FewWuikKNNzh630a4ybkrVt3n42jQ+yyT1DFik+CThjV1eDsNf+PIqEZChC3U6LxRwmS6EZKUb/1Yi/pSP/sSqvjbfG2uvv7mEcv5qRhuPg74uVST40pbuYlZa4mNDkTEM/nZWq8bBhVz67zJWr03aTckxwMqiNG8Bj+O8ngQVPMunJVfqODA3weWRsyuI+7NQ3dF9RIwaV85Ru4ZzCk1X59mCxoeScqJpnJ8kittNr2fh5JwMVlHmgsevQLw/uJWIDkta1TQ19Vsl+OgkNtVkGeOjbHoGiAu5DcQkA0srwkOILcMqoHNKoAf8C1b2sE3SWU6hy3iXykqWrywAL0JRDHLPNGgEjiOVjbg8Uc4yoZzXlyFnCcpNYXlT+Ir9y5VoC3LmIH+Cr94RE8NIKMh3ILFAYQG1IOw9S2RbtiIne9umfTBG4qynJwLmRopcBYvHdIhJjwK7qoRVAm3KsChOLG9Pkmd8K4rx0FdmaXIr+zMgqX9l8rf+Bf2fF8UlTv+9CnwE1K8SB2dzW1k+Z7I7h2sz+hmJPw3q93Mv3lpQF26CbNfEP/zT/0zNJGzR79o8vwHsDGNEH77k6X5S7KEoFZtL/LyhDhvASBQcQpQgBGF2wNuhBD8l2SJJIhxvxlcvQCshJ164Opc5B3MHFe7Fi8tMfaAOi8WzG5qUSmlRthxA3zWTDRmvSaMsWM9jtoQHWwxaEBeYgcAGC31HenPB1iXoTEHF4YVp8ColEw2VOJzI0JijiIAjhVYVfOMZ8TvJC5eUrkvlEzQ9jc8fs0qs5nIM3A7qabzr6pOfh8uhNjBZbo0a1ag9xuWE1N+ELVOWj+LQwvmns5u289/2Ybcw+w9aSlqSvlLZMiLpPpu5oAxgxRKzRbxvJKVm0nyuwJdo/nTkx6JmI/WG0i9kzu6DZz33TyxQXxp8umM5lfT7I0WqSl9X0+KilkFotAzmADbfDrqL6ATEpVcL5fOClE8uFj0yGZLqVyQ/EPfaflCR/3xVv1tHel7x5pTLMPDjkavGLjDX4cRgRBH3XqYXcynsx35WgrNk9LnihUm1oXMpqs0pYaKjA/yAUgaNDrbG6e6yVltM46J4KmhpVVQ62Muz71DwgS7fm+H4CyoGkR6lFzkgmJS31YklDYvkVllAIGIkNrJ8kFqXdb48A94CbIeprpH3n/i7ntI16G1JPHpLdyRa2AismWFegq/8aIDEki8uXhTjQmRoQvl7+OqT9NVc+P8Xpwi4IUXRlUJ3TYuKfK0C8zN0uZb5einHZP86XIiBONpNs0gsJMHjkuHdAz8O6XGgvN6Ll6Ea7GnAZT8shd+YpZOaqC4Lb90pSs5FjBhI2SjjKNmibJgpRkU2LYFCR0svQBSLsAKWIacz+bDl7KxZxpwfK/Lku5Jdz+G/B/9jztGxIHbTdD26Z0Zbi7KyHnoFCVgoMBAokaHOmzOJnILCsTA8+saWF2u4wMDBuuQSYF+Tlx97UVa9JHh2nS+OiHMBwy6sRGBSkQdVmsvEUV8zoVz8Brk+8b+NzgDbOlFXT30XS3uL0kJZl6A8RqxiKeYyHNaBaFBJBqoigbssqOP5VuCUxXUE+BnxZCDp0sUGikNw68fumwUWK+LOTzHOo6whnq7T5JxtjcVxQvIVUbLYMy1sAnXJkTCTpjl9sKrVYpgQOBmJYIdLCV744exyiQYSurGnOQl0t5WFHCn7yWPOB15y20U2599lUzsjVyDI1EXd9Hd183kylpG+9lq1v1a8P2dnw8TSCrVACN92DmF0k3BFKItUkUiwxpIJud3yR4/BcSfcPDM0T/QtchLHsiuT/FvqYJlMqvHGcjv2bP80lb6y8r9OR7LUrYHperyYlWTIpQmUHJjpxcm2PGykqB7VnxLRI/KMqyFWZNiacEcTOU8+WGEPnvJ9Hb9eJg8WZ88dE2pKYdm7NMOrsGCB9NdbioI5nCCko96tEGXnBQTqn9ZaE/lbP1lvEr2HygEcc1zK0NZM1sfo2n7mtzA8LhP7Bss+Q2uWl4ytz2v0Xzmm8UZ6WxLHMb2opPcb6c1EmctEmdJSDL96gRfafIXrs22pvJSEfziPE0kVLGpn4kNSHUD3SyndBNKxsTsVm0P1gen8fyo6KsZ/NHV3P8iezqa304KSRieRLDKJGcKoxi8ArBt4m8UHsTYbMJ5gEzN5y9YEH7ZpUJYXLqILgIN/HIeb5nwD3cDA3MXdp177Lf38xyCX0TOf4jRm8DhNFlgoOJki+ddp6vLg6mm1xvn73dLUBGLB8raAdYl4V41+lWAD0yyw18RyNv1VYuxf9P80MPNZX+PFXj1q9GHtx/wZQ8fIX5+b9wdIXxX7ILzzSnOfKakXja4bZWHVqpZuRZOMmMzoX/0VAs7sz3Oq3VXlsebG4jZt/8quvEKD27NFReEzhrN9jjPgbEJvbGIZQ+GBqycJV9AzGVo9ddIP5AKcm2BLk6UCm97kNU9yhqT0CMgNPLgUcxMkDWC+jVOK6BHsenKwW+QqN+Z4FdOTK0nrelo41Z0RdCbSbQ2DptjN66LkVY4zphvlhyzNUiQBFImJDWOHaSqQjqGho+mqerQULnZ14kpjG5jXvYzmySd4cEl5AMpXUhQqY6IxyHqD6GOo5IfBZdl4viD0DNuycPoOjySh78vL+0w6H5PBo1CV+DQnnZWN7SZtZCm44UM5lVWeFDLLj1SnIicBDQwI2gBVuWsyCDmR2dkCMcv9GwyjMX8FYSZMNzQQnDE0h6GFkpRdrXLT4XMd6xI/uwBaB9AscSukSMVOsfcQ5B4tjP4d2LyliC9T8db3rWyNx0648FVaGDhf+PL5FaO0BdZsYgI+suBdpJ+M+UkvuvUxeDDpf3698ZvZNIc0f4n5CEy16O4TKX4Tem668ip1MaFF3UHiWQ7fTyGosF+5yc1X6qYiDs7SmQSIgHxDXYr5XMEvqvA2YE84iF6SHw7Uk1FwkM92yxLiKFQ4WaKNkL86xXNFFAO2B2H6QjN9dYELs5d+6cKzYf52GdziyKWiB4BWA0tzEL4XfHXJtUhefzWZFowESe2DILeXbBIJZ4S/oViySHfUszom6X8Cwi6pfKfWdt1XF7K2pgps3v+FX37T+5dyPL5eufMOmr+WZ0fRJGLjQC0BCHLoGbcLShyF6o0nksfww4hdyxGjJ0+PXPmB/msO87ayqY4/sWqT4nTjWDe2hOiAXgbOj1iugd33sbvkaUGQTR3CWKCwSyLMKbp+uKL2gskonS8YnVy8MNWqLn86g8NK8od1YVXTniodzMH3XZioMJ6njVzO/UqMS0BNrR111G+a34lMtev1SsZu4gmOK1+gROb5FYB1mFkRaYD8Gyhn0WcUplOe1zjri9EC84FcsTg+B83LzkOj/Of3pXe/d7k1V8Kxb5xSU/DKCHtV/mQJLt8IeVuzP6OuRYAv8CYZtENTyJU5OCLJHU6Ux+ggK0pfZFbnLJilA9N0CjKOwcZEWUujPSzeQO+Gmctl6b0oyhOT2P9cVUsAmqCWgYd97zhwfvxQLmbd9mL5fI3lrySFthLWgB4oigVfEtiR2E9eZzKj8SdfRGo9W6xGY80cN5LVObsoKBPJiphwL5LrY+zKhPQdeAd3knSdS2bM3ARHOlR08SgqyJ202NcmA9MspbIiziSkj/B9BHJ3kqho+TpozSZpp1HIJ9EGyREcEsZaOiXQ/iZF7zCm8UpVZx2REvDOE//xLHhlK8Z7UqpD769ww0kKGMrfarWUvgYMDYmyDiERBuc3GOqfS/NadBtpytw/IpIfxuECCQNU/lGg/p6Icu54wuwvao1LeW/qH9VNeT167yPpsynv0fDWQzMSEBbJrIHyNVHGdKZIrAPqZ9Ospf88m/4kKy8ouD9kxETbiUxt0Y7lNUzbTbK/k011pskctMFkRhZf8NxoTkg/gn0Wb2vr2/7z7erefleHaPpOPrkaq6pzto8yajFP43/xtpxPSFlnK2eytIwCJkKb+DqnN8RYoloKcnF4iNX5dgx6pDGX82G0b+faP8BmEkEb5hzu78AgFsqNlFzKF0O0/FjZRsAxBH3CcxIZWHC7JhYWvWlLHSRk5xeR5+PUGx5fyR2VnfcmWeXSVZIEVTKTa9LRinkZpz8MtOcJIHnUsMm/jiwtJb2M1C4GVyjoaRy5xLhNc5tIGpDLPle+ZufbcqihJT1uaWocs1U1pSEyIFxry+03SYYCeKxNNqszCUnnjJynK7NQSsAzDAxq3H4wLvfy50EqHwRSXW2/LTjjfYyUh1K5BiYNkLmlLOzpX2edcUZJ6gEL4RKGEwhOErzwJtE99pBDcjMsufJpJNwWuxsldeyAgk2qP8Rr3yn/ctz+ZWP5xspsnC+xKfwNgaIrL8VW9pDNl6E3IhykORfpMTh2xQ8W/PZ9FHt87ZX13acsBWAHKodZxVdBPlCpxtcLIHhbHsdwtekctuE4YQpR26agDBdmJPM6LYzTAxOP1mHlqsieg7KHD/eDeZcIpGzDeU/JGULkVgv9I+/Oxbz02uFZMi/o8f3cAIRvCxz/yggVshn4j5H2uhh87/te3QYnAJPdwtYrQ/6qv7+hSGWydTO1ZrAdwZnKpJLkztnOHGzN+5/zWsea2lZBKdD5kSRzkJnEPGGvR85B27yZlTUdjdbgfI3NrNTfE+U2n3+eNWz4wzifGMmLiM9eiQ88EuloYsKbPmWntHfFGG2mHKZtF77zCSJv5p+fu0eLOv2TivLxDMtBvVdsP9GVl8n1AM+XQM9UlTuZbkkQKRHS9zD1QX8pWA7Jwu35eKyTkZyPsflUJBb45gjdv5Y2Z0pnJvIU3MrR8AV4eC4XpqCWhW0FKATVKugiBySF5304G8FyjqUdEnV4/xfKAmeOjZSxm8hqF0bNrCoZUAM4Isgfx40/w1V1cnAujcsEVe27VRxskzM1eac4a3DtHCYTqjLfThK5ELP9xiwYUJnjCZK4yliWLQ0kGoMnPzOdTFpdY1qbnWcQuJdzVsMYhtqFNWG42UyvjOEXK+D81F+u2U2ckRW00itij+06VvWjdHPMvvvQ5C6q2PxUiRb2yfIo/O7reBgYV4tqJ8ejAO1bouqKZj75RpG3W+ngUfQCcWvNVhZgNyCVVdCbIS6BO2mhL+g0wLcbSVJqTtLh8BW7vmery2pHkRo2NH9Ist+hN8N0REFmSTvPpiQY4KgsdCS1H2NwkFZ165ur0MpxUaHWjrJO8P6chh1ppZ3MBT5cwO9cxHXJOxoFK4v5d7DzjzTUKGqWYKc9nHPBlbnziGoPCf8YoPwDXjyWRwXu9pKyjbZeeLETh+Hw+L3F3F25ovHD42Rxj+nu6KVS6d7mxW0aOJLPpOyppnb5+a4Uv63UFbFmSNMJfumr7oFWoLRW4e3leHEimy3QdbkL0pRItSPQ7ivXeHjlCn15D9MkzbdNRiAsMU7BGZXIk/R6rFdOwtFdvV8JGp4x1dkhYYu1wJwjTGXMYO0C7T6PoSxLOuXX7MnlbLevbhc1tM7DECqWmGQwu+0DAHJDQz8kUZcePQx3dszM7TnF6uWZeGtiFhGOvx9bysRuyNEzMDtJv5nIDybKRhFVcuHLHLD//XhzLl8e6ReP0vhzQI7+2OtNlD/4biEcsmMZb8aR/rMUGbJGEFoBu5BOarGmKagAoCnimTDrCVZTqkMx4GIEjC5yAgpHYpGzlwa4D9hqEX5+OQdXSvoMP9+OLI3fFEawE1dkTckX2w/D48VYRfBvyDSFefffoUEhAeth2ktzp4Vymn421K8hoXARrQtI+OipuTSgiUftJUmYaJQTZxM1HIKNi4BNA8jIatPAGejWsOaCwY4SRXgwYduPs0KFZ30q56WCYLWbqcKkgRCDb2PjLx1C49KyOtyS+oXg1r+x8sqQDw3uJpIMjJw+eA82NXRHdQcHVpiySQRiwjefM2sZ/7zDkIbvLfhyJX7YJNMzdXNmFL/03/xaGmZh821VASD14MkzpWUvNz41P6CAH7rtt/CFqroWnTvazc+C9s2MP0aVd12HW2UikcKhdUkAr4jlLDjBRGCpOLAO3swrU6rvpiKHrB7Qs/Qsr01ddq/FRwV9YBgVKzUTcr6sLF4XuedqHwnnCi/LYtbgpzzSUhF2hPYNt1e1Uyf6a3oa9IzJA7ax2jr4I2p/U525tHdurpoCDdFRMYu/k+ovU3rojctK0wS0DlslhWSjtC9V84m/CTyHhHOYPUm1hF5m8YKMSuuUlYwhxwt9FA15vMIrNTzAKEvB9gxdctEzhVfG24sMIzYYKJbClx3Y+/vIxkrxML8vJ1bIbyV6xo2Ojby2jitZ3oEoXRyDmd2P5OYF2UmkLzpR6EHzGIZLshIwboLST0HPV5CKi3f09IafM8HVavBnvj1Fye0TKB+7iIOJyqNVXLTosxLmJbN2xMD5OE9Z2rBpmnb+dSJFtD7IReuiaFL8P9P+k8Ebaa6SGzw6lAj2SP2uoywZk/fh7D4qZ43S8+TsMnqug8KidDsfH2QVPwPutDG/gAeXUAKyWWfD1ZToPBVg9RK3Iy2JSd0U7joQKcY9uJGm+1B9vR4sH2dyA0v5Jbrw06Ijv6U5n83V1yfgqiObsjx/G1cNwmw4mYJJSsIA5RJpM6ZBKKUn6N7RuH/kHtIglrFVVDNFMWhAaqEHqThh+BA474QyOhTBq9BoJ3MJz3yqUky65Izjsil2PO+Fop72+IeCCiB96c9NrrzvUpun7VCZUUSX2KULohQtf6NKGHt5cNVyx6Y5xNxYksG1JF2nrMmqim4CgurSRYueXtKdvrL0Qb/fyPkuMZ45poxOt4zIQssWOVEVXuLaZgSrUmZDN4U6m6VrNejkzcv76gXkaVVsySkZ3bUnKSKewB1GiXi+RR+cmeVCeubAZqCsgvTl75gZzUiSoCNFipVQnciXclYPvygr8gyaxyKKyGglqQ61B8PkfKqc6LQRq42Z36qYeisGOvnKVFUL4KdmZ4RWUbL2Nvg6gVOBRqpiWrzKcSI4AaIr+ytZfTuMf1qXS4680SG7cnpYVpo+ta4R1ZCLP87GgyDM8HHKuCIG58ZCF1TT2ZmQfDUuKaFWkb++roMitfOReaZGpyCKRXYKEwO2FhTFjhaeKZNHwAoSs670pZCvEYHpWKHzhJoJ2qZ496kSW4jbfJBJHrhh2TDbGdGYgfY/5TNLqlOwmE8Oq8qhmdSuoB//nEwl/u3ny+s6K8eonde8LW0KY5blw5x0XnU1CBeOdA0JWWLWXTp0jEcCZLKMaGxYibaHGf00Ji7Elg1kGzCCix7KfpLA7tRBqNdAbh1c3RDZmx4d6Dd+pu0f978sFa5I1DXRSU6rfOhzBp0Axy/kO/9CFMa9lxHgd8oWwOkCdIl2xPjWNWXToL9BrO6gehd6FRhUUYGlxMVTwSxOJ1RJYpT3oTNidiTHZTnUwHYktVzey4pbHYR9cC5L0mY8uuNCEBTncvhbjYfCfQ41mc5MPNuWV1I1v0tm/eDVmqkUgDrGe68NtMgqV0XMmDfA1acMLZBphBrrXMqBU02xfAhHgP+Szq4bpi8Nb0RvjtDH5bSWV/r51BoRZarJvlMCIJbZDMPFZeURpACSjTodGmk2y66HLPhI6rfxEIH3FwPTTp7YuDgikiMgAMYUzGKpfqkaNj87BUsaghgu5Pg5Qv0WNhGKRexzIDcAJtf+IZzi9wrJGCsXq7SMVekdrbVo+NvgqqHCCf7NHn83kDet5LdreKePKzp7YiutTTpKxO2QwEDSEGow0V7IGLfMfhU4ISsJkl1l/rW0YjEW4oNLtj6GSQb3YxrYuDYT04w8NpP3dgN3qr8aBUvX8BrhL6EYAfZx7EcD9FRi61BWi+j4PFEtkr5GHdVAfaNJ0PoLAt54fBS2C5qzA+UF6gNco3JUUoc5UBkD5WGYdOhlIqiMVxNScmGGsfNzHszpkgM9SLpVlruQ5QRp5/E51GYKXD1EQYoqPagYsHfMHIe++9LPOcFftlCOq2odd65Fym0/XwWGzXpdxd4l9NPYtOVmxPRL+t0x6qpWoczUgMQIRiOoUHne4dfnLJEQULF8lZ+uC6OehAuJn+VwKS4FxjtuRKaMNDcV28XzQ2AKqo+V5F0fVBxDYhsPa+lvo4uEWQpNN6HXRHWizt+Te5gMSoGB4fqpMfGAJ4OSxuU/nlci5USB+FPr2hwPD4LP+sjMyMACExUt3OG5lKoHsJOA08vkg4306lAaHwooQwdBjmDuX7q9nJ5mKa5K5Cyxqnor8a5N5QLlx0vy2Wqycankfx1f5KUNF8l3wWwlm14PpBmIxqD9wngwDmf36a+tsKBCQ0DjHSg0QJ9BMAbLZ547Yac5Hawr3nbIHsJ8O3r8LN0mUjsnJR9moAQmuXhrQAb5+HKmLSvpDsejAXNSEJqGv6FxjTtKTGfiwVEeOeBowK6LlMRsd13vAfSekmZJ/D/YYjGUtEPDBvz6C/4wYU6OVyWJX2e7Z7xym+kRbOO0YaZrM+lzLSUBWSvTliKTmUKSDSc/MCQFDYGkD8Hpb5VCt1DOEXMY65vkBVK1lB6maDyV7sWwUQr/cixjIm1/h06TWCa4jIWc8G/286SM34LJoQxhAwdrSm4IN87iyw1Nc0W8yEd9pbyWuJgaA0V7E+Wej1an6ctrRSbzzIYymEmTtwmHsWWD2YaccwKDYGmAnQwY4vD61DAzPFhXlL3YzRP9Auo/ci9QvBzjt+bo4DDZK6jOBbD65Ed9rzUFn93Va3W0nOOTqVANARvqqxy/Y/Oiq0w3QBMz2DUIxKkqdgvxtUhuPpFkmKIeFDXgqzB5V1SniiJJURLNrECX8dVX1ss47B36C/cM/zayMnF+yn4JUYo4WQx4ZS5TNJvRH35nURf2I5Au4dY8/r2RAPtJy2bqWd5IIWipoq9GBnQkuuJLd8LpYSX75k6M/6ryX5S6YJbDQZk2silzZe0yURkY3FLtq9GFDWIZ2DU4yEXrdd7H0qVJf+8rDhPxQmXyHfmtnpc5Hn56Np5ntNtVAAwIRqBnCxzCTS/9ZBq0Nb6c6FgC706GD+fWuBv+oJj66zb8XeNZDXqL/GaFT3/ghQSmAuaeKJkqhi7uQDWyeSOEQwXor2BGhywrqldEdxGeUgD31eqf8+VvQqmXHqo43SD2AFgxjD3wellVMCqN4MrrxE3wcppc7Gjf8NmGqYlHIFeEKgVyHWIfPZr5tbFan4qpjaGB0w6nLjgKxOpGuqE4jwtolocFLI8DsXmOtQiHOUlW0ClOVxheOZ8Ov5Gft4ZUr1oGGfn6+sDe7IRnGQ1soMktb1aiP1ymsWpMO8g79/0BbQAZ92LJwK2AZyxScdPzFvA+C8hYh2qZiAmoHMBYkxJF1P6I7AZwVnEaTLpGRMsk8zY0Rv//guArxtLsQAzzSf/5839zqlt1K8fO3dPdEznkcEkutdpdaSEIkmF59eQn+2UBAwJsWI8G/GY/6cmADRleYAHL1FK7S3LJ4QwndZjuru7qCl256uZ8/5zOOf4+SjiIqlJJIup2mEykhCThHgOrRPwwBwTudgI3yEgAtPMoc8g3WCptSH3F32hQ0hITg0/7WnGCIJa7ltS751IGrIGunSjtE9F+jh462PFjEiXtXwh5h6xG9G0lsockV5HAfTAzGGkTWkr9U3V5nkVjoJUVPQbHUA7eA6zHshgvSQz8CLsVX3Jo5NFCNwpl6Wkxk/PF/cNcmkX9CqcWV7rSRid8q0i+loAGi0Ns5WILMLqJ1SHmZ+LilxAZdF2DzRXQ98QtT87PpfsqnBaD+ROjtgcuMtJDEq3eVv7aD5PXidc0GUtLGYiqYjafdKo27ekbDM/UAH5o1+8YT4Z4oWtujqKDde1CiJJMZQF7H6vyQshtDf83f/Lvs2ex/2LWd8FhDtdX4AqL3nDUmoTrOWmpxfZT4g35QwmDVnR4EaYOmLsJ3LoYZWF+RLOL3FsOLSjb13K6Lwp1pKm8twyGC5Dd9kWgp8dEvIkLHinuJHJeOlgL2ZnBgFw8o6vH4mACW3r80JHWQPBmykaPUXlZSWtCTVDPF0TD946jCxf738TrGL5o0bQEVgB3VHRv0evcpeerECdo8QzKCuxARPro3bd+5Youpkh9n3eobD+yF08krYJ3z71kHT7uQXOQDGX5eIHLWbx6LbcdMIigwcjaSBT24uGr8cANO8vqXANkdgV+Gc1m4nqBmALVhzIKxKiG0jzcuOEOHwdvamnZzK+exKKVkqtgxI2LPgp8We5IhZCEU1kNiLE2sVOtQpDR4Wc5LClwDsB9I8VT2gBiTDD+NPrvJjHytzK5n+GuDLQ+KT3znache+M1D+AdT8SKdoaTRxk+W5UZoLRCXp3yNZlsHoMuwruX/MxRH02hWqALM0CeTodfT6S95DUF6J3+UVs47+Ih5WRB9lwlr6XdKdUktPWVh9rpEVC6/8TBq+Fn+Viy0bcMSjayKWi42IS8HSFH8NtJMu2AUy2tr8nDmpA1sdVPp1PSKknGGMfVFD0ljU3QuuQ5Fa107WNJGuO04BJmymkHjs5x9ZrVFtkrE3AbbFxyOQMu8nSWCjFBqQ8TWdQFrvfTwQBlC2J+S91fVztjb1NS6ml0VtXjWGR6wr2I+XkYExwWYN5DlNLTi5yHyH1ATQ3ZdRXL9LAKVseg8Cba79mf7dn2tfjdRZQG5Y0z/P7L9rALfoU8ryHuN4SXSIkL0Ds4aCNS/UsLaezL+fHJVFpFmg7F+L+SqjJODvPTp35Ll8MBNwEajNDVIzb/g1R6IYdH/tkpXsY8UzYuQFqZqtNNwSjj/zSIJhYvqqinRAO3usfns/6vt1UjwdZJEjfdoKYOjJC+p9GPiZ2DkDLc0vLfAom6ronpQzi+incuCCXpKCdlY0F9oIOIL+qDJefIlKHCN19JXZe6KqyMoXqZOBNFLUI678meniPsOpuhZjp3iZsUtI7Y6mN4NYXpR7yTwIcjLTqLz7x07gPpmqV5hukUTu+HXiJKHTpJsb0Nq+tusxyCrlo/NqN3gi3D6lL4wgWbX+AMBwOK2xnR6dk/HSPvtXgrgpuy5vN0UKfyw0TZYKUr+XpZrGS1jXPcVpMZQmCdOqdRbY7nJfs4U1bOeo+Oyfck6RfjrYemKWA5Qrg49z83L/B1B+p99VOSjCzk2HQ9ScZZ2LPQKsKjocAySlV8ehUvWtKCFJGGcVwl7IeS9QPHzaieC9wLnB3jBcTYXHjSGGlzrpSV9GWs1kF3HlhFRG2pPC+fK2RgsKqQ9YUUznmDjhYeQjOC6CdoeDsuVhOsqABIloFZCKwEuB4PdBWpqN1h0ve8uoc0ipxtVJCE7aNZifTn4608V4/JCYTF7ehqxynU4mUFnxjcwNLja/9sX7QusRPR0hKbK4PeknzeBxUd1YTwRvB6P+Fn4K4E3FU4dZF8rQTPrIyvWRokGPdU0gxQtZ5UHjmjh0BalusvgH/myylVNHxVVYxOzIryXiHNpnSjl0xPYKfGazuJeZ/hD3n/Hgoq7OapNAux9SnGP4meb0IFFdSK6i6hRZfoSMx8SFQOVyzkMblLgvhMRgmaztiFoW2LpFampwOgNXAqgbc534gkf4a7dVSa76JYaUJ+d09PCH6JGNxEgcp3Y1Xd1ch3WUHgRpkxg52ZojKlFci9He6t204MF7oaeCa+PAd/GiqfmO7vAs3+kXjF4UJA86/l8wDc9EC16fyWUVqjy3cxzrLuEJEyVIoaY6gYhehL8b2KyssyejRRxnLjQFzNFAPC0yl9N2Yf1eFa6hwMC2Ocomnil2WHJ0VGc4ipKdA0UXzi9SHch7z8MEMUSU5gaIl3E1RPYXEQHYWk0BcqBKM62uomNiN7e2DjVqaoIAfC7VJ4nRhHGtp6KCV1m/xcKjpstC91TxJjWVn+NHgasud9+m+z/heSBQ7po5GwS6gE2NOq2gfJZ3cca7N1MTG8Aei+lebmE7KFSPZfBO6p7j0JWZ41c/I8ickqiXx0oqG2ka7cS2I9FRO50VdqbeiO2ctr8C+L+Z/vR7868b6Dif6jWroYSxRvPk/SUfJEor4kKjq9vhSkKsklaWuShiE+SKE1y/pG8pMpGBBwCdiooSm5UA+li9+5qs2ZplRy4cMBvIDYjIG1Jh9lg0yOrp2D+T6/xKgoQJgVx5fodjCbDOnxuc1+D7Z7MzMXfFuq+8vSzlvFE6l0lZXVsD4GiQuzCynbTnrp7GdnyvkvWC1JlSUJ3TazEjxm/npGFBPSiuNTR94cpiUcR6O0pBKXib4GBeEmSyWGR7H78qR0k/Ic5fhWuvAJPjzBl31IjzR0C7OXoD5OTkxxnmCV4HlbGUbJ6XV+m7B+nyGfVQlwAvH6f4+UrFpPagGE8jTc4aKWC3tfh8OMTKz/DTgbEN0nhg6kkUgJdBxktdkciDtAenIT/PNrZRiQw/1Z0Q1aqtKqhxNRWq7xQqHuLAOjJUgXux1upuFY4GspKq3qIgfSAFEJ4CHESOSdKDDoYMDqDjVQwBAkBvEDONYpK/FMTp5KycaVMDvBRQf0Fw3+x1owZ6M2VpukAN1pRXc7kTxGvofje7RUD6+4Fb1Ql6dIWcryVbcvQGE9zfREwdamr+PpqlLKsmYB7wd5Zz/WdaPuBu7HelcTSiUuZDwOSByE/Gs1P+GXlI0Wea0OfIa1MWpMxa8yQMoBzWTegzRDWT6Qlg6gb6O2QW6MUzxTCgmcesxOY+ULqlRw47b4nvBuz/nhd/RIAaHKYJkUTgNTw7td+MUO/lNCbsLC3w0HN0R+Mw5eVy145gd2LOwwPw3I5L+WpwXbogk6yjgzuN7x45CeFGTik5Cl5f/HkUTMFIOVZONnqqNgpYWIBk/vkNx8VxwXLq6hP46XKkaduuNqqYn7ZV3iAkeC3z8i06O0aZFGAXvLSTqFDRdEAWa+2ObSrh/c6hNzm0xjaDGyPxZbd4ztj4LzRHp1Gaz2zTlVJAC4OVLnoV6VUkA9yJKEabuiUKL9j6eozD0p3aexNcOpK9dH8i2XpnF4ZqvyjO9UeSclvuGXXCWYYyNFwGrkvlFDXWYprGbV7aLnjdHfcdvaBevl+Ds5S2/G8xkHB1Jk43wsJx1VH2IaJ+2x2IGpHUt9IFNFyGWwJKNJEZ4G8MF80EtQZVcxoXrWjwebqQkkH0CxgGId+x+iOSMWccw0kGnT0YK73BNexjdmdAMGX1kmVFOS6Kn0rcWOQhrG+SWEEoYRICeesSTrRBo8yPRukanB1aorrqh1ImMfHo2hG+vVJ+ajMLisKN8N+RCxE704SUljWJTe4WsE6oCocuJlpX4e5w2YscEV8DOUAAKGSySRxL1I8WboXZKsBBIfp3UDjE3UXAIZP6w2FXiWShyANXwJ5EI2zhEAA6HaJHZEyvF4LHxbmvPVS4qpz1csdJqGl2XpseR0l9T/DOLNZeUHiTMOLPka1Cb81Zwy8dI7Ju3PWDFKXQb8ptNZN0OdaCUl5NDrgZmcplxaXlBuHCjf8eA8DRbXNSzg+zNJLYFzSseFdInEniBvDf+W0EoQjS1fbqmSyu5PuB2AgxLSuqIQAefzSfuDzHg9kTIh2jfFBVNcxOfDyZU6XIoLgim5CLhiJrjQPMKfq7UU2NuqORZ9Faqf6VbN6RCUcwiVkh0OpSA5iYR5qfsRvMtZKTbHLV967SGJ7N7OcRdCA+nvkvQm6hJ0ryPHqnjhzpbz2WV//I7Unpu2sqbILlp0tM2XrVmfn3lSrpI9WJaTNXavSQzCLiH8vMqyr/DdrgWKYOthlHfp83bcOokLHypKJb57qinXgD+dOMvmcM0EjSRqpg7CE53pdZjxAAQAlBK7wZjhFMZqogQDwvNklulLd/8Admfpker8OSZD04ymLOaQG/SKSotZ3hCGrSZaDnZLvCe7f9Qjm+Xo1TVUAxRegt4tnttOHI/MHQoak11M8vNpo2tRTUxGIOMZip12E7pWiFRE/lN19tgu1hGYMKs/g6+eojUjc8dMgjsiGaGiLMWHPOOByyupNU9u+LaB9IvzkFiLPK/FHZ1nrlTDBYcOvSVrS3nuKqx+pg099PVJWKsqjYvEvksy1RQuQAy0ZYskLe/wfIYKyuIHsp8HVxfQi0F1UxAB1p4Z5d3Bu4C9rc9IDBSbQiEaV4niON9L9VePwj9XtGUn/fvvA0rUynD2G4xNzaiU8GAgWgNeHWu5uy78GPFLos1w9AtteexMiNxeN/w10QdK6YKqU5p1Yi9hwy1F1TlWOfgNycri0sgBjauX3Gcop3E4L1GDpTLxowRliDwF3p/TcshzRfH6W+FOkJwyVhSH83oGgKxt2Wp6eSOp30JgQF8fpsY5fsChM0UUs1kTDDNiTkI3XsdfS2KCgh8XrBkhNBJJAQ7rmABAF1KVJu2fRKUj05+mEaN5Ep8N1fl+su+Bi4yvd7ihG7uxP31MMpiTNYNc/PW0m1NNSdrM+sOz5MCNRm58XDdLunoX2xcFE78HS3qqYHJ6JHhe2l70n/8UTfOBhURvEjYi+f7fBW890hOip0KrCGsuLP0YkYucvBxHZhSESfnbFF0nM5WEf2lN3utth2i5Dzr/IVvqRYHrHn1Sm25MMz2EJ6Jx5cQOeNpKFu5lNqvic5HQ55GcsHBend4h6dawMDamCRJtoRZFdEKShPeb8X0kmS2UgPQptEYZsAkRvQf3I/JT26vNyMn7fA5FBgTjc9m4F51nkpCAWwOYW4bjcpCTYCJHdpdqMdTb0LHw4CupMc9DAq+208o5PXouGOA/uu9+t6mFNFl+CqcN2lci3gBLHe8ly1yXuDQvelqwPTZphwxPUdlS60OnPsXHYFzKZnIykyVGUyIMQT7gBSUVJ6jZUaEhqjseUdczXhUYgszqHK7JjyNLP4jaVqQQUrgZtSeyYyf3hma4E5GbIGJweKnM8glsG9n1waqQ3cS3duTVCf5/1VijhL+iBTcsZeHRh2mnOq2O9Z1OGVlcr1K7QP42qb59O/3kqjD3dhTexblS/rISUMlpJPiOB099gX+q5zRmXCqtA+F+zz7ikM/Rs3mY3PSKu1j5Q/Zqat9eyaUN4NejUsPfEMr+a5zfDbTr4TeGpWJtqIqZCT7WUjPPOySVg/AcpQsdfTVrNVVJZmn990ZI4XguzW46HZAGTWtnT20Nkuw0aWzL34/gOJ8sXxPFFVZM8m6UKOi8gc+QYfhI6kmWN77cpp3p9CfX88nl9Bwn6gPUtOXaMdI9eOom7xWIcRG6Fm3ETAby3sT/wZoGbjC7j0ACJpd6ZEiLDugPhXfl3/xbQKI/9cS5Wj/ns1M6ucFuyfboJp69DknJ8A7VnJCSQdwuAkuXpWLKZe7cCHiEQiBabyqFJrkbMMOanjzE05lTC/O1ITeuptffJU++g2An837dXD4JGAfTOfV40fen/OPPcw/m7et6xnngFzm61Nykre10rPW22wn0ZA9Jq5DR2P4h0QJacfmwB9vXYZuQf5uGqxX9aJHYOcw04Z1TX8ere0JrMWU867y/cGC5NwUlx0kiAxlAz5dZVskV0WvZvxFCx1FUX4RTKdThwjR95sDyr6yyAY3jOK/ElwuUL9FIY2ke5ooQARZ4WLOlpCDoDMo90T3kGTdqV2hUpv0ZYSHfmKaZTFw8o72/CScI1AAsZOQTzLuPycYSCuZCTwFb1+qvL9neAD6Y0gzCiURnLtFi/h4Ur/ME2LTuBCT+G7oxSEiGvx1HlTPFmdPbH4iH84rp42Nq3CmAbypqqxUHHUk/w8uJSLjMR0mWA2VsX1a1mUUqkgq+V9fGZLGbRiJhN6zoLyTXtauvSWUvnJXoyV3OqvYmR1czZNZRD2jRDCX/xfwGhR+cWJGM31F/7s9IYvmNXY38xsmakrOJRovJByRowWwX+B/18+q6a1IpSeLZOcwc8SuUuAGaX+JJUe4+yHatWS07LbsJOc2868RDWVkI4DiFg6nYkvQUicEkLRaJSoXaiHSX2wkgqnxT52GOEDkxj4G3xE/bqFQAzTfAmYCtbGD3pd05sJyh5S0+WpOqCl5v47Em5GdxKWe4CbjYyNpbqDbWZpdskfi/4fLp3LjOdC0Qs7fGTAM3S/5G1rhaCHpH6vIO03+DWQ1cnAH6Q7j4gufnIWxTcq34jfcL+UVvKiMDgItC4A6UTVk4x+jsTngnFJsDhb9zxzB6WxJ3ZGpe2jMiZQGdn1OOEIgqAlYYGAJmoYab7pZVpcaXqFsaGdVmNB56QVOpvYbfmuyc81tmRtnmrxfQIy8qRuDra6TdVq4YGOk+mpL8QJ4vumd/alzOPCuKi23KC6G+7hdj7Mti0DSDsbTjZqvtqe+nIouaeXOOgzyIjw7Vr2Pvtt3Ia6AdwXpNzpylDiF8xlIItHZopGnPiDOVYl0VzQhsB3wZqk4CwTUGOvT7hKZA/0N8tkpuvGBFLg4Z17GUXZTCaTA/EFpTXHuguy0LDqiC1+bZ6Uj7LfZ/ntU2VxypQvTA/J1pNGvORg3Sl6DXp9TlTg5cEL1RDdt6XGtLyS44ZemY0Nk9Vi+G/CfCnDGlDPDdf/3v4RwXY0WoYONEejnG6ES6y9O0BftD4lxLH3ZmuYTvNSdtNV5aKdQ/jl+8j6XH+OGSf+1Zp6cjGuXMBbZQEt4aHulgSAV+JW87wLmhjX8u848wMUxziGshQn3vFSETDj4rT65MrWmTO+vRLgXRUlD6Xhu3xK2Rn2fsbU+yeZJtQi2nHLaoFcvrI8BU1LnJallJfojshtm7J8w83WoFsx58euErQHnc4vF5iNtxdBJfAwwK0g0rvKZ0LhBzcvo59kejeA6ZN16l2lF4+jzuhny1mRo291vposw6EdqNZ3cqRrJA3jwIP84B1GDPeZqd1+KUMJ3EY16yUElO1WriaNpUcOkVuHgKs2eyviZaG17AROEy8+BbVwLwOCXOZqI3JVWCB+fgMzMkNthdl3CD8xi5hxREdLEya68lpOYqV06w0CTmity8ZI978YDy50Npax7ce+78ogwfFGTrn4/R+Xycjp4HaaWRmgExRzI/ZfoCUOqaI/OFUDQ1OM7Gd1zJD5FfQuieD+OUx1CNceGj0egx6bpoqZX3/TgdpNFMMYdw7Sb/g00pEY8OCjAD4o/DEwuLAC3GqHOtRCUUMagpQAA4zYGdMB7sKcOCqHrAryXejA3NJPksyaB4Z5Y7/SI5XJJhTtYX2PoLnGKw76X5bVklXHzIbALwWCpdZ/hRGiciqSooS8s5lBTAMIMqCetkkFtOt3uFkQGUGMQknWgK6cFqTIorcZrFZN1O3lr+CIxewjzh0ZIYFUOwnClzCSwEIILhkQaPYh0A+Y7UMaW2EuemdDFh7c+ZCtJ8xrFx/p0/Lrwp354kbyJwds3qtCDxAP/lX/0PN94qvB2fHc5qi7pYovtzoESlUiUpFME3FZEsKqV8xNb9IUCeB6qjbGZfXjtJxky+XEvZhr1+bpID5lzAUw5+2nRKf+j+ct+/bmnFllJ6xvpfOM6hsXUtF2zlsBxDDG61ZbqX7DJVUUgyRvU2nrkiHbPcPrweaUZFqPPOFBFgMAkQJANzhEQE68Nwepp676JJGw8CSbKJAvG9YQIC6auZZK5hdZ7nSqwsxGSRH1qcJmSd86sxzmSFNiYjIFtdWugkxpxUwHGrrJ6dzXBDCRZT844Trtk4ptsBePeU7YXR7bdanuOui9Nb6dkZKiXEeqfyIfrweupMxIt5wyuy7FZKi0kWQ7irDH+V5K94Qkm/LtaqgisgbFLUFL6Fa4uwn5NqVBYZfKhgmODGQxGVJRlK4yPxbkZJe9e4w0PlhvRuyvM18CPo7cr0tBgZBWGtOZ+clr8ee8bz0r2l0P+DeKtH7xx3bttUlsBZCR7Pove+Kz+2e782ywdSlE2pP0+1DzTFUqYtsYJjwsV5kg0icO4TBEB8gj64AhaK3sXE3YAzxBdkVNZZz0MLOTS9jFunfmmfRNlsUgJmCSsA5afM9jhvhfYGdf4MuaVgc4QKA/idw7Kn6NRVxApd3WGi4vd3LfsMghEnd6XFWsofe6ddlYdcf02uEa42kxtS8nZRbtaEkcg3+1FvwfAv0kksSqe50iw5jbHsBaUN3e+hoIBfqmBFBpsn0ospjwtwkOeqCiql8LmaOamOyxrxXZR7Yay5wSBNS+vSIC8d0ElZUc3ddDaBZOTMqfiJRNyS9F6VjSkYK9wQ6fY18TpgiPmnKP1HC11FLum/9cv3ovYWZHGwds0vjpWxHH4Ua5CAnp+/6cz+oIonOW+1huv/VG5HlDWRWhdHBSwwq3Ml7zKlwkexEKsC2GD/HtvS3WJh5oHCzNfNAN5m4okL1Ymo5fnBMBmXNFrCuUb63dSpJdqaGR0s4tDmDRHnc/I3BA572krCWkPmjRnzITfgzJSqd5WE8v4Qrjq67aN+j98domvAB3cUaSmaDaW5X6jW2LnYNPkiGQfi6PvoVsO458ZvFPmoIB6BcGDRJwkmS7EqCbs+LdhIGNw9zMoMJW2QU1JtHffmUJ4H3FNxJ32OomxO/+xF57tY+VbnH28Vq2nay5vTagTGdP33ercT4TQoSJN9rfy0gebn2M7bzGQWnxu68YhtU+Xal87cQYUVIxerCFQu4ZKrXGFGAFzlsMEmMzUzVF3iYP5/R1bjDM1lSZzA+a3ITCW7D1feeT5Eg/esnJKGZtIKZONeX+UQ7ShgLzO8JDvN1FawWIXddUW6QFlb9s/jt9RQO+a8igwB2TxD16KQS2eJmG3A4hTUt1Qzm/Y50mekMtATl/fr8nQG1lUeQihS8OnIjFrxZYbMKKv6WEagNUdzMw5K4ncT8P4eK+5d/QEo8EbZfyBFOB0mAr9VbrYjPAcP72RGNMlPkdkXNUdypqmb8DyPDhfBukrFZnxjTz79Tur1fKtQfuBdPz6W/14f06w2uCmZShyfKpen0meXXqkI/gamThBtTRC5pYwMCRhCvhDRVFxIWvoUPJ7QuOmNVbC9oI/z+XclnqvxsofDJeL0SYGk+iB5EmnjBjfmiTSGuAlynQB4adNh/H5mfRuXW5z1MGhGhk6IAtF0HG8f4Yap9g1YsgiTubfAiw/So5JoJUk+hegrY3AQnv02s6hTUcShJ0oYJATakCd1USLS+g13eGq8mgd8yHMWsEPARoB1RIAE1VGUjVCFh/N8yZXSt4pzEpsVMslFN+bUvg2lMy4r+HlZ+8HmTB4qvyzjBsIPi/RNyvI+Dc00OiOF40RjMHdTGB+WZgPNI6w+hgYjvJUSIngds5U0cXkMmZEhSla0TlD5MvIoRJwPx8H+XGGbg/HNuH5OtVg1r/zrbFaaJ3GdOV6ypcAhUtbdBHRAf8FcVMN6UW9P/KmkVBpBgmMlkfIqkzXxdQZoHVhb5a9+TEnBq19HJGS8iU88Vj+R1u7wSYQOAM5M8MpWOvFwY89YaTnPMVwo4bmlUGPF77UOPan8mTwarulWKlcuIf6L//XfuRNZ8tGUsW6BPwricaKmFzyX0Oal3nNRpq9+5oeBopxMXIuTUtN3OfQglG4iZYRGPTF5jspFyXJAJyPiodhSoHAhB8jnwLuFxzURcmQdq8Xf8sYLr3MS92pUmiNjM5UpqgdQngmPw3bMrSWxguzeLfZacVckaW5I2ynoOez2HV9FqOmQigxnaynfCCvH5tl5gGy+Y+FRwCNK2o40NwL6JT5KmWbi/MMIrcizT1O6TWYNJPUlekpWAh4t8FglKxQc/Jjwv+jr7/nXFlBGWnU+pQuJ/T5LqwAvxy/UWKqAzzB/AY0jz/9MymQwT1R4FcFyFbDF+AX3V2fm+mV60dL4Zar3IVeINobjgC9qyPs4umr42AQrrnxvOozPwtdUm65kp3cC24WZQF7eYoPVRLwXVW9T/K/+2f9IDSzWGd9iOiFzsthjKMmBch+2CZj3yNJBNJPpsIiDR2DBlIsYXqika3IFE5wHYQRvjePOOQzG4L2D4M3AH7l07gYCd6OkgrtWInlkrU0mLrDGyfwd8eymNfpkenMkuxcYfR82hvG4oRwaiVyAoKlATYpcJRzL77/j8lHyvc89Ny1U5aya5FeS7zC6TtGjVGRLSWsLSjtCvxuE84RkYKiKjXIEfHIEEyrI+gBlx+L5MbEXk+JULSDEztIRl/A5vOV40wr9azDSRPYHL43Tvo4nqDEmAmA4kLVzfJXKo0xo5XgD4nwLnYR46QkgEd7DRKwkj9vp4Fty8sy5s4fVvNS+DbQ/8qOSMqqxikqWZdC85gff+ZUTSxnLtyseaEhPbxVxjU5koVCoxwqOEGxp1TdA7huttkLq58CrgBdxuthX5w95W5Z5ht9q8HYVlXr41pf9dtP7rm5NP1DuZBCPeVVEq1f49cxZPFG3suKdSfYfaUsDMU1hpT9bs5XZu7PkteynvGVp7TyOytnSuryTMvRjsotld3nKOrKhsI+Z+J2FPY+HgZha8cOu3nX5S0FXs2K9h8TZVGN8UICEQ/q5cpA3avfCOUtcRGI4U+cWR+V+/iSJ8cRYbzgLV3T/a/QiQ5S7MJ9F4JWwXveGPgxhon2jgDmiLsj+RxhIfH4/HZbULy1eA+bK7zTHS5QSAks8bpKpL2WuUmOdXw2R70t3TqykJpwYF2UUl7BXB2E1gQkklbQSSFUt72A6HKbm70E0lqcNkEqwoif+OZ8WJGbIsY7kXhp2gXZTLOz4b3Hstmiur1Q4zkWgNUhXx6F86NsOI8MS8l3cmOj1AXPXcL+SYDnOvFHlMbh2UvyBUVrRohZxmD/9pZl/XwyWkbEWrh/noAHfBsIrRPVyqs+lYkbFAy3ChsNV8qVSHERnEvbM4D6iswD2MiSfia8YW9jP0VPhWKBQS+rv4yOGmM8KrhxGsExE6zRBF7NMRT/ayN5ctm/uG2edSXQ1pBi/egJrqrzJeN9xHFXBVaBkqAsFeW4SNTA21OMCvz0CTNCzUnzjx/5zdfGId/44KZNrcRqzapuUxikDYhLi8+Lk5rTQINHAg5bLh+cxlgX2aH+JlGEQ5jlsgZwK+jO8oCQ5Xbq45VUVELnw4eeytAC4Be6ptHma+g5bYekg4FE7NXNqO8Q7Vc9h9G0myiO5eAP7lvSWKldu9ANHP4R4yqFJgMgDugXDCggNzlRG7H+Ao7yIF/lOjtcOwug/RV0WnizJeQ0tbcDWCuwtu49I7stn8njm73yhtJd0sJO8Nx8rAf48i2w9ZF9beju4MvG3/1IvZYNifRDeRUT1wDhf3s+HL+BJy116rAmbZAVYfxONe+mehsv3VAkkrBguXhnyAM5Cke2Fm07cZmAMobMZ3ozBZgUcC5reK+SH7LqXKE2/DNNDzseAWTLSIRiwuI+Uwh2AN3vMkfiTArgCsA6a9/F1vn9npN3oB5+HNJL4QovriPtLpJmCXFOvTwAqAr5FtWvhoLBZlKUa980UXYGcIjEFKKuMvAOdmESv43EP3TgFOYJGXuginUhgqR7aEg3fJ8DE6YNhcKyu25h78NkGUqM4O5YKp2gl5geQznvCJNqzES9A9N47d5cBmKP3FRBG2kVBYXdjYh8OE0NOxkZrXa2VAc7q2iSZUxBS4JspKP69hKaZNSt63VCDBWQO2JM3drmp3df9tmw41+6GDRfG1/uFQlMT9KUcR1IJZNUsWJgLLEJuDbG9xYkjtYww7ik/aXmI8INVy5lPQSbZeEtSVe8JeGcpueD4YVEAJL2tGF05nExTrpLi3dEcJAFwLAcYBkAtKxPGHCqdgk0OcRbAjpfMNvhbpiYv9T9+l+SLzv8h6DAKneMy1+WMkqbX0nYWz2wiR6k3R760oj+xReMA/UaMM1Nrc83pqVZoCmXM1Yu0MwoHO/pYS/ECh02SI6mwJE/CMgSSCkIVb0rJLoHTmG1YSWlefiExt0vobqkSgqIHvsXx8pTW67MG1GgITloonAIlELOJmE8F0IVz38gwOOCMXyXNgnLJkswbiXj/U1E+lMOLJHzlk58j594Emk74et6bSvMttC37X2OyRzSiAVpF+hy3qHkyiAYNtWA49+byLwZRe2lB3J4MQ/vDN3OeS87GcQbR6KWkUwksp02DSblk9Yk+I4AbWK+nsgPHUVT/B5xDIW87vccFx5QeIOYaxNZRv+SCFDQGRi/H+iO5zsH679PdguKXxOrGpINkX3KykOe24vIYP0tj7aWMJJjbt8kS6R1zuAHxlXg50uGEbdyUrxtpJWVZV7qskEgHmSb1DSh9BhVdnglonEVaEYrzxLUghHBHJ6cxjL1k3tDOU/TDmhsNEImhj4X4IQGK8Foq6oOOnswuFbjM8BBNl8KV1wotQFsR719J716nX/nKzQVlJ7T/QTffyd7PNhJtqv+DgDsOYRvhOAQVjs085CthIMJyrJFsPrA2BJvKZzP+/30RaU+tRr5UW4mvTDa8HWfdoCZyVyGMz1l5QnkYDvIJrYBmlVtMLj8cLDDa0Wdhy1zxLJ0LMhJmio6u4vwKVhJxhiAfki2ZrF/b3/n4SVnZvsEDza/16N1lEVbU6ZDICvR+5eZw2iybrVVCFXnltVLsx+OT2aWKP5QRmlPepq7FaeWpaAr9OGP/6Ym1GLj/eQJRgS1FwfMU3srSjBa5HHCfz7ivWDmQIe/GfOEI5zJpjwNji006aKIl0xV4xwlyvt59Bdk8KgzTWzOd9f3esjr5Z6l9IlbPVPBrmwswraGTDNbKMD9C3Sd8aqIPGuPrRnEiBbGq9+rRmqxcIdyZ48ZiAl0yj4Vek6YjoJQBGOHY5WvfAvfz+GlOFe8RVmTnU3T/DaqG4S81JTmFm3pOayf4j27/LwWULoug+558oEXZVbk4wYoD2Z5wORV1iKq+hlHunVR8Oe6OxCvswSrOT/VCAigGxx51rtXGiWqNMTeFWeAaIbzLS8cRHfLvz7z8iVB6KFPBwab2uhgtJ7KcT2FPqWwFp77ivm9LTN6oyNuW932gtXhKT+BcBEAKujdMd4tmH8vkYdiaE5lAXubgIEv7Nf9jisk87EPdSqSVNNkzcPgDKi0j8WdOiqzrarDR0YUBo6mozxIPkKGKHQKNFKo5dDBhc75sTomXReXVWC5y+z45KsNggb0XYMMhCoDXZeItyxuLsL8Og5UwrQDSgIYgq3E4vJI7JwlJjdM+3LRA9ivoTaH0HRs5eCUvCjHYy6bgLSp9EnOiFKBkjMNnDWqL5C6Uwl2UlEjVj4RD0FXo9UOfCbw2/W/ZuaQ9xi+IoIvx1liXU3QlwUXIeyl6afP7CON8GNXR8kcM6tZX1al6Kt0OlSub5J+Cyktx0RTCIuUldu5CbctrcDael3AXRWXKEyxVZU+CO6tRR5beEe/DL+M3byi7TksN/L3C7jeN3CWOCpAvQZylvQAwj23cwdEOGH08xDlglcPznp4L6MYu6C1J3VwqQ3yXJ4qaPJvHuIyWIOoAQnYTrU3Oy7KmCJAooYtzDG54sWrAv8/y4GGwVGZ5SVwOYP3zqFFD5xPMP/C7TXM7P8mF6OusL0nowVcgnKFLApMPwh2NRBh9OQs1KH1gwxShAz+9m4l9SXEspTOJEijuZER/HU024sVQLXriYjcKmaT3EaqTnk9vgGizPPv2cfZNZVJH5tabZBoIr0zmtlKYJ2dVysuy9REmR0uIYGm5jYdxfDstkCG7yvD6Fq/b/gvPGnV8/VpyuT65I7FNZ/rDib5HG8Rgl7FDIS7jEkjMVjppuuwLHC3q777BC5+ibJ7D/37IU6yF0ta+8c0VfLanSirIY6W+4PjIGNTjOz7mBiM2kDk/O4WKJivv9cup5DtUe0F2Pdz6SvsTG1+4qJuJ3lvTVzX3q5caPLI3EPovOXnthvmvsf1Lw3q9CX44S/9eJv5ZNPtW+lkMDYt+kXo/cnHtsvsfSbG15H3cLQfnsArTrA9rdXX6+9ksYsGJEt9KYaCMFC11+I2eOV8bfqeok/mgumcEPS4nLG/ReITaKc7044+miZMj+6vI2olhXxqdJ5PfiOCGJGoQ/XTGr3RlohdicUEAN2NlSHJOZM/J4z760KmmV+nRvBpvJnYcnxN59cawlIGga9W+lkn0L2JtIiW/j5SBC9L4fMtANdTv48wgWOqreyyJQzhM0du3kTwp3dyePUxzRYo8A9pJDEpEyUD+yBx0g1KPniZwjGNnl/gADS8rJkbz1UQaArWGagoIFZA7hFImnbjRBETjmeUbaXY5JVV2KTPzwthpZrknB4up5PGsLg10yWygzJAYEeuPxAYGlgynZU3VSXeRazfi9RCYXRgd4NkGf3SPXzwm+wfuqJgrXbHNgTweBMr9ymwZACGk18CIOVF4iSNlFeqhUsiqX84G5QGReWITjBY51kCYhTZL5D4tdVmwiM+rLDaD+VPLsthKGh4Zxm89rgXw5lfg7Ng/K8eHCzk3m5gneP0QpxP/t1vW+ZRv5fDpoQgsnqyCK0mGUlogqK/g6UK03ZEOObgeQw3mc19KZszHHUY+fddYuk7YMNqS9JM67ErOnDA2mhCVBBBkIczqrtdsqO1893ZBve6aK1NoZtnXOtRWkX2IaQOXDM7KSJ2m/pVMiTod4WbMKscQMeaeosqNdKeNxxTFz8NNAo5pdiKH5armVUgWgWuAqcCftmHq8TdvU3WJdq84uRdJHMU7fmEEr2rWtMPLfTxeloO5pLg9gl0rbcLq/wmVJd7ica1G20MKAVCXo/WuKWWANxbVhtTelgY/7lRtRXtXcCjYMnmzLPV70Kgl+SwTc+Gk7//0opJeOy+5Hyciu5Xafa3kUToRBRb3D3h/N4qqElsU/ArxPCLzzDD5xBbXA3mxjo64IlJQPMF0ys56bLZoaldiQ4HpF85VOV05o7EknYzJvZIIqDiZt3WChUw2x+g6BUd7pJEHldt2vyrwv/mrv1ouBq331e4/8ctZvR8J/CbdsYhF2VFRFQ1QmsMHAmZPqfk0bY/AgzBMcvhFO7p5LZMJ+9bAQQznQiozBLOoFpAIQJBDcRUJiLJc9Mc4INAoC7CFyQ/D0Qe+u5mUahxOlJ19zl94p2+C1atA74f7G0ZrK9ZMrMzUcIqhSzd2k2GizGTwwOTvsHQQJluDTPUAD19Laxi80Y1pBfws5z99wwHCa29Yt0FGb9I7eRbX0T/U+4WL8gefw+Q5O6dsLiLFXnJp4TYC2k3PZPBCoEaNbBW8Nzd1pytMX8tIQNNAkIHCxIN51C0zK5asCMsaVO56fkBLB4R8w662AL3rrnXV4xfusGv/RIfKsvLNLY4aYEEVNTvZFzhQwM5rp+3h6CBoMSk8YNmeWsqiNCPMFAYzMMlBqOHzABPpc23SSM/mQhaQhVw0mWgXiz5AUHaSpMcVBUkFAKbCVRnb1O1y4hXxOIHyvNh8Erxd0+1OeKsuiwnsFQBHgi8m6iUZqiLfRXCZuz6OTK7M+4CmPoSrb+l3zJiO3XsjbZowQeH4x2buSiwWZ687Zq8RkwtYQUQepl0MuA7Lee8PsXWszH5eUa1ryY1Te0o/DZr8WNqtFr9ZnZg3w8IV3Fyb+xr6dyf44UB8CdhpWT2DTDkz7p3HiYLotiLBxKZEDsBYS7MnmIf5vo9MKiUWpTjdfi23T91eMjO2MzvZ4ExVFAlUl/1jEMiRlhwTAMHoVXYgo3tVd1jVZmep/Sbz2ezSiHL/V+K9NIuTLTbxog9iFWST6b9JP3mW/8fEGxdK+QaeYLFwCWdUDg8m42O5QACrqX0ThEP+/tNQGyfk2Ut70c8qU2U8THINXkKINZTBJZ7ltaqBdifp+ZA+AuLJBr1Mw0UinwSEWaw0F6M/i90EhIO02KWTnlD24qmGB7fQ/cUoCqTRRBTHyFXFzExEXzI9NetD0gmkVGRclK+AnobFdihZAXrA7A4kGyk6gSkQpRnHjOdsMZgyt0LnuiGk8atJ3rqVLtgqrSAeKORR/gWI1Cvpj15bB4T3Pk4y1YDeROaR4lag0uZBDkRpqt2FMBa2zo0zLDt8sIBtNcg1qPQtymOw0ceDOLik1nwmXNzOX3LfivlYlhKdAQKuT9XF5+ROEL90Z5eq9HjmxrXsFx9o9R17Lat3ToWxyHhebfcnqoxmDiBZAcaQ7iF3kNVMVkRSd4vFejSzvNqC8ekJ/V4rvI2iPwlRb5V4drRakoMQTRcI4f8OXsRurq+tNODRkC53mdESzwrByhauZafHWPIDqZSwq0lQudQfDP1fSEjWyE01p7ozw6XzSDIdd6+g3iNiGvFvXvZ3GjW5AtWK0Ppg7ILiE4HtiIZxz1TdTynIidhIvZBHgr91yfqvJb0K35nIWvcfVZU9mbWr6MdR3AzM7tgmSOBFGkLgd5L6MyQLcJLj790mfKulk+jGr3dEM/51AVSJMH1FeMBccjQqt+ekwgSrA8u/TEUrMRTwLhuvBemrZ7QnT9bvzYNPwjETalfKDOlEp2QhXp2Cs77osHiJSplTbBo86vGdPCGtiLqxDlCvaF0QcNR0Nl+oS3fTPQOc3lbWp70bDePNV5ELkkJHqaNwj6mDrvjZvH/umM+G/rKmLiuqXIx1LSneJQMXRBk+8njjUqq/9U82NPIjj/D/qE2yXNGwusXqXVYY+6MZcrT0HwfGTwOYrYuoRfOyl+toch0ruuAAOTErXyUjlaazRF5Urg1jbhHpEoeurLQ1712UNIkuQaBCuZckFE2qClmxKgN2PcPSk3BpyertuRVTSkahRsThVBlvSu87JKlE85hWLoF24XsVY1aLhzdhInsVykqnmP4+Fk5KffnMKYy+LdU60Yfz7tv3jAu1p7WKW89xooijlWJBhpX18I0r0AbPfembOHzd5tclL7yRyUhE3ldHL6N+T1upxD7ggIHRAB048vuyuJ0aTTu8es5LgGfCMEnRKg4uN3J778M7KxI3k7wAuZbUuLAv/l66mptNzMrCbufuvvQNGtifqMYSUpz0RhI8H6pfDkyEQKUmDS/TR710L8Rgna4P2LdJMm1bWk4s5Vgq0b2+vfS3Bsm97vdKuFfNKLG2NB1nrPgfk0KiJZ1Lf1IylAhqAQAzJCKhO9jXhJXiKUwKFrO3ZW9Kxa1wJKCaoCAEFchKDQ1wMutGeRnDBFomcdZIZ8nRl+zNDml1La1JoM1DAqtpesiYnKcTE76Lxzeuy1LATQCWvUDn4f50Fqgx9LUTW9Eguuf4WiP5/UxzwuDDJpiESHEjv6h9fxEZmrrSBZbgSSCe9dPFGMeBOp56nzygleUggDTCigeGr3OFh8ZkU8pcHPq0h3ZGycyXzJEvyaSdTfmmtUr51RAkbqrXZMpxygns+e9S5Fg+LciXEb8TqPf6ar3QuwiKIzw53m/8ROreyxv/YWmoQ/OOZgAWp5dooRUdqGRSB5YErRAX1GCqSFEKPxFpWagnIctiuJkfv1jLuWdibgj+f68Wy1ygV5GEAAAAAElFTkSuQmCC"

var OPTION_SSAO_SCALE = "renderer-ssao-scale";
var OPTION_SSAO_INTENSITY = "renderer-ssao-intensity";
var OPTION_SSAO_BIAS = "renderer-ssao-bias";
var OPTION_SSAO_RADIUS = "renderer-ssao-radius";
var FLAGS = {};
FLAGS[OPTION_SSAO_SCALE] = {defaultValue: 1};
FLAGS[OPTION_SSAO_INTENSITY] = {defaultValue: 5};
FLAGS[OPTION_SSAO_BIAS] = {defaultValue: 0.2};
FLAGS[OPTION_SSAO_RADIUS] = {defaultValue: 1};
for (var flag in FLAGS) {
    Options.register(flag, FLAGS[flag].defaultValue);
}

var SSAOPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    var context = this.renderInterface.context;
    this._program = context.programFactory.getProgramByName("ssao");
    this.randomVectorTexture = this.createRandomVectorTexture(context);
    this.loadRandomVectorImage();
    this._screenQuad = new FullscreenQuad(context);
    this._uniformsDirty = true;
//		if (!this.inputs.positionBuffer)
//			this._positionPass = this.createVertexAttributePass("render-position");
//		if (!this.inputs.normalBuffer)
//			this._normalPass = this.createVertexAttributePass("render-normal");
};

XML3D.createClass(SSAOPass, BaseRenderPass);

XML3D.extend(SSAOPass.prototype, {
    createRandomVectorTexture: function (context) {
        var gl = context.gl;
        var tex = context.createTexture();
        tex.createTex2DFromData(gl.RGBA, 64, 64, gl.RGBA, gl.UNSIGNED_BYTE, {
            wrapS: gl.REPEAT, wrapT: gl.REPEAT, minFilter: gl.LINEAR, magFilter: gl.LINEAR
        });
        tex.isTexture = true;
        return tex;
    },

    loadRandomVectorImage: function () {
        var img = new Image();
        img.src = base64RandomNormals;
        var gl = this.renderInterface.context.gl;
        var texhandle = this.randomVectorTexture.handle;

        img.onload = function () {
            gl.bindTexture(gl.TEXTURE_2D, texhandle);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        }
    },

    createVertexAttributePass: function (programName) {
        var context = this.renderInterface.context;
        var buffer = new GLRenderTarget(context, {
            width: context.canvasTarget.width,
            height: context.canvasTarget.height,
            colorFormat: context.gl.RGBA,
            colorType: context.gl.FLOAT,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });
        return new VertexAttributePass(this.renderInterface, buffer, {
            programName: programName
        });
    },

    render: (function () {
//			if (this._positionPass)
//				this._positionPass.setProcessed(false);

        var viewMatrix = XML3D.math.mat4.create();
        var uniformNames = ["viewMatrix"];
        return function (scene) {
            var gl = this.renderInterface.context.gl;
            var target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.viewport(0, 0, target.getWidth(), target.getHeight());
            gl.disable(gl.DEPTH_TEST);

            this._program.bind();
            this._setNonVolatileShaderUniforms();

            var uniforms = {};
            scene.getActiveView().getWorldToViewMatrix(viewMatrix);
            uniforms["viewMatrix"] = viewMatrix;
            this._program.setSystemUniformVariables(uniformNames, uniforms);
            this._screenQuad.draw(this._program);

            this._program.unbind();
            target.unbind();
        }
    }()),

    _setNonVolatileShaderUniforms: (function () {
        var uniformNames = ["canvasSize", "sPositionTex", "sNormalTex", "sRandomNormals", "uRandomTexSize", "uScale", "uBias", "uIntensity", "uSampleRadius", "uConstVectors"];

        return function () {
            if (!this._uniformsDirty)
                return;

            var uniforms = {};
            var program = this._program;
            program.bind();
            var target = this.output;

            uniforms["canvasSize"] = [target.width, target.height];
            uniforms["sPositionTex"] = [this.inputs.positionBuffer.colorTarget.handle];
            uniforms["sNormalTex"] = [this.inputs.normalBuffer.colorTarget.handle];
            uniforms["sRandomNormals"] = [this.randomVectorTexture];
            uniforms["uRandomTexSize"] = [64, 64];
            uniforms["uScale"] = Options.getValue(OPTION_SSAO_SCALE);
            uniforms["uBias"] = Options.getValue(OPTION_SSAO_BIAS);
            uniforms["uIntensity"] = Options.getValue(OPTION_SSAO_INTENSITY);
            uniforms["uSampleRadius"] = Options.getValue(OPTION_SSAO_RADIUS);
            uniforms["uConstVectors"] = [1, 0, -1, 0, 0, 1, 0, -1];

            program.setSystemUniformVariables(uniformNames, uniforms);
            program.unbind();

//                this._uniformsDirty = false;
        }
    })()
});

module.exports = SSAOPass;


},{"../../../utils/options.js":132,"../base/fullscreenquad.js":74,"../base/rendertarget.js":77,"./base.js":99,"./vertexattribute-pass.js":109}],109:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");

var VertexAttributePass = function (renderInterface, output, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this._program = this.renderInterface.context.programFactory.getProgramByName(opt.programName);
};

XML3D.createClass(VertexAttributePass, SceneRenderPass);

XML3D.extend(VertexAttributePass.prototype, {
    render: function (scene) {
        var gl = this.renderInterface.context.gl;
        var target = this.output;
        var width = target.getWidth();
        var height = target.getHeight();
        var aspect = width / height;

        target.bind();
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.viewport(0, 0, target.getWidth(), target.getHeight());
        gl.enable(gl.DEPTH_TEST);

        scene.updateReadyObjectsFromActiveView(aspect);

        this.renderObjectsToActiveBuffer(scene.ready, scene, target, scene.systemUniforms, [], {
            transparent: false,
            program: this._program
        });

        target.unbind();
    }
});

module.exports = VertexAttributePass;


},{"./scene-pass.js":107}],110:[function(require,module,exports){
var BaseRenderTree = function (renderInterface) {
    this.mainRenderPass = null;
    this.renderInterface = renderInterface;
};

XML3D.extend(BaseRenderTree.prototype, {
    render: function (scene) {
        this.mainRenderPass.renderTree(scene);
    }
});

module.exports = BaseRenderTree;


},{}],111:[function(require,module,exports){
var BaseRenderTree = require("./base.js");
var GLRenderTarget = require("../base/rendertarget.js").GLRenderTarget;
var GLCubeMapRenderTarget = require("../base/rendertarget.js").GLCubeMapRenderTarget;
var ForwardRenderPass = require("../render-passes/forward.js");
var BoxBlurPass= require("../render-passes/boxblur.js");
var LightPass= require("../render-passes/light-pass.js");
var PointLightPass= require("../render-passes/pointlight-pass.js");
var VertexAttributePass = require("../render-passes/vertexattribute-pass.js");
var SSAOPass = require("../render-passes/ssao-pass.js");
var EVENT_TYPE = require("../../renderer/scene/constants.js").EVENT_TYPE;
var MaterialEvents = require("../materials/events.js");
/**
 *
 * @param {GLRenderInterface} renderInterface
 * @param {boolean} enableSSAO
 * @constructor
 */
var ForwardRenderTree = function (renderInterface, enableSSAO) {
    BaseRenderTree.call(this, renderInterface);
    var scene = renderInterface.scene;
    this._enableSSAO = enableSSAO;
    this.mainPass = null;
    this.createMainPass();
};

XML3D.createClass(ForwardRenderTree, BaseRenderTree);

XML3D.extend(ForwardRenderTree.prototype, {

    createMainPass: function () {
        var outputTarget = this.renderInterface.context.canvasTarget;
        if (this._enableSSAO) {
            var positionPass = this.createVertexAttributePass("render-position");
            var normalPass = this.createVertexAttributePass("render-normal");
            var ssaoPass = this.createSSAOPass(positionPass.output, normalPass.output);
            ssaoPass.addPrePass(positionPass);
            ssaoPass.addPrePass(normalPass);
            var blurPass = this.createBlurPass(ssaoPass.output);
            blurPass.addPrePass(ssaoPass);
            this._blurPass = blurPass;
            this._ssaoPass = ssaoPass;
            this._positionPass = positionPass;
            this._normalPass = normalPass;
            this.mainPass = new ForwardRenderPass(this.renderInterface, outputTarget, {
                inputs: {
                    ssaoMap: blurPass.output
                }
            });
            this.mainPass.addPrePass(blurPass);
        } else {
            this.mainPass = new ForwardRenderPass(this.renderInterface, outputTarget);
        }
        this.mainRenderPass = this.mainPass;
    },

    createVertexAttributePass: function (programName) {
        var context = this.renderInterface.context;
        var buffer = new GLRenderTarget(context, {
            width: context.canvasTarget.width,
            height: context.canvasTarget.height,
            colorFormat: context.gl.RGBA,
            colorType: context.gl.FLOAT,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });
        return new VertexAttributePass(this.renderInterface, buffer, {
            programName: programName
        });
    },

    createSSAOPass: function (positionBuffer, normalBuffer) {
        var context = this.renderInterface.context;
        var ssaoBuffer = new GLRenderTarget(context, {
            width: context.canvasTarget.width,
            height: context.canvasTarget.height,
            colorFormat: context.gl.RGBA,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });

        return new SSAOPass(this.renderInterface, ssaoBuffer, {
            inputs: {
                positionBuffer: positionBuffer, normalBuffer: normalBuffer
            }
        });
    },

    createBlurPass: function (inputBuffer) {
        var context = this.renderInterface.context;
        var blurBuffer = new GLRenderTarget(context, {
            width: inputBuffer.width,
            height: inputBuffer.height,
            colorFormat: context.gl.RGBA,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });

        return new BoxBlurPass(this.renderInterface, blurBuffer, {
            inputs: {
                buffer: inputBuffer
            }
        });
    },

    render: function (scene) {
        if (this._enableSSAO) {
            this._positionPass.setProcessed(false);
            this._normalPass.setProcessed(false);
            this._ssaoPass.setProcessed(false);
            this._blurPass.setProcessed(false);
        }
        this.mainRenderPass.setProcessed(false);
        BaseRenderTree.prototype.render.call(this, scene);
    },

    getRenderStats: function () {
        return this.mainPass.getRenderStats();
    }
});

module.exports = ForwardRenderTree;


},{"../../renderer/scene/constants.js":59,"../base/rendertarget.js":77,"../materials/events.js":83,"../render-passes/boxblur.js":100,"../render-passes/forward.js":101,"../render-passes/light-pass.js":102,"../render-passes/pointlight-pass.js":106,"../render-passes/ssao-pass.js":108,"../render-passes/vertexattribute-pass.js":109,"./base.js":110}],112:[function(require,module,exports){
var GLContext = require("./base/context.js");
var GLScene = require("./scene/glscene.js");
var GLScaledRenderTarget = require("./base/rendertarget.js").GLScaledRenderTarget;
var DataChangeListener = require("../renderer/tools/datachangelistener.js");
var RenderInterface = require("./render-interface.js");
var PickObjectRenderPass= require("./render-passes/pick-object.js");
var PickPositionRenderPass = require("./render-passes/pick-position.js");
var PickNormalRenderPass = require("./render-passes/pick-normal.js");
var ForwardRenderTree = require("./render-trees/forward.js");
var GLU = require("../../contrib/glu.js");
var Options = require("../../utils/options.js");
var xml3dFormatHandler = require("../../base/formathandler.js").xml3dFormatHandler;
var MAX_PICK_BUFFER_DIMENSION = 512;

var OPTION_SSAO = "renderer-ssao";
var FLAGS = {};
FLAGS[OPTION_SSAO] = {defaultValue: false, recompileOnChange: true};
for (var flag in FLAGS) {
    Options.register(flag, FLAGS[flag].defaultValue);
}

/**
 * Convert the given y-coordinate on the canvas to a y-coordinate appropriate in
 * the GL context. The y-coordinate gets turned upside-down. The lowest possible
 * canvas coordinate is 0, so we need to subtract 1 from the height, too.
 *
 * @param {HTMLCanvasElement} canvas
 * @param {number} y
 * @return {number} the converted y-coordinate
 */
var canvasToGlY = function (canvas, y) {
    return canvas.height - y - 1;
};
/**
 * @interface
 */
var IRenderer = function () {
};

IRenderer.prototype.renderToCanvas = function () {
};
IRenderer.prototype.handleResizeEvent = function (width, height) {
};
IRenderer.prototype.requestRedraw = function (reason) {
};
IRenderer.prototype.needsRedraw = function () {
};
IRenderer.prototype.getWorldSpaceNormalByPoint = function (obj, x, y) {
};
IRenderer.prototype.getWorldSpacePositionByPoint = function (obj, x, y) {
};
IRenderer.prototype.getRenderObjectFromPickingBuffer = function (x, y) {
};
IRenderer.prototype.generateRay = function (x, y) {
};
IRenderer.prototype.dispose = function () {
};

/**
 * @param {Element} element The <xml3d> Element
 * @implements {IRenderer}
 * @constructor
 */
var GLRenderer = function (element, canvasHandler) {

    this._canvasHandler = canvasHandler;
    var canvas = this._canvasHandler.getCanvas();
    this.width = canvas.clientWidth;
    this.height = canvas.clientHeight;

    this.context = new GLContext(canvas, this._canvasHandler.id);
    this.scene = new GLScene(this.context);

    var factory = xml3dFormatHandler.getFactory("webgl", this._canvasHandler.id);
    factory.setScene(this.scene);
    factory.setRenderer(this);

    var xml3dAdapter = factory.getAdapter(element);
    xml3dAdapter.traverse(function () {
    });

    this.scene.rootNode.setVisible(true);


    /** @type {RenderObject} */
    this.pickedObject = null;

    this.needsDraw = true;
    this.needsPickingDraw = true;
    this.context.requestRedraw = this.requestRedraw.bind(this);

    //Currently used as a helper to calculate view and projection matrices for ray casting, since the scene
    //must be rendered from the point of view of the ray
    this.rayCamera = this.scene.createRenderView();

    this.initGL();
    this.changeListener = new DataChangeListener(this);

    this.renderInterface = this.createRenderInterface();
    this.createDefaultPipelines();
    Options.addObserver(this.onFlagsChange.bind(this));
};

// Just to satisfy jslint
GLRenderer.prototype.generateRay = function () {
};

XML3D.extend(GLRenderer.prototype, {
    initGL: function () {
        var gl = this.context.gl;

        gl.clearColor(0, 0, 0, 0);
        gl.clearDepth(1);
        gl.clearStencil(0);

        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        gl.frontFace(gl.CCW);
        gl.cullFace(gl.BACK);
        gl.disable(gl.CULL_FACE);

        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.disable(gl.BLEND);

        gl.viewport(0, 0, this.width, this.height);

        gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);

    },

    handleResizeEvent: function (width, height) {
        this.width = width;
        this.height = height;
        this.context.handleResizeEvent(width, height);
        this.createDefaultPipelines();
        this.scene.handleResizeEvent(width, height);
        this.needsDraw = this.needsPickingDraw = true;
    },

    createDefaultPipelines: function () {
        var pipeline = new ForwardRenderTree(this.renderInterface, Options.getValue(OPTION_SSAO));
        this.renderInterface.setRenderPipeline(pipeline);

        var pickTarget = new GLScaledRenderTarget(this.context, MAX_PICK_BUFFER_DIMENSION, {
            width: this.context.canvasTarget.width,
            height: this.context.canvasTarget.height,
            colorFormat: this.context.gl.RGBA,
            depthFormat: this.context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });
        this.pickObjectPass = new PickObjectRenderPass(this.renderInterface, pickTarget);
        this.pickPositionPass = new PickPositionRenderPass(this.renderInterface, pickTarget);
        this.pickNormalPass = new PickNormalRenderPass(this.renderInterface, pickTarget);
    },

    createRenderInterface: function () {
        return new RenderInterface(this.context, this.scene);
        //TODO need to provide an interface for creating shaders, buffers and so on
    },

    requestRedraw: function (reason) {
        XML3D.debug.logDebug("Request redraw because:", reason);
        this.needsDraw = true;
        this.needsPickingDraw = true;
    },

    getWorldSpaceNormalByPoint: function (x, y, object) {
        var obj = object || this.pickedObject;
        if (!obj)
            return null;
        y = canvasToGlY(this._canvasHandler.getCanvas(), y);
        this.pickNormalPass.render(obj);
        this.needsPickingDraw = true;
        return this.pickNormalPass.readNormalFromPickingBuffer(x, y);
    },

    getWorldSpacePositionByPoint: function (x, y, object) {
        var obj = object || this.pickedObject;
        if (!obj)
            return null;
        y = canvasToGlY(this._canvasHandler.getCanvas(), y);
        this.pickPositionPass.render(obj);
        this.needsPickingDraw = true;
        return this.pickPositionPass.readPositionFromPickingBuffer(x, y);
    },

    getRenderObjectByRay: function (xml3dRay, viewMat, projMat) {
        var intersectedObjects = this.scene.findRayIntersections(xml3dRay);
        this.pickObjectPass.render(intersectedObjects, viewMat, projMat);
        //Target the middle of the buffer
        var x = Math.floor(this.pickObjectPass.output.getWidth() / 2 / this.pickObjectPass.output.getScale());
        var y = Math.floor(this.pickObjectPass.output.getHeight() / 2 / this.pickObjectPass.output.getScale());
        return this.pickObjectPass.getRenderObjectFromPickingBuffer(x, y, intersectedObjects);

    },

    getWorldSpaceNormalByRay: function (ray, intersectedObject, viewMat, projMat) {
        if (!intersectedObject)
            return null;
        this.pickNormalPass.render(intersectedObject, viewMat, projMat);
        var x = Math.floor(this.pickNormalPass.output.getWidth() / 2 / this.pickNormalPass.output.getScale());
        var y = Math.floor(this.pickNormalPass.output.getHeight() / 2 / this.pickNormalPass.output.getScale());
        return this.pickNormalPass.readNormalFromPickingBuffer(x, y);

    }, getWorldSpacePositionByRay: function (ray, intersectedObject, viewMat, projMat) {
        if (!intersectedObject)
            return null;
        this.pickPositionPass.render(intersectedObject, viewMat, projMat);
        var x = Math.floor(this.pickPositionPass.output.getWidth() / 2 / this.pickPositionPass.output.getScale());
        var y = Math.floor(this.pickPositionPass.output.getHeight() / 2 / this.pickPositionPass.output.getScale());
        return this.pickPositionPass.readPositionFromPickingBuffer(x, y);

    },

    calculateMatricesForRay: function (ray, viewMat, projMat) {
        this.rayCamera.updatePosition(ray.origin._data);
        this.rayCamera.updateOrientation(this.calculateOrientationForRayDirection(ray));
        this.rayCamera.getWorldToViewMatrix(viewMat);
        var aspect = this.pickObjectPass.output.getWidth() / this.pickObjectPass.output.getHeight();
        this.rayCamera.getProjectionMatrix(projMat, aspect);
    },

    calculateOrientationForRayDirection: (function () {
        var tmpX = XML3D.math.vec3.create();
        var tmpY = XML3D.math.vec3.create();
        var tmpZ = XML3D.math.vec3.create();
        var up = XML3D.math.vec3.create();
        var q = XML3D.math.quat.create();
        var m = XML3D.math.mat4.create();

        return function (ray) {
            XML3D.math.vec3.set(up, 0, 1, 0);
            XML3D.math.vec3.cross(tmpX, ray.direction._data, up);
            if (!XML3D.math.vec3.length(tmpX)) {
                XML3D.math.vec3.set(tmpX, 1, 0, 0);
            }
            XML3D.math.vec3.cross(tmpY, tmpX, ray.direction._data);
            XML3D.math.vec3.negate(tmpZ, ray.direction._data);

            XML3D.math.quat.setFromBasis(tmpX, tmpY, tmpZ, q);
            XML3D.math.mat4.fromRotationTranslation(m, q, [0, 0, 0]);
            return m;
        }
    })(),

    needsRedraw: function () {
        return this.needsDraw;
    },

    renderToCanvas: function () {
        this.needsDraw = false; //Set this early to avoid endless rendering if an exception is thrown during rendering
        this.prepareRendering();
        this.renderInterface.getRenderPipeline().render(this.scene);
        var stats = this.renderInterface.getRenderPipeline().getRenderStats();
        XML3D.debug.logDebug("Rendered to Canvas");
        return stats;
    },

    getRenderObjectFromPickingBuffer: function (x, y) {
        y = canvasToGlY(this._canvasHandler.getCanvas(), y);
        if (this.needsPickingDraw) {
            this.needsPickingDraw = false;
            this.prepareRendering();
            this.scene.updateReadyObjectsFromActiveView(this.pickObjectPass.output.getWidth() / this.pickObjectPass.output.getHeight());
            this.pickObjectPass.render(this.scene.ready);
            XML3D.debug.logDebug("Rendered Picking Buffer");
        }
        this.pickedObject = this.pickObjectPass.getRenderObjectFromPickingBuffer(x, y, this.scene.ready);
        return this.pickedObject;
    },

    prepareRendering: function () {
        this.scene.update();
    },

    /**
     * Uses gluUnProject() to transform the 2D screen point to a 3D ray.
     * Not tested!!
     *
     * @param {number} canvasX
     * @param {number} canvasY
     */
    generateRay: (function () {

        var c_viewMatrix = XML3D.math.mat4.create();
        var c_projectionMatrix = XML3D.math.mat4.create();

        return function (canvasX, canvasY) {

            var glY = canvasToGlY(this._canvasHandler.getCanvas(), canvasY);

            // setup input to unproject
            var viewport = new Array();
            viewport[0] = 0;
            viewport[1] = 0;
            viewport[2] = this.width;
            viewport[3] = this.height;

            // get view and projection matrix arrays
            var view = this.scene.getActiveView();
            view.getWorldToViewMatrix(c_viewMatrix);
            view.getProjectionMatrix(c_projectionMatrix, viewport[2] / viewport[3]);

            var ray = new window.XML3DRay();

            var nearHit = new Array();
            var farHit = new Array();

            // do unprojections
            if (false === GLU.unProject(canvasX, glY, 0, c_viewMatrix, c_projectionMatrix, viewport, nearHit)) {
                return ray;
            }

            if (false === GLU.unProject(canvasX, glY, 1, c_viewMatrix, c_projectionMatrix, viewport, farHit)) {
                return ray;
            }

            // calculate ray
            XML3D.math.mat4.invert(c_viewMatrix, c_viewMatrix);
            var viewPos = new window.XML3DVec3(c_viewMatrix[12], c_viewMatrix[13], c_viewMatrix[14]);

            ray.origin.set(viewPos);
            ray.direction.set(farHit[0] - nearHit[0], farHit[1] - nearHit[1], farHit[2] - nearHit[2]);
            ray.direction.set(ray.direction.normalize());

            return ray;
        }
    }()),

    dispose: function () {
        this.scene.clear();
    },

    getRenderInterface: function () {
        return this.renderInterface;
    },

    onFlagsChange: function (key) {
        if (key == OPTION_SSAO) {
            this.scene.shaderFactory.setShaderRecompile();
            this.createDefaultPipelines();
        }
    }
});

module.exports = GLRenderer;

},{"../../base/formathandler.js":9,"../../contrib/glu.js":12,"../../utils/options.js":132,"../renderer/tools/datachangelistener.js":69,"./base/context.js":73,"./base/rendertarget.js":77,"./render-interface.js":98,"./render-passes/pick-normal.js":103,"./render-passes/pick-object.js":104,"./render-passes/pick-position.js":105,"./render-trees/forward.js":111,"./scene/glscene.js":115}],113:[function(require,module,exports){
var XflowMesh = require("../xflow/xflow-mesh.js");

/**
 * @constructor
 */
var DrawableFactory = function () {};

XML3D.extend(DrawableFactory.prototype, {
    createDrawable: function (obj, context) {
        XML3D.debug.logDebug("DrawableFactory::createDrawable", obj);
        try {
            var result = new XflowMesh(context, obj.getDataNode(), obj.getType(), {boundingBoxChanged: obj.setObjectSpaceBoundingBox.bind(obj)});
            obj.mesh = result.getMesh();
            return result;
        } catch (e) {
            XML3D.debug.logError(e, obj.node);
            return null;
        }
    }
});

module.exports = DrawableFactory;



},{"../xflow/xflow-mesh.js":120}],114:[function(require,module,exports){
var lightModels = {
    point: {
        parameters: [ "pointLightPosition", "pointLightAttenuation", "pointLightIntensity", "pointLightOn", "pointLightCastShadow", "pointLightMatrix", "pointLightShadowBias", "pointLightNearFar", "pointLightShadowMap"]
    },
    directional: {
        parameters: ["directionalLightDirection", "directionalLightIntensity", "directionalLightOn", "directionalLightCastShadow", "directionalLightMatrix", "directionalLightShadowBias", "directionalLightShadowMap"]
    },
    spot: {
        parameters: ["spotLightAttenuation", "spotLightPosition", "spotLightIntensity", "spotLightDirection", "spotLightOn", "spotLightSoftness", "spotLightCosFalloffAngle", "spotLightCosSoftFalloffAngle", "spotLightCastShadow", "spotLightMatrix", "spotLightShadowBias", "spotLightShadowMap"]
    }
};

var ALL_PARAMETERS = lightModels.point.parameters.concat(lightModels.directional.parameters).concat(lightModels.spot.parameters);

module.exports = {
    ALL_PARAMETERS: ALL_PARAMETERS
};

},{}],115:[function(require,module,exports){
var Scene = require("./../../renderer/scene/scene.js");
var DrawableFactory = require("./drawable-factory.js");
var C = require("./../../renderer/scene/constants.js");
var FrustumTest = require("./../../renderer/tools/frustum.js").FrustumTest;
var ShaderComposerFactory = require("../materials/shadercomposerfactory.js");
var Options = require("../../../utils/options.js");
var ShadowMapService = require("../materials/shadowmap-service");

var OPTION_FRUSTUM_CULLING = "renderer-frustumCulling";
var OPTION_SHADEJS_EXTRACT_UNIFORMS = "shadejs-extractUniformExpressions";
var OPTION_SHADEJS_TRANSFORM_SPACES = "shadejs-transformSpaces";
var OPTION_SHADEJS_CACHE = "shadejs-cache";


// All the shader flags
var FLAGS = {};
FLAGS[OPTION_SHADEJS_EXTRACT_UNIFORMS] = {defaultValue: false, recompileOnChange: true};
FLAGS[OPTION_SHADEJS_TRANSFORM_SPACES] = {defaultValue: true, recompileOnChange: true};
FLAGS[OPTION_FRUSTUM_CULLING] = {defaultValue: true, recompileOnChange: false};
FLAGS[OPTION_SHADEJS_CACHE] = {defaultValue: true, recompileOnChange: false};

for (var flag in FLAGS) {
    Options.register(flag, FLAGS[flag].defaultValue);
}


/**
 *
 * @param {GLContext} context
 * @extends {Scene}
 * @constructor
 */
var GLScene = function (context) {
    Scene.call(this);
    this.context = context;
    this.shaderFactory = new ShaderComposerFactory(context);
    this.drawableFactory = new DrawableFactory();

    this.shadowMapService = new ShadowMapService(context, this);
    /**
     * @type {Array.<RenderObject>}
     */
    this.ready = [];
    this.queue = [];
    this.lightsNeedUpdate = true;
    this.systemUniforms = {};
    this.deferred = window['XML3D_DEFERRED'] || false;
    this.colorClosureSignatures = [];
    this.doFrustumCulling = !!Options.getValue(OPTION_FRUSTUM_CULLING);
    this.addListeners();
};

XML3D.createClass(GLScene, Scene);

function removeSafe(arr, obj) {
    var index = arr.indexOf(obj);
    if (index != -1) {
        arr.splice(index, 1);
        return true;
    }
    return false;
}

XML3D.extend(GLScene.prototype, {
    remove: function (obj) {
        removeSafe(this.queue, obj);
        removeSafe(this.ready, obj);
    },

    clear: function () {
        this.ready = [];
        this.queue = [];
    },

    moveFromQueueToReady: function (obj) {
        if (removeSafe(this.queue, obj)) {
            this.ready.push(obj);
        }
    },

    moveFromReadyToQueue: function (obj) {
        if (removeSafe(this.ready, obj)) {
            this.queue.push(obj);
        }
    },

    update: function () {
        if (this.lightsNeedUpdate) {
            this.lightsNeedUpdate = false;
            this.updateLightParameters();
            this.lights.lightValueChanged();
        }
        this.updateObjectsForRendering();

        // Render shadow maps if necessary
        this.shadowMapService.updateForRendering();

        // Make sure that shaders are updates AFTER objects
        // Because unused shader closures are cleared on update
        this.updateShaders();
    }, updateLightParameters: function () {
        var parameters = this.systemUniforms;

        this.lights.fillGlobalParameters(parameters);
        this.shadowMapService.fillGlobalParameters(parameters);

        // Derived parameters that are implementation specific.
        // TODO: Put those to an appropriate place
        var spotLightFalloffAngle = parameters["spotLightFalloffAngle"];
        var spotLightSoftness = parameters["spotLightSoftness"];
        if(spotLightFalloffAngle) {
            // Map both parameters into cosinus space
            var spotLightCosSoftFalloffAngle = [];
            var spotLightCosFalloffAngle = [];
            for (var i = 0; i < spotLightFalloffAngle.length; i++) {
                spotLightCosFalloffAngle[i] = Math.cos(spotLightFalloffAngle[i]);
                spotLightCosSoftFalloffAngle[i] = Math.cos(spotLightFalloffAngle[i] * (1.0 - spotLightSoftness[i]));
            }
            parameters["spotLightCosFalloffAngle"] = spotLightCosFalloffAngle;
            parameters["spotLightCosSoftFalloffAngle"] = spotLightCosSoftFalloffAngle;
        }


    },

    updateSystemUniforms: function (names) {
        this.shaderFactory.updateSystemUniforms(names, this);
    },

    updateShaders: function () {
        this.shaderFactory.update(this);
    },

    updateObjectsForRendering: function () {
        this.forEach(function (obj) {
            obj.updateForRendering();
        });
    },

    forEach: function (func, that) {
        this.queue.slice().forEach(func, that);
        this.ready.slice().forEach(func, that);
    },

    updateReadyObjectsFromActiveView: (function () {
        var c_worldToViewMatrix = XML3D.math.mat4.create();
        var c_viewToWorldMatrix = XML3D.math.mat4.create();
        var c_projMat_tmp = XML3D.math.mat4.create();
        var c_bbox = XML3D.math.bbox.create();
        var c_frustumTest = new FrustumTest();

        return function (aspectRatio) {
            var activeView = this.getActiveView(), readyObjects = this.ready;

            // Update all MV matrices
            activeView.getWorldToViewMatrix(c_worldToViewMatrix);
            readyObjects.forEach(function (obj) {
                obj.updateModelViewMatrix(c_worldToViewMatrix);
                obj.updateModelMatrixN();
                obj.updateModelViewMatrixN();
            });

            this.updateBoundingBox();


            activeView.getProjectionMatrix(c_projMat_tmp, aspectRatio);
            activeView.getViewToWorldMatrix(c_viewToWorldMatrix);

            var frustum = activeView.getFrustum();
            c_frustumTest.set(frustum, c_viewToWorldMatrix);

            for (var i = 0, l = readyObjects.length; i < l; i++) {
                var obj = readyObjects[i];
                obj.updateModelViewProjectionMatrix(c_projMat_tmp);
                obj.getWorldSpaceBoundingBox(c_bbox);
                obj.inFrustum = this.doFrustumCulling ? c_frustumTest.isBoxVisible(c_bbox) : true;
            }
        }
    }()),
    updateReadyObjectsFromMatrices: function (worldToViewMatrix, projectionMatrix) {
        var readyObjects = this.ready;
        for (var i = 0, l = readyObjects.length; i < l; i++) {
            var obj = readyObjects[i];
            obj.updateModelViewMatrix(worldToViewMatrix);
            obj.updateModelMatrixN();
            obj.updateModelViewProjectionMatrix(projectionMatrix);
        }
    },
    addListeners: function () {
        this.addEventListener(C.EVENT_TYPE.SCENE_STRUCTURE_CHANGED, function (event) {
            if (event.newChild !== undefined) {
                this.addChildEvent(event.newChild);
            } else if (event.removedChild !== undefined) {
                this.removeChildEvent(event.removedChild);
            }
        });
        this.addEventListener(C.EVENT_TYPE.VIEW_CHANGED, function (/*event*/) {
            this.context.requestRedraw("Active view changed.");
        });
        this.addEventListener(C.EVENT_TYPE.LIGHT_STRUCTURE_CHANGED, function (/*event*/) {
            this.lightsNeedUpdate = true;
            this.shaderFactory.setLightStructureDirty();
            this.context.requestRedraw("Light structure changed.");
        });
        this.addEventListener(C.EVENT_TYPE.LIGHT_VALUE_CHANGED, function (event) {
            this.lightsNeedUpdate = true;
            this.shaderFactory.setLightValueChanged();
            this.lights.lightValueChanged(event.light);
            this.context.requestRedraw("Light value changed.");
        });
         this.addEventListener(C.EVENT_TYPE.SCENE_SHAPE_CHANGED, function (event) {
            // Need to update light frustum. Defer this until the next render phase
             this.lightsNeedUpdate = true;
        });

        Options.addObserver(this.onFlagsChange.bind(this));
    },

    addChildEvent: function (child) {
        if (child.type == C.NODE_TYPE.OBJECT) {
            this.queue.push(child);
            this.context.requestRedraw("Object was added to scene.");
        }
    },

    removeChildEvent: function (child) {
        if (child.type == C.NODE_TYPE.OBJECT) {
            this.remove(child);
            child.dispose();
            this.context.requestRedraw("Object was removed from scene.");
        }
    },

    handleResizeEvent: function (/*width, height*/) {
        this.getActiveView().setProjectionDirty();
    },

    createDrawable: function (obj) {
        return this.drawableFactory.createDrawable(obj, this.context);
    },

    requestRedraw: function (reason) {
        return this.context.requestRedraw(reason);
    },

    onFlagsChange: function (key, value) {
        if (FLAGS[key] && FLAGS[key].recompileOnChange)
            this.shaderFactory.setShaderRecompile();
        if (key == OPTION_FRUSTUM_CULLING) {
            this.doFrustumCulling = !!value;
        }
    }
});
module.exports = GLScene;


},{"../../../utils/options.js":132,"../materials/shadercomposerfactory.js":87,"../materials/shadowmap-service":88,"./../../renderer/scene/constants.js":59,"./../../renderer/scene/scene.js":68,"./../../renderer/tools/frustum.js":70,"./drawable-factory.js":113}],116:[function(require,module,exports){
var ShaderUtils = require("./shader-utils.js");
var ShaderDescriptor = require("../materials/urn/shader-descriptor.js");
var URNShaderClosure = require("../materials/urn/urnshaderclosure.js");

var ProgramFactory = function (context) {
    this.context = context;
    this.programs = {
        fallback: null, picking: {
            id: null, normal: null, position: null
        }
    }
};



XML3D.extend(ProgramFactory.prototype, {

    getProgramByName: function (name) {
        var scriptDescriptor = XML3D.shaders.getScript(name);
        if (!scriptDescriptor || !scriptDescriptor.vertex) {
            XML3D.debug.logError("Unknown shader: ", name);
            return null;
        }
        var descriptor = new ShaderDescriptor();
        XML3D.extend(descriptor, scriptDescriptor);
        descriptor.fragment = ShaderUtils.addFragmentShaderHeader(descriptor.fragment);
        var shader = new URNShaderClosure(this.context, descriptor);
        shader.createSources({}, null, null);
        shader.compile();
        return shader;
    },

    getFallbackProgram: function () {
        if (!this.programs.fallback) {
            var descriptor = new ShaderDescriptor();
            XML3D.extend(descriptor, XML3D.shaders.getScript("matte"));
            descriptor.fragment = ShaderUtils.addFragmentShaderHeader(descriptor.fragment);
            var shader = new URNShaderClosure(this.context, descriptor);
            shader.uniformCollection.envBase.diffuseColor = [1, 0, 0];
            shader.createSources({}, null, null);
            shader.compile();
            this.programs.fallback = shader;
            this.programs.fallback.bind();
            this.programs.fallback.setUniformVariables(["diffuseColor"], null, {envBase: {diffuseColor: [1, 0, 0]}});
            this.programs.fallback.unbind();
        }
        return this.programs.fallback;
    },

    getPickingObjectIdProgram: function () {
        var picking = this.programs.picking;
        if (!picking.id) {
            picking.id = this.getProgramByName("pickobjectid");
        }
        return picking.id;
    },

    getPickingPositionProgram: function () {
        var picking = this.programs.picking;
        if (!picking.position) {
            picking.position = this.getProgramByName("pickedposition");
        }
        return picking.position;
    },

    getPickingNormalProgram: function () {
        var picking = this.programs.picking;
        if (!picking.normal) {
            picking.normal = this.getProgramByName("pickedNormals");
        }
        return picking.normal;
    }

});

module.exports = ProgramFactory;


},{"../materials/urn/shader-descriptor.js":93,"../materials/urn/urnshaderclosure.js":95,"./shader-utils.js":117}],117:[function(require,module,exports){
var FRAGMENT_HEADER = ["#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "#else", "precision mediump float;", "#endif // GL_FRAGMENT_PRECISION_HIGH", "\n"].join("\n");

module.exports = {
    addFragmentShaderHeader: function (fragmentShaderSource) {
        return FRAGMENT_HEADER + fragmentShaderSource;
    }
};

},{}],118:[function(require,module,exports){
var SystemNotifier = {
    node: null,

    setNode: function (node) {
        this.node = node;
    },

    sendEvent: function (type, data) {
        if (this.node) {
            var event = document.createEvent('CustomEvent');
            data.systemtype = type;
            event.initCustomEvent('xml3dsystem', true, true, data);
            this.node.dispatchEvent(event);
        }
    }
};

module.exports = SystemNotifier;

},{}],119:[function(require,module,exports){
var GLContext = require("../base/context.js");
var XC = require("../../../xflow/interface/constants.js");

function convertToJSArray(value) {
    var jsArray = [value.length];
    for (var i = 0; i < value.length; i++) {
        jsArray[i] = value[i];
    }
    return jsArray;
}

/**
 * @param {GLContext} context
 * @param {Uint32Array} data
 * @param {number} maxIndex
 */
var createElementBuffer = function (context, data, maxIndex) {
    var gl = context.gl;
    var bufferData = data;
    var glType = gl.UNSIGNED_INT;

    if (maxIndex < (1 << 8)) {
        glType = gl.UNSIGNED_BYTE;
        bufferData = new Uint8Array(data);
    } else if (maxIndex < (1 << 16)) {
        glType = gl.UNSIGNED_SHORT;
        bufferData = new Uint16Array(data);
    } else if (!context.extensions[GLContext.EXTENSIONS.UINT32_INDICES]) {
        XML3D.debug.logError("Trying to use index data with indices larger than 65535, but this is not supported on your platform. Indexing errors will occur.");
        glType = gl.UNSIGNED_SHORT;
        bufferData = new Uint16Array(data);
    }

    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, bufferData, gl.STATIC_DRAW);
    buffer.bytesPerElement = bufferData.BYTES_PER_ELEMENT;
    buffer.length = data.length;
    buffer.glType = glType;
    return buffer;
};

/**
 * @param {GLContext} context
 * @param {Object} data
 */
var createArrayBuffer = function (context, data) {
    var gl = context.gl;

    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
    buffer.length = data.length;
    buffer.glType = getGLTypeFromArray(data);
    return buffer;
};

var getGLTypeFromArray = function (array) {
    var GL = window.WebGLRenderingContext;
    if (array instanceof Int8Array)
        return GL.BYTE;
    if (array instanceof Uint8Array)
        return GL.UNSIGNED_BYTE;
    if (array instanceof Int16Array)
        return GL.SHORT;
    if (array instanceof Uint16Array)
        return GL.UNSIGNED_SHORT;
    if (array instanceof Int32Array)
        return GL.INT;
    if (array instanceof Uint32Array)
        return GL.UNSIGNED_INT;
    if (array instanceof Float32Array)
        return GL.FLOAT;
    return GL.FLOAT;
};


module.exports = {
    getGLUniformValueFromXflowDataEntry: function (xflowDataEntry, context) {
        var value;
        if (!xflowDataEntry)
            return null;
        if (xflowDataEntry.type == XC.DATA_TYPE.TEXTURE) {
            var webglData = context.getXflowEntryWebGlData(xflowDataEntry);
            var texture = webglData.texture || context.createTexture();
            if (webglData.changed)
                texture.updateFromTextureEntry(xflowDataEntry);

            webglData.texture = texture;
            webglData.changed = 0;
            value = [texture];
        } else if (xflowDataEntry.type == XC.DATA_TYPE.BOOL) {
            //TODO Can we get Xflow to return boolean arrays as normal JS arrays? WebGL doesn't accept Uint8Arrays here...
            //TODO Alternatively we could set boolean uniforms using uniform1fv together with Float32Arrays, which apparently works too
            value = convertToJSArray(xflowDataEntry.getValue());
        } else {
            value = xflowDataEntry.getValue();
        }

        return value;
    },

    getGLBufferFromXflowDataEntry: function (xflowDataEntry, context, elementBuffer) {
        var webglData = context.getXflowEntryWebGlData(xflowDataEntry);
        var buffer = webglData.buffer;
        var gl = context.gl;

        // Also write min and max values for elementBuffers
        if (webglData.changed && elementBuffer) {
            var indexValue = xflowDataEntry.getValue();
            var minIndex = 100000000, maxIndex = 0;
            var i = indexValue.length;
            while (i--) {
                minIndex = Math.min(minIndex, indexValue[i]);
                maxIndex = Math.max(maxIndex, indexValue[i]);
            }
            webglData.maxIndex = maxIndex;
            webglData.minIndex = minIndex;
        }

        //noinspection FallthroughInSwitchStatementJS
        switch (webglData.changed) {
            case XC.DATA_ENTRY_STATE.CHANGED_VALUE:
                if (elementBuffer) {
                    var bufferData = xflowDataEntry.getValue();
                    switch (buffer.glType) {
                        case gl.UNSIGNED_BYTE:
                            bufferData = new Uint8Array(bufferData);
                            break;
                        case gl.UNSIGNED_SHORT:
                            bufferData = new Uint16Array(bufferData);
                            break;
                        case gl.UNSIGNED_INT:
                            // This is what we expect anyway
                            break;
                        default:
                            XML3D.debug.logError("Unknown GL type for element buffer: ", buffer.glType);
                            return null;
                    }
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
                    gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, bufferData);
                } else {
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferSubData(gl.ARRAY_BUFFER, 0, xflowDataEntry.getValue());
                }
                break;
            case XC.DATA_ENTRY_STATE.CHANGED_NEW:
            case XC.DATA_ENTRY_STATE.CHANGED_SIZE:
            case XC.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE:
                if (elementBuffer) {
                    buffer = createElementBuffer(context, xflowDataEntry.getValue(), webglData.maxIndex);
                } else {
                    buffer = createArrayBuffer(context, xflowDataEntry.getValue());
                }
                buffer.tupleSize = xflowDataEntry.getTupleSize();
                webglData.buffer = buffer;
                break;
        }

        webglData.changed = 0;
        return buffer;
    },

    /**
     * Calculate bounding box from positions and optional indices
     * TODO: Remove FloatArray creation
     * @param {Float32Array} positions
     * @param {Int16Array|null} index
     * @returns {Float32Array}
     */
    calculateBoundingBox: function (positions, index) {
        var bbox = new XML3D.math.bbox.create(), i;

        if (!positions || positions.length < 3)
            return bbox;

        if (index) {
            var i0 = index[0] * 3;
            bbox[0] = positions[i0];
            bbox[1] = positions[i0 + 1];
            bbox[2] = positions[i0 + 2];
            bbox[3] = positions[i0];
            bbox[4] = positions[i0 + 1];
            bbox[5] = positions[i0 + 2];

            for (i = 1; i < index.length; i++) {
                var i1 = index[i] * 3;
                var p1 = positions[i1];
                var p2 = positions[i1 + 1];
                var p3 = positions[i1 + 2];

                if (p1 < bbox[0])
                    bbox[0] = p1;
                if (p2 < bbox[1])
                    bbox[1] = p2;
                if (p3 < bbox[2])
                    bbox[2] = p3;
                if (p1 > bbox[3])
                    bbox[3] = p1;
                if (p2 > bbox[4])
                    bbox[4] = p2;
                if (p3 > bbox[5])
                    bbox[5] = p3;
            }
        } else {
            bbox[0] = positions[0];
            bbox[1] = positions[1];
            bbox[2] = positions[2];
            bbox[3] = positions[0];
            bbox[4] = positions[1];
            bbox[5] = positions[2];

            for (i = 3; i < positions.length; i += 3) {
                if (positions[i] < bbox[0])
                    bbox[0] = positions[i];
                if (positions[i + 1] < bbox[1])
                    bbox[1] = positions[i + 1];
                if (positions[i + 2] < bbox[2])
                    bbox[2] = positions[i + 2];
                if (positions[i] > bbox[3])
                    bbox[3] = positions[i];
                if (positions[i + 1] > bbox[4])
                    bbox[4] = positions[i + 1];
                if (positions[i + 2] > bbox[5])
                    bbox[5] = positions[i + 2];
            }
        }
        return bbox;
    }
};

},{"../../../xflow/interface/constants.js":136,"../base/context.js":73}],120:[function(require,module,exports){
var DrawableClosure = require("../../renderer/scene/drawableclosure.js");
var GLMesh = require("../base/mesh.js");
var XflowUtils = require("./utils.js");
var EVENT_TYPE = require("../../renderer/scene/constants.js").EVENT_TYPE;
var MaterialEvents = require("../materials/events.js");
var XC = require("../../../xflow/interface/constants.js");
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;

var CHANGE_STATE = {
    NOTHING_CHANGED: 0,
    STRUCTURE_CHANGED: 1,
    TYPE_DATA_CHANGED: 2,
    VS_DATA_CHANGED: 4,
    TYPE_CHANGED: 2 + 1,
    VS_CHANGED: 4 + 1,
    SHADER_CHANGED: 32
};
var SHADER_CLOSURE_NEEDS_UPDATE = CHANGE_STATE.STRUCTURE_CHANGED | CHANGE_STATE.SHADER_CHANGED;

var READY_STATE = DrawableClosure.READY_STATE;


var MESH_PARAMETERS = {};

MESH_PARAMETERS[WebGLRenderingContext.TRIANGLES] = {
    attributeData: {"position": XC.DATA_TYPE.FLOAT3}, typeData: {
        "index": XC.DATA_TYPE.INT, "solid": XC.DATA_TYPE.BOOL, "vertexCount": XC.DATA_TYPE.INT
    }, bboxFix: {
        "boundingBox": XC.DATA_TYPE.FLOAT3
    }, bboxCompute: {
        "position": XC.DATA_TYPE.FLOAT3
    }
};
MESH_PARAMETERS[WebGLRenderingContext.LINE_STRIP] = MESH_PARAMETERS[WebGLRenderingContext.TRIANGLES];
MESH_PARAMETERS[WebGLRenderingContext.LINES] = MESH_PARAMETERS[WebGLRenderingContext.TRIANGLES];
MESH_PARAMETERS[WebGLRenderingContext.POINTS] = MESH_PARAMETERS[WebGLRenderingContext.TRIANGLES];
MESH_PARAMETERS[WebGLRenderingContext.TRIANGLE_STRIP] = MESH_PARAMETERS[WebGLRenderingContext.TRIANGLES];


/**
 * Class that synchronizes data changes from Xflow with a GLMesh instance
 *
 * @param {GLContext} context
 * @param {Xflow.DataNode} dataNode
 * @param {string} type
 * @param {object} opt
 * @extends {DrawableClosure}
 * @constructor
 */
var XflowMesh = function (context, dataNode, type, opt) {
    DrawableClosure.call(this, context, DrawableClosure.TYPES.MESH);
    opt = opt || {};
    this.mesh = new GLMesh(context, type);

    /**
     * Data Node of the renderObject
     * @type {Xflow.DataNode}
     */
    this.dataNode = dataNode;

    /**
     * Shader Composer that will provide ShaderClosure and Program
     * @type {AbstractShaderComposer}
     */
    this.shaderComposer = null;

    /**
     * Shader Closure used by this mesh
     * @type {AbstractShaderClosure}
     */
    this.shaderClosure = null;

    /**
     * Attributes required to create the GLMesh
     * @type {ComputeRequest}
     */
    this.typeRequest = null;

    /**
     * Are all attributes required by drawable available?
     * @type {boolean}
     */
    this.typeDataValid = true;

    /**
     * Attributes and uniforms values for the shader
     * @type {Xflow.Request}
     */
    this.objectShaderRequest = null;

    /**
     * Bitfield that records the changes reported by Xflow
     * @private
     * @type {number}
     */
    this.changeState = CHANGE_STATE.STRUCTURE_CHANGED;

    /**
     * Callback if bounding box has changed. Gets only called if
     * this.boundingBoxRequired is true.
     * @type {*|function(Float32Array)}
     */
    this.boundingBoxChanged = opt.boundingBoxChanged || function () {
    };

    this.initialize();
};

XML3D.createClass(XflowMesh, DrawableClosure, {
    initialize: function () {
        this.typeDataChanged(this.typeRequest, XC.RESULT_STATE.CHANGED_STRUCTURE);
        this.shaderChanged();
    },

    setShaderComposer: function (shaderComposer) {
        if (!this.bindedShaderChanged) this.bindedShaderChanged = this.shaderChanged.bind(this);

        if (this.shaderComposer)
            this.shaderComposer.removeEventListener(MaterialEvents.MATERIAL_STRUCTURE_CHANGED, this.bindedShaderChanged);

        this.shaderComposer = shaderComposer;
        if (this.shaderComposer)
            this.shaderComposer.addEventListener(MaterialEvents.MATERIAL_STRUCTURE_CHANGED, this.bindedShaderChanged);

        this.changeState |= CHANGE_STATE.SHADER_CHANGED;
    },

    update: function (scene) {
        if (this.changeState === CHANGE_STATE.NOTHING_CHANGED) {
            return;
        }
        XML3D.debug.logDebug("Update mesh closure", this.changeState);

        var oldValid = !!this.shaderClosure && this.typeDataValid, someError = null, typeDataResolved = false;

        try {
            if (this.changeState & SHADER_CLOSURE_NEEDS_UPDATE) {
                this.mesh.clear();
            }

            if (this.changeState & CHANGE_STATE.TYPE_CHANGED) {
                this.updateTypeData();
            }

            typeDataResolved = true;

            if (this.changeState & (SHADER_CLOSURE_NEEDS_UPDATE | CHANGE_STATE.TYPE_CHANGED)) {
                this.updateIndexBuffer();
            }

            if (this.changeState & SHADER_CLOSURE_NEEDS_UPDATE) {
                this.updateObjectShaderRequest();
                this.updateShaderClosure(scene);
                this.updateObjectShaderData();
            } else if (this.changeState & CHANGE_STATE.VS_CHANGED) {
                this.updateObjectShaderData();
            }

            if (this.dataNode.isSubtreeLoading()) {
                this.shaderClosure = null;
                this.typeDataValid = false;
            }
        } catch (e) {
            someError = e;
            if (!typeDataResolved)
                this.typeDataValid = false; else
                this.shaderClosure = null;
        }


        var newValid = !!this.shaderClosure && this.typeDataValid;

        if (oldValid != newValid) {
            this.dispatchEvent({
                type: EVENT_TYPE.DRAWABLE_STATE_CHANGED,
                newState: newValid ? READY_STATE.COMPLETE : READY_STATE.INCOMPLETE,
                oldState: oldValid ? READY_STATE.COMPLETE : READY_STATE.INCOMPLETE
            });
        }
        this.changeState = CHANGE_STATE.NOTHING_CHANGED;

        if (someError) throw someError;
    },

    calculateBoundingBox: (function () {
        var c_empty = XML3D.math.bbox.create();

        return function () {
            // compute bounding box from positions and indices, if present
            var dataResult = this.typeRequest.getResult();
            var boundingBoxEntry = dataResult.getOutputData("boundingBox");
            if (boundingBoxEntry) {
                this.boundingBoxChanged(XflowUtils.calculateBoundingBox(boundingBoxEntry.getValue(), null));
                return;
            }
            var positionEntry = dataResult.getOutputData("position");
            if (!positionEntry) {
                this.boundingBoxChanged(c_empty);
                return;
            }
            var indexEntry = dataResult.getOutputData("index");
            this.boundingBoxChanged(XflowUtils.calculateBoundingBox(positionEntry.getValue(), indexEntry ? indexEntry.getValue() : null));
        }
    }()), /**
     *
     * @param {ComputeRequest} request
     * @param {XC.RESULT_STATE} state
     */
    typeDataChanged: function (request, state) {
        this.changeState |= state == XC.RESULT_STATE.CHANGED_STRUCTURE ? CHANGE_STATE.STRUCTURE_CHANGED : CHANGE_STATE.TYPE_DATA_CHANGED;
        this.dispatchEvent({type: EVENT_TYPE.SCENE_SHAPE_CHANGED});
        this.context.requestRedraw("Mesh Type Data Change");
        XML3D.debug.logDebug("XflowMesh: Type data changed", request, state, this.changeState);
    },

    getMesh: function () {
        return this.mesh;
    },

    getMeshType: function () {
        return this.mesh.glType;
    },

    updateObjectShaderRequest: function () {
        if (this.objectShaderRequest) this.objectShaderRequest.clear();
        this.objectShaderRequest = null;
        if (this.dataNode.isSubtreeLoading())
            return;

        this.objectShaderRequest = this.shaderComposer.createObjectDataRequest(this.dataNode, this.shaderInputDataChanged.bind(this));
    },

    updateShaderClosure: function (scene) {
        this.shaderClosure = null;
        if (!this.dataNode.isSubtreeLoading() && !this.dataNode.getOutputChannelInfo("position")) {
            throw new Error("Mesh does not have 'position' attribute.");
            //XML3D.debug.logError("Mesh does not have 'position' attribute.", this.mesh, this.getMeshType());
        } else if (!this.dataNode.isSubtreeLoading()) {
            var objectShaderResult = this.objectShaderRequest.getResult();
            if (!objectShaderResult.loading)
                this.shaderClosure = this.shaderComposer.getShaderClosure(scene, this.objectShaderRequest);
        }
    },

    updateIndexBuffer: function () {
        // Add Index buffer, if available
        var dataResult = this.typeRequest.getResult();
        var entry = dataResult.getOutputData("index");
        if (entry && entry.getValue())
            this.handleBuffer("index", entry, true);
    },

    updateObjectShaderData: function () {
        if (!this.shaderClosure) {
            return; // if only the data has changed, it can't get valid after update
        }

        if (!this.bindedHandleBuffer) this.bindedHandleBuffer = this.handleBuffer.bind(this);
        if (!this.bindedHandleUniform) this.bindedHandleUniform = this.handleUniform.bind(this);

        this.shaderComposer.distributeObjectShaderData(this.objectShaderRequest, this.bindedHandleBuffer, this.bindedHandleUniform);

        if (!this.mesh.isReadyToRender()) {
            throw new Error("Mesh has empty vertex attributes.");
        }
    },

    updateTypeData: function () {
        if (!this.typeDataValid && !(this.changeState & CHANGE_STATE.STRUCTURE_CHANGED)) {
            return; // only if structure has changed, it can't get valid after update
        }

        this.updateTypeRequest();

        this.calculateBoundingBox();

        var dataResult = this.typeRequest.getResult();

        var entry = dataResult.getOutputData("vertexCount");
        this.mesh.setVertexCount(entry && entry.getValue() ? entry.getValue() : null);
        this.typeDataValid = true;
    },

    /**
     * @param {string} name
     * @param {Xflow.BufferEntry} xflowDataEntry
     * @param {boolean=} isIndex
     */
    handleBuffer: function (name, xflowDataEntry, isIndex) {
        isIndex = isIndex || false;
        var mesh = this.mesh;

        if (name == "position" && !xflowDataEntry) {
            throw new Error("'position' attribute of mesh is empty.");
        }

        if (!xflowDataEntry) {
            this.mesh.removeBuffer(name);
            return;
        }

        if (xflowDataEntry.type == XC.DATA_TYPE.TEXTURE) {
            XML3D.debug.logError("Texture as mesh parameter is not yet supported");
            return;
        }

        var buffer = XflowUtils.getGLBufferFromXflowDataEntry(xflowDataEntry, this.context, name == "index");
        if (isIndex) {
            this.updateIndexRange(xflowDataEntry);
        } else {
            this.mesh.checkBufferCompatible(name, xflowDataEntry);
        }
        // In every case, set the buffer, because other meshes might have already
        // performed one or more of the tasks above
        //console.log("Set buffer", name, buffer.id);
        mesh.setBuffer(name, buffer);
    },

    updateIndexRange: function (xflowDataEntry) {
        var webglData = this.context.getXflowEntryWebGlData(xflowDataEntry);
        this.mesh.setIndexRange(webglData.minIndex, webglData.maxIndex);
    },

    /*checkBufferSize: function(name, xflowDataEntry){
     if(xflowDataEntry.getIterateCount){
     var cnt = xflowDataEntry.getIterateCount();
     if(cnt >= this.mesh.maxIndex)
     throw new Error("Index range of [" + this.mesh.minIndex + ", " + this.mesh.maxIndex + "] " +
     " goes beyond element count " + cnt + " of attribute '" + name + "'");
     }
     },*/

    handleUniform: function (name, xflowDataEntry) {
        var value = XflowUtils.getGLUniformValueFromXflowDataEntry(xflowDataEntry, this.context);
        this.mesh.setUniformOverride(name, value);
    }, /**
     *
     */
    updateTypeRequest: function () {
        var meshConfig = MESH_PARAMETERS[this.getMeshType()];
        if (!meshConfig) {
            XML3D.debug.logError("Unsupported Mesh request: ", this.mesh, this.getMeshType());
            this.typeDataValid = false;
            return;
        }
        var requestNames = this.getTypeRequestNames(meshConfig);

        if (!this.typeRequest || this.typeRequest.filter != requestNames) {
            if (this.typeRequest) this.typeRequest.clear();
            this.typeRequest = new ComputeRequest(this.dataNode, requestNames, this.typeDataChanged.bind(this));
        }
    },

    getTypeRequestNames: function (meshConfig) {
        var requestNames = [];
        requestNames.push.apply(requestNames, Object.keys(meshConfig.typeData));
        // We always request fixed bounding box values: that way we can react, when those values get available
        requestNames.push.apply(requestNames, Object.keys(meshConfig.bboxFix));
        var computeBBox = !this.checkXflowTypes(this.dataNode, meshConfig.bboxFix);

        if (computeBBox) {
            if (!this.checkXflowTypes(this.dataNode, meshConfig.bboxCompute)) {
                this.typeDataValid = false;
            }
            requestNames.push.apply(requestNames, Object.keys(meshConfig.bboxCompute));
        }
        return requestNames;
    },

    checkXflowTypes: function (dataNode, requirements) {
        for (var name in requirements) {
            var info = dataNode.getOutputChannelInfo(name);
            if (!info) return false;
            if (info.type != requirements[name])
                return false;
        }
        return true;
    },

    /**
     * @param {ComputeRequest} request
     * @param {XC.RESULT_STATE} state
     */
    shaderInputDataChanged: function (request, state) {
        this.changeState |= state != XC.RESULT_STATE.CHANGED_DATA_VALUE ? CHANGE_STATE.STRUCTURE_CHANGED : CHANGE_STATE.VS_DATA_CHANGED;
        // TODO: We don't know if the change of data only influences the surface shading or the actual mesh shape
        this.dispatchEvent({type: EVENT_TYPE.SCENE_SHAPE_CHANGED});
        this.context.requestRedraw("Mesh Attribute Data Changed");
        XML3D.debug.logDebug("XflowMesh: Attribute data changed", request, state, this.changeState);
    },

    shaderChanged: function () {
        this.changeState |= CHANGE_STATE.SHADER_CHANGED;
    },

    getProgram: function () {
        return this.shaderClosure;
    }

});

module.exports = XflowMesh;


},{"../../../xflow/interface/constants.js":136,"../../../xflow/interface/request.js":139,"../../renderer/scene/constants.js":59,"../../renderer/scene/drawableclosure.js":60,"../base/mesh.js":75,"../materials/events.js":83,"./utils.js":119}],121:[function(require,module,exports){

/**
 * Creates an instance of XML3DBox. XML3DBox represents an axis-aligned box,
 * described by two vectors min and max.
 * @constructor
 * @param {XML3DVec3=} min The smaller point of the box. Default: (0,0,0)
 * @param {XML3DVec3=} max The biggest point of the box. Default: (0,0,0)
 */
var XML3DBox = function(min, max, cb) {
    var that = this;

    /** anonymous callback to inform this instance * */
    var vec_cb = function() {
        if (that._callback)
            that._callback(that);
    };

    /**
     * @private
     * @type {XML3DVec3}
     */
    this._min = new window.XML3DVec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, vec_cb);
    /**
     * @private
     * @type {XML3DVec3}
     */
    this._max = new window.XML3DVec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, vec_cb);

    // Copy constructor
    if (min && min.min) {
        this._min.set(min.min);
        this._max.set(min.max);
    } else {
        if (min)
            this._min.set(min);
        if (max)
            this._max.set(max);
    }

    /** @private * */
    this._callback = typeof cb == 'function' ? cb : 0;

};

/** @type {XML3DVec3} */
Object.defineProperty(XML3DBox.prototype, "min", {
    /** @this {XML3DBox} **/
    get : function() { return this._min; },
    set : function() { throw Error("XML3DBox::min is readonly."); },
    configurable : false,
    enumerable : false
});

/** @type {XML3DVec3} */
Object.defineProperty(XML3DBox.prototype, "max", {
    /** @this {XML3DBox} **/
    get : function() { return this._max; },
    set : function() { throw Error("XML3DBox::max is readonly."); },
    configurable : false,
    enumerable : false
});

/**
 * Calculates the size of the Box in each dimension
 * @return {XML3DVec3} Size of the Box
 */
XML3DBox.prototype.size = function() {
    var v = this._max.subtract(this._min);
    if (v.x < 0)
        v.x = 0;
    if (v.y < 0)
        v.y = 0;
    if (v.z < 0)
        v.z = 0;

    return v;
};

/**
 * Calculates the center of the Box
 * @returns {XML3DVec3} that is the center of the box
 */
XML3DBox.prototype.center = function() {
    return this._min.add(this._max).scale(0.5);
};

/**
 * Set Box empty Sets min's components to Number.MAX_VALUE and max'
 * components to -Number.MAX_VALUE.
 */
XML3DBox.prototype.makeEmpty = function() {
    this._min = new window.XML3DVec3(Number.MAX_VALUE, Number.MAX_VALUE,
            Number.MAX_VALUE);
    this._max = new window.XML3DVec3(-Number.MAX_VALUE, -Number.MAX_VALUE,
            -Number.MAX_VALUE);
    if (this._callback)
        this._callback(this);
};

/**
 * Test, if this Box is empty
 * @returns {boolean} 'true', if box is empty
 */
XML3DBox.prototype.isEmpty = function() {
    return (this._min.x > this._max.x || this._min.y > this._max.y || this._min.z > this._max.z);
};

/**
 * String representation of the XML3DBox.
 * @override
 * @return {string} Human-readable representation of this XML3DBox.
 */
XML3DBox.prototype.toString = function() {
    return "[object XML3DBox]";
};

/**
 * The set method copies the values from other.
 * @param {XML3DBox} other The other box
 */
XML3DBox.prototype.set = function(other) {
    this._min.set(other.min);
    this._max.set(other.max);
    if (this._callback)
        this._callback(this);
};

/** updates the min or max accoring to the given point or bounding box.
*
* @param that the object used for extension, which can be a XML3DVec3 or XML3DBox
*/
XML3DBox.prototype.extend = function(that)
{
    if (!that)
        return;

    var min, max;
    if(that.constructor === window.XML3DBox)
    {
        min = that.min;
        max = that.max;
    }
    else if(that.constructor === window.XML3DVec3)
    {
        min = that;
        max = that;
    }
    else
        return;

    if(min.x < this._min.x)
        this._min.x = min.x;
    if(min.y < this._min.y)
        this._min.y = min.y;
    if(min.z < this._min.z)
        this._min.z = min.z;

    if(max.x > this._max.x)
        this._max.x = max.x;
    if(max.y > this._max.y)
        this._max.y = max.y;
    if(max.z > this._max.z)
        this._max.z = max.z;
};

module.exports = XML3DBox;

},{}],122:[function(require,module,exports){
var XC = require("../xflow/interface/constants.js");
var Resource = require("../base/resourcemanager.js").Resource;

var c_XflowObserverList = [];

var XML3DDataObserver = function(callback){
    this.callback = callback;
    this.observed = [];
};

XML3DDataObserver.prototype.observe = function(node, options){
    if(!node)
        throw new Error("The node to observe is null.");


    if(!node._configured)
        throw new Error("Note to observe is not   (yet). Make sure to pass an XML3D node and to execute " +
            "this function after XML3D has been configured e.g. inside a DOMContentLoaded listener.");


    var dataAdapter = Resource.getAdapter(node, "data");
    if(!dataAdapter)
        throw new Error("Can't observe node. XML3DataObserver can only observe data containers such as <data>, <mesh> or <shader>");

    if(this.observed.length == 0)
        c_XflowObserverList.push(this);

    var entry = {
        node: node,
        changed: false,
        request: null
    };

    var names = options && options['names'];
    var typeOfNames = Object.prototype.toString.call(names).slice(8, -1);
    if (typeOfNames === "String") {
        names = [names];
    }

    entry.request = dataAdapter.getComputeRequest(names, function(request, changeType){
        entry.changed = true;
    });
    // Fetch result to synchronize Xflow structures and connect to callbacks
    // TODO: Find an option to connect request to callback structure without computing result
    entry.request.getResult();

    this.observed.push(entry);
};

XML3DDataObserver.prototype.disconnect = function(){
    for(var i = 0; i < this.observed.length; ++i){
        this.observed[i].request.clear();
    }
    this.observed = [];
    var i = c_XflowObserverList.length;
    while(i--){
        if(c_XflowObserverList[i] == this)
            c_XflowObserverList.splice(i, 1);
    }
};


XML3D.updateXflowObserver = function(){
    for(var i = 0; i < c_XflowObserverList.length; ++i){
        var observer = c_XflowObserverList[i];
        var records = [];
        for(var j = 0; j < observer.observed.length; ++j){
            var entry = observer.observed[j];
            if(entry.changed){
                entry.changed = false;
                var result = entry.request.getResult();
                var dataResult = new XML3DDataResult(result);
                records.push( new XML3DDataRecord(entry.node, dataResult));
            }
        }
        if(records.length > 0 && observer.callback){
            observer.callback(records, observer);
        }
    }
};

var XML3DDataRecord = function(target, result){
    this.target = target;
    this.result = result;
};


var XML3DDataResult = function(result){
    this._entries = {};
    constructDataResult(this, result);
};

XML3DDataResult.prototype.getValue = function(name) {
    if (this._entries[name])
        return this._entries[name].value;
    return null;
};

XML3DDataResult.prototype.getType = function(name) {
    if (this._entries[name])
        return this._entries[name].type;
    return null;
};

XML3DDataResult.prototype.getNames = function(){
    var result = [];
    for(var name in this._entries){
        result.push(name);
    }
    return result;
};

XML3DDataResult.FLOAT  = 0;
XML3DDataResult.FLOAT2 = 1;
XML3DDataResult.FLOAT3 = 2;
XML3DDataResult.FLOAT4 = 3;
XML3DDataResult.FLOAT4X4 = 4;
XML3DDataResult.INT = 10;
XML3DDataResult.INT4 = 11;
XML3DDataResult.BOOL = 20;
XML3DDataResult.TEXTURE = 30;
XML3DDataResult.BYTE = 40;
XML3DDataResult.UBYTE = 50;


function constructDataResult(dataResult, result){
    for(var i = 0; i < result.outputNames.length; ++i){
        var name = result.outputNames[i];
        var entry = result.getOutputData(name);
        var value = entry && entry.getValue();
        if (value !== null) {
            var type = getXML3DDataType(entry.type);
            dataResult._entries[name] = { type: type, value: value};
        }
    }
}

function getXML3DDataType(type){
    switch(type){
        case XC.DATA_TYPE.FLOAT : return XML3DDataResult.FLOAT;
        case XC.DATA_TYPE.FLOAT2 : return XML3DDataResult.FLOAT2;
        case XC.DATA_TYPE.FLOAT3 : return XML3DDataResult.FLOAT3;
        case XC.DATA_TYPE.FLOAT4 : return XML3DDataResult.FLOAT4;
        case XC.DATA_TYPE.FLOAT4X4 : return XML3DDataResult.FLOAT4X4;
        case XC.DATA_TYPE.INT : return XML3DDataResult.INT;
        case XC.DATA_TYPE.INT4 : return XML3DDataResult.INT4;
        case XC.DATA_TYPE.BOOL : return XML3DDataResult.BOOL;
        case XC.DATA_TYPE.TEXTURE : return XML3DDataResult.TEXTURE;
        case XC.DATA_TYPE.BYTE : return XML3DDataResult.BYTE;
        case XC.DATA_TYPE.UBYTE : return XML3DDataResult.UBYTE;
        default: throw new Error("WHAT IS THIS I DON'T EVEN...");
    }
}

var XML3DDataChannelInfo = function(type, origin, originalName, seqLength, seqMinKey, seqMaxKey){
    this.type = getXML3DDataType(type);
    this.origin = origin;
    this.originalName = originalName;
    this.seqLength = seqLength;
    this.seqMinKey = seqMinKey;
    this.seqMaxKey = seqMaxKey;
};

XML3DDataChannelInfo.ORIGIN_CHILD = 1;
XML3DDataChannelInfo.ORIGIN_COMPUTE = 2;
XML3DDataChannelInfo.ORIGIN_PROTO = 3;

module.exports = {
    XML3DDataChannelInfo: XML3DDataChannelInfo,
    XML3DDataResult: XML3DDataResult,
    XML3DDataObserver: XML3DDataObserver
};
},{"../base/resourcemanager.js":10,"../xflow/interface/constants.js":136}],123:[function(require,module,exports){

/**
 * Configure array properties
 * @private
 * @this {XML3DMatrix}
 * @param {number} index Array index
 */
function prop(index) {
    return {
        get : function() {
            return this._data[index];
        },
        set : function(val) {
            this._data[index] = val;
            if (this._callback)
                this._callback(this);
        },
        configurable : false,
        enumerable : false
    };
}

/**
 * Creates an instance of XML3DMatrix. XML3DMatrix represents a represents a
 * 4x4 homogeneous matrix.
 * @constructor
 * @param {number=} m11 Represents the value in the 1st column of the 1st
 *            row.
 * @param {number=} m12 Represents the value in the 2st column of the 1st
 *            row.
 * @param {number=} m13 Represents the value in the 3st column of the 1st
 *            row.
 * @param {number=} m14 Represents the value in the 4st column of the 1st
 *            row.
 * @param {number=} m21 Represents the value in the 1st column of the 2st
 *            row.
 * @param {number=} m22 Represents the value in the 2st column of the 2st
 *            row.
 * @param {number=} m23 Represents the value in the 3st column of the 2st
 *            row.
 * @param {number=} m24 Represents the value in the 4st column of the 2st
 *            row.
 * @param {number=} m31 Represents the value in the 1st column of the 3st
 *            row.
 * @param {number=} m32 Represents the value in the 2st column of the 3st
 *            row.
 * @param {number=} m33 Represents the value in the 3st column of the 3st
 *            row.
 * @param {number=} m34 Represents the value in the 4st column of the 3st
 *            row.
 * @param {number=} m41 Represents the value in the 1st column of the 4st
 *            row.
 * @param {number=} m42 Represents the value in the 2st column of the 4st
 *            row.
 * @param {number=} m43 Represents the value in the 3st column of the 4st
 *            row.
 * @param {number=} m44 Represents the value in the 4st column of the 4st
 *            row.
 */
var XML3DMatrix = function(m11, m12, m13, m14, m21, m22, m23, m24, m31,
        m32, m33, m34, m41, m42, m43, m44, cb) {
    /** @private */
    if (typeof m11 == 'number' && arguments.length >= 16) {
        this.set(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44);
        this._callback = typeof cb == 'function' ? cb : 0;
    } else if (typeof m11 == 'object' && arguments.length == 1) {
        this.set(m11);
    } else{
        this._data = new Float32Array( [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
                0, 0, 0, 0, 1 ]);
        this._callback = typeof m11 == 'function' ? m11 : 0;
    }
};
var p = XML3DMatrix.prototype;

/** @type {number} */
Object.defineProperty(p, "m11", prop(0));
/** @type {number} */
Object.defineProperty(p, "m12", prop(1));
/** @type {number} */
Object.defineProperty(p, "m13", prop(2));
/** @type {number} */
Object.defineProperty(p, "m14", prop(3));
/** @type {number} */
Object.defineProperty(p, "m21", prop(4));
/** @type {number} */
Object.defineProperty(p, "m22", prop(5));
/** @type {number} */
Object.defineProperty(p, "m23", prop(6));
/** @type {number} */
Object.defineProperty(p, "m24", prop(7));
/** @type {number} */
Object.defineProperty(p, "m31", prop(8));
/** @type {number} */
Object.defineProperty(p, "m32", prop(9));
/** @type {number} */
Object.defineProperty(p, "m33", prop(10));
/** @type {number} */
Object.defineProperty(p, "m34", prop(11));
/** @type {number} */
Object.defineProperty(p, "m41", prop(12));
/** @type {number} */
Object.defineProperty(p, "m42", prop(13));
/** @type {number} */
Object.defineProperty(p, "m43", prop(14));
/** @type {number} */
Object.defineProperty(p, "m44", prop(15));

/**
 * Set the value of the matrix.
 *
 * @param {Object} m11 another XML3DMatrix, Float32Array or a number. In the last case the remaining arguments are considered.
 * @param {number=} m12
 * @param {number=} m13
 * @param {number=} m14
 * @param {number=} m21
 * @param {number=} m22
 * @param {number=} m23
 * @param {number=} m24
 * @param {number=} m31
 * @param {number=} m32
 * @param {number=} m33
 * @param {number=} m34
 * @param {number=} m41
 * @param {number=} m42
 * @param {number=} m43
 * @param {number=} m44
 */
p.set = function(m11, m12, m13, m14, m21, m22, m23, m24, m31,
        m32, m33, m34, m41, m42, m43, m44) {

    if (typeof m11 == 'number' && arguments.length >= 16) {
        this._data = new Float32Array(arguments);
        return;
    }

    if(m11._data && m11._data.length && m11._data.length === 16) {
        this._data = new Float32Array(m11._data);
        return;
    }

    if(m11.length && m11.length >= 16) {
        this._data = new Float32Array(m11);
        return;
    }

    XML3D.debug.logError("XML3DMatrix.set(): invalid parameter(s). Expect XML3DMatrix, Float32Array or 16 numbers.");
};

/**
 * String representation of the XML3DMatrix.
 * @override
 * @return {string} Human-readable representation of this XML3DMatrix.
 */
p.toString = function() {
    return "[object XML3DMatrix]";
};

p.setMatrixValue = function(str) {
    var m = /^(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)$/
            .exec(str);

    if (!m)
        throw {
            code : DOMException.SYNTAX_ERR,
            message : "SYNTAX_ERR: DOM Exception 12"
        };

    if (m.length != 17) // m[0] is the whole string, the rest is the actual
        // result
        throw {
            code : DOMException.SYNTAX_ERR,
            message : "Illegal number of elements: " + (m.length - 1)
                    + "expected: 16"
        };

    this._data = new Float32Array(m.slice(1));
    if (this._callback)
        this._callback(this);
};

/**
 * Multiply returns a new construct which is the result of this matrix
 * multiplied by the argument which can be any of: XML3DMatrix, XML3DVec3,
 * XML3DRotation. This matrix is not modified.
 * @param {XML3DMatrix} secondMatrix Matrix to multiply with
 * @return {XML3DMatrix} New matrix with the result
 */
p.multiply = function(secondMatrix) {
    var result = new XML3DMatrix();
    XML3D.math.mat4.multiply(result._data, this._data, secondMatrix._data);
    return result;
};

/**
 * Inverse returns a new matrix which is the inverse of this matrix. This
 * matrix is not modified.
 * @return {XML3DMatrix} Inverted matrix
 * @throws DOMException when the matrix cannot be inverted.
 */
p.inverse = function() {
    var result = new XML3DMatrix();
    result._data = XML3D.math.mat4.invert(result._data, this._data);
    if (result._data == null || isNaN(result._data[0]))
        throw new Error("Trying to invert matrix that is not invertable.");
    return result;
};

/**
 * This method returns a new matrix which is this matrix multiplied by each
 * of 3 rotations about the major axes. If the y and z components are
 * undefined, the x value is used to rotate the object about the z axis.
 * Rotation values are in RADIANS. This matrix is not modified.
 *
 * @returns {XML3DMatrix} new rotated matrix
 */
p.rotate = function(rotX, rotY, rotZ) {
    var r = new XML3DMatrix();
    if(rotY === undefined && rotZ === undefined) {
        XML3D.math.mat4.rotateZ(r._data, this._data, rotX);
        return r;
    }
    XML3D.math.mat4.rotateZ(r._data, this._data, rotZ);
    XML3D.math.mat4.rotateY(r._data, r._data, rotY);
    XML3D.math.mat4.rotateX(r._data, r._data, rotX);
    return r;
};

/**
 * RotateAxisAngle returns a new matrix which is this matrix multiplied by a
 * rotation matrix with the given XML3DRotation. This matrix is not
 * modified.
 *
 * @param {number} x x-component of the rotation axis
 * @param {number} y y-component of the rotation axis
 * @param {number} z z-component of the rotation axis
 * @param {number} angle angle in radians
 * @returns {XML3DMatrix} The result of the rotation in a new matrix
 */
p.rotateAxisAngle = function(x, y, z, angle) {
    var result = new XML3DMatrix();
    XML3D.math.mat4.rotate(result._data, this._data, angle, [ x, y, z ]);
    return result;
};

/**
 * Scale returns a new matrix which is this matrix multiplied by a scale
 * matrix containing the passed values. If the z component is undefined a 1
 * is used in its place. If the y component is undefined the x component
 * value is used in its place. This matrix is not modified.
 *
 * @param {number} scaleX scale factor in x direction
 * @param {number=} scaleY scale factor in y direction. Optional. If
 *            undefined the scaleX value is used in its place
 * @param {number=} scaleZ scale factor in z direction. Optional. If
 *            undefined 1 is used.
 * @returns {XML3DMatrix} The result of the rotation in a new matrix
 */
p.scale = function(scaleX, scaleY, scaleZ) {
    var result = new XML3DMatrix();
    if (!scaleZ)
        scaleZ = 1;
    if (!scaleY)
        scaleY = scaleX;
    XML3D.math.mat4.scale(result._data, this._data, [ scaleX, scaleY, scaleZ ]);
    return result;
};

/**
 * Translate returns a new matrix which is this matrix multiplied by a
 * translation matrix containing the passed values. This matrix is not
 * modified.
 * @param {number} x Translation in x direction
 * @param {number} y Translation in y direction
 * @param {number} z Translation in z direction
 * @returns {XML3DMatrix} The (new) resulting matrix
  */
p.translate = function(x, y, z) {
    var result = new XML3DMatrix();
    XML3D.math.mat4.translate(result._data, this._data, [x, y, z]);
    return result;
};

module.exports = XML3DMatrix;


},{}],124:[function(require,module,exports){

/** returns an XML3DRay that has an origin and a direction.
*
* If the arguments are not given, the ray's origin is (0,0,0) and
* points down the negative z-axis.
*
*  @param {XML3DVec3=} origin (optional) the origin of the ray
*  @param {XML3DVec3=} direction (optional) the direction of the ray
*  @param {function(XML3DRay=)=} cb Called if value has changed.
*/
var XML3DRay = function(origin, direction, cb) {
    var that = this;

    var vec_cb = function() {
        if (that._callback)
            that._callback(that);
    };

    /** @private */
    this._origin = new window.XML3DVec3(0, 0, 0, vec_cb);
    this._direction = new window.XML3DVec3(0, 0, -1, vec_cb);

    if (origin && origin.origin) {
        this.set(origin, direction);
    } else {
        if (origin) {
            this._origin.set(origin);
        }
        if (direction) {
            this._direction.set(direction);
        }
    }
    /** @private * */
    this._callback = typeof cb == 'function' ? cb : 0;

};
var p = XML3DRay.prototype;

/** @type {XML3DVec3} */
Object.defineProperty(p, "origin", {
    /** @this {XML3DRay} * */
    get : function() { return this._origin; },
    set : function() { throw Error("Can't set axis. XML3DRay::origin is readonly."); },
    configurable : false,
    enumerable : false
});

/** @type {XML3DVec3} */
Object.defineProperty(p, "direction", {
    /** @this {XML3DRay} * */
    get : function() { return this._direction; },
    set : function() { throw Error("Can't set axis. XML3DRay::_direction is readonly."); },
    configurable : false,
    enumerable : false
});

/**
 * The set method copies the values from other.
 * @param {XML3DRay} other The other ray
 */
p.set = function(other) {
    this._origin.set(other.origin);
    this._direction.set(other.direction);
    if (this._callback)
        this._callback(this);
};

/**
 * String representation of the XML3DRay.
 * @override
 * @return {string} Human-readable representation of this XML3DRay.
 */
p.toString = function() {
    return "[object XML3DRay]";
};

module.exports = XML3DRay;

},{}],125:[function(require,module,exports){

function orthogonal(v) {
    if ((Math.abs(v._data[1]) >= 0.9*Math.abs(v._data[0])) && (Math.abs(v._data[2]) >= 0.9*Math.abs(v._data[0])))
        return new window.XML3DVec3(0.0, -v._data[2], v._data[1]);
      else
        if ((Math.abs(v._data[0]) >= 0.9*Math.abs(v._data[1])) && (Math.abs(v._data[2]) >= 0.9*Math.abs(v._data[1])))
          return new window.XML3DVec3(-v._data[2], 0.0, v._data[0]);
        else
          return new window.XML3DVec3(-v._data[1], v._data[0], 0.0);
}

/**
 * Creates an instance of XML3DRotation. XML3DRotation represents a
 * three-dimensional vector as a 3-tuple floating point values.
 * @constructor
 * @this {XML3DRotation}
 * @param {XML3DVec3=} axis
 * @param {number=} angle
 * @param {function(XML3DVec3=)=} cb Called, if value has changed.
 *                                   Has this as first parameter.
 */
var XML3DRotation = function(axis, angle, cb) {
    var that = this;
    this._data = new Float32Array(4);

    var vec_cb = function() {
        that._updateQuaternion();
        if (that._callback)
            that._callback(that);
    };

    /** @private */
    this._axis = new window.XML3DVec3(0, 0, 1, vec_cb);
    /** @private */
    this._angle = 0;

    this._updateQuaternion();

    if(axis !== undefined && axis !== null) {
        this.set(axis, angle);
    }

    /** @private */
    this._callback = typeof cb == 'function' ? cb : 0;
};

var p = XML3DRotation.prototype;

/**
 * The set method copies the values from other.
 * @param {Object} other another XML3DRotation, Float32Array or XML3DVec3. In the last case the 2nd argument is considered.
 * @param {number=} angle
 */
p.set = function(other, angle) {
    if(other.axis && other.angle !== undefined) {
        this.setAxisAngle(other.axis, other.angle);
    } else if(other.length && other.length >= 4) {
        this._setQuaternion(other);
    } else if(other._data && other._data.length && other._data.length === 3) {
        this.setAxisAngle(other, angle);
    } else {
        XML3D.debug.logError("XML3DRotation.set(): invalid argument given. Expect XML3DRotation or Float32Array.");
    }
};

/** @type {number} */
Object.defineProperty(p, "axis", {
    /** @this {XML3DRotation} * */
    get : function() {
        return this._axis;
    },
    set : function() {
        throw Error("Can't set axis. XML3DRotation::axis is readonly.");
    },
    configurable : false,
    enumerable : false
});

/** @type {number} */
Object.defineProperty(p, "angle", {
    /** @this {XML3DRotation} * */
    get : function() {
        return this._angle;
    },
    set : function(angle) {
        this._angle = angle;
        this._updateQuaternion();
        if (this._callback)
            this._callback(this);
},
configurable : false,
enumerable : false
});

/**
 * String representation of the XML3DRotation.
 * @override
 * @this {XML3DRotation}
 * @return {string} Human-readable representation of this XML3DRotation.
 */
p.toString = function() {
    return "[object XML3DRotation]";
};

/**
 * Replaces the existing rotation with the axis-angle representation passed
 * as argument
 */
p.setAxisAngle = function(axis, angle) {
    if (typeof axis != 'object' || isNaN(angle)) {
        throw new Error("Illegal axis and/or angle values: " + "( axis="
                + axis + " angle=" + angle + " )");
    }

    // TODO: slice?
    this._axis._data[0] = axis._data[0];
    this._axis._data[1] = axis._data[1];
    this._axis._data[2] = axis._data[2];
    this._angle = angle;
    this._updateQuaternion();
    if (this._callback)
        this._callback(this);
};

/**
 * Replaces the existing rotation with one computed from the two vectors
 * passed as arguments. {XML3DVec} from First vector {XML3DVec} from Second
 * vector
 */
p.setRotation = function(from, to) {
    var a = from.normalize();
    var b = to.normalize();

    var axis = a.cross(b);
    if (!axis.length()) {
        // from and to are parallel
        axis = orthogonal(a);
    }
    // This function will also callback
    this.setAxisAngle(axis, Math.acos(a.dot(b)));
};

p._updateQuaternion = function() {
    var l = this._axis.length();
    if (l > 0.00001) {
        var s = Math.sin(this._angle / 2) / l;
        this._data[0] = this._axis.x * s;
        this._data[1] = this._axis.y * s;
        this._data[2] = this._axis.z * s;
        this._data[3] = Math.cos(this._angle / 2);
    } else {
        XML3D.math.quat.set(this._data, 0, 0, 0, 1);
    }
};

/**
 * Replaces the existing matrix with one computed from parsing the passed
 * string.
 * @param str String to parse
 */
p.setAxisAngleValue = function(str) {
    var m = /^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s*$/.exec(str);
    if (!m)
        throw new Error("Could not parse AxisAngle string: " + str);

    // This function will also callback
    this.setAxisAngle(new window.XML3DVec3(+m[1], +m[2], +m[3]), +m[4]);
};

/**
 * Linear interpolation of this rotation rot0 with the passed rotation rot1
 * with factor t. The result is (1-t)rot0 + t rot1. Typically realized with
 * a spherical linear interpolation based on quaternions.
 * @param {XML3DRotation} rot1 the passed rotation
 * @param {number} t the factor
 */
p.interpolate = function(rot1, t) {
    var dest = XML3D.math.quat.create(), result = new XML3DRotation();
    XML3D.math.quat.slerp(dest, this._data, rot1._data, t);
    result._setQuaternion(dest);
    return result;
};

/**
 * Replaces the existing rotation with the quaternion representation passed
 * as argument
 * @param {XML3DVec3} vector
 * @param {number} scalar
 */
p.setQuaternion = function(vector, scalar) {
    this._setQuaternion( [ vector.x, vector.y, vector.z, scalar ]);
};

/**
 * Returns a XML3DMatrix that describes this 3D rotation in a
 * 4x4 matrix representation.
 * @return {XML3DMatrix} Rotation matrix
 */
p.toMatrix = function() {
    var q = XML3D.math.quat.copy(XML3D.math.quat.create(), this._data);
    var m = new XML3DMatrix();
    XML3D.math.mat4.fromRotationTranslation(m._data, q, [0, 0, 0]);
    return m;
};

/**
 * Rotates the vector passed as parameter with this rotation
 * representation. The result is returned as new vector instance.
 * Neither this nor the inputVector are changed.
 * 4x4 matrix representation.
 * @param {XML3DVec3} inputVector
 * @return {XML3DVec3} The rotated vector
 */
p.rotateVec3 = function(inputVector) {
    var result = new XML3DVec3();
    XML3D.math.vec3.transformQuat(result._data, inputVector._data, this._data);
    return result;
};

/**
 * Replaces the existing rotation with the quaternion representation passed
 * as argument
 * @private
 * @param {Array} q
 */
p._setQuaternion = function(q) {
    var s = Math.sqrt(1 - q[3] * q[3]);
    if (s < 0.001 || isNaN(s)) {
        this._axis._data[0] = 0;
        this._axis._data[1] = 0;
        this._axis._data[2] = 1;
        this._angle = 0;
    } else {
        s = 1 / s;
        this._axis._data[0] = q[0] * s;
        this._axis._data[1] = q[1] * s;
        this._axis._data[2] = q[2] * s;
        this._angle = 2 * Math.acos(q[3]);
    }
    this._data = XML3D.math.quat.copy(XML3D.math.quat.create(), q);
    if (this._callback)
        this._callback(this);
};

/**
 * Multiplies this rotation with the passed rotation. This rotation is not
 * changed.
 *
 * @param {XML3DRotation} rot1
 * @return {XML3DRotation} The result
 */
p.multiply = function(rot1) {
    var result = new XML3DRotation(), q = XML3D.math.quat.create();
    XML3D.math.quat.multiply(q, this._data, rot1._data);
    result._setQuaternion(q);
    return result;
};

/**
 * Returns the normalized version of this rotation. Result is a newly
 * created vector. This is not modified.
 */
p.normalize = function(that) {
    var na = this._axis.normalize();
    return new XML3DRotation(na, this._angle);
};

/**
 * Returns the quaternion, that underlies this rotation.
 *
 * @return {Float32Array}
 */
p.getQuaternion = function() {
    return XML3D.math.quat.copy(XML3D.math.quat.create(), this._data);
};

/**
 * Set this rotation based on the given base vectors.
 *
 * @param {XML3DVec3} xAxis
 * @param {XML3DVec3} yAxis
 * @param {XML3DVec3} zAxis
 */
p.setFromBasis = function(xAxis, yAxis, zAxis) {
    var q = XML3D.math.quat.create();
    XML3D.math.quat.setFromBasis(xAxis._data, yAxis._data, zAxis._data, q);
    this._setQuaternion(q);
};

module.exports = XML3DRotation;
},{}],126:[function(require,module,exports){

/**
 * Configure array properties
 *  @private
 *  @this {XML3DVec3}
 *  @param {number} index Array index
 */
function prop(index) {
    return {
        get : function() {
            return this._data[index];
        },
        set : function(val) {
            this._data[index] = val;
            // Value changed
            if (this._callback)
                this._callback(this);
    },
    configurable : false,
    enumerable : false
    };
}

/**
 * Creates an instance of XML3DVec3. XML3DVec3 represents a
 * three-dimensional vector as a 3-tuple floating point values.
 * @constructor
 * @this {XML3DVec3}
 * @param {number=} x The x value (optional). Default: 0.
 * @param {number=} y The y value (optional). Default: 0.
 * @param {number=} z The z value (optional). Default: 0.
 * @param {function(XML3DVec3=)=} cb Called, if value has changed.
 *                                Has this as first parameter.
 */
var XML3DVec3 = function(x, y, z, cb) {
    /** @private */
    this._data = new Float32Array(3);

    if(x !== undefined && x !== null) {
        this.set(x,y,z);
    }

    this._callback = typeof cb == 'function' ? cb : 0;

}, p = XML3DVec3.prototype;

/**
 * The set method copies the values from other.
 * @param {Object|number} other another XML3DVec3, Float32Array or a number. In the last case the other args are considered, too.
 * @param {number=} y
 * @param {number=} z
 */
p.set = function(other,y,z) {
    if(other.length && other.length >= 3) {
        this._data[0] = other[0];
        this._data[1] = other[1];
        this._data[2] = other[2];
    }
    else if(other._data && other._data.length && other._data.length === 3) {
        this._data[0] = other._data[0];
        this._data[1] = other._data[1];
        this._data[2] = other._data[2];
    } else if(arguments.length == 3) {
        this._data[0] = other;
        this._data[1] = y;
        this._data[2] = z;
    }
    if (this._callback)
        this._callback(this);
};

/** @type {number} */
Object.defineProperty(p, "x", prop(0));
/** @type {number} */
Object.defineProperty(p, "y", prop(1));
/** @type {number} */
Object.defineProperty(p, "z", prop(2));

/**
 * String representation of the XML3DVec3.
 * @override
 * @this {XML3DVec3}
 * @return {string} Human-readable representation of this XML3DVec3.
 */
p.toString = function() {
    return "[object XML3DVec3]";
};

/**
 * Returns the component-wise addition of this vector with a second vector
 * passed as parameter. Result is a newly created vector. This is not
 * modified.
 * @param {XML3DVec3} that The vector to add
 * @return {XML3DVec3} The new vector with the result of the addition
 */
p.add = function(that) {
    if (that._data)
        return new XML3DVec3(this._data[0] + that._data[0], this._data[1]
                + that._data[1], this._data[2] + that._data[2]);
    return new XML3DVec3(this._data[0] + that.x, this._data[1] + that.y,
            this._data[2] + that.z);
};

/**
 * Returns the component-wise subtraction of this vector with a second
 * vector passed as parameter. Result is a newly created vector. This is not
 * modified.
 * @param {XML3DVec3} that The vector to subtract
 * @return {XML3DVec3} The new vector with the result of the subtraction
 */
p.subtract = function(that) {
    if (that._data)
        return new XML3DVec3(this._data[0] - that._data[0], this._data[1]
                - that._data[1], this._data[2] - that._data[2]);
    return new XML3DVec3(this._data[0] - that.x, this._data[1] - that.y,
            this._data[2] - that.z);
};

/**
 * Returns the length of this vector.
 * @return {number} The length of this vector
 */
p.length = function() {
    return Math.sqrt((this._data[0] * this._data[0])
            + (this._data[1] * this._data[1])
            + (this._data[2] * this._data[2]));
};

/**
 * The setVec3Value method replaces the existing vector with one computed
 * from parsing the passed string.
 * @param {string} str The string to parse
 * @throws {Error} If passed string can not be parsed
 */
p.setVec3Value = function(str) {
    var m = /^\s*(\S+)\s+(\S+)\s+(\S+)\s*$/.exec(str);
    if (!m) // TODO Throw DOMException
        throw Error("Wrong format for XML3DVec3::setVec3Value");
    this._data[0] = +m[1];
    this._data[1] = +m[2];
    this._data[2] = +m[3];
    if (this._callback)
        this._callback(this);
};

/**
 * Returns the component-wise multiplication of this vector with a second
 * vector passed as parameter. Result is a newly created vector. This is not
 * modified.
 * @param {XML3DVec3} that The vector to multiply
 * @return {XML3DVec3} The new vector with the result of the multiplication
 */
p.multiply = function(that) {
    if (that._data)
        return new XML3DVec3(this._data[0] * that._data[0], this._data[1]
                * that._data[1], this._data[2] * that._data[2]);
    return new XML3DVec3(this._data[0] * that.x, this._data[1] * that.y,
            this._data[2] * that.z);
};

/**
 * Returns the component-wise multiplication of this vector with a factor
 * passed as parameter. Result is a newly created vector. This is not
 * modified.
 * @param {number} fac The factor for the multiplication
 * @return {XML3DVec3} The new and scaled vector
 */
p.scale = function(fac) {
    return new XML3DVec3(this._data[0] * fac, this._data[1] * fac,
            this._data[2] * fac);
};

/**
 * Returns the cross product of this vector with a second vector passed as
 * parameter. Result is a newly created vector. This is not modified.
 * @param {XML3DVec3} that The second vector
 * @return {XML3DVec3} The new vector with the result of the cross product
 */
p.cross = function(that) {
    if (that._data)
        return new XML3DVec3(this._data[1] * that._data[2] - this._data[2]
                * that._data[1], this._data[2] * that._data[0]
                - this._data[0] * that._data[2], this._data[0]
                * that._data[1] - this._data[1] * that._data[0]);

    return new XML3DVec3(this._data[1] * that.z - this._data[2] * that.y,
            this._data[2] * that.x - this._data[0] * that.z, this._data[0]
                    * that.y - this._data[1] * that.x);
};

/**
 * Returns the component wise multiplication by -1 of this vector. Result is
 * a newly created vector. This is not modified.
 * @return {XML3DVec3} The new and negated vector
 */
p.negate = function() {
    return new XML3DVec3(-this._data[0], -this._data[1], -this._data[2]);
};

/**
 * Returns the dot product of this vector with a second vector passed as
 * parameter. This is not modified.
 * @param {XML3DVec3} that The second vector
 * @return {number} The result of the dot product
 */
p.dot = function(that) {
    return (this._data[0] * that.x + this._data[1] * that.y + this._data[2]
            * that.z);
};

/**
 * Returns the normalized version of this vector. Result is a newly created
 * vector. This is not modified.
 * @return {XML3DVec3} The new and normalized vector
 * @throws {Error} If length of this vector is zero
 */
p.normalize = function() {
    var n = this.length();
    if (n)
        n = 1.0 / n;
    else
        throw new Error();

    return new XML3DVec3(this._data[0] * n, this._data[1] * n,
            this._data[2] * n);
};

module.exports = XML3DVec3;
},{}],127:[function(require,module,exports){
// Add convienent array methods if non-existant
if (!Array.forEach) {
    Array.forEach = function(array, fun, thisp) {
        var len = array.length;
        for ( var i = 0; i < len; i++) {
            if (i in array) {
                fun.call(thisp, array[i], i, array);
            }
        }
    };
}
if (!Array.map) {
    Array.map = function(array, fun, thisp) {
        var len = array.length;
        var res = [];
        for ( var i = 0; i < len; i++) {
            if (i in array) {
                res[i] = fun.call(thisp, array[i], i, array);
            }
        }
        return res;
    };
}
if (!Array.filter) {
    Array.filter = function(array, fun, thisp) {
        var len = array.length;
        var res = [];
        for ( var i = 0; i < len; i++) {
            if (i in array) {
                var val = array[i];
                if (fun.call(thisp, val, i, array)) {
                    res.push(val);
                }
            }
        }
        return res;
    };
}

if (!Array.erase) {
    Array.erase = function(array, object) {
        var erased = false;
        var idx = -1;
        while( (idx = array.indexOf(object) ) != -1){
            array.splice(idx, 1);
            erased = true;
        }
        return erased;
    };
}

if (!Array.set) {
    Array.set = function(array, offset, value) {
        for (var i=0; i < value.length; i++)
            array[offset+i] = value[i];
    };
}

if (!Array.isArray) {
    Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) == '[object Array]';
    };
}

},{}],128:[function(require,module,exports){
var CSSMatrix = require("./cssMatrix.js");

var css = {};

css.TRANSFORM_PROPERTY = null;

css.init = function () {
    if ('transform' in document.body.style) {
        css.TRANSFORM_PROPERTY = 'transform'
    } else if ('WebkitTransform' in document.body.style) {
        css.TRANSFORM_PROPERTY = '-webkit-transform'
    } else if ('MozTransform' in document.body.style) {
        css.TRANSFORM_PROPERTY = '-moz-transform'
    } else {
        XML3D.debug.logWarning("No supported transform css property found");
    }

};

css.getInlinePropertyValue = function (node, property) {
    var styleValue = node.getAttribute('style');
    if (styleValue) {
        var pattern = new RegExp(property + "\s*:([^;]+)", "i");
        var result = pattern.exec(styleValue);
        if (result)
            return result[1].trim();
    }
    return null;
};

css.getPropertyValue = function (node, property) {
    var value = this.getInlinePropertyValue(node, property);
    if (value)
        return value;

    var style = window.getComputedStyle(node);
    return style.getPropertyValue(property);
};

css.getCSSMatrix = function (node) {
    if (!css.TRANSFORM_PROPERTY || !CSSMatrix)
        return null;

    var style = null;

    if (css.TRANSFORM_PROPERTY != "transform")
        style = css.getInlinePropertyValue(node, "transform");

    if (!style)
        style = css.getPropertyValue(node, css.TRANSFORM_PROPERTY);

    if (!style || style == "none")
        return null;

    var result = null;
    try {
        result = new CSSMatrix(style);
    } catch (e) {
        XML3D.debug.logError("Error parsing transform property: " + style);
    }
    return result;

};


css.convertCssToMat4 = function (cssMatrix, m) {
    var matrix = m || XML3D.math.mat4.create();
    matrix[0] = cssMatrix.m11;
    matrix[1] = cssMatrix.m12;
    matrix[2] = cssMatrix.m13;
    matrix[3] = cssMatrix.m14;
    matrix[4] = cssMatrix.m21;
    matrix[5] = cssMatrix.m22;
    matrix[6] = cssMatrix.m23;
    matrix[7] = cssMatrix.m24;
    matrix[8] = cssMatrix.m31;
    matrix[9] = cssMatrix.m32;
    matrix[10] = cssMatrix.m33;
    matrix[11] = cssMatrix.m34;
    matrix[12] = cssMatrix.m41;
    matrix[13] = cssMatrix.m42;
    matrix[14] = cssMatrix.m43;
    matrix[15] = cssMatrix.m44;
    return matrix;
};

module.exports = css;


},{"./cssMatrix.js":129}],129:[function(require,module,exports){

/**
 *  class FirminCSSMatrix
 *
 *  The [[FirminCSSMatrix]] class is a concrete implementation of the
 *  `CSSMatrix` interface defined in the [CSS 2D Transforms][2d] and
 *  [CSS 3D Transforms][3d] Module specifications.
 *
 *  [2d]: http://www.w3.org/TR/css3-2d-transforms/
 *  [3d]: http://www.w3.org/TR/css3-3d-transforms/
 *
 *  The implementation was largely copied from the `WebKitCSSMatrix` class, and
 *  the supparting maths libraries in the [WebKit][webkit] project. This is one
 *  reason why much of the code looks more like C++ than JavaScript.
 *
 *  [webkit]: http://webkit.org/
 *
 *  Its API is a superset of that provided by `WebKitCSSMatrix`, largely
 *  because various pieces of supporting code have been added as instance
 *  methods rather than pollute the global namespace. Examples of these include
 *  [[FirminCSSMatrix#isAffine]], [[FirminCSSMatrix#isIdentityOrTranslation]]
 *  and [[FirminCSSMatrix#adjoint]].
 **/

/**
 *  new FirminCSSMatrix(domstr)
 *  - domstr (String): a string representation of a 2D or 3D transform matrix
 *    in the form given by the CSS transform property, i.e. just like the
 *    output from [[FirminCSSMatrix#toString]].
 *
 *  @constructor
 **/
var FirminCSSMatrix = function(domstr) {
    this.m11 = this.m22 = this.m33 = this.m44 = 1;

    this.m12 = this.m13 = this.m14 =
    this.m21 =            this.m23 = this.m24 =
    this.m31 = this.m32 =            this.m34 =
    this.m41 = this.m42 = this.m43            = 0;

    if (typeof domstr == "string") {
        this.setMatrixValue(domstr);
    }
};

/**
 *  FirminCSSMatrix.displayName = "FirminCSSMatrix"
 **/
FirminCSSMatrix.displayName = "FirminCSSMatrix";

/**
 *  FirminCSSMatrix.degreesToRadians(angle) -> Number
 *  - angle (Number): an angle in degrees.
 *
 *  Converts angles in degrees, which are used by the external API, to angles
 *  in radians used in internal calculations.
 **/
FirminCSSMatrix.degreesToRadians = function(angle) {
    return angle * Math.PI / 180;
};

/**
 *  FirminCSSMatrix.determinant2x2(a, b, c, d) -> Number
 *  - a (Number): top-left value of the matrix.
 *  - b (Number): top-right value of the matrix.
 *  - c (Number): bottom-left value of the matrix.
 *  - d (Number): bottom-right value of the matrix.
 *
 *  Calculates the determinant of a 2x2 matrix.
 **/
FirminCSSMatrix.determinant2x2 = function(a, b, c, d) {
    return a * d - b * c;
};

/**
 *  FirminCSSMatrix.determinant3x3(matrix) -> Number
 *  - a1 (Number): matrix value in position [1, 1].
 *  - a2 (Number): matrix value in position [1, 2].
 *  - a3 (Number): matrix value in position [1, 3].
 *  - b1 (Number): matrix value in position [2, 1].
 *  - b2 (Number): matrix value in position [2, 2].
 *  - b3 (Number): matrix value in position [2, 3].
 *  - c1 (Number): matrix value in position [3, 1].
 *  - c2 (Number): matrix value in position [3, 2].
 *  - c3 (Number): matrix value in position [3, 3].
 *
 *  Calculates the determinant of a 3x3 matrix.
 **/
FirminCSSMatrix.determinant3x3 = function(a1, a2, a3, b1, b2, b3, c1, c2, c3) {
    var determinant2x2 = FirminCSSMatrix.determinant2x2;
    return a1 * determinant2x2(b2, b3, c2, c3) -
    b1 * determinant2x2(a2, a3, c2, c3) +
    c1 * determinant2x2(a2, a3, b2, b3);
};

/**
 *  FirminCSSMatrix.determinant4x4(matrix) -> Number
 *  - matrix (FirminCSSMatrix): the matrix to calculate the determinant of.
 *
 *  Calculates the determinant of a 4x4 matrix.
 **/
FirminCSSMatrix.determinant4x4 = function(m) {
    var determinant3x3 = FirminCSSMatrix.determinant3x3,

        // Assign to individual variable names to aid selecting correct elements
    a1 = m.m11, b1 = m.m21, c1 = m.m31, d1 = m.m41,
    a2 = m.m12, b2 = m.m22, c2 = m.m32, d2 = m.m42,
    a3 = m.m13, b3 = m.m23, c3 = m.m33, d3 = m.m43,
    a4 = m.m14, b4 = m.m24, c4 = m.m34, d4 = m.m44;

    return a1 * determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) -
    b1 * determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) +
    c1 * determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) -
    d1 * determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
};

/**
 * FirminCSSMatrix.toMatrixString(transformValue) -> String
 * - transformValue (String): `el.style.WebkitTransform`-style string (like `rotate(18rad) translate3d(50px, 100px, 10px)`)
 *
 * Tranforms a `el.style.WebkitTransform`-style string
 * (like `rotate(18rad) translate3d(50px, 100px, 10px)`)
 * into a `getComputedStyle(el)`-style matrix string
 * (like `matrix3d(0.6603167082440828, -0.7509872467716737, 0, 0, 0.7509872467716737, 0.6603167082440828, 0, 0, 0, 0, 1, 0, 108.11456008937151, 28.482308485824596, 10, 1)`)
 **/
FirminCSSMatrix.toMatrixString = function (transformValue) {
    var rgx = {
        functionSignature: /(\w+)\([^\)]+\)/ig,
        nameAndArguments: /(\w+)\(([^\)]+)\)/i,
        units: /([-\+]?[0-9]+[\.0-9]*)(deg|rad|grad|px|%)*/
    };
    var transformStatements = transformValue.match(/(\w+)\([^\)]+\)/ig);
    var onlyMatrices = transformStatements && transformStatements.every(function (t) { return (/^matrix/).test(t) });
    if (!transformStatements || onlyMatrices) return transformValue;

    var values = function (o) { return o.value };
    var cssFunctionToJsFunction = {
        matrix: function (m, o) {
            var m2 = new FirminCSSMatrix(o.unparsed);

            return m.multiply(m2)
        },
        matrix3d: function (m, o) {
            var m2 = new FirminCSSMatrix(o.unparsed);

            return m.multiply(m2)
        },

        perspective: function (m, o) {
            var m2 = new FirminCSSMatrix();
            m2.m34 -= 1 / o.value[0].value;

            return m.multiply(m2);
        },

        rotate: function (m, o) {
            return m.rotate.apply(m, o.value.map(values))
        },
        rotate3d: function (m, o) {
            return m.rotateAxisAngle.apply(m, o.value.map(values))
        },
        rotateX: function (m, o) {
            return m.rotate.apply(m, [o.value[0].value, 0, 0]);
        },
        rotateY: function (m, o) {
            return m.rotate.apply(m, [0, o.value[0].value, 0]);
        },
        rotateZ: function (m, o) {
            return m.rotate.apply(m, [0, 0, o.value[0].value]);
        },

        scale: function (m, o) {
            return m.scale.apply(m, o.value.map(values));
        },
        scale3d: function (m, o) {
            return m.scale.apply(m, o.value.map(values));
        },
        scaleX: function (m, o) {
            return m.scale.apply(m, o.value.map(values));
        },
        scaleY: function (m, o) {
            return m.scale.apply(m, [0, o.value[0].value, 0]);
        },
        scaleZ: function (m, o) {
            return m.scale.apply(m, [0, 0, o.value[0].value]);
        },

        skew: function (m, o) {
            var mX = new FirminCSSMatrix('skewX(' + o.value[0].unparsed + ')');
            var mY = new FirminCSSMatrix('skewY(' + o.value[1].unparsed + ')');
            var sM = 'matrix(1.00000, '+ mY.b +', '+ mX.c +', 1.000000, 0.000000, 0.000000)';
            var m2 = new FirminCSSMatrix(sM);

            return m.multiply(m2);
        },
        skewX: function (m, o) {
            return m.skewX.apply(m, [o.value[0].value]);
        },
        skewY: function (m, o) {
            return m.skewY.apply(m, [o.value[0].value]);
        },

        translate: function (m, o) {
            return m.translate.apply(m, o.value.map(values));
        },
        translate3d: function (m, o) {
            return m.translate.apply(m, o.value.map(values));
        },
        translateX: function (m, o) {
            return m.translate.apply(m, [o.value[0].value, 0, 0]);
        },
        translateY: function (m, o) {
            return m.translate.apply(m, [0, o.value[0].value, 0]);
        },
        translateZ: function (m, o) {
            return m.translate.apply(m, [0, 0, o.value[0].value]);
        }
    };
    var parseTransformStatement = function (str) {
        var pair = str.match(rgx.nameAndArguments).slice(1);

        return {
            key: pair[0],
            value: pair[1].split(/, ?/).map(function (value) {
                var parts = value.match(/([-\+]?[0-9]+[\.0-9]*)(deg|rad|grad|px|%)*/) || [];

                return {
                    value: parseFloat(parts[1]),
                    units: parts[2],
                    unparsed: value
                };
            }),
            unparsed: str
        };
    };

    var transformOperations = transformStatements.map(parseTransformStatement);
    var startingMatrix = new FirminCSSMatrix();
    var transformedMatrix = transformOperations.reduce(function (matrix, operation) {
        // convert to degrees b/c all CSSMatrix methods expect degrees
        operation.value = operation.value.map(function (operation) {
            if (operation.units == 'rad') {
                operation.value = operation.value * (180 / Math.PI);
                operation.units = 'deg';
            }
            else if (operation.units == 'grad') {
                operation.value = operation.value / (400 / 360); // 400 gradians in 360 degrees
                operation.units = 'deg'
            }

            return operation;
        });

        var jsFunction = cssFunctionToJsFunction[operation.key];
        var result = jsFunction(matrix, operation);

        return result || matrix;
    }, startingMatrix);

    return transformedMatrix.toString();
};

/**
 *  FirminCSSMatrix#a -> Number
 *  The first 2D vector value.
 **/

/**
 *  FirminCSSMatrix#b -> Number
 *  The second 2D vector value.
 **/

/**
 *  FirminCSSMatrix#c -> Number
 *  The third 2D vector value.
 **/

/**
 *  FirminCSSMatrix#d -> Number
 *  The fourth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#e -> Number
 *  The fifth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#f -> Number
 *  The sixth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#m11 -> Number
 *  The 3D matrix value in the first row and first column.
 **/

/**
 *  FirminCSSMatrix#m12 -> Number
 *  The 3D matrix value in the first row and second column.
 **/

/**
 *  FirminCSSMatrix#m13 -> Number
 *  The 3D matrix value in the first row and third column.
 **/

/**
 *  FirminCSSMatrix#m14 -> Number
 *  The 3D matrix value in the first row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m21 -> Number
 *  The 3D matrix value in the second row and first column.
 **/

/**
 *  FirminCSSMatrix#m22 -> Number
 *  The 3D matrix value in the second row and second column.
 **/

/**
 *  FirminCSSMatrix#m23 -> Number
 *  The 3D matrix value in the second row and third column.
 **/

/**
 *  FirminCSSMatrix#m24 -> Number
 *  The 3D matrix value in the second row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m31 -> Number
 *  The 3D matrix value in the third row and first column.
 **/

/**
 *  FirminCSSMatrix#m32 -> Number
 *  The 3D matrix value in the third row and second column.
 **/

/**
 *  FirminCSSMatrix#m33 -> Number
 *  The 3D matrix value in the third row and third column.
 **/

/**
 *  FirminCSSMatrix#m34 -> Number
 *  The 3D matrix value in the third row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m41 -> Number
 *  The 3D matrix value in the fourth row and first column.
 **/

/**
 *  FirminCSSMatrix#m42 -> Number
 *  The 3D matrix value in the fourth row and second column.
 **/

/**
 *  FirminCSSMatrix#m43 -> Number
 *  The 3D matrix value in the fourth row and third column.
 **/

/**
 *  FirminCSSMatrix#m44 -> Number
 *  The 3D matrix value in the fourth row and fourth column.
 **/

[["m11", "a"],
    ["m12", "b"],
    ["m21", "c"],
    ["m22", "d"],
    ["m41", "e"],
    ["m42", "f"]].forEach(function(pair) {
    var key3d = pair[0], key2d = pair[1];

    Object.defineProperty(FirminCSSMatrix.prototype, key2d, {
        set: function(val) {
            this[key3d] = val;
        },

        get: function() {
            return this[key3d];
        },
        enumerable : true,
        configurable : true
    });
});

/**
 *  FirminCSSMatrix#isAffine() -> Boolean
 *
 *  Determines whether the matrix is affine.
 **/
FirminCSSMatrix.prototype.isAffine = function() {
    return this.m13 === 0 && this.m14 === 0 &&
    this.m23 === 0 && this.m24 === 0 &&
    this.m31 === 0 && this.m32 === 0 &&
    this.m33 === 1 && this.m34 === 0 &&
    this.m43 === 0 && this.m44 === 1;
};

/**
 *  FirminCSSMatrix#multiply(otherMatrix) -> FirminCSSMatrix
 *  - otherMatrix (FirminCSSMatrix): the matrix to multiply this one by.
 *
 *  Multiplies the matrix by a given matrix and returns the result.
 **/
FirminCSSMatrix.prototype.multiply = function(otherMatrix) {
    if (!otherMatrix) return null;

    var a = otherMatrix,
    b = this,
    c = new FirminCSSMatrix();

    c.m11 = a.m11 * b.m11 + a.m12 * b.m21 + a.m13 * b.m31 + a.m14 * b.m41;
    c.m12 = a.m11 * b.m12 + a.m12 * b.m22 + a.m13 * b.m32 + a.m14 * b.m42;
    c.m13 = a.m11 * b.m13 + a.m12 * b.m23 + a.m13 * b.m33 + a.m14 * b.m43;
    c.m14 = a.m11 * b.m14 + a.m12 * b.m24 + a.m13 * b.m34 + a.m14 * b.m44;

    c.m21 = a.m21 * b.m11 + a.m22 * b.m21 + a.m23 * b.m31 + a.m24 * b.m41;
    c.m22 = a.m21 * b.m12 + a.m22 * b.m22 + a.m23 * b.m32 + a.m24 * b.m42;
    c.m23 = a.m21 * b.m13 + a.m22 * b.m23 + a.m23 * b.m33 + a.m24 * b.m43;
    c.m24 = a.m21 * b.m14 + a.m22 * b.m24 + a.m23 * b.m34 + a.m24 * b.m44;

    c.m31 = a.m31 * b.m11 + a.m32 * b.m21 + a.m33 * b.m31 + a.m34 * b.m41;
    c.m32 = a.m31 * b.m12 + a.m32 * b.m22 + a.m33 * b.m32 + a.m34 * b.m42;
    c.m33 = a.m31 * b.m13 + a.m32 * b.m23 + a.m33 * b.m33 + a.m34 * b.m43;
    c.m34 = a.m31 * b.m14 + a.m32 * b.m24 + a.m33 * b.m34 + a.m34 * b.m44;

    c.m41 = a.m41 * b.m11 + a.m42 * b.m21 + a.m43 * b.m31 + a.m44 * b.m41;
    c.m42 = a.m41 * b.m12 + a.m42 * b.m22 + a.m43 * b.m32 + a.m44 * b.m42;
    c.m43 = a.m41 * b.m13 + a.m42 * b.m23 + a.m43 * b.m33 + a.m44 * b.m43;
    c.m44 = a.m41 * b.m14 + a.m42 * b.m24 + a.m43 * b.m34 + a.m44 * b.m44;

    return c;
};

/**
 *  FirminCSSMatrix#isIdentityOrTranslation() -> Boolean
 *
 *  Returns whether the matrix is the identity matrix or a translation matrix.
 **/
FirminCSSMatrix.prototype.isIdentityOrTranslation = function() {
    var t = this;
    return t.m11 === 1 && t.m12 === 0 && t.m13 === 0 && t.m14 === 0 &&
    t.m21 === 0 && t.m22 === 1 && t.m23 === 0 && t.m24 === 0 &&
    t.m31 === 0 && t.m31 === 0 && t.m33 === 1 && t.m34 === 0 &&
        /* m41, m42 and m43 are the translation points */   t.m44 === 1;
};

/**
 *  FirminCSSMatrix#adjoint() -> FirminCSSMatrix
 *
 *  Returns the adjoint matrix.
 **/
FirminCSSMatrix.prototype.adjoint = function() {
    var result = new FirminCSSMatrix(), t = this,
    determinant3x3 = FirminCSSMatrix.determinant3x3,

    a1 = t.m11, b1 = t.m12, c1 = t.m13, d1 = t.m14,
    a2 = t.m21, b2 = t.m22, c2 = t.m23, d2 = t.m24,
    a3 = t.m31, b3 = t.m32, c3 = t.m33, d3 = t.m34,
    a4 = t.m41, b4 = t.m42, c4 = t.m43, d4 = t.m44;

    // Row column labeling reversed since we transpose rows & columns
    result.m11 =  determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
    result.m21 = -determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
    result.m31 =  determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
    result.m41 = -determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);

    result.m12 = -determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
    result.m22 =  determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
    result.m32 = -determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
    result.m42 =  determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);

    result.m13 =  determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
    result.m23 = -determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
    result.m33 =  determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
    result.m43 = -determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);

    result.m14 = -determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
    result.m24 =  determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
    result.m34 = -determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
    result.m44 =  determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);

    return result;
};

/**
 *  FirminCSSMatrix#inverse() -> FirminCSSMatrix | null
 *
 *  If the matrix is invertible, returns its inverse, otherwise returns null.
 **/
FirminCSSMatrix.prototype.inverse = function() {
    var inv, det, result, i, j;

    if (this.isIdentityOrTranslation()) {
        inv = new FirminCSSMatrix();

        if (!(this.m41 === 0 && this.m42 === 0 && this.m43 === 0)) {
            inv.m41 = -this.m41;
            inv.m42 = -this.m42;
            inv.m43 = -this.m43;
        }

        return inv;
    }

    // Calculate the adjoint matrix
    result = this.adjoint();

    // Calculate the 4x4 determinant
    det = FirminCSSMatrix.determinant4x4(this);

    // If the determinant is zero, then the inverse matrix is not unique
    if (Math.abs(det) < 1e-8) return null;

    // Scale the adjoint matrix to get the inverse
    for (i = 1; i < 5; i++) {
        for (j = 1; j < 5; j++) {
            result[("m" + i) + j] /= det;
        }
    }

    return result;
};

/**
 *  FirminCSSMatrix#rotate(rotX, rotY, rotZ) -> FirminCSSMatrix
 *  - rotX (Number): the rotation around the x axis.
 *  - rotY (Number): the rotation around the y axis. If undefined, the x
 *    component is used.
 *  - rotZ (Number): the rotation around the z axis. If undefined, the x
 *    component is used.
 *
 *  Returns the result of rotating the matrix by a given vector.
 *
 *  If only the first argument is provided, the matrix is only rotated about
 *  the z axis.
 **/
FirminCSSMatrix.prototype.rotate = function(rx, ry, rz) {
    var degreesToRadians = FirminCSSMatrix.degreesToRadians;

    if (typeof rx != "number" || isNaN(rx)) rx = 0;

    if ((typeof ry != "number" || isNaN(ry)) &&
    (typeof rz != "number" || isNaN(rz))) {
        rz = rx;
        rx = 0;
        ry = 0;
    }

    if (typeof ry != "number" || isNaN(ry)) ry = 0;
    if (typeof rz != "number" || isNaN(rz)) rz = 0;

    rx = degreesToRadians(rx);
    ry = degreesToRadians(ry);
    rz = degreesToRadians(rz);

    var tx = new FirminCSSMatrix(),
    ty = new FirminCSSMatrix(),
    tz = new FirminCSSMatrix(),
    sinA, cosA, sinA2;

    rz /= 2;
    sinA = Math.sin(rz);
    cosA = Math.cos(rz);
    sinA2 = sinA * sinA;

    // Matrices are identity outside the assigned values
    tz.m11 = tz.m22 = 1 - 2 * sinA2;
    tz.m12 = tz.m21 = 2 * sinA * cosA;
    tz.m21 *= -1;

    ry /= 2;
    sinA  = Math.sin(ry);
    cosA  = Math.cos(ry);
    sinA2 = sinA * sinA;

    ty.m11 = ty.m33 = 1 - 2 * sinA2;
    ty.m13 = ty.m31 = 2 * sinA * cosA;
    ty.m13 *= -1;

    rx /= 2;
    sinA = Math.sin(rx);
    cosA = Math.cos(rx);
    sinA2 = sinA * sinA;

    tx.m22 = tx.m33 = 1 - 2 * sinA2;
    tx.m23 = tx.m32 = 2 * sinA * cosA;
    tx.m32 *= -1;

    var isIdentity = (this.toString() === (new FirminCSSMatrix).toString());

    return (isIdentity)
    ? tz.multiply(ty).multiply(tx)
    : this.multiply(tx).multiply(ty).multiply(tz);
};

/**
 *  FirminCSSMatrix#rotateAxisAngle(rotX, rotY, rotZ, angle) -> FirminCSSMatrix
 *  - rotX (Number): the rotation around the x axis.
 *  - rotY (Number): the rotation around the y axis. If undefined, the x
 *    component is used.
 *  - rotZ (Number): the rotation around the z axis. If undefined, the x
 *    component is used.
 *  - angle (Number): the angle of rotation about the axis vector, in degrees.
 *
 *  Returns the result of rotating the matrix around a given vector by a given
 *  angle.
 *
 *  If the given vector is the origin vector then the matrix is rotated by the
 *  given angle around the z axis.
 **/
FirminCSSMatrix.prototype.rotateAxisAngle = function(x, y, z, a) {
    if (typeof x != "number" || isNaN(x)) x = 0;
    if (typeof y != "number" || isNaN(y)) y = 0;
    if (typeof z != "number" || isNaN(z)) z = 0;
    if (typeof a != "number" || isNaN(a)) a = 0;
    if (x === 0 && y === 0 && z === 0) z = 1;

    var t   = new FirminCSSMatrix(),
    len = Math.sqrt(x * x + y * y + z * z),
    cosA, sinA, sinA2, csA, x2, y2, z2;

    a     = (FirminCSSMatrix.degreesToRadians(a) || 0) / 2;
    cosA  = Math.cos(a);
    sinA  = Math.sin(a);
    sinA2 = sinA * sinA;

    // Bad vector, use something sensible
    if (len === 0) {
        x = 0;
        y = 0;
        z = 1;
    } else if (len !== 1) {
        x /= len;
        y /= len;
        z /= len;
    }

    // Optimise cases where axis is along major axis
    if (x === 1 && y === 0 && z === 0) {
        t.m22 = t.m33 = 1 - 2 * sinA2;
        t.m23 = t.m32 = 2 * cosA * sinA;
        t.m32 *= -1;
    } else if (x === 0 && y === 1 && z === 0) {
        t.m11 = t.m33 = 1 - 2 * sinA2;
        t.m13 = t.m31 = 2 * cosA * sinA;
        t.m13 *= -1;
    } else if (x === 0 && y === 0 && z === 1) {
        t.m11 = t.m22 = 1 - 2 * sinA2;
        t.m12 = t.m21 = 2 * cosA * sinA;
        t.m21 *= -1;
    } else {
        csA = sinA * cosA;
        x2  = x * x;
        y2  = y * y;
        z2  = z * z;

        t.m11 = 1 - 2 * (y2 + z2) * sinA2;
        t.m12 = 2 * (x * y * sinA2 + z * csA);
        t.m13 = 2 * (x * z * sinA2 - y * csA);
        t.m21 = 2 * (y * x * sinA2 - z * csA);
        t.m22 = 1 - 2 * (z2 + x2) * sinA2;
        t.m23 = 2 * (y * z * sinA2 + x * csA);
        t.m31 = 2 * (z * x * sinA2 + y * csA);
        t.m32 = 2 * (z * y * sinA2 - x * csA);
        t.m33 = 1 - 2 * (x2 + y2) * sinA2;
    }

    return this.multiply(t);
};

/**
 *  FirminCSSMatrix#scale(scaleX, scaleY, scaleZ) -> FirminCSSMatrix
 *  - scaleX (Number): the scaling factor in the x axis.
 *  - scaleY (Number): the scaling factor in the y axis. If undefined, the x
 *    component is used.
 *  - scaleZ (Number): the scaling factor in the z axis. If undefined, 1 is
 *    used.
 *
 *  Returns the result of scaling the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.scale = function(scaleX, scaleY, scaleZ) {
    var transform = new FirminCSSMatrix();

    if (typeof scaleX != "number" || isNaN(scaleX)) scaleX = 1;
    if (typeof scaleY != "number" || isNaN(scaleY)) scaleY = scaleX;
    if (typeof scaleZ != "number" || isNaN(scaleZ)) scaleZ = 1;

    transform.m11 = scaleX;
    transform.m22 = scaleY;
    transform.m33 = scaleZ;

    return this.multiply(transform);
};

/**
 *  FirminCSSMatrix#skewX(skewX) -> FirminCSSMatrix
 *  - skewX (Number): the scaling factor in the x axis.
 *
 *  Returns the result of skewing the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.skewX = function(degrees) {
    var radians = FirminCSSMatrix.degreesToRadians(degrees);
    var transform = new FirminCSSMatrix();

    transform.c = Math.tan(radians);

    return this.multiply(transform);
};

/**
 *  FirminCSSMatrix#skewY(skewY) -> FirminCSSMatrix
 *  - skewY (Number): the scaling factor in the x axis.
 *
 *  Returns the result of skewing the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.skewY = function(degrees) {
    var radians = FirminCSSMatrix.degreesToRadians(degrees);
    var transform = new FirminCSSMatrix();

    transform.b = Math.tan(radians);

    return this.multiply(transform);
};

/**
 *  FirminCSSMatrix#translate(x, y, z) -> FirminCSSMatrix
 *  - x (Number): the x component of the vector.
 *  - y (Number): the y component of the vector.
 *  - z (Number): the z component of the vector. If undefined, 0 is used.
 *
 *  Returns the result of translating the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.translate = function(x, y, z) {
    var t = new FirminCSSMatrix();

    if (typeof x != "number" || isNaN(x)) x = 0;
    if (typeof y != "number" || isNaN(y)) y = 0;
    if (typeof z != "number" || isNaN(z)) z = 0;

    t.m41 = x;
    t.m42 = y;
    t.m43 = z;

    return this.multiply(t);
};

/**
 *  FirminCSSMatrix#setMatrixValue(domstr) -> undefined
 *  - domstr (String): a string representation of a 2D or 3D transform matrix
 *    in the form given by the CSS transform property, i.e. just like the
 *    output from [[FirminCSSMatrix#toString]].
 *
 *  Sets the matrix values using a string representation, such as that produced
 *  by the [[FirminCSSMatrix#toString]] method.
 **/
FirminCSSMatrix.prototype.setMatrixValue = function(domstr) {
    domstr = FirminCSSMatrix.toMatrixString(domstr.trim());
    var mstr   = domstr.match(/^matrix(3d)?\(\s*(.+)\s*\)$/),
    is3d, chunks, len, points, i, chunk;

    if (!mstr) return;

    is3d   = !!mstr[1];
    chunks = mstr[2].split(/\s*,\s*/);
    len    = chunks.length;
    points = new Array(len);

    if ((is3d && len !== 16) || !(is3d || len === 6)) {
        XML3D.debug.logError("Invalid CSS Matrix: ", domstr);
        return;
    }

    for (i = 0; i < len; i++) {
        chunk = chunks[i];
        if (chunk.match(/^-?\d+(\.\d+)?$/)) {
            points[i] = parseFloat(chunk);
        } else {
            XML3D.debug.logError("Invalid CSS Matrix: ", domstr);
            return;
        }
    }

    for (i = 0; i < len; i++) {
        var point = is3d ?
        ("m" + (Math.floor(i / 4) + 1)) + (i % 4 + 1) :
        String.fromCharCode(i + 97); // ASCII char 97 == 'a'
        this[point] = points[i];
    }
};

/**
 *  FirminCSSMatrix#toString() -> String
 *
 *  Returns a string representation of the matrix.
 **/
FirminCSSMatrix.prototype.toString = function() {
    var self = this, points, prefix;

    if (this.isAffine()) {
        prefix = "matrix(";
        points = ["a", "b", "c", "d", "e", "f"];
    } else {
        prefix = "matrix3d(";
        points = ["m11", "m12", "m13", "m14",
            "m21", "m22", "m23", "m24",
            "m31", "m32", "m33", "m34",
            "m41", "m42", "m43", "m44"];
    }

    return prefix + points.map(function(p) {
        return self[p].toFixed(6);
    }).join(", ") + ")";
};

module.exports = FirminCSSMatrix;


},{}],130:[function(require,module,exports){
var printStackTrace = require("../contrib/stacktrace-0.4.js");
var Options = require("./options.js");

(function (ns) {

    var OPTION_LOGLEVEL = "loglevel";
    Options.register(OPTION_LOGLEVEL, "warning");

    ns.exports = {
        ALL: 0,
        DEBUG: 1,
        INFO: 2,
        WARNING: 3,
        ERROR: 4,
        EXCEPTION: 5,
        params: {},
        isSetup: false,
        loglevel: 4,
        loglevels: {
            all: 0,
            debug: 1,
            info: 2,
            warning: 3,
            error: 4,
            exception: 5
        },

        setup: function () {
            var debug = XML3D.debug;
            if (!debug.isSetup) {
                debug.isSetup = true;
                debug.loglevel = debug.loglevels[Options.getValue(OPTION_LOGLEVEL)] || 3;
                Options.addObserver(function(key, value) {
                    if(key == OPTION_LOGLEVEL) {
                        debug.loglevel = debug.loglevels[value] || 3;
                    }
                })
            }
            return true;
        },
        _setLogLevel: function() {
        },
        doLog: function (logType, args) {
            var params = XML3D.debug.params;
            if (params.xml3d_nolog || logType < XML3D.debug.loglevel) {
                return;
            }
            args = Array.prototype.slice.call(args);
            if (window.console) {
                switch (logType) {
                    case XML3D.debug.INFO:
                        window.console.info.apply(window.console, args);
                        break;
                    case XML3D.debug.WARNING:
                        window.console.warn.apply(window.console, args);
                        break;
                    case XML3D.debug.ERROR:
                        window.console.error.apply(window.console, args);
                        break;
                    case XML3D.debug.EXCEPTION:
                        window.console.error(printStackTrace({e: args[0], guess: true}).join('\n'));
                        break;
                    case XML3D.debug.DEBUG:
                        window.console.debug.apply(window.console, args);
                        break;
                    default:
                        break;
                }
            }
        },
        logDebug: function () {
            XML3D.debug.doLog(XML3D.debug.DEBUG, arguments);
        },
        logInfo: function () {
            XML3D.debug.doLog(XML3D.debug.INFO, arguments);
        },
        logWarning: function () {
            XML3D.debug.doLog(XML3D.debug.WARNING, arguments);
        },
        logError: function () {
            XML3D.debug.doLog(XML3D.debug.ERROR, arguments);
        },
        logException: function () {
            XML3D.debug.doLog(XML3D.debug.EXCEPTION, arguments);
        },
        assert: function (c, msg) {
            if (!c) {
                var caller;
                try{
                    caller = XML3D.debug.assert.caller ? XML3D.debug.assert.caller.name : null;
                }
                catch(e){
                    caller = null;
                }
                if (caller)
                    XML3D.debug.doLog(XML3D.debug.WARNING, ["Assertion failed in " + caller, msg ]);
                else
                    XML3D.debug.doLog(XML3D.debug.WARNING, ["Assertion failed", msg ]);
            }
        },
        trace: function (msg, logType) {
            logType = logType !== undefined ? logType : XML3D.debug.ERROR;
            if (window.console.trace) {
                if (msg) {
                    XML3D.debug.doLog(logType, [msg]);
                }
                window.console.trace();
            } else {
                var stack = printStackTrace();
                msg && stack.splice(0, 0, msg);
                XML3D.debug.doLog(logType, stack);
            }
        },
        getNumberWithPadding: function (number, width) {
            var res = "" + number;
            while (res.length < width) res = " " + res;
            return res;
        },
        formatSourceCode: function (source) {
            var result = "";
            var sourceLines = source.split("\n");
            for (var i = 0; i < sourceLines.length; ++i) {
                result += this.getNumberWithPadding(i + 1, 3) + "  " + sourceLines[i] + "\n";
            }
            return result;
        }
    };

}(module));

},{"../contrib/stacktrace-0.4.js":13,"./options.js":132}],131:[function(require,module,exports){
// utils/misc.js

window.requestAnimFrame = (function(){
    return  window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.oRequestAnimationFrame      ||
            window.msRequestAnimationFrame     ||
            function(f, fps){
              window.setTimeout(f, 1000 / fps);
            };
  })();

(function(exports) {


    /**
     * This function sends single or multiple adapter functions by calling functions
     * specified in funcs parameter for each adapter associated with the node.
     *
     * funcs parameter is used as a dictionary where each key is used as name of a
     * adapter function to call, and corresponding value is a list of arguments
     * (i.e. must be an array). For example sendAdapterEvent(node, {method : [1,2,3]})
     * will call function 'method' with arguments 1,2,3 for each adapter of the node.
     *
     * @param {Object} node
     * @param {Object} funcs
     * @return {Array} array of all returned values
     */
    exports.callAdapterFunc = function(node, funcs) {
        var result = [];
        if (!node || node._configured === undefined)
            return result;
        var adapters = node._configured.adapters;
        for (var adapter in adapters) {
            for (var func in funcs) {
                var adapterObject = adapters[adapter];
                var eventHandler = adapterObject[func];
                if (eventHandler) {
                    result.push(eventHandler.apply(adapterObject, funcs[func]));
                }
            }
        }
        return result;
    };

    /**
     * This function sends single or multiple adapter events by calling functions
     * specified in events parameter for each adapter associated with the node.
     *
     * events parameter is used as a dictionary where each key is used as name of a
     * adapter function to call, and corresponding value is a list of arguments
     * (i.e. must be an array). For example sendAdapterEvent(node, {method : [1,2,3]})
     * will call function 'method' with arguments 1,2,3 for each adapter of the node.
     *
     * @param {Object} node
     * @param {Object} events
     * @return {Boolean} false if node is not configured.
     */
    exports.sendAdapterEvent = function(node, events) {
        if (!node || node._configured === undefined)
            return false;
        var adapters = node._configured.adapters;
        for (var adapter in adapters) {
            for (var event in events) {
                var eventHandler = adapters[adapter][event];
                if (eventHandler) {
                    eventHandler.apply(adapters[adapter], events[event]);
                }
            }
        }
        return true;
    };

    /**
     *
     * Dispatch custom HTML event
     *
     * @param {Object} target element or document.
     * @param {string} eventType custom event type.
     * @param {boolean} canBubble Whether the event propagates upward. Sets the value for the bubbles property.
     * @param {boolean} cancelable Whether the event is cancelable and so preventDefault can be called. Sets the value
     *                  for the cancelable property.
     * @param {Object} detail A user-defined object that can contain additional information about the event.
     *                        This parameter can be of any type, or null. This value is returned in the detail property of the event.
     */
    exports.dispatchCustomEvent = function(target, eventType, canBubble, cancelable, detail) {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent(eventType, canBubble, cancelable, detail);
        return target.dispatchEvent(event);
    };

    /** Dispatch HTML event
     *
     * @param {Object} target    element or document
     * @param {string} eventType standard event type e.g. load, click
     */
    exports.dispatchEvent = function(target, eventType) {
        var evt = null;
        if (document.createEvent) {
                evt = document.createEvent("Events");
                evt.initEvent(eventType, true, true);
                return target.dispatchEvent(evt);
            } else if (document.createEventObject) {
                evt = document.createEventObject();
                return target.fireEvent('on' + eventType, evt);
            }
        };

    var __autoCreatedViewId = 0;
    /**
     * Returns the active view element corresponding to the given xml3d element.
     *
     * @param {!Object} xml3d
     * @return {Object} the active view element
     */
    exports.getOrCreateActiveView = function(xml3d)
    {
        // try to resolve reference
        var ref = xml3d.activeView;
        if(ref)
        {
            var v = window.XML3D.URIResolver.resolveLocal(ref);
            if(!v)
                throw "XML3D Error: xml3d references view that is not defined: '" + ref + "'.";

            return v;
        }

        // didn't succeed, so now try to just take the first view
        var firstView = xml3d.querySelector("view");
        if(firstView)
        {
            // if it has an id, set it as active
            if(firstView.id && firstView.id.length > 0)
                xml3d.activeView = "#" + firstView.id;

            return firstView;
        }

        // didn't find any: create new one
        XML3D.debug.logWarning("xml3d element has no view defined: creating one.");

        var vid = "xml3d.autocreatedview_" + __autoCreatedViewId++;
        var v = XML3D.createElement("view");
        v.setAttribute("id", vid);

        xml3d.appendChild(v);
        xml3d.setAttribute("activeView", "#" + vid);

        return v;
    };
}(module.exports));

},{}],132:[function(require,module,exports){
(function (ns) {

    /**
     * Class to handle options. Currently only used for global options, could
     * be extended to work hierarchically to configure other elements.
     * @constructor
     */
    var Options = function () {
        this._options = {};
        this._listeners = { "*": [] };
    };

    Options.prototype = {
        register: function (key, defaultValue) {
            if (this._options.hasOwnProperty(key))
                throw new Error("Option already registered '" + key + "'");
            this._options[key] = {
                currentValue: defaultValue,
                defaultValue: defaultValue
            };
        },
        resetValue: function (key) {
            if (!this._options.hasOwnProperty(key))
                throw new Error("Invalid configuration key '" + key + "'");
            this._options[key].currentValue = this._options[key].defaultValue;
            this.notifyObservers(key, this._options[key].currentValue);
        },
        setValue: function (key, value) {
            if (!this._options.hasOwnProperty(key))
                throw new Error("Invalid configuration key '" + key + "'");
            this._options[key].currentValue = value;
            this.notifyObservers(key, value);
        },
        getValue: function (key) {
            if (!this._options.hasOwnProperty(key)) {
                throw new Error("Invalid configuration key '" + key + "'");
            }
            return this._options[key].currentValue;
        },
        getKeys: function () {
            return Object.keys(this._options);
        },
        notifyObservers: function (key, value) {
            // Notify specific observers
            if(this._listeners.hasOwnProperty(key)) {
                this._listeners[key].forEach(function(l) {
                   l(key, value);
                });
            }
            // Notify generic observers
            this._listeners["*"].forEach(function(l) {
               l(key, value);
            });
        },
        addObserver: function (key, observer) {
            if(typeof key == 'function') {
                observer = key;
                key = "*"
            }
            if(!this._options.hasOwnProperty(key) && key !== "*") {
                throw new Error("Can't register to unknown option '" + key + "'");
            }
            if(!this._listeners.hasOwnProperty(key)) {
                this._listeners[key] = [];
            }
            this._listeners[key].push(observer);
        },
        removeObserver: function (observer) {
            for(var filter in this._listeners) {
                var listeners = this._listeners[filter];
                var idx = listeners.indexOf(observer);
                if (idx != -1)
                    listeners.splice(idx, 1);
            }

        }
    };

    var GlobalOptions = new Options();

    GlobalOptions.setOptionsFromQuery = function () {
        var p = window.location.search.substr(1).split('&');

        p.forEach(function (e) {
            var keyVal = e.split('=');
            try {
                var key = keyVal[0].toLowerCase();
                if (key.indexOf("xml3d-") === 0) {
                    var value = decodeURIComponent(keyVal[1]);
                    try {
                        value = JSON.parse(value);
                    } catch (e) {
                        // Do nothing
                    }
                    XML3D.options.setValue(key.substr(6), value);
                }
            } catch (e) {
                XML3D.debug && XML3D.debug.logError(e);
            }
        });
    }

    ns.exports = GlobalOptions;

}(module));

},{}],133:[function(require,module,exports){
(function(exports) {
    /**
     * Class URI
     * @constructor
     * @param {string} str The URI as string
     */
    var URI = function (str) {
        str = str || "";
        if (str.indexOf("blob:") == 0) {
            // Based on http://www.w3.org/TR/FileAPI/#url
            var parser = /^(?:([^:\/?\#]+):)?([^\#]*)(?:\#(.*))?/;
            var result = str.match(parser);
            /**  @type {boolean} */
            this.valid = result != null;
            /**  @type {?string} */
            this.scheme = result[1] || null;
            /**  @type {?string} */
            this.authority = null;
            /**  @type {?string} */
            this.path = null;
            /**  @type {?string} */
            this.query = null;
            /**  @type {?string} */
            this.opaqueString = result[2] || null;
            /**  @type {?string} */
            this.fragment = result[3] || null;
        } else {
            // Based on the regex in RFC2396 Appendix B.
            var parser = /^(?:([^:\/?\#]+):)?(?:\/\/([^\/?\#]*))?([^?\#]*)(?:\?([^\#]*))?(?:\#(.*))?/;
            var result = str.match(parser);
            /**  @type {boolean} */
            this.valid = result != null;
            /**  @type {?string} */
            this.scheme = result[1] || null;
            /**  @type {?string} */
            this.authority = result[2] || null;
            /**  @type {?string} */
            this.path = result[3] || null;
            /**  @type {?string} */
            this.query = result[4] || null;
            /**  @type {?string} */
            this.opaqueString = null;
            /**  @type {?string} */
            this.fragment = result[5] || null;
        }
    };

    /**
     * @return {boolean} true if URI is relative to current document
     */
    URI.prototype.isLocal = function () {
        return this.scheme != "blob" && !this.authority && !this.path;
    }

    /**
     * @return {boolean} true if URI is absolute
     */
    URI.prototype.isAbsolute = function () {
        return this.scheme != null;
    }

    /**
     * Get absolute URI relative to the provided document uri
     * @param {string} docUri uri of document from which this uri originates
     * @returns {URI}
     */
    URI.prototype.getAbsoluteURI = function (docUri) {
        if (!this.valid || this.isAbsolute()) {
            return this;
        }

        var docUriObj = new URI(docUri);

        if (this.path) {
            if (this.path.indexOf("/") == 0) {
                docUriObj.path = this.path;
            } else {
                docUriObj.path = docUriObj.path.substr(0, docUriObj.path.lastIndexOf("/") + 1) + this.path;
            }
            docUriObj.query = this.query;
        } else if (this.query) {
            docUriObj.query = this.query;
        }
        docUriObj.fragment = this.fragment;

        return docUriObj;
    }

    /**
     * Returns if this URI has the same origin as the provided reference
     * @param {URI|string} other
     * @returns {boolean}
     */
    URI.prototype.hasSameOrigin = function (other) {
        if (typeof other == 'string')
            other = new URI(other);

        if (this.scheme == "blob" || this.scheme == "data") {
            return true;
        }

        return this.scheme == other.scheme && this.authority == other.authority;
    };


// Restore the URI to it's stringy glory.
    URI.prototype.toString = function () {
        var str = "";
        if (this.scheme == "blob") {
            str = "blob:" + this.opaqueString;
            if (this.fragment) {
                str += "#" + this.fragment;
            }
            return str;
        }
        if (this.scheme) {
            str += this.scheme + ":";
        }
        if (this.authority) {
            str += "//" + this.authority;
        }
        if (this.path) {
            str += this.path;
        }
        if (this.query) {
            str += "?" + this.query;
        }
        if (this.fragment) {
            str += "#" + this.fragment;
        }
        return str;
    };

// Restore the URI to it's stringy glory minus the fragment
    URI.prototype.toStringWithoutFragment = function () {
        var str = "";
        if (this.scheme == "blob") {
            str = "blob:" + this.opaqueString;
            return str;
        }
        if (this.scheme) {
            str += this.scheme + ":";
        }
        if (this.authority) {
            str += "//" + this.authority;
        }
        if (this.path) {
            str += this.path;
        }
        if (this.query) {
            str += "?" + this.query;
        }
        return str;
    };

    /**
     * Class URIResolver
     * @constructor
     */
    var URIResolver = function () {
    };

    /**
     * Resolve a local URI to an element
     * @param {(string|URI)} uri Element to resolve
     * @param {Document=} document Base document to use
     * @return {Element} The resolved element or null if it could not be resolved
     */
    URIResolver.resolveLocal = function (uri, document) {
        if (typeof uri == 'string')
            uri = new URI(uri);
        document = document || window.document;

        if (uri.scheme == 'urn' || uri.scheme == "blob") {
            return null;
        }

        if (!uri.path && uri.fragment) { // local uri
            return document.getElementById(uri.fragment);
        }
        return null;
    };


    /**
     * @deprecated
     */
    URIResolver.resolve = function (uri, document) {
        XML3D.debug.logWarning("You are using deprecated XML3D.URIResolver.resolve. Use XML3D.URIResolver.resolveLocal instead.");
        return URIResolver.resolveLocal(uri, document);
    };

    exports.URI = URI;
    exports.URIResolver = URIResolver;

    window.XML3D.URIResolver = URIResolver;

}(module.exports));

},{}],134:[function(require,module,exports){
//TODO: Helpful API methods concerning WebCL will be added when needed. Please provide feedback!

/**
 * @file WebCL API. Provides useful methods for initialising and utilising the WebCL platform.
 * @version 0.2
 * @author Toni Dahl
 */

(function (namespace, undefined) {

    "use strict";

    var platforms = [],
        devices = [],
        ctx = null,

        WebCLNamespaceAvailable = false,
        OpenCLDriversAvailable = false;

    /**
     *     @constant {string} DEFAULT_DEVICE
     *     @default "CPU"
     */
    var DEFAULT_DEVICE = "CPU",

        /**
         *     @readonly
         *     @name CL_ERROR_CODES
         *     @enum {number}
         */
            CL_ERROR_CODES = {
            "SUCCESS": 0,
            "DEVICE_NOT_FOUND": -1,
            "DEVICE_NOT_AVAILABLE": -2,
            "COMPILER_NOT_AVAILABLE": -3,
            "MEM_OBJECT_ALLOCATION_FAILURE": -4,
            "OUT_OF_RESOURCES": -5,
            "OUT_OF_HOST_MEMORY": -6,
            "PROFILING_INFO_NOT_AVAILABLE": -7,
            "MEM_COPY_OVERLAP": -8,
            "IMAGE_FORMAT_MISMATCH": -9,
            "IMAGE_FORMAT_NOT_SUPPORTED": -10,
            "BUILD_PROGRAM_FAILURE": -11,
            "MAP_FAILURE": -12,
            "INVALID_VALUE": -30,
            "INVALID_DEVICE_TYPE": -31,
            "INVALID_PLATFORM": -32,
            "INVALID_DEVICE": -33,
            "INVALID_CONTEXT": -34,
            "INVALID_QUEUE_PROPERTIES": -35,
            "INVALID_COMMAND_QUEUE": -36,
            "INVALID_HOST_PTR": -37,
            "INVALID_MEM_OBJECT": -38,
            "INVALID_IMAGE_FORMAT_DESCRIPTOR": -39,
            "INVALID_IMAGE_SIZE": -40,
            "INVALID_SAMPLER": -41,
            "INVALID_BINARY": -42,
            "INVALID_BUILD_OPTIONS": -43,
            "INVALID_PROGRAM": -44,
            "INVALID_PROGRAM_EXECUTABLE": -45,
            "INVALID_KERNEL_NAME": -46,
            "INVALID_KERNEL_DEFINITION": -47,
            "INVALID_KERNEL": -48,
            "INVALID_ARG_INDEX": -49,
            "INVALID_ARG_VALUE": -50,
            "INVALID_ARG_SIZE": -51,
            "INVALID_KERNEL_ARGS": -52,
            "INVALID_WORK_DIMENSION": -53,
            "INVALID_WORK_GROUP_SIZE": -54,
            "INVALID_WORK_ITEM_SIZE": -55,
            "INVALID_GLOBAL_OFFSET": -56,
            "INVALID_EVENT_WAIT_LIST": -57,
            "INVALID_EVENT": -58,
            "INVALID_OPERATION": -59,
            "INVALID_GL_OBJECT": -60,
            "INVALID_BUFFER_SIZE": -61,
            "INVALID_MIP_LEVEL": -62,
            "INVALID_GLOBAL_WORK_SIZE": -63
        };
    Object.freeze(CL_ERROR_CODES);


    function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    /**
     * Returns a CL error name corresponding to a CL error code
     *
     * @function XML3D.webcl~getCLErrorName
     * @param {number} errorCode
     * @returns {string}
     */

    function getCLErrorName(errorCode) {
        var prop;

        if (isNumber(errorCode)) {
            for (prop in CL_ERROR_CODES) {
                if (CL_ERROR_CODES[prop] === errorCode) {
                    return prop;
                }
            }
            XML3D.debug.logDebug("Got unknown OpenCL Error Code:", errorCode);
        }

        return "UNKNOWN_ERROR";
    }

    /**
     * Gets an error code from a CL error message (thrown by Nokia WebCL Plugin)
     *
     * @param e
     * @returns {Integer|Boolean}
     */

    function getErrorCodeFromCLError(e) {
        var code = null;

        if (e.name && typeof e.name === "string") {
            if (CL_ERROR_CODES[e.name]) {
                return CL_ERROR_CODES[e.name];
            }
        }
        if (e.message && typeof e.message === "string") {
            code = e.message.match(/-?\d+/g);

            if (code instanceof Array) {
                return parseInt(code[code.length - 1], 10);
            }
        }

        return false;
    }

    /**
     * Creates instance of WebCLError
     *
     * @constructor XML3D.webcl~WebCLError
     * @param {string} [name="WebCLError"] Error name
     * @param {string} [msg="Generic WebCL error."] The desired error message
     */

    function WebCLError(name, msg) {
        if (name && typeof name !== "string") {
            XML3D.debug.logDebug("WebCL API: WebCLError: Error name not type of String");
            name = "";
        }

        if (msg && typeof msg !== "string") {
            XML3D.debug.logDebug("WebCL API: WebCLError: Error message not type of String");
            msg = "";
        }

        this.name = name || "WebCLError";
        this.message = msg || "Generic WebCL error.";
        this.stack = (new Error()).stack;
    }

    WebCLError.prototype = Object.create(Error.prototype);
    WebCLError.prototype.constructor = WebCLError;


    /**
     * Checks if WebCL namespace is available. The namespace can be provided by a WebCL plugin or native implementation.
     *
     * @function XML3D.webcl~hasWebCLNamespace
     * @returns {Boolean}
     */

    function hasWebCLNamespace() {
        WebCLNamespaceAvailable = window.webcl && webcl.getPlatforms;

        return WebCLNamespaceAvailable;

    }

    /**
     * Tests a basic WebCL method to see if the OpenCL drivers are working on users device.
     *
     * @function XML3D.webcl~hasOpenCLDrivers
     * @returns {Boolean}
     */

    function hasOpenCLDrivers() {
        var platArr;
        OpenCLDriversAvailable = true;

        try {
            platArr = webcl.getPlatforms();
        } catch (e) {
            OpenCLDriversAvailable = false;
        }

        if (!platArr || platArr.length === 0) {
            OpenCLDriversAvailable = false;
        }

        return OpenCLDriversAvailable;

    }

    /**
     * Combines WebCL namespace and driver test.
     *
     * @function XML3D.webcl~isAvailable
     * @returns {Boolean}
     */

    function isAvailable() {
        return hasWebCLNamespace() && hasOpenCLDrivers();
    }


    /**
     * Initialises the WebCL API with default values using a predefined device type or a default device type.
     *
     * @function XML3D.webcl~init
     * @param {string} [type="CPU"] Device type
     * @return {Boolean}
     */

    function init(type) {
        // Checking if WebCL is available in the users system
        if (!hasWebCLNamespace()) {
            XML3D.debug.logWarning("WebCL API: Unfortunately your system does not support WebCL. " +
                "WebCL namespace is not available.");
            return false;
        }

        if (!hasOpenCLDrivers()) {
            XML3D.debug.logWarning("WebCL API: Unfortunately your system does not support WebCL. " +
                "OpenCL drivers are not working properly.");
            return false;
        }

        getPlatforms();

        devices = getDevicesByType(type || DEFAULT_DEVICE);

        // Creating default context
        ctx = createContext(devices);

        return true;
    }

    /**
     * Returns all available WebCL device platforms.
     *
     * @function XML3D.webcl~getPlatforms
     * @returns {Array}
     */

    function getPlatforms() {
        if(platforms.length === 0) {
            platforms = webcl.getPlatforms();
        }

        return platforms;
    }

    /**
     * Returns all devices of a chosen type from a selected platform.
     *
     * @param {string} [type="CPU"] Device type
     * @param {IWebCLPlatform} platform
     * @returns {Array|Boolean}
     */

    function getPlatformDevicesByType(type, platform) {
        var deviceArr = [], errCode;

        if (!platform) {
            XML3D.debug.logError("WebCL API: getPlatformDevicesByType(): platform was not defined.");
            return false;
        }

        type = type || DEFAULT_DEVICE;

        try {
            if (type === "CPU") {
                deviceArr = platform.getDevices(webcl.DEVICE_TYPE_CPU);
            } else if (type === "GPU") {
                deviceArr = platform.getDevices(webcl.DEVICE_TYPE_GPU);
            } else if (type === "ALL") {
                deviceArr = platform.getDevices(webcl.DEVICE_TYPE_ALL);
            }

        } catch (e) {
            errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            } else if (errCode !== CL_ERROR_CODES.DEVICE_NOT_FOUND) {
                throw new WebCLError(getCLErrorName(errCode), "Could not get devices.");
            }

            return false;
        }

        return deviceArr;
    }

    /**
     * Gets all devices of a selected type from all available platforms.
     *
     * @function XML3D.webcl~getDevicesByType
     * @param {string} type Device type
     * @returns {Array|Boolean}
     */

    function getDevicesByType(type) {
        var resultArr = [], deviceArr, i;

        getPlatforms();

        for (i = platforms.length; i--;) {
            deviceArr = getPlatformDevicesByType(type, platforms[i]);

            if (deviceArr) {
                deviceArr.forEach(function (v) {
                    resultArr.push(v);
                });
            }
        }
        return resultArr.length === 0 ? false : resultArr;
    }


    /**
     * Gets the platform on where the device is.
     *
     * @function XML3D.webcl~getDevicePlatform
     * @param {IWebCLDevice} device
     * @returns {IWebCLPlatform|Boolean}
     */

    function getDevicePlatform(device) {
        var platform;

        if (!device) {
            XML3D.debug.logError("WebCL API: getDevicePlatform(): device was not defined.");
            return false;
        }

        try {
            platform = device.getInfo(webcl.DEVICE_PLATFORM);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }

            throw new WebCLError(getCLErrorName(errCode), "Could not get the platform of the device.");
        }

        return platform;
    }

    /**
     *
     * @param clCtx
     * @returns {boolean}
     */

    function getContextDevices(clCtx) {
        var deviceArr = [], errCode;

        if(!clCtx) {
            XML3D.debug.logError("WebCL API: getContextDevices(): clCtx was not defined.");
            return false;
        }

        try {
            deviceArr = clCtx.getInfo(webcl.CONTEXT_DEVICES);
        }catch(e) {
            errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            } else {
                throw new WebCLError(getCLErrorName(errCode), "Could not get devices.");
            }

        }

        return deviceArr.length === 0 ? false : deviceArr;
    }

    /**
     * Creates a WebCL context
     *
     * @function XML3D.webcl~createContext
     * @param {object} [properties]
     * @returns {IWebCLContext}
     */

    function createContext(properties) {
      /*
        var props = {
            devices: getDevicesByType(DEFAULT_DEVICE)
            }, context;

        XML3D.extend(props, properties);*/

        try {
            var context = webcl.createContext(properties);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode), "Failed to create a WebCL context.");
        }

        return context;
    }

    /**
     * Gets the default WebCL context.
     *
     * @function XML3D.webcl~getDefaultContext
     * @returns {IWebCLContext}
     */

    function getDefaultContext() {
        return ctx;
    }


    /**
     * Creates a WebCL program from a string of WebCL code.
     *
     * @function XML3D.webcl~createProgram
     * @param {string} codeStr
     * @param {IWebCLContext} clCtx
     * @returns {IWebCLProgram | Boolean}
     */

    function createProgram(codeStr, clCtx) {
        var program;

        clCtx = clCtx || ctx;

        if (!codeStr) {
            XML3D.debug.logError("WebCL API: createProgram(): codeStr was not defined.");
            return false;
        }

        if (!clCtx) {
            XML3D.debug.logError("WebCL API: createProgram(): clCtx was not defined.");
            return false;
        }

        try {
            program = clCtx.createProgram(codeStr);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }

            throw new WebCLError(getCLErrorName(errCode), "Failed to create a WebCL program.");
        }

        return program;
    }

    /**
     * Builds a WebCL program.
     *
     * @function XML3D.webcl~buildProgram
     * @param {IWebCLProgram} program
     * @param {Array} deviceArr
     * @returns {IWebCLProgram|Boolean}
     */

    function buildProgram(program, deviceArr) {
        deviceArr = deviceArr || devices;

        if (!program) {
            XML3D.debug.logError("WebCL API: buildProgram(): program was not defined.");
            return false;
        }

        try {
            program.build(deviceArr, "");
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode),
                program.getBuildInfo(deviceArr[0], WebCL.PROGRAM_BUILD_LOG));
        }

        return program;
    }

    /**
     * Creates a WebCL Kernel using a defined program.
     *
     * @function XML3D.webcl~createKernel
     * @param {IWebCLProgram} program
     * @param {string} name
     * @returns {IWebCLKernel|Boolean}
     */

    function createKernel(program, name) {
        var kernel;

        if (!program) {
            XML3D.debug.logError("WebCL API: createKernel(): program was not defined.");
            return false;
        }

        if (!name) {
            XML3D.debug.logError("WebCL API: createKernel(): name was not defined.");
            return false;
        }

        try {
            kernel = program.createKernel(name);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode), "Failed to create a WebCL kernel.");
        }

        return kernel;
    }

    /**
     * Creates a WebCL Command Queue for queueing kernels for execution.
     *
     * @function XML3D.webcl~createCommandQueue
     * @param {IWebCLDevice} device
     * @param {IWebCLContext} clCtx
     * @returns {IWebCLCommandQueue|Boolean}
     */

    function createCommandQueue(device, clCtx) {
        var cmdQueue;

        clCtx = clCtx || ctx;

        if(!clCtx) {
            XML3D.debug.logError("WebCL API: createCommandQueue: clCtx was not defined");
            return false;
        }

        try {
            cmdQueue = clCtx.createCommandQueue(device || devices[0], 0);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(getErrorCodeFromCLError(e)), "Could not create CommandQueue.");
        }

        return cmdQueue;
    }

    /**
     * Creates an input/output buffer to be used with a WebCL kernel
     *
     * @function XML3D.webcl~createBuffer
     * @param {int} size
     * @param {string} type
     * @param {IWebCLContext} clCtx
     * @returns {IWebCLMemoryObject|Boolean}
     */

    function createBuffer(size, type, clCtx) {
        clCtx = clCtx || ctx;

        if (!size) {
            XML3D.debug.logError("WebCL API: createBuffer(): Buffer size was not defined.");
            return false;
        }else if (!isNumber(size) || size < 0) {
            XML3D.debug.logError("WebCL API: createBuffer(): Buffer size must be a positive number.");
            return false;
        }

        if (!type) {
            XML3D.debug.logError("WebCL API: createBuffer(): Buffer type was not defined.");
            return false;
        }

        if(!clCtx) {
            XML3D.debug.logError("WebCL API: createBuffer(): clCtx was not defined.");
            return false;
        }

        try {
            if (type === "r") {
                return clCtx.createBuffer(webcl.MEM_READ_ONLY, size);
            } else if (type === "w") {
                return clCtx.createBuffer(webcl.MEM_WRITE_ONLY, size);
            } else if (type === "rw") {
                return clCtx.createBuffer(webcl.MEM_READ_WRITE, size);
            } else {
                XML3D.debug.logError("WebCL API: createBuffer(): Unknown buffer type:", type);
                return false;
            }
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode), "Could not create a WebCL buffer.");
        }
    }

    /**
     * Creates an instance of KernelManager.
     *
     * @name KernelManager
     * @constructor XML3D.webcl~KernelManager
     */

    var KernelManager = function (clCtx, deviceArr) {
        var kernels = {};

        return {

            /**
             * Creates and builds a WebCL program from a code string and creates a WebCL kernel from the program.
             *
             * @function KernelManager~register
             * @param {string} name
             * @param {string} codeStr
             */

            register: function (name, codeStr) {
                if (kernels.hasOwnProperty(name)) {
                    XML3D.debug.logWarning("WebCL API: kernels.register(): Kernel with a same name is already defined.");
                    return false;
                }

                if (typeof name !== "string") {
                    XML3D.debug.logError("WebCL API: kernels.register(): Kernel name was not defined or was not type of String.");
                    return false;
                }

                if (typeof codeStr !== "string") {
                    XML3D.debug.logError("WebCL API: kernels.register(): Kernel code was not defined or was not type of String.");
                    return false;
                }

                var program, kernel;

                program = createProgram(codeStr, clCtx);

                buildProgram(program, deviceArr);

                if (program) {
                    kernel = createKernel(program, name);
                }

                if (kernel) {
                    kernels[name] = kernel;

                    return true;
                }

                return false;

            },

            /**
             * Deallocates and unregisters a kernel.
             *
             * @function KernelManager~unRegister
             * @param {string} name
             */

            unRegister: function (name) {
                if (kernels.hasOwnProperty(name)) {
                    try {
                        kernels[name].release();
                    } catch (e) {
                        var errCode = getErrorCodeFromCLError(e);

                        if (!errCode) {
                            throw e;
                        }

                        throw new WebCLError(getCLErrorName(errCode), "Could not release kernel resources.");
                    }
                    delete kernels[name];

                    return true;
                }

                return false;
            },

            /**
             * Gets a kernel of a specified name.
             *
             * @function KernelManager~getKernel
             * @param {string} name
             * @returns {IWebCLKernel | Boolean}
             */

            getKernel: function (name) {
                if (typeof name !== "string") {
                    return false;
                }

                if (kernels.hasOwnProperty(name)) {
                    return kernels[name];
                }

                return false;
            },

            /**
             * Sets arguments of a specified kernel.
             * The first argument of this function is a registered kernel name, other arguments are the kernel arguments respectively.
             *
             * @function KernelManager~setArgs
             * @param {IWebCLKernel} kernel WebCL kernel
             * @param {...*} args Kernel arguments in the same order as defined in the kernel code
             * @returns {boolean}
             */

            setArgs: function () {
                var args = Array.prototype.slice.call(arguments),
                    kernel, inputArgs, nKernelArgs, i;

                if (args.length < 2) {
                    XML3D.debug.logWarning("WebCL API: setArgs(): No kernel arguments were defined.");
                    return false;
                }

                kernel = args[0];
                inputArgs = args.slice(1);

                if (!kernel) {
                    XML3D.debug.logWarning("WebCL API: setArgs(): WebCL kernel was not defined.");
                    return false;
                }

                nKernelArgs = kernel.getInfo(webcl.KERNEL_NUM_ARGS);

                if (inputArgs.length > nKernelArgs) {
                    XML3D.debug.logWarning("WebCL: setArgs: Input args amount > kernel program args amount! Ignoring extra arguments.");
                } else if (inputArgs.length < nKernelArgs) {
                    XML3D.debug.logError("WebCL: setArgs: Not enough arguments were given to WebCL kernel.");
                    return false;
                }

                XML3D.debug.logDebug("Args for kernel:", kernel.getInfo(webcl.KERNEL_FUNCTION_NAME));

                i = nKernelArgs;

                try {
                    while (i--) {
                        XML3D.debug.logDebug("Arg:", i, inputArgs[i]);
                        kernel.setArg(i, inputArgs[i]);
                    }
                } catch (e) {
                    var errCode = getErrorCodeFromCLError(e);

                    if (!errCode) {
                        throw e;
                    }
                    throw new WebCLError(getCLErrorName(errCode), "Could not set kernel arguments.");
                }

                return true;

            }
        };
    };

    /**
     * Checks if WebCL is available and attaches a context to the given object
     * @param webclObject the object that the context will be attached to
     * @returns {boolean}
     */
    function initWebCLPlatform(webclObject) {
        if (!isAvailable()) {
            return false;
        }

        var clPlatforms = getPlatforms();
        if (!clPlatforms || clPlatforms.length <= 0) {
            return false;
        }

        try {
            // Trying initially to use GPU (for the best performance). Using CPU as a fallback.
            var clDevices = getDevicesByType("GPU") || getDevicesByType("CPU");
            if (!clDevices) {
                return false;
            }
            var clCtx = createContext(clDevices);
            var cmdQueue = createCommandQueue(clDevices[0], clCtx);

            /**
             *  TODO: Maybe we should just store the cl-platform objects in C.cl so they are more easily available and
             *  to avoid long prototype chains. Or we could pass the graph context to each node of the graph.
             *  However, it would be good to allow each Graph object to have at least own context, cmdQueue and kernelManager.
             */
            webclObject.cl = {
                API: webcl,
                kernelManager: new KernelManager(clCtx, clDevices),
                platforms: clPlatforms,
                devices: clDevices,
                ctx: clCtx,
                cmdQueue: cmdQueue
            };
            XML3D.debug.logDebug("Successfully initialized WebCL platform.");
            return true;
        } catch (e) {
            return false;
        }
    }

    /**
     * API
     *
     * @namespace webcl
     * @memberOf XML3D
     */

    namespace['webcl'] = {
        "init": init,
        "createContext": createContext,
        "createProgram": createProgram,
        "buildProgram": buildProgram,
        "createKernel": createKernel,
        "createCommandQueue": createCommandQueue,
        "createBuffer": createBuffer,
        "getDefaultContext": getDefaultContext,
        "getPlatforms": getPlatforms,
        "getDevicesByType": getDevicesByType,
        "getContextDevices": getContextDevices,
        "getDevicePlatform": getDevicePlatform,

        /** @name XML3D.webcl~kernels */
        "kernels": new KernelManager(),
        "KernelManager": KernelManager,

        "hasWebCLNamespace": hasWebCLNamespace,
        "hasOpenCLDrivers": hasOpenCLDrivers,
        "isAvailable": isAvailable,
        "WebCLError": WebCLError,
        "getCLErrorName": getCLErrorName
    };

    initWebCLPlatform(namespace.webcl);
    window.XML3D.webcl = namespace.webcl;

}(module.exports));

},{}],135:[function(require,module,exports){
// Error Callbacks:
var c_errorCallbacks = [];

var c_listedCallbacks = [];
var c_listedCallbacksData = [];

module.exports = {

    registerErrorCallback: function (callback) {
        c_errorCallbacks.push(callback);
    },

    notifyError: function (message, node) {
        if (c_errorCallbacks.length > 0) {
            var i;
            for (i = 0; i < c_errorCallbacks.length; ++i) {
                c_errorCallbacks[i](message, node);
            }
        } else {
            // TODO: Do Default error printing
        }
    },

    /**
     *
     * @param {Object} ctor Constructor
     * @param {Object} parent Parent class
     * @param {Object=} methods Methods to add to the class
     * @returns {Object}
     */
    createClass: function (ctor, parent, methods) {
        methods = methods || {};
        if (parent) {
            /** @constructor */
            var F = function () {
            };
            F.prototype = parent.prototype;
            ctor.prototype = new F();
            ctor.prototype.constructor = ctor;
            ctor.superclass = parent.prototype;
        }
        for (var m in methods) {
            ctor.prototype[m] = methods[m];
        }
        return ctor;
    },

    extend: function (a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }
    },

    /**
     * Cluster internal notifications to avoid multiple notifications
     * of same type. Mainly for Requests and Results
     *
     * @param requestOrResult Request or Result
     * @param {RESULT_STATE} resultState
     * @private
     */
    _queueResultCallback: function (requestOrResult, resultState) {
        var index;
        if (( index = c_listedCallbacks.indexOf(requestOrResult)) == -1) {
            index = c_listedCallbacks.length;
            c_listedCallbacks.push(requestOrResult);
        }
        var prevData = c_listedCallbacksData[index];

        if (!prevData || prevData < resultState) {
            c_listedCallbacksData[index] = resultState;
        }
    },

    _flushResultCallbacks: function () {
        if (c_listedCallbacks.length) {
            var i;
            for (i = 0; i < c_listedCallbacks.length; ++i) {
                c_listedCallbacks[i]._onPostponedResultChanged(c_listedCallbacksData[i]);
            }
            c_listedCallbacks = [];
            c_listedCallbacksData = [];
        }
    }
};







},{}],136:[function(require,module,exports){
var C = {};

C.EPSILON = 0.000001;

/**
 * Type of DataEntry
 * @enum
 */
C.DATA_TYPE = {
    UNKNOWN: 0,
    FLOAT: 1,
    FLOAT2: 2,
    FLOAT3: 3,
    FLOAT4: 4,
    FLOAT3X3: 5,
    FLOAT4X4: 10,
    INT: 20,
    INT4: 21,
    BOOL: 30,
    TEXTURE: 40,
    BYTE: 50,
    UBYTE: 60,
    fromString: function(str) {
        if (!str || !str.toUpperCase) {
            return;
        }
        return this[str.toUpperCase()];
    }
};

C.DATA_TYPE_MAP = {
    'float': C.DATA_TYPE.FLOAT,
    'float2': C.DATA_TYPE.FLOAT2,
    'float3': C.DATA_TYPE.FLOAT3,
    'float4': C.DATA_TYPE.FLOAT4,
    'float3x3': C.DATA_TYPE.FLOAT3X3,
    'float4x4': C.DATA_TYPE.FLOAT4X4,
    'int': C.DATA_TYPE.INT,
    'int4': C.DATA_TYPE.INT4,
    'bool': C.DATA_TYPE.BOOL,
    'texture': C.DATA_TYPE.TEXTURE,
    'byte': C.DATA_TYPE.BYTE,
    'ubyte': C.DATA_TYPE.UBYTE
};

// Values are chosen to be in line with DATA_TYPE
C.TEXTURE_TYPE = {
    UNKNOWN: 0, FLOAT: 1, UBYTE: 60, USHORT_5_6_5: 70, USHORT_4_4_4_4: 71, USHORT_5_5_5_1: 72
};

C.TEXTURE_FORMAT = {
    UNKNOWN: 0, ALPHA: 100, RGB: 101, RGBA: 102, LUMINANCE: 103, LUMINANCE_ALPHA: 104
};

C.DATA_TYPE_TUPLE_SIZE = {};
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT2] = 2;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT3] = 3;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT4] = 4;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT3X3] = 9;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT4X4] = 16;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.INT] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.INT4] = 4;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.BOOL] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.TEXTURE] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.BYTE] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.UBYTE] = 1;

C.TYPED_ARRAY_MAP = {};
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT2] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT3] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT4] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT4X4] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.INT] = Int32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.INT4] = Int32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.BOOL] = Int8Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.BYTE] = Int8Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.UBYTE] = Uint8Array;

// texture formats
// float and ubyte are mapped to DATA_TYPE values above
C.TYPED_ARRAY_MAP[C.TEXTURE_TYPE.USHORT_4_4_4_4] = Uint16Array;
C.TYPED_ARRAY_MAP[C.TEXTURE_TYPE.USHORT_5_6_5] = Uint16Array;
C.TYPED_ARRAY_MAP[C.TEXTURE_TYPE.USHORT_5_5_5_1] = Uint16Array;

C.TEXTURE_FORMAT_TUPLE_SIZE = {};
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.ALPHA] = 1;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.RGB] = 3;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.RGBA] = 4;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.LUMINANCE] = 1;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.LUMINANCE_ALPHA] = 2;

C.getTypeName = function (type) {
    var i;
    for (i in C.DATA_TYPE_MAP) {
        if (C.DATA_TYPE_MAP[i] === type) {
            return i;
        }
    }
};

/**
 * @enum {number}
 */
C.TEX_FILTER_TYPE = {
    NEAREST: 0x2600, LINEAR: 0x2601, MIPMAP_NEAREST: 0x2700, MIPMAP_LINEAR: 0x2701

};
/**
 * @enum {number}
 */
C.TEX_WRAP_TYPE = {
    CLAMP: 0x812F, REPEAT: 0x2901
};
/**
 * @enum {number}
 */
C.TEX_TYPE = {
    TEXTURE_2D: 0x0DE1
};

C.SHADER_CONSTANT_KEY = {
    WORLD_TRANSFORM: 1,
    VIEW_TRANSFORM: 2,
    SCREEN_TRANSFORM: 3,
    WORLD_TRANSFORM_NORMAL: 4,
    VIEW_TRANSFORM_NORMAL: 5,
    SCREEN_TRANSFORM_NORMAL: 6,
    OBJECT_ID: 7
};

C.VS_ATTRIB_TRANSFORM = {
    NONE: 0, VIEW_POINT: 1, WORLD_POINT: 2, VIEW_NORMAL: 3, WORLD_NORMAL: 4
};


/**
 * Filter Type of DataNode
 * KEEP - Keep only the provided names
 * REMOVE - Remove provided names (ignores name mapping)
 * RENAME - Only apply name mapping
 * @enum
 */
C.DATA_FILTER_TYPE = {
    NONE: 0, RENAME: 1, KEEP: 2, REMOVE: 3
};


/**
 * TODO: Maybe merge this structure with RESULT_STATE to avoid back and forth conversion within notification chain
 * @enum {number}
 */
C.DATA_ENTRY_STATE = {
    CHANGED_VALUE: 1,
    CHANGED_NEW: 2,
    LOAD_START: 3,
    LOAD_END: 4,
    CHANGED_SIZE: 5,
    CHANGED_REMOVED: 6, // Not just the size changed, but also qualifier
    // if we have 0, 1 or many tuples in value
    CHANGED_SIZE_TYPE: 7
};

/** TODO: Merge with C.PLATFORM? **/
C.RESULT_TYPE = {
    COMPUTE: 0, VS: 1
};


/**
 * Type of Modification, used internally only
 * Ordered by importance.
 * @enum
 */
C.RESULT_STATE = {
    NONE: 0, CHANGED_DATA_VALUE: 1, CHANGED_DATA_SIZE: 2, CHANGED_STRUCTURE: 3, // TODO: Felix: Still required?
    IMAGE_LOAD_START: 4, IMAGE_LOAD_END: 5
};


/**
 * Type of Sequence access - used by operators
 * @enum
 */
C.SEQUENCE = {
    NO_ACCESS: 0, PREV_BUFFER: 1, NEXT_BUFFER: 2, LINEAR_WEIGHT: 3
};


C.ITERATION_TYPE = {
    NULL: 0, ONE: 1, MANY: 2
};

/**
 * Type of Information Extraction - used by operators
 * @private
 * @enum
 */
//TODO: This seems to be unused, is it still needed?
C.EXTRACT = {
    NO_EXTRAC: 0, TEX_WIDTH: 1, TEX_HEIGHT: 2
};

C.ORIGIN = {
    CHILD: 1, COMPUTE: 2, PROTO: 3
};

/**
 * Types of platforms to perform computation on
 * @type {enum}
 */
C.PLATFORM = {
    JAVASCRIPT: 0, GLSL: 1, CL: 2, ASYNC: 3
};

/**
 * Possible states of a ProcessNode
 * @type {enum}
 */
C.PROCESS_STATE = {
    MODIFIED: 0, // We don't know (TODO Felix: Find out!)
    LOADING: 1, // Something still loading (blocked)
    INVALID: 3, // Input is invalid (might happen even after operator selection - e.g. because of empty array output etc.)
    UNPROCESSED: 4, // Process node is dirty
    PROCESSED: 5 // All data is up-to-date
};

//window.Xflow.PLATFORM = C.PLATFORM;

module.exports = C;

},{}],137:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./constants.js");
require("../../utils/array.js");

/**
 * Content of this file:
 * All Code for handling data entries connected to Xflow including:
 *  - BufferEntries: Typed value buffers (e.g float3 buffer, without name)
 *  - TextureEntries: e.g. images
 *
 *  This file also includes the DataChangeNotifier used to react to changes on Xflow data structures
 */

//----------------------------------------------------------------------------------------------------------------------
// SamplerConfig
//----------------------------------------------------------------------------------------------------------------------


/**
 * SamplerConfig is used to define sampler properties of a TextureEntry or ImageDataTextureEntry
 * @constructor
 */
var SamplerConfig = function(){
    this.minFilter = 0;
    this.magFilter = 0;
    this.mipFilter = 0;
    this.wrapS = 0;
    this.wrapT = 0;
    this.wrapU = 0;
    this.textureType = 0;
    this.colorR = 0;
    this.colorG = 0;
    this.colorB = 0;
    this.generateMipMap = 0;
};

SamplerConfig.prototype.setDefaults = function() {
    this.minFilter = C.TEX_FILTER_TYPE.LINEAR;
    this.magFilter = C.TEX_FILTER_TYPE.LINEAR;
    this.mipFilter = C.TEX_FILTER_TYPE.NEAREST;
    this.wrapS = C.TEX_WRAP_TYPE.CLAMP;
    this.wrapT = C.TEX_WRAP_TYPE.CLAMP;
    this.wrapU = C.TEX_WRAP_TYPE.CLAMP;
    this.textureType = C.TEX_TYPE.TEXTURE_2D;
    this.colorR = 0;
    this.colorG = 0;
    this.colorB = 0;
    this.generateMipMap = 0;
};

SamplerConfig.prototype.set = function(other) {
    this.minFilter = other.minFilter;
    this.magFilter = other.magFilter;
    this.mipFilter = other.mipFilter;
    this.wrapS = other.wrapS;
    this.wrapT = other.wrapT;
    this.wrapU = other.wrapU;
    this.textureType = other.textureType;
    this.colorR = other.colorR;
    this.colorG = other.colorG;
    this.colorB = other.colorB;
    this.generateMipMap = other.generateMipMap;
};


//----------------------------------------------------------------------------------------------------------------------
// DataEntry
//----------------------------------------------------------------------------------------------------------------------


/**
 * The abstract base class for all DataEntries connected to an xflow graph.
 * @abstract
 * @param {C.DATA_TYPE} type Type of DataEntry
 */
var DataEntry = function(type){
    this._type = type;
    /** @type {Array.<Function(DataEntry, C.DATA_ENTRY_STATE)>} **/
    this._listeners = [];
    /** Add related custom data (e.g. WebGL buffers) **/
    this.userData = {};
};

Object.defineProperty(DataEntry.prototype, "type", {
    set: function(){
        throw new Error("type is read-only");
    },
    /** @return {C.DATA_TYPE} */
    get: function(){ return this._type; }
});

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataEntry.prototype.addListener = function(callback){
    this._listeners.push(callback);
};

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataEntry.prototype.removeListener = function(callback){
    Array.erase(this._listeners, callback);
};

/**
 */
DataEntry.prototype._notifyChanged = function(){
    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_VALUE);
};

//----------------------------------------------------------------------------------------------------------------------
// BufferEntry
//----------------------------------------------------------------------------------------------------------------------

/**
 * A typed value buffer basically linking to a typed array.
 * @constructor
 * @extends {DataEntry}
 * @param {C.DATA_TYPE} type
 * @param {Object} value A typed array
 */
var BufferEntry = function(type, value){
    DataEntry.call(this, type);
    this._value = value;
    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_NEW);
};
Base.createClass(BufferEntry, DataEntry);


/**
 *  Set value of entry. Triggers notification chain
 *  @param {Object} v Value to set (has to be a TypedArray)
 */
BufferEntry.prototype.setValue = function(v){
    this._setValue(v);
    Base._flushResultCallbacks();
};

/**
 * Are there no, one or many values?
 * @param size
 * @param tupleSize
 * @returns {number}
 */
function getSizeType(size, tupleSize){
    if(size >= tupleSize*2)
        return 2;
    else if(size >= tupleSize)
        return 1;
    else
        return 0;
}

BufferEntry.prototype._setValue = function(v){
    var oldSize = (this._value ? this._value.length : 0), newSize = (v ? v.length : 0), tupleSize = this.getTupleSize();
    var notification;
    if(getSizeType(oldSize, tupleSize) != getSizeType(newSize, tupleSize))
        notification = C.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE;
    else if(oldSize != newSize){
        notification = C.DATA_ENTRY_STATE.CHANGED_SIZE;
    }
    else{
        notification = C.DATA_ENTRY_STATE.CHANGED_VALUE;
    }
    this._value = v;
    notifyListeners(this, notification);
};

/** @return {Object} */
BufferEntry.prototype.getValue = function(){
    return this._value;
};

/**
 * Returns the buffer length
 * @return {Object}
 */
BufferEntry.prototype.getLength = function(){
    return this._value ? this._value.length : 0;
};

/**
 * Returns tuple size (e.g 1, 2, 3, 4, 16)
 * @returns {number}
 */
BufferEntry.prototype.getTupleSize = function() {
    return C.DATA_TYPE_TUPLE_SIZE[this._type];
};

/**
 * Return tuple count
 * @return {number}
 */
BufferEntry.prototype.getIterateCount = function(){
    return this.getLength() / this.getTupleSize();
};

/**
 * Is value not set or the length of the buffer 0
 * @returns {boolean}
 */
BufferEntry.prototype.isEmpty = function(){
    return !this._value || !this.getLength();
};


//----------------------------------------------------------------------------------------------------------------------
// TextureEntry
//----------------------------------------------------------------------------------------------------------------------

var tmpCanvas, tmpContext;

C.toImageData = function(imageData) {
    if(imageData instanceof ImageData)
        return imageData;
    if(!imageData.data)
        throw new Error("no data property");
    if(!imageData.width)
        throw new Error("no width property");
    if(!imageData.height)
        throw new Error("no height property");
    if(!tmpContext) {
        tmpCanvas = document.createElement('canvas');
        tmpContext = tmpCanvas.getContext('2d');
    }
    var newImageData = tmpContext.createImageData(imageData.width, imageData.height);
    for(var i = 0; i < imageData.data.length; ++i) {
        var v = imageData.data[i];
        if(v > 255)
            v = 255;
        if(v < 0)
            v = 0;
        newImageData.data[i] = v;
    }
    return newImageData;
};

function TexelSource(sourceOrWidth, height, format, type) {
    if (typeof sourceOrWidth === "object") {
        if (sourceOrWidth.nodeName) {
            var nodeName = sourceOrWidth.nodeName.toLowerCase();
            if (nodeName === "video" && (typeof sourceOrWidth.complete === "undefined")) {
                Object.defineProperties(sourceOrWidth, {
                    width: {
                        get: function () {
                            return this.videoWidth;
                        }
                    },
                    height: {
                        get: function () {
                            return this.videoHeight;
                        }
                    },
                    complete: {
                        get: function () {
                            return !(this.readyState == 0 || this.videoWidth <= 0 || this.videoHeight <= 0);
                        }
                    }
                });
            }
            sourceOrWidth.texelFormat = C.TEXTURE_FORMAT.RGBA;
            sourceOrWidth.texelType = C.TEXTURE_TYPE.UBYTE;
        }
        //assume source is a image data like object
        this._source = sourceOrWidth;
    } else {
        format = format || C.TEXTURE_FORMAT.RGBA;
        type =  type || C.TEXTURE_TYPE.UBYTE;
        //create a new texel source backed by type array
        this._source = {
            width: sourceOrWidth,
            height: height,
            texelFormat: format,
            texelType: type,
            data: new C.TYPED_ARRAY_MAP[type](sourceOrWidth * height * C.TEXTURE_FORMAT_TUPLE_SIZE[format])
        }
    }
}

Object.defineProperties(TexelSource.prototype, {
    imageData: {
        get: function () {
            if (this._source instanceof HTMLElement) {
                var canvas = document.createElement("canvas");
                canvas.width = this._source.width;
                canvas.height = this._source.height;
                var ctx = canvas.getContext("2d");
                ctx.drawImage(this._source, 0, 0);
                var source = ctx.getImageData(0, 0, this._source.width, this._source.height);
                source.texelFormat = this._source.texelFormat;
                source.texelType = this._source.texelType;
                this._source = source;
            }
            return this._source;
        }
    },
    // TODO this is very confusing. asGLTextureData is texelsource.source
    glTextureData: {
        get: function () {
            return this._source;
        }
    },
    complete: {
        get: function () {
            return typeof this._source.complete === "undefined" ? true : this._source.complete;
        }
    },
    width: {
        get: function () {
            return this._source ? this._source.width : -1;
        }
    },
    height: {
        get: function () {
            return this._source ? this._source.height : -1;
        }
    },
    texelFormat: {
        get: function () {
            return this._source ? this._source.texelFormat: C.TEXTURE_FORMAT.UNKNOWN;
        }
    },
    texelType: {
        get: function () {
            return this._source ? this._source.texelType: C.TEXTURE_TYPE.UNKNOWN;
        }
    }
});

/**
 * A data entry for a texture.
 * Note: each TextureEntry includes a samplerConfig.
 * @constructor
 * @extends {DataEntry}
 * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} source //TODO: Which kinds are supported?
 */
TextureEntry = function(source){
    DataEntry.call(this, C.DATA_TYPE.TEXTURE);
    this._samplerConfig = new SamplerConfig();
    this._loading = false;
    this.setImage(source);

    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_NEW);
};

Base.createClass(TextureEntry, DataEntry);

Object.defineProperties(TextureEntry.prototype, {
    width: {
        get: function () {
            return this._source ? this._source.width : -1;
        }
    },
    height: {
        get: function () {
            return this._source ? this._source.height : -1;
        }
    },
    texelFormat: {
        get: function () {
            return this._source ? this._source.texelFormat: C.TEXTURE_FORMAT.UNKNOWN;
        }
    },
    texelType: {
        get: function () {
            return this._source ? this._source.texelType: C.TEXTURE_TYPE.UNKNOWN;
        }
    }
});

TextureEntry.prototype.isLoading = function() {
    if (!this._source)
        return false;

    return !this._source.complete;
};

/**
 * @private
 */
TextureEntry.prototype._createImage = function(width, height, format, type, samplerConfig) {
    if (!this._source || this.width != width || this.height != height || this.format != format || this.type != type) {
        var source = new TexelSource(width, height, format, type);

        if (!samplerConfig) {
            samplerConfig = new SamplerConfig();
            samplerConfig.setDefaults();
        }

        this._samplerConfig.set(samplerConfig);
        this._setImage(source);
    } else {
        this._notifyChanged();
    }

    return this._source;
};

/**
 * Set image source of a Texture Entry
 * TODO: This is called even if image is just loaded (on XML3D side). Add a notifyImageLoaded method could
 * be helpful
 *
 * @param {HTMLImageElement|HTMLVideoElement|TexelSource|null} element
 * @param {boolean?} forceLoadCallback trigger load callback if data changes
 */
TextureEntry.prototype.setImage = function (element, forceLoadCallback) {
    this._setImage(element, forceLoadCallback);
    Base._flushResultCallbacks();
};

TextureEntry.prototype._setImage = function (element, forceLoadCallback) {
    if (!element)
        this._setSource(null, forceLoadCallback);
    else if (element instanceof TexelSource)
        this._setSource(element, forceLoadCallback);
    else
        this._setSource(new TexelSource(element), forceLoadCallback);
};

TextureEntry.prototype._setSource = function(s, forceLoadCallback) {
    var prevLoading = this.isLoading();
    this._source = s;
    var loading = this.isLoading();
    if(forceLoadCallback && !loading && !prevLoading){
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_START);
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_END);
    }
    else if(loading){
        this._loading = true;
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_START);
    }
    else if(this._loading){
        this._loading = false;
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_END);
    }
    else
        notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_VALUE);
};

TextureEntry.prototype.asGLTextureValue = function () {
    return this._source && this._source.glTextureData;
};

/** @return {ImageData} */
TextureEntry.prototype.getValue = function() {
    if (!this._source)
        return null;
    if (!this.isLoading())
        return this._source.imageData;
    else
        return null;
};

/** @return {SamplerConfig} */
TextureEntry.prototype.getSamplerConfig = function(){
    return this._samplerConfig;
};

/** @return {number} */
TextureEntry.prototype.getLength = function(){
    return 1;
};
TextureEntry.prototype.isEmpty = function(){
    return false;
};

/** @return {number} */
TextureEntry.prototype.getIterateCount = function() {
    return 1;
};

//----------------------------------------------------------------------------------------------------------------------
// ImageDataTextureEntry
//----------------------------------------------------------------------------------------------------------------------

/**
 * Same as TextureEntry, only based on imageData.
 * This class is used for xflow running inside Web Workers (which don't support HTML images)
 * @param imageData
 * @extends{DataEntry}
 * @constructor
 */
var ImageDataTextureEntry = function(imageData){
    DataEntry.call(this, C.DATA_TYPE.TEXTURE);
    this._samplerConfig = new SamplerConfig();
    this._imageData = null;
    this._texelFormat = C.TEXTURE_FORMAT.RGBA;
    this._texelType = C.TEXTURE_TYPE.UBYTE;

    this._updateImageData(imageData);

    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_NEW);
};

Base.createClass(ImageDataTextureEntry, DataEntry);

Object.defineProperties(ImageDataTextureEntry.prototype, {
    width: {
        get: function () {
            return this._imageData ? this._imageData.width : -1;
        }
    },
    height: {
        get: function () {
            return this._imageData ? this._imageData.height : -1;
        }
    },
    texelFormat: {
        get: function () {
            return this._texelFormat;
        }
    },
    texelType: {
        get: function () {
            return this._texelType;
        }
    }
});



ImageDataTextureEntry.prototype.isLoading = function() {
    return !this._imageData;
};

ImageDataTextureEntry.prototype._updateImageData = function(imageData) {
    this._texelFormat = C.TEXTURE_FORMAT.RGBA;
    this._texelType = C.TEXTURE_TYPE.UBYTE;
    this._imageData = imageData;
};

/** Create new image
 * TODO: Jan: Write source documentation
 * @param width
 * @param height
 * @param format
 * @param type
 * @param samplerConfig
 * @return {HTMLImageElement|HTMLCanvasElement}
 */
ImageDataTextureEntry.prototype._createImage = function(width, height, format, type, samplerConfig) {
    if (!this._imageData || this.getWidth() != width || this.getHeight() != height || this._format != format || this._type != type) {
        if (!width || !height)
            throw new Error("Width or height is not specified");
        this._texelFormat = format;
        this._texelType = type;
        if (!samplerConfig) {
            samplerConfig = new SamplerConfig();
            samplerConfig.setDefaults();
        }
        this._samplerConfig.set(samplerConfig);

        /**
         * @type {{width: *, height: *, data: null|ArrayBufferView}}
         */
        var imageData = {
            width: width,
            height: height,
            data: null
        };
        if(type == C.TEXTURE_TYPE.FLOAT){
            imageData.data = new Float32Array(width*height*4);
        }
        else {
            // FIXME: We should allocate Uint8ClampedArray here instead
            // But Uint8ClampedArray can't be allocated in Chrome inside a Web Worker
            // See bug: http://code.google.com/p/chromium/issues/detail?id=176479
            // As a work around, we allocate Int16Array which results in correct clamping outside of web worker
            if(Uint8Array == Uint8ClampedArray)
                imageData.data = new Int16Array(width*height*4);
            else
                imageData.data = new Uint8ClampedArray(width*height*4);
        }
        this._imageData = imageData;
    }
    this._notifyChanged();
};

/** @param {Object} v */
ImageDataTextureEntry.prototype.setImageData = function(v) {
    this._updateImageData(v);
    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_VALUE);
    Base._flushResultCallbacks();
};

ImageDataTextureEntry.prototype.getWidth = function() {
    return this._imageData && this._imageData.width || 0;
};

ImageDataTextureEntry.prototype.getHeight = function() {
    return this._imageData && this._imageData.height || 0;
};

/** @return {ImageData} */
ImageDataTextureEntry.prototype.getValue = function() {
    return this._imageData;
};

/** @return {SamplerConfig} */
ImageDataTextureEntry.prototype.getSamplerConfig = function(){
    return this._samplerConfig;
};

/** @return {number} */
ImageDataTextureEntry.prototype.getLength = function(){
    return 1;
};
ImageDataTextureEntry.prototype.isEmpty = function(){
    return false;
};


/** @return {number} */
ImageDataTextureEntry.prototype.getIterateCount = function() {
    return 1;
};

//----------------------------------------------------------------------------------------------------------------------
// DataChangeNotifier
//----------------------------------------------------------------------------------------------------------------------


/**
 * Used to listen to modifications of any DataEntry connected to an Xflow graph.
 * @constructor
 */
var DataChangeNotifier = {
    _listeners: []
};

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataChangeNotifier.addListener = function(callback){
    this._listeners.push(callback);
};

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataChangeNotifier.removeListener = function(callback){
    Array.erase(this._listeners, callback);
};

/**
 * @param {DataEntry} dataEntry
 * @param {C.DATA_ENTRY_STATE} notification
 */
function notifyListeners(dataEntry, notification){
    var i;
    // Global notifications
    for(i = 0; i < DataChangeNotifier._listeners.length; ++i){
        DataChangeNotifier._listeners[i](dataEntry, notification);
    }
    // Internal and external listeners
    for(i = 0; i < dataEntry._listeners.length; ++i){
        dataEntry._listeners[i](dataEntry, notification);
    }
}

module.exports = {
    DataEntry: DataEntry,
    BufferEntry: BufferEntry,
    TextureEntry: TextureEntry,
    ImageDataTextureEntry: ImageDataTextureEntry,
    SamplerConfig: SamplerConfig,
    DataChangeNotifier: DataChangeNotifier
};

},{"../../utils/array.js":127,"../base.js":135,"./constants.js":136}],138:[function(require,module,exports){
var C = require("./constants.js");
var Mapping = require("./../processing/mapping.js");
require("../../utils/array.js");

var Base = require("../base.js");
var ChannelNode = require("../processing/channel-node.js").ChannelNode;
var Utils = require("../utils/utils.js");

//----------------------------------------------------------------------------------------------------------------------
// GraphNode
//----------------------------------------------------------------------------------------------------------------------

/**
 * Base class for other graph nodes
 * @constructor
 * @abstract
 * @param {Graph} graph Reference to parent graph
 */
var GraphNode = function(){
    /**
     * All nodes that add a dependency to this node
     * @type array<GraphNode>
     **/
    this._parents = [];
};


//----------------------------------------------------------------------------------------------------------------------
// InputNode
//----------------------------------------------------------------------------------------------------------------------

/**
 * An InputNode include an DataEntry, a name and other information
 * This class mirrors XML3D elements such as <float3>, <int> or <texture>
 *
 * @constructor
 * @param {Graph} graph
 * @extends {GraphNode}
 */
var InputNode = function(){
    GraphNode.call(this);
    /**
     * Name of the input node
     * @type {string}
     * @private
     */
    this._name = "";
    /**
     * Sequence key
     * @type {number}
     * @private
     */
    this._key = 0;
    /**
     * DataEntry node that holds the value
     * @type {DataEntry}
     */
    this._data = null;
    /**
     * If this nodes is a parameter within a <dataflow>
     * this is set to the name of the parameter, otherwise null
     * @type {null|String}
     * @private
     */
    this._paramName = null;

    /**
     * Experimental! Apply different override logic in order
     * to propagate global parameters to the source of the graph
     * Could be used for instance for LOD concepts, where the
     * renderer propagates the distance along the graph
     * @type {boolean}
     * @private
     */
    this._paramGlobal = false;

    /**
     *  Cache listener for DataEntry
     *  @see {InputNode.onDataChange}
     */
    this._dataListener = this.onDataChange.bind(this);
};
Base.createClass(InputNode, GraphNode);

/**
 * Propagate events from DataEntry to parent nodes
 * @param {Object} newValue
 * @param {C.DATA_ENTRY_STATE} notification
 */
InputNode.prototype.onDataChange = function(newValue, notification) {
    var downNote;
    switch(notification){
        case C.DATA_ENTRY_STATE.CHANGED_VALUE: downNote = C.RESULT_STATE.CHANGED_DATA_VALUE; break;
        case C.DATA_ENTRY_STATE.LOAD_START: downNote = C.RESULT_STATE.IMAGE_LOAD_START; break;
        case C.DATA_ENTRY_STATE.LOAD_END: downNote = C.RESULT_STATE.IMAGE_LOAD_END; break;
        case C.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE: downNote = C.RESULT_STATE.CHANGED_STRUCTURE; break;
        case C.DATA_ENTRY_STATE.CHANGED_SIZE: downNote = C.RESULT_STATE.CHANGED_DATA_SIZE; break;
        default: downNote = C.RESULT_STATE.CHANGED_DATA_SIZE; break;
    }
    notifyParentsOnChanged(this,downNote);
};

Object.defineProperty(InputNode.prototype, "name", {
    /** @param {string} v */
    set: function(v){
        this._name = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._name; }
});

Object.defineProperty(InputNode.prototype, "key", {
    /** @param {number} v */
    set: function(v){
        this._key = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {number} */
    get: function(){ return this._key; }
});

Object.defineProperty(InputNode.prototype, "paramName", {
    /** @param {string} v */
    set: function(v){
        this._paramName = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._paramName; }
});

Object.defineProperty(InputNode.prototype, "paramGlobal", {
    /** @param {boolean} v */
    set: function(v){
        this._paramGlobal = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {boolean} */
    get: function(){ return this._paramGlobal; }
});

Object.defineProperty(InputNode.prototype, "data", {
    /** @param {DataEntry} dataEntry */
    set: function(dataEntry){
        var prevDataLoading = false;
        if(this._data) {
            prevDataLoading = this._data._loading;
            this._data.removeListener(this._dataListener);
        }
        this._data = dataEntry;
        if(this._data) {
            this._data.addListener(this._dataListener);
        }
        if(prevDataLoading != this._data._loading){
            notifyParentsOnChanged(this, this._data._loading ? C.RESULT_STATE.IMAGE_LOAD_START :
                C.RESULT_STATE.IMAGE_LOAD_END);
        }
        Base._flushResultCallbacks();
    },
    /** @return {DataEntry} */
    get: function(){ return this._data; }
});

/**
 * Getter for local parameter name, returns null if this is a global
 * parameter
 *
 * @returns {null|String}
 * @private
 */
InputNode.prototype._getParamNames = function(){
    return this._paramGlobal ? null : this._paramName;
};

/**
 * Getter for global parameter name, returns null if this is not a global
 * parameter
 *
 * @returns {null|String}
 * @private
 */
InputNode.prototype._getGlobalParamNames = function(){
    return this._paramGlobal ? this._paramName : null;
};

//----------------------------------------------------------------------------------------------------------------------
// DataNode
//----------------------------------------------------------------------------------------------------------------------
var c_xflowNodeId = 0;
function getXflowNodeId(){
    return ++c_xflowNodeId;
}

/**
 * The DataNode is the central structure of an Xflow Graph.
 * It is used to build a data composition graph as well as a data flow.
 * It mirror the <data> element of XML3D
 *
 * @constructor
 * @param {Graph} graph Context graph
 * @param {boolean} isDataFlow is this node a dataflow
 * @extends {GraphNode}
 */
var DataNode = function(isDataFlow){
    GraphNode.call(this);

    /**
     * Marker, if this data node is expecting data. Xflow
     * is not monitoring any load events. This must be set
     * from external
     * @type {boolean}
     */
    this._loading = false;

    /**
     * Experimental! Priority. How important is this data?
     * 0: Very important
     * @type {number}
     */
    this._loadLevel = 0;

    /**
     * Used for loading events: If progress level
     * reaches infinity, loading events are triggered
     * @type {Number}
     */
    this._progressLevel = Infinity;

    /**
     * Globally unique id
     */
    this.id = getXflowNodeId();

    /**
     * Is this node a proto node
     * @type {boolean}
     */
    this._isProtoNode = isDataFlow;

    /**
     * Children. InputNodes and DataNodes (as found in DOM)
     * @type {Array}
     */
    this._children = [];

    /**
     * The DataNode that has been reference via src
     * @type {DataNode}
     */
    this._sourceNode = null;

    /**
     * Field to attach custom data
     * @type {null|Object}
     */
    this._userData = null;

    /**
     * The filter type of this node (keep, rename, remove ...)
     * @type {DATA_FILTER_TYPE}
     */
    this._filterType = C.DATA_FILTER_TYPE.NONE;

    /**
     * Define the mapping
     * @type {Mapping.Mapping}
     */
    this._filterMapping = null;

    /**
     * String identifier for operator
     * TODO: Operator class
     * @type {string|Object}
     */
    this._computeOperator = "";

    /**
     * True, if compute is a dataflow reference
     * @type {boolean}
     */
    this._computeUsesDataflow = false;

    /**
     * Mapping for input of operator,
     * e.g. (position, texcoord) or ({position: pos, texcoord: uv})
     * @type {Mapping}
     */
    this._computeInputMapping = null;

    /**
     * Mapping for output of operator,
     * e.g. (position, texcoord) = ... or {position: pos, texcoord: uv} = ...
     * @type {Mapping}
     */
    this._computeOutputMapping = null;

    /**
     * If dataflow node has been resolved, this
     * entry is set
     * @type {DataNode}
     */
    this._dataflowNode = null;

    /**
     * Internal (optimized) version of this data node
     * @type {ChannelNode}
     */
    this._channelNode = new ChannelNode(this);

    /**
     * Map of cached channel nodes for dataflow instances with varying
     * input arguments (specialized nodes)
     * TODO: Use WeakMap?
     * @type {Object.<string, ChannelNode>}
     */
    this._substitutionNodes = {};

    /**
     * Cached version of local param names collected from
     * children
     * @type {Array.<string>}
     */
    this._paramNames = null;

    /**
     * Cached version of global param names collected from
     * children
     * @type {Array.<string>}
     */
    this._globalParamNames = null;

    /**
     * Platform, this data node should be executed on
     * TODO: This should be implicit, not explicit
     * @type {null}
     */
    this._platform = null;

    /**
     * Observers of the node's C.RESULT_STATE
     * @type {Array}
     */
    this._listeners = [];

    /**
     * Observers of the node's progress level
     * @type {Array}
     */
    this._loadListeners = [];

};
Base.createClass(DataNode, GraphNode);


Object.defineProperty(DataNode.prototype, "sourceNode", {
    /** @param {?DataNode} newSourceNode */
    set: function(newSourceNode){
        replaceNodeInHierarchy(this, "_sourceNode", newSourceNode);
        updateProgressLevel(this);
        this.notify(C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {?DataNode} */
    get: function(){ return this._sourceNode; }
});

Object.defineProperty(DataNode.prototype, "dataflowNode", {
    /** @param {?DataNode} newDataflowNode */
    set: function(newDataflowNode){
        if(newDataflowNode && !this._computeUsesDataflow) {
            throw new Error("Cannot set dataflowNode when compute doesn't use dataflow.");
        }
        replaceNodeInHierarchy(this, "_dataflowNode", newDataflowNode);
        updateProgressLevel(this);
        this.notify(C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {?DataNode} */
    get: function(){ return this._dataflowNode; }
});


Object.defineProperty(DataNode.prototype, "userData", {
    /** @param {?DataNode} v */
    set: function(v){
        this._userData = v;
    },
    /** @return {?DataNode} */
    get: function(){ return this._userData; }
});

/**
 * Set (from external) if more data is expected.
 * @param {boolean} loading
 */
DataNode.prototype.setLoading = function(loading){
    if(this._loading != loading){
        this._loading = loading;
        this._channelNode.setStructureOutOfSync();
        this._channelNode.loading = loading;
        for (var sub in this._substitutionNodes) {
            var subNode = this._substitutionNodes[sub];
            subNode.setStructureOutOfSync();
            subNode.loading = loading;
        }
        updateProgressLevel(this);
        Base._flushResultCallbacks();
    }
};

/**
 * Returns if this or any child node is loading
 * @returns {boolean}
 */
DataNode.prototype.isSubtreeLoading = function(){
    return this._progressLevel == 0;
};

/**
 * @returns {Number}
 */
DataNode.prototype.getProgressLevel = function(){
    return this._progressLevel;
};


Object.defineProperty(DataNode.prototype, "filterType", {
    /** @param {C.DATA_FILTER_TYPE} v */
    set: function(v){
        this._filterType = v;
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {C.DATA_FILTER_TYPE} */
    get: function(){ return this._filterType; }
});

Object.defineProperty(DataNode.prototype, "filterMapping", {
    /** @param {Mapping} v */
    set: function(v){
        swapMapping(this, "_filterMapping", v);
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {Mapping} */
    get: function(){ return this._filterMapping; }
});

Object.defineProperty(DataNode.prototype, "computeOperator", {
    /** @param {string} v */
    set: function(v){
        this._computeOperator = v;
        this._computeUsesDataflow = false;
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._computeUsesDataflow ? null : this._computeOperator; }
});

Object.defineProperty(DataNode.prototype, "computeDataflowUrl", {
    /** @param {string} v */
    set: function(v){
        this._computeOperator = v;
        this._computeUsesDataflow = true;
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._computeUsesDataflow ? this._computeOperator : null; }
});

Object.defineProperty(DataNode.prototype, "computeInputMapping", {
    /** @param {Mapping} v */
    set: function(v){
        swapMapping(this, "_computeInputMapping", v);
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {Mapping} */
    get: function(){ return this._computeInputMapping; }
});
Object.defineProperty(DataNode.prototype, "computeOutputMapping", {
    /** @param {Mapping} v */
    set: function(v){
        swapMapping(this, "_computeOutputMapping", v);
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {Mapping} */
    get: function(){ return this._computeOutputMapping; }
});

//noinspection JSUnusedGlobalSymbols
DataNode.prototype.isProtoNode = function(){
    return this._isProtoNode;
};

/**
 * @param {GraphNode} child
 */
DataNode.prototype.appendChild = function(child){
    this._children.push(child);
    addParent(this, child);
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};
/**
 * @param {GraphNode} child
 */
DataNode.prototype.removeChild = function(child){
    Array.erase(this._children, child);
    removeParent(this, child);
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * @param {GraphNode} child
 * @param {GraphNode} beforeNode
 */
DataNode.prototype.insertBefore = function(child, beforeNode){
    var idx = this._children.indexOf(beforeNode);
    if(idx == -1)
        this._children.push(child);
    else
        this._children.splice(idx, 0, child);
    addParent(this, child);
    // TODO: Next three calls on all structural changes. Add Method
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * remove all children of the DataNode
 */
DataNode.prototype.clearChildren = function(){
    for(var i =0; i < this._children.length; ++i){
        removeParent(this, this._children[i]);
    }
    this._children = [];
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

//noinspection JSUnusedGlobalSymbols
/**
 * Detach this DataNode from all connections, including source- and proto-node references
 */
DataNode.prototype.detachFromParents = function(){
    for(var i =0; i < this._parents.length; ++i){
        var parent = this._parents[i];
        if(parent._sourceNode == this)
            parent.sourceNode = null;
        else if(parent._dataflowNode == this){
            parent.dataflowNode = null;
        }
        else{
            parent.removeChild(this);
        }
    }
    this._children = [];
};

/**
 * Sets platform of a DataNode. If _platform is defined, it will override the default platform setting of
 * an Xflow graph.
 *
 * @param {String|C.PLATFORM|null} platformSrc
 */
DataNode.prototype.setPlatform = function(platformSrc) {
    if (typeof platformSrc === 'string') {
        if (platformSrc === "cl") {
            this._platform = C.PLATFORM.CL;
        }
        else if (platformSrc === "gl") {
            this._platform = C.PLATFORM.GLSL;
        }
        else if (platformSrc === "js") {
            this._platform = C.PLATFORM.JAVASCRIPT;
        }
    } else if (!isNaN(parseFloat(platformSrc)) && isFinite(platformSrc)) {
        this._platform = platformSrc;
    } else {
        this._platform = null;
    }

    this.notify(C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * @const
 */
var filterParser = /^([A-Za-z\s]*)\(([^()]+)\)$/;

/**
 * Set filter by string
 * @param {string} filterString
 */
DataNode.prototype.setFilter = function(filterString){
    filterString = filterString || "";
    var newType = C.DATA_FILTER_TYPE.RENAME;
    var newMapping = null;
    if(filterString){
        var result = filterString.trim().match(filterParser);
        if(result){
            var type = result[1].trim();
            switch(type){
                case "keep": newType = C.DATA_FILTER_TYPE.KEEP; break;
                case "remove": newType = C.DATA_FILTER_TYPE.REMOVE; break;
                case "rename": newType = C.DATA_FILTER_TYPE.RENAME; break;
                default:
                    Base.notifyError("Unknown filter type:" + type, this);
            }
            newMapping = Mapping.Mapping.parse(result[2], this);
        }
        else{
            Base.notifyError("Could not parse filter '" + filterString + "'", this);
        }
    }
    if(!newMapping){
        // TODO Remove this? (Mapping can be null from now on)
        newMapping = new Mapping.OrderMapping();
    }
    swapMapping(this, "_filterMapping", newMapping);
    this._filterType = newType;
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

var computeParser = /^(([^=]+)\=)?([^'(]+('[^']+')?[^'(]+)(\(([^()]*)?\))?$/;
var bracketsParser = /^\(([^()]*)\)$/;
var dataflowParser = /^dataflow\['([^']+)'\]$/;

//noinspection JSUnusedGlobalSymbols
/**
 * If the compute string contains a reference to an external dataflow,
 * the parser returns its URL. Null, otherwise
 * @param computeString
 * @returns {string|null}
 */
var getComputeDataflowUrl = function(computeString){
    computeString = computeString || "";
    var result = computeString.trim().match(computeParser);
    if(result){
        if(result = result[3].trim().match(dataflowParser)){
            return result[1];
        }
    }
    return null;
};

/**
 * Set compute by string
 * @param {string} computeString
 */
DataNode.prototype.setCompute = function(computeString){
    computeString = computeString || "";
    var newOperator = "";
    var inputMapping = null, outputMapping = null;
    var result = computeString.trim().match(computeParser);
    if(result){
        var output = result[2] ? result[2].trim() : "";
        newOperator = result[3].trim();
        var input = result[6] ? result[6].trim() : "";
        if(result = output.match(bracketsParser)){
            output = result[1];
        }
        if(input)
            inputMapping = Mapping.Mapping.parse(input, this);
        if(output)
            outputMapping = Mapping.Mapping.parse(output, this);

        if(result = newOperator.match(dataflowParser)){
            this._computeUsesDataflow = true;
            newOperator = result[1];
        }
        else{
            this._computeUsesDataflow = false;
        }
        this._dataflowNode = null;
    }
    else if(computeString){
        Base.notifyError("Error parsing Compute value '" + computeString + "'", this);
    }
    swapMapping(this, "_computeInputMapping", inputMapping);
    swapMapping(this, "_computeOutputMapping", outputMapping);
    this._computeOperator = newOperator;
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * Notifies DataNode about a change. Notification will be forwarded to parents, if necessary
 * @param {C.RESULT_STATE} changeType
 * @param {GraphNode?} senderNode
 */
DataNode.prototype.notify = function(changeType, senderNode){
    //noinspection FallthroughInSwitchStatementJS
    switch(changeType) {
        case C.RESULT_STATE.CHANGED_STRUCTURE:
            this._paramNames = null;
            this._globalParamNames = null;
            this._channelNode.setStructureOutOfSync();
            clearSubstitutionNodes(this);
            notifyParentsOnChanged(this, changeType);
            break;

        case C.RESULT_STATE.IMAGE_LOAD_START:
        case C.RESULT_STATE.IMAGE_LOAD_END:
            updateProgressLevel(this);
            if(senderNode){
                this._channelNode.notifyDataChange(senderNode, changeType);
            }
            break;

        case C.RESULT_STATE.CHANGED_DATA_VALUE:
        case C.RESULT_STATE.CHANGED_DATA_SIZE:
            if(senderNode){
                this._channelNode.notifyDataChange(senderNode, changeType);
            }
            break;
    }
    // Inform listeners (e.g. Requests)
    for(var i = 0; i < this._listeners.length; ++i) {
        this._listeners[i](changeType);
    }
};

DataNode.prototype.addListener = function(listener){
    this._listeners.push(listener)
};

DataNode.prototype.removeListener = function(listener) {
    Array.erase(this._listeners, listener);
};

DataNode.prototype.addLoadListener = function(listener){
    this._loadListeners.push(listener);
};

//noinspection JSUnusedGlobalSymbols
DataNode.prototype.removeLoadListener = function(listener){
    Array.erase(this._loadListeners, listener);
};

DataNode.prototype._callLoadListeners = function(newLevel, oldLevel){
    var len = this._loadListeners.length;
    for(var i = 0; i < len; ++i){
        this._loadListeners[i](this, newLevel, oldLevel);
    }
};

DataNode.prototype.getOutputNames = function(){
    return getForwardNode(this)._channelNode.getOutputNames();
};

DataNode.prototype.getOutputChannelInfo = function(name){
    return getForwardNode(this)._channelNode.getOutputChannelInfo(name);
};

//noinspection JSUnusedGlobalSymbols
DataNode.prototype.getParamNames = function(){
    return this._getParamNames();
};

/**
 * Delegate computation of the result to the channel node
 * of the first contributing DataNode.
 * @param type
 * @param filter
 * @returns {Result}
 */
DataNode.prototype._getResult = function(type, filter){
    return getForwardNode(this, filter)._channelNode.getResult(type, filter);
};

DataNode.prototype._getForwardNode = function(filter){
    return getForwardNode(this, filter);
};

DataNode.prototype._getParamNames = function(){
    if(!this._paramNames){
        this._paramNames = [];
        if(this._sourceNode)
            Utils.nameset.add(this._paramNames, this._sourceNode._getParamNames());
        else{
            for(var i = 0; i < this._children.length; ++i){
                Utils.nameset.add(this._paramNames, this._children[i]._getParamNames());
            }
        }
    }
    return this._paramNames;
};

DataNode.prototype._getGlobalParamNames = function(){
    if(!this._globalParamNames){
        this._globalParamNames = [];
        if(this._dataflowNode)
            Utils.nameset.add(this._globalParamNames, this._dataflowNode._getGlobalParamNames());

        if(this._sourceNode)
            Utils.nameset.add(this._globalParamNames, this._sourceNode._getGlobalParamNames());
        else{
            for(var i = 0; i < this._children.length; ++i){
                Utils.nameset.add(this._globalParamNames, this._children[i]._getGlobalParamNames());
            }
        }
    }
    return this._globalParamNames;
};

/**
 * @param {Substitution} substitution
 * @returns {ChannelNode}
 */
DataNode.prototype._getOrCreateChannelNode = function(substitution){
    if(!substitution)
        return this._channelNode;
    else{
        var key = substitution.getKey(this);
        if(!this._substitutionNodes[key]) {
            this._substitutionNodes[key] = new ChannelNode(this, substitution);
        } else {
            this._substitutionNodes[key].increaseRef();
        }
        return this._substitutionNodes[key];
    }
};

/**
 * Remove ChannelNode passed as argument from internal substitution nodes
 * Decreases reference counter of substitution node and deletes it if not
 * used by any other node.
 * @param {ChannelNode} substitutionNode
 */
DataNode.prototype._removeSubstitutionNode = function(substitutionNode){
    var key = substitutionNode.substitution.getKey(this);
    if(this._substitutionNodes[key] && this._substitutionNodes[key].decreaseRef())
        delete this._substitutionNodes[key];
};

/**
 * Calls clear of all substitutionNodes and clears the map
 * @param {DataNode} dataNode
 */
function clearSubstitutionNodes(dataNode){
    for(var name in dataNode._substitutionNodes){
        dataNode._substitutionNodes[name].clear();
    }
    dataNode._substitutionNodes = {};
}

/**
 * Skips nodes, if it does not contribute to the result (optimization)
 * @param {DataNode} dataNode
 * @param {array.<string>?} filter
 * @returns {DataNode}
 */
function getForwardNode(dataNode, filter){
    var hasFilter = (dataNode._filterMapping && !dataNode._filterMapping.isEmpty());
    if(hasFilter)
        return dataNode;

    if(!dataNode._computeOperator ){
        if(dataNode._sourceNode && dataNode._children.length == 0)
            return getForwardNode(dataNode._sourceNode);
        if(dataNode._children.length == 1 && dataNode._children[0] instanceof DataNode)
            return getForwardNode(dataNode._children[0]);
    }

    var idx = dataNode._channelNode.getChildDataIndex(filter);
    if(idx != -1 && idx != undefined){
        if(dataNode._sourceNode)
            return getForwardNode(dataNode._sourceNode);
        else
            return getForwardNode(dataNode._children[idx]);
    }
    return dataNode;
}


/**
 * Computes the progress level
 * @private
 * @param {DataNode} node
 */
function updateProgressLevel(node){
    var progressLevel = node._loading ? node._loadLevel : Infinity;
    var i;

    for(i = 0; progressLevel && i < node._children.length; ++i){
        var child = node._children[i];
        if(child instanceof DataNode){
            progressLevel = Math.min(progressLevel, Math.max(child._loadLevel, child._progressLevel) );
        }
        else if(child._data && child._data.isLoading && child._data.isLoading()){
            progressLevel = Math.min(progressLevel, 1);
        }
    }
    if(progressLevel && node._sourceNode){
        progressLevel = Math.min(progressLevel, Math.max(node._sourceNode._loadLevel, node._sourceNode._progressLevel));
    }
    if(progressLevel && node._dataflowNode){
        progressLevel = Math.min(progressLevel, Math.max(node._dataflowNode._loadLevel, node._dataflowNode._progressLevel));
    }
    var oldLevel = node._progressLevel;
    node._progressLevel = progressLevel;

    if(oldLevel != node._progressLevel){
        node._callLoadListeners(node._progressLevel, oldLevel);
        for(i = 0; i < node._parents.length; ++i)
            updateProgressLevel(node._parents[i]);
    }
}

//----------------------------------------------------------------------------------------------------------------------
// Helpers
//----------------------------------------------------------------------------------------------------------------------


/**
 * @private
 * @param {DataNode} parent
 * @param {GraphNode} child
 */
function addParent(parent, child){
    child._parents.push(parent);
}

/**
 * @private
 * @param {DataNode} parent
 * @param {GraphNode} child
 */
function removeParent(parent, child){
    Array.erase(child._parents, parent);
}

/**
 * Notify all parent nodes about a change
 * @param {GraphNode} node
 * @param {exports.C.RESULT_STATE} changeType
 * @private
 */
function notifyParentsOnChanged(node, changeType){
    for(var i = 0; i < node._parents.length; ++i){
        node._parents[i].notify(changeType, node);
    }
}

/**
 * Update the owners of the mappings
 * @param {DataNode} dataNode
 * @param {string} key
 * @param {Mapping} mapping
 */
function swapMapping(dataNode, key, mapping){
    dataNode[key] && dataNode[key]._removeOwner(dataNode);
    dataNode[key] = mapping;
    dataNode[key] && dataNode[key]._addOwner(dataNode);
}

function replaceNodeInHierarchy(node, field, newChild) {
    var oldChild = node[field];
    if(oldChild) {
        removeParent(node, oldChild);
    }
    node[field] = newChild;
    if(newChild) {
        addParent(node, newChild);
    }
}

module.exports = {
    InputNode: InputNode,
    DataNode: DataNode,
    getComputeDataflowUrl: getComputeDataflowUrl
};

},{"../../utils/array.js":127,"../base.js":135,"../processing/channel-node.js":179,"../utils/utils.js":187,"./../processing/mapping.js":183,"./constants.js":136}],139:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./constants.js");
var DataNode = require("./graph.js").DataNode;

/**
 * Content of this file:
 * Classes to request results from an Xflow graph.
 */

/**
 * Abstract Request class.
 * Any Request is created from a DataNode to receive the result of that DataNode.
 * To allow effective optimization, it is recommended to create only one Request per DataNode and receive all
 * results through that Request.
 * @abstract
 * @param {DataNode} dataNode The DataNode from which to request results
 * @param {?Array.<string>} filter A list of names filtering the values to be received (only return values with names inside the filter)
 * @param {?function} callback A callback function that gets called whenever the result of the Request changes
 */
var Request = function(dataNode, filter, callback){
    this._dataNode = dataNode;
    this._filter = filter ? filter.slice().sort() : null;
    this._listener = callback;

    /**
     * Cached result of this request
     * @type {Result}
     */
    this._result = null;

    /**
     * Cached callback function attached to data node
     * @private
     */
    this._dataNodeListener = this._onDataNodeChange.bind(this);

    this._dataNode.addListener(this._dataNodeListener);
};

Object.defineProperty(Request.prototype, "dataNode", {
    set: function(){
       throw new Error("dataNode is readonly");
    },
    get: function(){ return this._dataNode; }
});

Object.defineProperty(Request.prototype, "filter", {
    set: function(){
        throw new Error("filter is read-only");
    },
    get: function(){ return this._filter; }
});

/**
 * Call this function, whenever the request is not required anymore.
 * Cleans up cached data and listeners
 */
Request.prototype.clear = function(){
    this._listener = null;
    if(this._result) this._result._removeRequest(this);
    this._dataNode.removeListener(this._dataNodeListener);
};

/**
 * @param {C.RESULT_STATE} data
 * @private
 */
Request.prototype._onPostponedResultChanged = function(data){
    this._listener && this._listener(this, data);
};

/**
 * Change the result of the request and update request list of old and new
 * result.
 * @private
 * @param {Request} request
 * @param {Result?} newResult
 * @returns {Result}
 */
function swapResultRequest(request, newResult){
    if(request._result) request._result._removeRequest(request);
    request._result = newResult;
    if(newResult) newResult._addRequest(request);
    return newResult;
}

/**
 * @param {Request} request
 * @param {C.RESULT_STATE} notification
 * @private
 */
function notifyListeners(request, notification){
    Base._queueResultCallback(request, notification);
}

/**
 * @param {C.RESULT_STATE} notification
 */
Request.prototype._onDataNodeChange = function(notification){
    notifyListeners(this, notification);
};

/**
 * A ComputeRequest is a Request for a ComputeResult, which contains a named map of typed values.
 * @constructor
 * @extends {Request}
 * @param {DataNode} dataNode The DataNode from which to request results
 * @param {?Array.<string>} filter A list of names filtering the values to be received (only return values with names inside the filter)
 * @param {?function} callback A callback function that gets called whenever the result of the Request changes
 */
var ComputeRequest = function(dataNode, filter, callback){
    Request.call(this, dataNode, filter, callback);
};
Base.createClass(ComputeRequest, Request);

/**
 * @returns {Result}
 */
ComputeRequest.prototype.getResult = function(){
    // swapResultRequest is called here because the result object of the request may change, e.g.
    // different forward node.
    return swapResultRequest(this, this._dataNode._getResult(C.RESULT_TYPE.COMPUTE, this._filter));
};

ComputeRequest.prototype._onResultChanged = function(notification){
    this._onDataNodeChange(notification);
};


var c_vsConnectNodeCount = {},
    c_vsConnectNodeKey = {},
    c_vsConnectNodeCache = {};

/**
 * A VertexShaderRequest is a Request for a VSDataResult, used to generate a VertexShader that includes
 * dataflow processing.
 * @constructor
 * @extends {Request}
 * @param {DataNode} dataNode
 * @param {VSConfig} vsConfig Configuration for the output of the generated vertex shader
 * @param {?function} callback A callback function that gets called whenever the result of the Request changes
 */
var VertexShaderRequest = function(dataNode, vsConfig, callback){
    var filter = vsConfig.getFilter();
    if(filter.length == 0)
        throw new Error("vsConfig requires at least one attribute entry.");
    Request.call(this, dataNode, filter, callback);
    this._vsConfig = vsConfig;
    this._vsConnectNode = getVsConnectNode(dataNode, vsConfig);
};
Base.createClass(VertexShaderRequest, Request);

VertexShaderRequest.prototype.getConfig = function(){
    return this._vsConfig;
};

/**
 * @see ComputeRequest.getResult
 * @returns {Result}
 */
VertexShaderRequest.prototype.getResult = function(){
    return swapResultRequest(this, this._vsConnectNode._getResult(C.RESULT_TYPE.VS, this._filter));
};

VertexShaderRequest.prototype._onDataNodeChange = function(notification){
    if(notification == C.RESULT_STATE.CHANGED_STRUCTURE){
        var newVSConnectedNode = getVsConnectNode(this._dataNode, this._vsConfig, this._filter);
        if(newVSConnectedNode != this._vsConnectNode){
            clearVsConnectNode(this._vsConnectNode);
            this._vsConnectNode = newVSConnectedNode;
        }
    }
    Request.prototype._onDataNodeChange.call(this, notification);
};

VertexShaderRequest.prototype.getVertexShader = function(){
    this.getResult(); // Update the result first
    if(!this._vertexShader){
        this._vertexShader = this._result.getVertexShader(this._vsConfig);
    }
    return this._vertexShader;
};

VertexShaderRequest.prototype._onResultChanged = function(result, notification){
    this._onDataNodeChange(notification);
};

function getVsConnectNode(dataNode, vsConfig, filter){
    var forwardNode = dataNode._getForwardNode(filter);

    var key = getDataNodeShaderKey(forwardNode, vsConfig);
    var connectNode;
    if(!(connectNode = c_vsConnectNodeCache[key])){
        connectNode = new DataNode(false);
        connectNode.appendChild(forwardNode);

        connectNode.computeOperator = vsConfig.getOperator();
        connectNode.computeInputMapping = null;
        connectNode.computeOutputMapping = null;

        c_vsConnectNodeCache[key] = connectNode;
        c_vsConnectNodeCount[connectNode.id] = 1;
        c_vsConnectNodeKey[connectNode.id] = key;
    }
    else{
        c_vsConnectNodeCount[connectNode.id]++;
    }

    return connectNode;
}

function clearVsConnectNode(connectNode){
    c_vsConnectNodeCount[connectNode.id]--;
    if(!c_vsConnectNodeCount[connectNode.id]){
        var key = c_vsConnectNodeKey[connectNode.id];
        c_vsConnectNodeCache[key] = null;
        connectNode.clearChildren();
    }
}


function getDataNodeShaderKey(dataNode, vsConfig){
    return dataNode.id + "|" + vsConfig.getKey();
}

module.exports = {
    ComputeRequest:  ComputeRequest,
    VertexShaderRequest: VertexShaderRequest
};

},{"../base.js":135,"./constants.js":136,"./graph.js":138}],140:[function(require,module,exports){
var C =require("../interface/constants.js");

/**
 * CLProgram implements automatic Xflow input/output adaptive WebCL kernel and application code generation.
 *
 * @param operatorList
 * @constructor
 */

var CLProgram = function (operatorList) {
    this.cl = XML3D.webcl.cl; // CL wrapper

    if (!this.cl) {
        return;
    }

    this.list = operatorList;
    this.entry = operatorList.entries[0];
    this.operator = this.entry.operator;

    this.kernelParamMap = {inputs: [], outputs: []}; // Stores initialised KernelParam objects
    this.kernelFunctionParams = []; // Stores generated function parameters for kernel function header.
    this.kernelCode = null; // Generated kernel code
    this.kernelProgram = null; // Compiled kernel program
    this.mainProgram = null; // Main WebCL application code

};

/**
 * Map of helper kernel parameters required for certain input data types.
 *
 * @type Object
 */
var helperParamMap = {
    'texture': {type: "uint", params: ["width", "height"]}, 'buffer': {type: "uint", params: ["length"]}
};

/**
 * Utility prototype object for mapping Xflow inputs to kernel parameters and for generating kernel code.
 *
 * @param {Object} program
 * @param {String} name
 * @param {C.DATA_TYPE} xflowType
 * @param {String} clType
 * @param entryValue
 * @param {Boolean?} isInput
 * @name KernelParam
 * @constructor KernelParam
 */

function KernelParam(program, name, xflowType, clType, entryValue, isInput) {
    this.program = program;
    this.cl = program.cl;
    this.name = name;
    this.type = clType || null;
    this.isInput = !!isInput;
    this.needsMemObject = false;
    this.hasMemObject = false;
    this.byteSize = null;
    this.memObjectSize = null;
    this.arg = null;
    this.clFunctionParam = null;
    this.xflowType = xflowType;
    this.helperMap = null;
    this.helpers = [];
    this.entryValue = entryValue || null;
    this.val = null;

    this.prepareParam();
    this.initHelperParams();
    this.initKernelArg();
    this.updateValue(this.entryValue);

}

KernelParam.prototype = {
    /**
     * Prepares the kernel parameter data.
     * Maps the input xflow data type to webcl data type and creates a kernel function header parameter with proper
     * declarations.
     */
    prepareParam: function () {
        var helperMap;
        var xflowDataTypes = C.DATA_TYPE;
        var kernelFuncParam = [];
        var addressSpace = '';
        var declarations = '';

        if (!this.type) {
            switch (this.xflowType) {
                case xflowDataTypes.TEXTURE:
                {
                    helperMap = helperParamMap.texture;
                    this.type = "uchar4*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.INT:
                {
                    this.type = "int";
                }
                    break;
                case xflowDataTypes.INT4:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "int4*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT:
                {
                    this.type = "float";
                }
                    break;
                case xflowDataTypes.FLOAT2:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float2*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT3:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT4:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float4*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT4X4:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float16*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                default:
                    return;
            }

            this.helperMap = helperMap;
        }

        // Arranging parameter parts
        if (addressSpace) {
            kernelFuncParam.push(addressSpace);
        }

        if (this.isInput) {
            declarations = 'const';
        }

        if (declarations) {
            kernelFuncParam.push(declarations);
        }

        kernelFuncParam.push(this.type);
        kernelFuncParam.push(this.name);
        this.clFunctionParam = kernelFuncParam.join(' ');
    },

    /**
     * Initialises helper parameters for an input parameter if needed.
     *
     */

    initHelperParams: function () {
        var helperVal;
        var self = this;
        var helperMap = this.helperMap;

        if (helperMap && this.isInput) {
            helperMap.params.forEach(function (p) {
                var pName = self.name + '_' + p;
                if (p === "width") {
                    helperVal = self.entryValue.width;
                } else if (p === "height") {
                    helperVal = self.entryValue.height;
                } else if (p === "length") {
                    helperVal = self.entryValue.length;
                    var type = self.xflowType;
                    switch (type) {
                        case C.DATA_TYPE.FLOAT2:
                        {
                            helperVal = helperVal / 2;
                        }
                            break;
                        case C.DATA_TYPE.FLOAT3:
                        {
                            helperVal = helperVal / 3;
                        }
                            break;
                        case C.DATA_TYPE.FLOAT4:
                        case C.DATA_TYPE.INT4:
                        {
                            helperVal = helperVal / 4;
                        }
                            break;
                        case C.DATA_TYPE.FLOAT4X4:
                        {
                            helperVal = helperVal / 16;
                        }
                            break;
                        default:
                            break;
                    }
                }
                self.helpers.push(new KernelParam(self.program, pName, null, helperMap.type, new Uint32Array([helperVal])));
            });
        }
    },

    /**
     * Initialises kernel argument that will be passed directly into the compiled kernel.
     * Creates a WebCL memory object if needed (e.g. for texture).
     */

    initKernelArg: function () {
        if (this.needsMemObject) {
            this.allocateMemObject();
        } else {
            this.arg = this.entryValue;
        }
    },

    allocateMemObject: function () {
        var clAPI = this.cl.API;
        var clCtx = this.cl.ctx;
        var paramType = this.type;
        var byteSize = parseInt(paramType.substring(paramType.length - 2, paramType.length - 1), 10);
        var memObjectMode = this.isInput ? 'r' : 'w';
        var entryValue = this.entryValue;
        var memObjectSize, memObject;

        if (this.hasMemObject) {
            this.arg.release();
        }

        this.byteSize = isNaN(byteSize) ? 1 : byteSize;

        if (this.xflowType === C.DATA_TYPE.TEXTURE) { // Texture is a special case
            memObjectSize = entryValue.width * entryValue.height * byteSize;
            this.byteSize = 4;
        } else {
            switch (this.xflowType) {
                case C.DATA_TYPE.INT4:
                {
                    memObjectSize = entryValue.length * Int32Array.BYTES_PER_ELEMENT;
                }
                    break;
                case C.DATA_TYPE.FLOAT2:
                case C.DATA_TYPE.FLOAT3:
                case C.DATA_TYPE.FLOAT4:
                case C.DATA_TYPE.FLOAT4x4:
                {
                    memObjectSize = entryValue.length * Float32Array.BYTES_PER_ELEMENT;
                }
                    break;
                default:
                    memObjectSize = entryValue.length * 4;
                    break;
            }
        }

        memObject = clAPI.createBuffer(memObjectSize, memObjectMode, clCtx);

        this.memObjectSize = memObjectSize;
        this.arg = memObject;

        this.hasMemObject = true;
        this.needsMemObject = false;

    },

    updateValue: function (entry) {
        if (this.hasMemObject) {
            this.val = entry.data === undefined ? entry : entry.data;
            this.entryValue = entry;
            this.checkEntrySize();
        } else {
            this.arg = this.entryValue = entry;
        }
    }, updateHelpers: function () {
        var helpers = this.helpers;
        var self = this;

        helpers.forEach(function (p) {
            var name = p.name;
            if (name.indexOf("width") !== -1) {
                p.updateValue(new Uint32Array([self.entryValue.width]));
            } else if (name.indexOf("height") !== -1) {
                p.updateValue(new Uint32Array([self.entryValue.height]));
            } else if (name.indexOf("length") !== -1) {
                var len = self.entryValue.length;
                if (self.xflowType === C.DATA_TYPE.FLOAT4 || self.xflowType === C.DATA_TYPE.INT4) {
                    len = len / 4;
                } else if (self.xflowType === C.DATA_TYPE.FLOAT4X4) {
                    len = len / 16;
                }
                p.updateValue(new Uint32Array([len]));
            }
        });
    }, checkEntrySize: function () {
        var newSize;
        var entryVal = this.entryValue;

        if (this.xflowType === C.DATA_TYPE.TEXTURE) {
            newSize = entryVal.width * entryVal.height * this.byteSize;
        } else if (this.xflowType === C.DATA_TYPE.FLOAT2 || this.xflowType === C.DATA_TYPE.FLOAT3 || this.xflowType === C.DATA_TYPE.FLOAT4 || this.xflowType === C.DATA_TYPE.FLOAT4X4) {
            newSize = entryVal.length * Float32Array.BYTES_PER_ELEMENT;
        } else if (this.xflowType === C.DATA_TYPE.INT4) {
            newSize = entryVal.length * Int32Array.BYTES_PER_ELEMENT;
        } else {
            newSize = entryVal.length * this.byteSize;
        }
        if (this.memObjectSize !== newSize) {
            this.allocateMemObject();
            this.updateHelpers();
            this.program.mainProgram = null; // Forcing CL application program update
        }
    }
};


/**
 * Runs CLProgram. WebCL related code initialised in the first run.
 *
 * @param programData
 */

CLProgram.prototype.run = function (programData) {
    var operatorData = prepareOperatorData(this.list, 0, programData);

    applyDefaultOperation(this.entry, programData, operatorData, this);

};

function prepareOperatorData(list, idx, programData) {
    var doIterate, i;
    var data = programData.operatorData[0];
    var entry = list.entries[idx];
    var mapping = entry.operator.mapping;

    data.iterFlag = {};

    for (i = 0; i < mapping.length; ++i) {
        doIterate = (entry.isTransferInput(i) || list.isInputIterate(entry.getDirectInputIndex(i)));
        data.iterFlag[i] = doIterate;
    }

    data.iterateCount = list.getIterateCount(programData);

    return data;
}

function applyDefaultOperation(entry, programData, operatorData, program) {
    if (program.operator.evaluate && program.operator.evaluate instanceof Array) {
        assembleFunctionArgs(entry, programData, program);

        if (program.kernelCode === null) {
            prepareWebCLKernel(programData, program);
        }
        //console.time('CLProgram (' + program.operator.name + ')');
        if (program.mainProgram === null) {
            program.mainProgram = createMainWebCLProgram(program);
        }
        program.mainProgram();
        //console.timeEnd('CLProgram (' + program.operator.name + ')');
    }
}

/**
 * Maps Xflow inputs and outputs into WebCL kernel inputs and outputs.
 *
 * @function assembleFunctionArgs
 * @param entry
 * @param programData
 * @param program
 */

function assembleFunctionArgs(entry, programData, program) {
    var d, dataEntry, i;
    var kernelFunctionParams = program.kernelFunctionParams;
    var outputs = program.operator.outputs;

    kernelFunctionParams.length = 0;

    for (i = 0; i < outputs.length; ++i) {
        d = outputs[i];
        dataEntry = programData.outputs[entry.getOutputIndex(i)].dataEntry;

        prepareKernelParameter(d, !!(d.source), program, kernelFunctionParams, dataEntry, i);
    }

    addInputToArgs(entry, programData, program, kernelFunctionParams);
}


function addInputToArgs(entry, programData, program, kernelFunctionParams) {
    var mapEntry, dataEntry, i;
    var mapping = entry.operator.mapping;

    for (i = 0; i < mapping.length; ++i) {
        mapEntry = mapping[i];
        dataEntry = programData.getDataEntry(entry.getDirectInputIndex(i));

        prepareKernelParameter(mapEntry, !!(mapEntry.source), program, kernelFunctionParams, dataEntry, i);
    }
}

/**
 * Creates a new KernelParam utility object or updates the existing object if input value has been changed.
 * Additionally, this is used for generating the WebCL kernel function header.
 *
 * @function prepareKernelParameter
 * @param param
 * @param input
 * @param program
 * @param functionParams
 * @param arg
 * @param i
 */

function prepareKernelParameter(param, input, program, functionParams, arg, i) {
    var kernelParams;
    var entryVal = arg ? arg.getValue() : null;

    if (input) {
        kernelParams = program.kernelParamMap.inputs;
    } else {
        kernelParams = program.kernelParamMap.outputs;
    }

    if (kernelParams[i]) {
        kernelParams[i].updateValue(entryVal);
        return;
    }

    kernelParams[i] = new KernelParam(program, param.name, param.type, null, entryVal, input);

    // Pushing generated kernel function params into array.
    // This array is later used in generating the WebCL kernel function header.
    functionParams.push(kernelParams[i].clFunctionParam);

    kernelParams[i].helpers.forEach(function (p) {
        functionParams.push(p.clFunctionParam);
    });
}


/** KERNEL CODE PREPARATION **/


/**
 * Compiles and registers the prepared WebCL kernel code.
 *
 * @function prepareWebCLKernel
 * @param programData
 * @param program
 * @returns {boolean}
 */

function prepareWebCLKernel(programData, program) {
    var kernelCode;
    var kernelManager = program.cl.kernelManager;
    var inputKernel = program.operator.evaluate;
    var kernelName = program.kernelName = program.operator.name.split('xflow.')[1];

    if (!inputKernel) {
        return false;
    }

    kernelCode = program.kernelCode = prepareKernelCode(kernelName, inputKernel, program);

    try {
        kernelManager.register(kernelName, kernelCode);
    } catch (e) {
        return false;
    }

    program.kernelProgram = kernelManager.getKernel(program.kernelName);

    return true;
}

/**
 *
 * Generates kernel function header and helper kernel code and combines it with user's input kernel code.
 *
 * @function prepareKernelCode
 * @param {String} kernelName
 * @param {Array} inputKernel
 * @param program
 * @returns {String}
 */

function prepareKernelCode(kernelName, inputKernel, program) {
    var result, innerKernelCode;

    result = createKernelHeader(kernelName, program);

    if (!result) {
        return false;
    }

    result += '{\n';

    innerKernelCode = createInnerKernelCode(program);

    if (!innerKernelCode) {
        return false;
    }

    result += innerKernelCode;
    result += inputKernel.join('\n');
    result += '\n}';

    return result;
}

/**
 * Generates a kernel function header from assembled kernel parameters.
 *
 * @function createKernelHeader
 * @param kernelName
 * @param program
 * @returns {string}
 */

function createKernelHeader(kernelName, program) {
    var functionHeader = [];

    functionHeader.push("__kernel void");
    functionHeader.push(kernelName + '(');
    functionHeader.push(program.kernelFunctionParams.join(', '));
    functionHeader.push(')');

    return functionHeader.join(' ');
}

/**
 * Generates helper kernel code.
 *
 * @function createInnerKernelCode
 * @param program
 * @returns {string}
 */

function createInnerKernelCode(program) {
    var codeLines = [];

    var firstInput = program.kernelParamMap.inputs[0];

    if (firstInput.type === "uchar4*") {
        // Add "iterators"
        codeLines.push("int x = get_global_id(0);");
        codeLines.push("int y = get_global_id(1);");

        // Add bounds checkers
        codeLines.push("if (x >= " + firstInput.name + "_width || y >= " + firstInput.name + "_height) return;");

        // Add input iterator
        codeLines.push("int " + firstInput.name + "_i = y * " + firstInput.name + "_width + x;");

    } else { // Else, assuming that the first input is an 1-dimensional buffer

        codeLines.push("int " + firstInput.name + "_i = get_global_id(0);");

        codeLines.push("if (" + firstInput.name + "_i >= " + firstInput.name + "_length) return;");
    }

    return codeLines.join('\n');

}


/** MAIN WEBCL PROGRAM INITIALISATION **/

/**
 * Initialises the main WebCL application code that executes the WebCL kernel
 *
 * @function createMainWebCLProgram
 * @param program
 * @returns {Function}
 */

function createMainWebCLProgram(program) {
    var cl = program.cl;
    var kernelManager = cl.kernelManager;
    var cmdQueue = cl.cmdQueue;
    var memObjects = {inputs: [], outputs: []};
    var assembledArgs = assembleKernelArguments(program.kernelParamMap, memObjects);
    var WSSizes = computeWorkGroupSize(program.kernelParamMap.inputs[0]);
    var kernel = program.kernelProgram;

    return function () {
        var i, len, memObj, args;
        var inputMemObjs = memObjects.inputs;
        var outputMemObjs = memObjects.outputs;

        if (!kernel) {
            return false;
        }

        args = assembledArgs.map(function (a) {
            return a.arg;
        });

        kernelManager.setArgs.apply(null, [kernel].concat(args));

        try {
            // Write the buffer to OpenCL device memory
            len = inputMemObjs.length;
            for (i = 0; i < len; i++) {
                memObj = inputMemObjs[i];
                cmdQueue.enqueueWriteBuffer(memObj.arg, false, 0, /*memObj.arg.getInfo(WebCL.MEM_SIZE)*/memObj.memObjectSize, memObj.val, []);
            }

            // Execute (enqueue) kernel
            cmdQueue.enqueueNDRangeKernel(kernel, WSSizes[1].length, [], WSSizes[1], WSSizes[0]);

            // Read the result buffer from OpenCL device
            len = outputMemObjs.length;
            for (i = 0; i < len; i++) {
                memObj = outputMemObjs[i];
                cmdQueue.enqueueReadBuffer(memObj.arg, false, 0, /*memObj.arg.getInfo(WebCL.MEM_SIZE)*/memObj.memObjectSize, memObj.val, []);
            }

            cmdQueue.finish(); //Finish all the operations

        } catch (e) {
            return false;
        }

        return true;
    };
}


/**
 * Arranges initialised kernel arguments into helper arrays so they are more easily available in
 * the main WebCL application.
 *
 * @function assembleKernelArguments
 * @param paramMap
 * @param memObjects
 * @returns {Array}
 */

function assembleKernelArguments(paramMap, memObjects) {
    var outputs = paramMap.outputs;
    var inputs = paramMap.inputs;
    var kernelArgs = [];

    outputs.forEach(function (p) {
        mapKernelArgument(p, kernelArgs, memObjects.outputs);
    });

    inputs.forEach(function (p) {
        mapKernelArgument(p, kernelArgs, memObjects.inputs);
    });

    return kernelArgs;
}

function mapKernelArgument(param, kernelArgs, memObjects) {
    kernelArgs.push(param);

    if (param.hasMemObject) {
        memObjects.push(param);
        param.helpers.forEach(function (p) {
            kernelArgs.push(p);
        });
    }
}

/**
 * Computes a proper WebCL kernel workgroup size for target input buffer
 *
 * @function computeWorkGroupSize
 * @param targetInput
 * @returns {Array}
 */

function computeWorkGroupSize(targetInput) {
    var localWS, globalWS;
    var entryVal = targetInput.entryValue;

    if (targetInput.xflowType === C.DATA_TYPE.TEXTURE) {
        localWS = [16, 4];
        globalWS = [Math.ceil(entryVal.width / localWS[0]) * localWS[0], Math.ceil(entryVal.height / localWS[1]) * localWS[1]];
    } else {
        var k = 1;
        switch (targetInput.xflowType) {
            case C.DATA_TYPE.INT4:
            case C.DATA_TYPE.FLOAT4:
            {
                k = 4;
            }
                break;
            case C.DATA_TYPE.FLOAT3:
            {
                k = 3;
            }
                break;
            case C.DATA_TYPE.FLOAT4X4:
            {
                k = 16;
            }
                break;
        }
        localWS = [16];
        globalWS = [Math.ceil(entryVal.length / (localWS[0] * k)) * localWS[0]];
    }

    return [localWS, globalWS];
}

module.exports = CLProgram;

},{"../interface/constants.js":136}],141:[function(require,module,exports){
Xflow.registerOperator("xflow.add", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value1'},
                {type: 'float3', source: 'value2'}],
    evaluate: function(result, value1, value2, info) {
        throw new Error("Not used!");
    },
    evaluate_core: function(result, value1, value2){
        result[0] = value1[0] + value2[0];
        result[1] = value1[1] + value2[1];
        result[2] = value1[2] + value2[2];
    }
});

},{}],142:[function(require,module,exports){
Xflow.registerOperator("xflow.bufferSelect", {
    outputs: [  {type: 'float3', name: 'result', noAlloc: true}],
    params:  [  {type: 'float3', source: 'trueOption', array: true},
                {type: 'float3', source: 'falseOption', array: true},
                {type: 'bool', source: 'value', array: true}],
    evaluate: function(result, falseOption, trueOption, value) {
        result.assign = value[0] ? trueOption : falseOption;

        return true;
    }
});

},{}],143:[function(require,module,exports){
Xflow.registerOperator("xflow.clampImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image', formatType: 'ImageData'} ],
    params:  [ {type: 'texture', source : 'image'},
               {type: 'float', source : 'min'},
               {type: 'float', source : 'max'}
             ],
    evaluate: function(result, image, min, max) {
        var inpix = image.data;
        var outpix = result.data;
        var minv = min[0];
        var maxv = max[0];
        var len = image.data.length;
        for (var i = 0 ; i < len; i++) {
            var val = inpix[i];
            if (val < minv) val = minv;
            if (val > maxv) val = maxv;
            outpix[i] = val;
        }
        return true;
    }
});

},{}],144:[function(require,module,exports){
// Code portions from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/

(function() {

    function convolute(inpixels, outpixels, weights, opaque) {
        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side/2);
        var src = inpixels.data;
        var sw = inpixels.width;
        var sh = inpixels.height;
        // pad output by the convolution matrix
        var w = sw;
        var h = sh;
        var dst = outpixels.data;
        // go through the destination image pixels
        var alphaFac = opaque ? 1 : 0;
        for (var y=0; y<h; y++) {
            for (var x=0; x<w; x++) {
                var sy = y;
                var sx = x;
                var dstOff = (y*w+x)*4;
                // calculate the weighed sum of the source image pixels that
                // fall under the convolution matrix
                var r=0, g=0, b=0, a=0;
                for (var cy=0; cy<side; cy++) {
                    for (var cx=0; cx<side; cx++) {
                        var scy = sy + cy - halfSide;
                        var scx = sx + cx - halfSide;
                        if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                            var srcOff = (scy*sw+scx)*4;
                            var wt = weights[cy*side+cx];
                            r += src[srcOff] * wt;
                            g += src[srcOff+1] * wt;
                            b += src[srcOff+2] * wt;
                            a += src[srcOff+3] * wt;
                        }
                    }
                }
                dst[dstOff] = r;
                dst[dstOff+1] = g;
                dst[dstOff+2] = b;
                dst[dstOff+3] = a + alphaFac*(255-a);
            }
        }
        return outpixels;
    };

    Xflow.registerOperator("xflow.convoluteImage", {
        outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
        params:  [
            {type: 'texture', source : 'image'},
            {type: 'float', source : 'kernel'}
        ],
        evaluate: function(result, image, kernel) {
            convolute(image, result, kernel, true);
            return true;
        }
    });

    Xflow.registerOperator("xflow.convoluteImageToFloat", {
        outputs: [ {type: 'texture', name : 'result', sizeof: 'image', formatType : 'float32'} ],
        params:  [
            {type: 'texture', source : 'image'},
            {type: 'float', source : 'kernel'}
        ],
        evaluate: function(result, image, kernel) {
            convolute(image, result, kernel, true);
            return true;
        }
    });

})();

},{}],145:[function(require,module,exports){
Xflow.registerOperator("xflow.createIGIndex", {
    outputs:[
        //{type:'int', name:'index', customAlloc:true },
        {type:'float2', name:'texcoord', customAlloc:true }
    ],
    params:[
        {type:'int', source:'vertexCount', optional:false},
        {type:'texture', source:'positionTex', optional: false}
    ],
    alloc:function (sizes, vertexCount, image) {
        sizes['texcoord'] = image.width * image.height;
        //sizes['index'] = vertexCount[0];
    },
    evaluate:function (texcoord, vertexCount, image, info) {
        // tex coords
        var halfPixel = {
            x: 0.5 / image.width,
            y: 0.5 / image.height
        };
        var i = 0;
        for (var y = 0, ylength = image.height; y < ylength; y++)
        {
            for (var x = 0, xlength = image.width; x < xlength; x++)
            {
                texcoord[i++] = (x / xlength) + halfPixel.x;
                texcoord[i++] = 1 - ((y / ylength) + halfPixel.y);
            }
        }

        // index creation
        /*for(var i = 0; i < vertexCount[0]; i++) {
            index[i] = i;
        }*/
        return true;
    }
});

},{}],146:[function(require,module,exports){
Xflow.registerOperator("xflow.createTransform", {
    outputs: [  {type: 'float4x4', name: 'result'}],
    params:  [  {type: 'float3', source: 'translation', optional: true},
                {type: 'float4', source: 'rotation', optional: true},
                {type: 'float3', source: 'scale', optional: true},
                {type: 'float3', source: 'center', optional: true},
                {type: 'float4', source: 'scaleOrientation', optional: true}],
    evaluate: function(result, translation,rotation,scale,center,scaleOrientation, info) {
        for(var i = 0; i < info.iterateCount; i++) {
            XML3D.math.mat4.makeTransformXflow(
                translation ? translation.subarray(info.iterFlag[0] ? i*3 : 0) : null,
                rotation ? rotation.subarray(info.iterFlag[1] ? i*4 : 0) : null,
                scale ? scale.subarray(info.iterFlag[2] ? i*3 : 0) : null,
                center ? center.subarray(info.iterFlag[3] ? i*3 : 0) : null,
                scaleOrientation ? scaleOrientation.subarray(info.iterFlag[4] ? i*4 : 0) : null,
                result.subarray(i*16)
            )
        }
        return true;
    }
});

},{}],147:[function(require,module,exports){
Xflow.registerOperator("xflow.createTransformInv", {
    outputs: [  {type: 'float4x4', name: 'result'}],
    params:  [  {type: 'float3', source: 'translation', optional: true},
                {type: 'float4', source: 'rotation', optional: true},
                {type: 'float3', source: 'scale', optional: true},
                {type: 'float3', source: 'center', optional: true},
                {type: 'float4', source: 'scaleOrientation', optional: true}],
    evaluate: function(result, translation,rotation,scale,center,scaleOrientation, info) {
        for(var i = 0; i < info.iterateCount; i++) {
            XML3D.math.mat4.makeTransformInvXflow(
                translation ? translation.subarray(info.iterFlag[0] ? i*3 : 0) : null,
                rotation ? rotation.subarray(info.iterFlag[1] ? i*4 : 0) : null,
                scale ? scale.subarray(info.iterFlag[2] ? i*3 : 0) : null,
                center ? center.subarray(info.iterFlag[3] ? i*3 : 0) : null,
                scaleOrientation ? scaleOrientation.subarray(info.iterFlag[4] ? i*4 : 0) : null,
                result.subarray(i*16)
            )
        }
    }
});

},{}],148:[function(require,module,exports){
(function(){

var c_CubePositions =  [
    [-1,-1,-1], [1,-1,-1], [-1,1,-1], [1,1,-1], // front
    [-1,-1,-1], [-1,-1,1], [-1,1,-1], [-1,1,1], // left
    [-1,-1,-1], [1,-1,-1], [-1,-1,1], [1,-1,1], // top
    [1,-1,-1], [1,1,-1], [1,-1,1], [1,1,1],     // right
    [-1,1,-1], [1,1,-1], [-1,1,1], [1,1,1],     // bottom
    [-1,-1,1], [1,-1,1], [-1,1,1], [1,1,1]      // back
];
var c_CubeNormals =  [
    [0,0,-1], [0,0,-1], [0,0,-1], [0,0,-1], // front
    [-1,0,0], [-1,0,0], [-1,0,0], [-1,0,0], // left
    [0,-1,0], [0,-1,0], [0,-1,0], [0,-1,0], // top
    [1,0,0], [1,0,0], [1,0,0], [1,0,0],     // right
    [0,1,0], [0,1,0], [0,1,0], [0,1,0],     // bottom
    [0,0,1], [0,0,1], [0,0,1], [0,0,1]      // back
];
var c_CubeIndex = [
    [0,1,2,1,2,3],
    [4,5,6,5,6,7],
    [8,9,10,9,10,11],
    [12,13,14,13,14,15],
    [16,17,18,17,18,19],
    [20,21,22,21,22,23]
]

/**
 * Grid Generation
 */
Xflow.registerOperator("xflow.debug.createSkinCubes", {
    outputs: [	{type: 'int', name: 'index', customAlloc: true},
                {type: 'float3', name: 'position', customAlloc: true},
                {type: 'float3', name: 'normal', customAlloc: true},
                {type: 'int4', name: 'boneIndices', customAlloc: true},
                {type: 'float4', name: 'boneWeights', customAlloc: true}],
    params:  [{type: 'float4x4', source: 'bindTransforms', array: true},
              {type: 'float', source: 'size', array: true, optional: true}],
    alloc: function(sizes, bindTransforms)
    {
        var s = bindTransforms.length / 16;
        sizes['position'] = s * 4 * 6;
        sizes['normal'] = s * 4 * 6;
        sizes['boneIndices'] = s * 4 * 6;
        sizes['boneWeights'] = s * 4 * 6;
        sizes['index'] = s * 6 * 6;
    },
    evaluate: function(index, position, normal, boneIdx, boneWeight, bindTransforms, size) {
        var cubeCount = bindTransforms.length / 16;
        var size = (size && size[0] || 1) / 2;

        var tmpPosition = XML3D.math.vec3.create(),
            tmpNormal = XML3D.math.vec3.create();

        for(var i = 0; i < cubeCount; ++i){
            for(var j = 0; j < 6; ++j){
                for(var k = 0; k < 4; k++){
                    var localIdx = j*4+ k, globalIdx = i*6*4 + localIdx;

                    XML3D.math.vec3.copy(tmpPosition, c_CubePositions[localIdx]);
                    XML3D.math.vec3.scale(tmpPosition, tmpPosition, size);
                    XML3D.math.mat4.multiplyOffsetVec3(bindTransforms, i*16, tmpPosition, 0);
                    XML3D.math.vec3.copy(tmpNormal, c_CubeNormals[localIdx]);
                    XML3D.math.mat4.multiplyOffsetDirection(bindTransforms, i*16, tmpNormal, 0);

                    position[globalIdx*3+0] = tmpPosition[0];
                    position[globalIdx*3+1] = tmpPosition[1];
                    position[globalIdx*3+2] = tmpPosition[2];
                    normal[globalIdx*3+0] = tmpNormal[0];
                    normal[globalIdx*3+1] = tmpNormal[1];
                    normal[globalIdx*3+2] = tmpNormal[2];
                    boneIdx[globalIdx*4+0] = i;
                    boneIdx[globalIdx*4+1] = boneIdx[globalIdx*4+2] = boneIdx[globalIdx*4+3]= 0;
                    boneWeight[globalIdx*4+0] = 1;
                    boneWeight[globalIdx*4+1] = boneWeight[globalIdx*4+2] = boneWeight[globalIdx*4+3]= 0;
                }
                var globalIndexIdx = i*6*6 + j*6;
                for(var k = 0; k < 6; ++k){
                    index[globalIndexIdx+k] = i*6*4 + c_CubeIndex[j][k];
                }
            }
        }
        // We are done!
        position = position;
    }
});

}());

},{}],149:[function(require,module,exports){
Xflow.registerOperator("xflow.flipNormal", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value'}],
    evaluate: function(result, value, info) {
        for(var i = 0; i<info.iterateCount*3; i++)
            result[i] = -value[i];
    }
});

},{}],150:[function(require,module,exports){
Xflow.registerOperator("xflow.flipVerticalImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var width = image.width;
        var height = image.height;

        var destpix = result.data;
        var srcpix = image.data;

        for (var y = 0; y < height; ++y) {
            for (var x = 0; x < width; ++x) {
                var rowOffset = y * width;
                var srcOffset = (rowOffset + x) * 4;
                var dstOffset = (rowOffset + ((width-1) - x)) * 4;
                destpix[dstOffset] =  srcpix[srcOffset];
                destpix[dstOffset+1] = srcpix[srcOffset+1];
                destpix[dstOffset+2] = srcpix[srcOffset+2];
                destpix[dstOffset+3] = srcpix[srcOffset+3];
            }
        }
        return true;
    }
});

},{}],151:[function(require,module,exports){
Xflow.registerOperator("xflow.forwardKinematics", {
    outputs: [  {type: 'float4x4',  name: 'result', customAlloc: true}],
    params:  [  {type: 'int',       source: 'parent', array: true },
                {type: 'float4x4',  source: 'xform', array: true }],
    alloc: function(sizes, parent, xform)
    {
        var length = Math.min(parent.length, xform.length / 16);
        sizes['result'] = length;
    },
    evaluate: function(result, parent,xform, info) {

        var boneCount = result.length / 16;

        var computed = [];
        //For each bone do:
        for(var i = 0; i < boneCount;){
            if(!computed[i]) {
                var p = parent[i];
                if(p >= 0){
                    //This bone has a parent bone
                    if(!computed[p]){
                        //The parent bone's transformation matrix hasn't been computed yet
                        while(parent[p] >= 0 && !computed[parent[p]]) p = parent[p];

                        if(parent[p] >= 0)
                            XML3D.math.mat4.multiplyOffset(result, p*16, xform, p*16, result, parent[p]*16);
                        else
                            for(var j = 0; j < 16; j++) {
                                result[p*16+j] = xform[p*16+j];
                            }
                        computed[p] = true;
                        continue;
                    }
                    else {
                        XML3D.math.mat4.multiplyOffset(result, i*16, xform, i*16, result,  p*16);
                    }
                }
                else{
                    for(var j = 0; j < 16; j++) {
                        result[i*16+j] = xform[i*16+j];
                    }
                }
                computed[i] = true;
            }
            i++;
        }
    }
});

},{}],152:[function(require,module,exports){
Xflow.registerOperator("xflow.forwardKinematicsInv", {
    outputs: [  {type: 'float4x4',  name: 'result', customAlloc: true}],
    params:  [  {type: 'int',       source: 'parent', array: true },
                {type: 'float4x4',  source: 'xform', array: true }],
    alloc: function(sizes, parent, xform)
    {
        var length = Math.min(parent.length, xform.length / 16);
        sizes['result'] = length;
    },
    evaluate: function(result, parent,xform, info) {
        var boneCount = xform.length / 16;

        var computed = [];
        //For each bone do:
        for(var i = 0; i < boneCount;){
            if(!computed[i]) {
                var p = parent[i];
                if(p >= 0){
                    //This bone has a parent bone
                    if(!computed[p]){
                        //The parent bone's transformation matrix hasn't been computed yet
                        while(parent[p] >= 0 && !computed[parent[p]]) p = parent[p];
                        //The current bone has a parent and its transform hasn't been computed yet

                        if(parent[p] >= 0)
                            XML3D.math.mat4.multiplyOffset(result, p*16, result, parent[p]*16, xform, p*16);
                        else
                            for(var j = 0; j < 16; j++) {
                                result[p*16+j] = xform[p*16+j];
                            }
                        computed[p] = true;
                        continue;

                    }
                    else {
                        XML3D.math.mat4.multiplyOffset(result, i*16,  result,  p*16, xform, i*16);
                    }
                }
                else{
                    for(var j = 0; j < 16; j++) {
                        result[i*16+j] = xform[i*16+j];
                    }
                }
                computed[i] = true;
            }
            i++;
        }
    }
});

},{}],153:[function(require,module,exports){
// Based on: http://web.archive.org/web/20100310063925/http://dem.ocracy.org/libero/photobooth/

Xflow.registerOperator("xflow.funMirrorImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'},
               {type: 'float', source : 'time'} ],
    evaluate: function(result, image, time) {
        var width = result.width;
        var height = result.height;
        var time = time[0];

        var s = image.data;
        var d = result.data;

        for (var y = 0; y < height; ++y) {
            for (var x = 0; x < width; ++x) {

                /*original coordinates*/
                // [0.0 ,1.0] x [0.0, 1.0]
                var coordX = x / width;
                var coordY = y / height;

                // [-1.0 ,1.0] x [-1.0, 1.0]
                var normCoordX = 2.0 * coordX - 1.0;
                var normCoordY = 2.0 * coordY - 1.0;

                /*go to polar coordinates*/
                var r = Math.sqrt(normCoordX*normCoordX + normCoordY*normCoordY); // length(normCoord)
                var phi = Math.atan2(normCoordY, normCoordX);

                /*squeeze and vary it over time*/
                r = Math.pow(r, 1.0/1.8) * time;

                /*back to cartesian coordinates*/
                normCoordX = r * Math.cos(phi);
                normCoordY = r * Math.sin(phi);
                // [0.0 ,1.0] x [0.0, 1.0]
                coordX = normCoordX / 2.0 + 0.5;
                coordY = normCoordY / 2.0 + 0.5;

                var sX = Math.round(coordX * width);
                var sY = Math.round(coordY * height);

                var i = (sY * width + sX)*4;
                var r = s[i];
                var g = s[i + 1];
                var b = s[i + 2];
                var a = s[i + 3];

                /*color the fragment with calculated texture*/
                var i = (y * width + x)*4;
                d[i] = r;
                d[i + 1] = g;
                d[i + 2] = b;
                d[i + 3] = a;
            }
        }
        return true;
    }
});

},{}],154:[function(require,module,exports){

function fetch(result, value, index, components){
    for(var i = 0; i < index.length; ++i) {
        var offset = index[i] * components;
        var j = components;
        while(j--) {
            result[i*components + j] = value[offset + j];
        }
    }
}

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float', name: 'result'}],
    params:  [  {type: 'float', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float2', name: 'result'}],
    params:  [  {type: 'float2', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 2);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 4);
    }
});


Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float4', name: 'result'}],
    params:  [  {type: 'float4', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 4);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float4x4', name: 'result'}],
    params:  [  {type: 'float4x4', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 16);
    }
});


Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'int', name: 'result'}],
    params:  [  {type: 'int', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'bool', name: 'result'}],
    params:  [  {type: 'bool', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'byte', name: 'result'}],
    params:  [  {type: 'byte', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});



Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'ubyte', name: 'result'}],
    params:  [  {type: 'ubyte', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

},{}],155:[function(require,module,exports){
Xflow.registerOperator("xflow.grayscaleImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var width = image.width;
        var height = image.height;

        var s = image.data;
        var d = result.data;
        for (var i = 0; i < s.length; i += 4) {
            var r = s[i];
            var g = s[i + 1];
            var b = s[i + 2];
            var a = s[i + 3];
            // CIE luminance for the RGB
            // The human eye is bad at seeing red and blue, so we de-emphasize them.
            var v = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            d[i] = d[i + 1] = d[i + 2] = v
            d[i + 3] = a;
        }
        return true;
    }
});

},{}],156:[function(require,module,exports){
require("./add.js");
require("./bufferSelect.js");
require("./clampImage.js");
require("./convoluteImage.js");
require("./createIGIndex.js");
require("./createTransform.js");
require("./createTransformInv.js");
require("./debug.js");
require("./flipNormal.js");
require("./flipVerticalImage.js");
require("./forwardKinematics.js");
require("./forwardKinematicsInv.js");
require("./funMirrorImage.js");
require("./get.js");
require("./grayscaleImage.js");
require("./lerp3seq.js");
require("./magnitudeImage.js");
require("./merge3.js");
require("./morph3.js");
require("./mul4x4.js");
require("./noiseImage.js");
require("./normalize3.js");
require("./popartImage.js");
require("./rgbePNGtoFloat.js");
require("./selectBool.js");
require("./selectTransform.js");
require("./sepiaImage.js");
require("./skinDirection.js");
require("./skinPosition.js");
require("./slerpseq.js");
require("./sobelImage.js");
require("./sub3.js");

},{"./add.js":141,"./bufferSelect.js":142,"./clampImage.js":143,"./convoluteImage.js":144,"./createIGIndex.js":145,"./createTransform.js":146,"./createTransformInv.js":147,"./debug.js":148,"./flipNormal.js":149,"./flipVerticalImage.js":150,"./forwardKinematics.js":151,"./forwardKinematicsInv.js":152,"./funMirrorImage.js":153,"./get.js":154,"./grayscaleImage.js":155,"./lerp3seq.js":157,"./magnitudeImage.js":158,"./merge3.js":159,"./morph3.js":160,"./mul4x4.js":161,"./noiseImage.js":162,"./normalize3.js":163,"./popartImage.js":164,"./rgbePNGtoFloat.js":165,"./selectBool.js":166,"./selectTransform.js":167,"./sepiaImage.js":168,"./skinDirection.js":169,"./skinPosition.js":170,"./slerpseq.js":171,"./sobelImage.js":172,"./sub3.js":173}],157:[function(require,module,exports){
var binarySearch = require("../../utils/utils").binarySearch;
var XC = require("../../interface/constants.js");

Xflow.registerOperator("xflow.lerpSeq", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'sequence'},
        {type: 'float', source: 'key'}],
    mapping: [  { name: 'value1', source: 'sequence', sequence: XC.SEQUENCE.PREV_BUFFER, keySource: 'key'},
        { name: 'value2', source: 'sequence', sequence: XC.SEQUENCE.NEXT_BUFFER, keySource: 'key'},
        { name: 'weight', source: 'sequence', sequence: XC.SEQUENCE.LINEAR_WEIGHT, keySource: 'key'}],
    evaluate_core: function(result, value1, value2, weight){
        var invWeight = 1 - weight[0];
        result[0] = invWeight*value1[0] + weight[0]*value2[0];
        result[1] = invWeight*value1[1] + weight[0]*value2[1];
        result[2] = invWeight*value1[2] + weight[0]*value2[2];
    }
});


Xflow.registerOperator("xflow.lerpSeqAsync", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'sequence'},
        {type: 'float', source: 'key'}],
    mapping: [  { name: 'value1', source: 'sequence', sequence: XC.SEQUENCE.PREV_BUFFER, keySource: 'key'},
        { name: 'value2', source: 'sequence', sequence: XC.SEQUENCE.NEXT_BUFFER, keySource: 'key'},
        { name: 'weight', source: 'sequence', sequence: XC.SEQUENCE.LINEAR_WEIGHT, keySource: 'key'}],
    evaluate_async: function(result, value1, value2, weight, info, callback){
        var i = info.iterateCount, off0, off1, off2;
        while(i--){
            off0 = (info.iterFlag[0] ? i : 0)*3;
            off1 = (info.iterFlag[1] ? i : 0)*3;
            off2 = info.iterFlag[2] ? i : 0;
            var invWeight = 1 - weight[off2];
            result[i*3] = invWeight*value1[off0] + weight[off2]*value2[off1];
            result[i*3+1] = invWeight*value1[off0+1] + weight[off2]*value2[off1+1];
            result[i*3+2] = invWeight*value1[off0+2] + weight[off2]*value2[off1+2];
        }
        window.setTimeout(callback, 200);
    }
});


Xflow.registerOperator("xflow.lerpKeys", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float', source: 'keys', array: true},
        {type: 'float3', source: 'values', array: true},
        {type: 'float', source: 'key'}],
    alloc: function(sizes, keys, values, key)
    {
        sizes['result'] = 3;
    },
    evaluate: function(result, keys, values, key) {
        var maxIdx = Math.min(keys.length, Math.floor(values.length / 3));
        var idx = binarySearch(keys, key[0], maxIdx);

        if(idx < 0 || idx == maxIdx - 1){
            idx = Math.max(0,idx);
            result[0] = values[3*idx];
            result[1] = values[3*idx+1];
            result[2] = values[3*idx+2];
        }
        else{
            var weight = (key[0] - keys[idx]) / (keys[idx+1] - keys[idx]);
            var invWeight = 1 - weight;
            result[0] = invWeight*values[3*idx] + weight*values[3*idx + 3];
            result[1] = invWeight*values[3*idx+1] + weight*values[3*idx + 4];
            result[2] = invWeight*values[3*idx+2] + weight*values[3*idx + 5];
        }
    }
});






},{"../../interface/constants.js":136,"../../utils/utils":187}],158:[function(require,module,exports){
Xflow.registerOperator("xflow.magnitudeImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image1'} ],
    params:  [
        {type: 'texture', source : 'image1'},
        {type: 'texture', source : 'image2'}
    ],
    evaluate: function(result, image1, image2) {
        var inpix1 = image1.data;
        var inpix2 = image2.data;
        var outpix = result.data;

        var len = inpix1.length;
        for (var i = 0 ; i < len; i+=1) {
            var val1 = inpix1[i];
            var val2 = inpix2[i];
            outpix[i] = Math.sqrt(val1*val1 + val2*val2);
        }
        return true;
    }
});

},{}],159:[function(require,module,exports){

Xflow.registerOperator("xflow.merge3", {
    outputs: [{name: 'result', tupleSize: '16'}],
    params:  ['value1','value2','value3'],
    evaluate: function(value1, value2, value3) {
        if(!(value1 && value2 && value3))
            throw "Xflow::morph3: Not all parameters are set";

        var overallLength = value1.length + value2.length + value3.length;
        if (!this.tmp || this.tmp.length != overallLength)
            this.tmp = new Float32Array(overallLength);

        this.tmp.set(value1);
        this.tmp.set(value2, value1.length);
        this.tmp.set(value3, value1.length + value2.length);
        this.result.result = this.tmp;
        return true;
    }
});
Xflow.registerOperator("xflow.merge8", {
    outputs: [{name: 'result', tupleSize: '16'}],
    params:  ['value1','value2','value3','value4','value5','value6','value7','value8'],
    evaluate: function(value1, value2, value3,value4,value5,value6,value7,value8) {
        if(!(value1 && value2 && value3 && value4 && value5 && value6 && value7 && value8))
            throw "Xflow::morph3: Not all parameters are set";

        var overallLength = value1.length + value2.length + value3.length + value4.length + value5.length + value6.length + value7.length + value8.length;
        if (!this.tmp || this.tmp.length != overallLength)
            this.tmp = new Float32Array(overallLength);

        var offset = 0;
        this.tmp.set(value1, offset);
        this.tmp.set(value2, (offset+=value1.length));
        this.tmp.set(value3, (offset+=value2.length));
        this.tmp.set(value4, (offset+=value3.length));
        this.tmp.set(value5, (offset+=value4.length));
        this.tmp.set(value6, (offset+=value5.length));
        this.tmp.set(value7, (offset+=value6.length));
        this.tmp.set(value8, (offset+=value7.length));
        this.result.result = this.tmp;
        return true;
    }
});

},{}],160:[function(require,module,exports){

Xflow.registerOperator("xflow.morph", {
    outputs: [{type: 'float3', name: 'result'}],
    params:  [
        { type: 'float3', source: 'value' },
        { type: 'float3', source: 'valueAdd'},
        { type: 'float', source: 'weight'}
    ],
    evaluate: function(result, value, valueAdd, weight, info) {
        for(var i = 0; i < info.iterateCount; i++){
            var w = weight[info.iterFlag[2] ? i : 0];
            result[3*i] = value[ info.iterFlag[0] ? 3*i : 0] + w * valueAdd[info.iterFlag[1] ? 3*i : 0];
            result[3*i+1] = value[ info.iterFlag[0] ? 3*i+1 : 1] + w * valueAdd[info.iterFlag[1] ? 3*i+1 : 1];
            result[3*i+2] = value[ info.iterFlag[0] ? 3*i+2 : 2] + w * valueAdd[info.iterFlag[1] ? 3*i+2 : 2];
        }
        return true;
    },
    evaluate_core: function(result, value, valueAdd, weight){
        result[0] = value[0] + weight[0] * valueAdd[0];
        result[1] = value[1] + weight[0] * valueAdd[1];
        result[2] = value[2] + weight[0] * valueAdd[2];
    }
});

},{}],161:[function(require,module,exports){
Xflow.registerOperator("xflow.mul", {
    outputs: [  {type: 'float4x4', name: 'result'}],
    params:  [  {type: 'float4x4', source: 'value1'},
                {type: 'float4x4', source: 'value2'}],
    evaluate: function(result, value1, value2, info) {
        for(var i = 0; i < info.iterateCount; i++)
        {
            XML3D.math.mat4.multiplyOffset(result, i*16,
                value1,  info.iterFlag[0] ? i*16 : 0,
                value2, info.iterFlag[1] ? i*16 : 0);
        }
    }
});

},{}],162:[function(require,module,exports){

Xflow.registerOperator("xflow.noiseImage", {
    outputs: [ {type: 'texture', name : 'image', customAlloc: true} ],
    params:  [ {type: 'int', source: 'width'},
               {type: 'int', source:'height'},
               {type: 'float2', source: 'scale'},
               {type: 'float', source: 'minFreq'},
               {type: 'float', source: 'maxFreq'} ],
    alloc: function(sizes, width, height, scale, minFreq, maxFreq) {
        var samplerConfig = new Xflow.SamplerConfig;
        samplerConfig.setDefaults();
        sizes['image'] = {
            imageFormat : {width: width[0], height :height[0]},
            samplerConfig : samplerConfig
        };
    },
    evaluate: function(image, width, height, scale, minFreq, maxFreq) {
        width = width[0];
        height = height[0];
        minFreq = minFreq[0];
        maxFreq = maxFreq[0];

        var id = image;
        var pix = id.data;
        this.noise = this.noise || new SimplexNoise();
        var noise = this.noise;

        var useTurbulence = minFreq != 0.0 && maxFreq != 0.0 && minFreq < maxFreq;

        var snoise = function(x,y) {
            return noise.noise(x, y); // noise.noise returns values in range [-1,1]
            //return 2.0 * noise.noise(x, y) - 1.0; // this code is for noise value in range [0,1]
        };

        var turbulence = function(minFreq, maxFreq, s, t) {
            var value = 0;
            for (var f = minFreq; f < maxFreq; f *= 2)
            {
                value += Math.abs(snoise(s * f, t * f))/f;
            }
            return value;
        };

        for (var y = 0; y < height; ++y)
        {
            var t = y / height * scale[1];
            var invWidth = 1.0 / width;

            for (var x = 0; x < width; ++x)
            {
                var s = x * invWidth * scale[0];
                var v = useTurbulence ? turbulence(minFreq, maxFreq, s, t) : snoise(s, t);
                var offset = (x * width + y) * 4;
                pix[offset] =  Math.floor(v * 255);
                pix[offset+1] = Math.floor(v * 255);
                pix[offset+2] = Math.floor(v * 255);
                pix[offset+3] = 255;
            }
        }

        /* Fill with green color
        for (var y = 0; y < height; ++y)
        {
            for (var x = 0; x < width; ++x)
            {
                var offset = (x * width + y) * 4;
                pix[offset] =  0
                pix[offset+1] = 255;
                pix[offset+2] = 0;
                pix[offset+3] = 255;
            }
        }
        */

        return true;
    }
});

},{}],163:[function(require,module,exports){

Xflow.registerOperator("xflow.normalize", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value'}],
    evaluate: function(result, value, info) {
        for(var i = 0; i < info.iterateCount; i++) {
            var offset = 3*i;
            var x = value[offset];
            var y = value[offset+1];
            var z = value[offset+2];
            var l = 1.0/Math.sqrt(x*x+y*y+z*z);
            result[offset] = x*l;
            result[offset+1] = y*l;
            result[offset+2] = z*l;
        }
    }
});

},{}],164:[function(require,module,exports){

// Based on http://kodemongki.blogspot.de/2011/06/kameraku-custom-shader-effects-example.html
Xflow.registerOperator("xflow.popartImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'},
        {type: 'float', source : 'time'} ],
    evaluate: function(result, image, time) {
        var width = image.width;
        var height = image.height;

        var s = image.data;
        var d = result.data;
        for (var i = 0; i < s.length; i += 4) {
            var r = s[i] / 255;
            var g = s[i + 1] / 255;
            var b = s[i + 2] / 255;
            var a = s[i + 3] / 255;

            var y = 0.3 * r + 0.59 * g + 0.11 * b;
            y = y < 0.3 ? 0.0 : (y < 0.6 ? 0.5 : 1.0);
            if (y == 0.5) {
                d[i]   = 0.8 * 255;
                d[i+1] = 0;
                d[i+2] = 0;
            } else if (y == 1.0) {
                d[i]   = 0.9 * 255;
                d[i+1] = 0.9 * 255;
                d[i+2] = 0;
            } else {
                d[i] = 0;
                d[i+1] = 0;
                d[i+2] = 0;
            }
            d[i+3] = s[i+3];
        }
        return true;
    }
});

},{}],165:[function(require,module,exports){
var SamplerConfig = require("../../interface/data.js").SamplerConfig;
var XC = require("../../interface/constants.js");

Xflow.registerOperator("xflow.rgbePNGtoFloat", {
    outputs: [ {type: 'texture', name : 'result', customAlloc: true } ],
    params:  [
        {type: 'texture', source : 'image'}
    ],
    alloc: function (sizes, image) {
        var samplerConfig = new SamplerConfig;
        samplerConfig.setDefaults();
        samplerConfig.minFilter = XC.TEX_FILTER_TYPE.NEAREST;
        samplerConfig.magFilter = XC.TEX_FILTER_TYPE.NEAREST;
        sizes["result"] = {
            imageFormat : {
                width: image.width,
                height: image.height,
                texelType: XC.TEXTURE_TYPE.FLOAT,
                texelFormat: XC.TEXTURE_FORMAT.RGB
            },
            samplerConfig: samplerConfig
        }
    },

    evaluate: function(result, image) {
        for (var idx = 0; idx < image.data.length; idx += 4) {
            var rgbe = image.data.subarray(idx, idx + 4);
            var f = 0.0;
            var e = rgbe[3];

            if (e > 0.0)
                f = Math.pow(2.0, e - (128.0 + 8.0));

            var rgb = new Float32Array(3);
            rgb[0] = rgbe[0] * f;
            rgb[1] = rgbe[1] * f;
            rgb[2] = rgbe[2] * f;
            result.data.set(rgb, idx / 4 * 3);
        }
        return true;
    }
});

},{"../../interface/constants.js":136,"../../interface/data.js":137}],166:[function(require,module,exports){

Xflow.registerOperator("xflow.selectBool", {
    outputs: [ {type: 'bool', name : 'result', customAlloc: true} ],
    params:  [ {type: 'int', source : 'index'},
               {type: 'bool', source: 'value'} ],
    alloc: function(sizes, index, value) {
        sizes['result'] = 1;
    },
    evaluate: function(result, index, value) {
        var i = index[0];
        if (i < value.length) {
            result[0] = value[i];
        } else {
            result[0] = false;
        }
    }
});

},{}],167:[function(require,module,exports){

Xflow.registerOperator("xflow.selectTransform", {
    outputs: [ {type: 'float4x4', name : 'result', customAlloc: true} ],
    params:  [ {type: 'int', source : 'index'},
               {type: 'float4x4', source: 'transform'} ],
    alloc: function(sizes, index, transform) {
        sizes['result'] = 1;
    },
    evaluate: function(result, index, transform) {
        var i = 16 * index[0];
        if (i < transform.length && i+15 < transform.length) {
            result[0] = transform[i+0];
            result[1] = transform[i+1];
            result[2] = transform[i+2];
            result[3] = transform[i+3];
            result[4] = transform[i+4];
            result[5] = transform[i+5];
            result[6] = transform[i+6];
            result[7] = transform[i+7];
            result[8] = transform[i+8];
            result[9] = transform[i+9];
            result[10] = transform[i+10];
            result[11] = transform[i+11];
            result[12] = transform[i+12];
            result[13] = transform[i+13];
            result[14] = transform[i+14];
            result[15] = transform[i+15];
        } else {
            result[0] = 1;
            result[1] = 0;
            result[2] = 0;
            result[3] = 0;
            result[4] = 0;
            result[5] = 1;
            result[6] = 0;
            result[7] = 0;
            result[8] = 0;
            result[9] = 0;
            result[10] = 1;
            result[11] = 0;
            result[12] = 0;
            result[13] = 0;
            result[14] = 0;
            result[15] = 1;
        }
    }
});

},{}],168:[function(require,module,exports){

Xflow.registerOperator("xflow.sepiaImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var s = image.data;
        var d = result.data;
        var r = 0, g = 0, b = 0;
        for(var i = 0 ; i < s.length; i += 4) {
            r = (s[i] * 0.393 + s[i+1] * 0.769 + s[i+2] * 0.189);
            g = (s[i] * 0.349 + s[i+1] * 0.686 + s[i+2] * 0.168);
            b = (s[i] * 0.272 + s[i+1] * 0.534 + s[i+2] * 0.131);
            if (r>255) r = 255;
            if (g>255) g = 255;
            if (b>255) b = 255;
            if (r<0) r = 0;
            if (g<0) g = 0;
            if (b<0) b = 0;
            d[i] = r;
            d[i+1] = g;
            d[i+2] = b;
            d[i+3] = 255;
        }
        return true;
    }
});

},{}],169:[function(require,module,exports){

Xflow.registerOperator("xflow.skinDirection", {
    outputs: [  {type: 'float3', name: 'result' }],
    params:  [  {type: 'float3', source: 'dir' },
                {type: 'int4', source: 'boneIdx' },
                {type: 'float4', source: 'boneWeight' },
                {type: 'float4x4', source: 'boneXform', array: true } ],
    evaluate: function(result, dir,boneIdx,boneWeight,boneXform, info) {
        var vec3 = XML3D.math.vec3,
            mat4 = XML3D.math.mat4;
        var r = vec3.create();
        var tmp =  vec3.create();

        for(var i = 0; i< info.iterateCount;++i) {
            var offset = i*3;
            r[0] = r[1] = r[2] = +0;
            for(var j = 0; j < 4; j++) {
                var weight = boneWeight[info.iterFlag[2] ? i*4+j : j];
                if (weight) {
                    var mo = boneIdx[info.iterFlag[1] ? i*4+j : j]*16;

                    mat4.multiplyOffsetDirection(boneXform, mo, dir, offset, tmp);
                    vec3.scale(tmp, tmp, weight);
                    vec3.add(r, r, tmp);
                }
            }
            vec3.normalize(r, r);
            result[offset] = r[0];
            result[offset+1] = r[1];
            result[offset+2] = r[2];
        }
    }
});

},{}],170:[function(require,module,exports){

Xflow.registerOperator("xflow.skinPosition", {
    outputs: [  {type: 'float3', name: 'result' }],
    params:  [  {type: 'float3', source: 'pos' },
                {type: 'int4', source: 'boneIdx' },
                {type: 'float4', source: 'boneWeight' },
                {type: 'float4x4', source: 'boneXform', array: true } ],
    evaluate: function(result, pos,boneIdx,boneWeight,boneXform, info) {
        var vec3 = XML3D.math.vec3,
            mat4 = XML3D.math.mat4;
        var r = vec3.create();
        var tmp =  vec3.create();

        for(var i = 0; i< info.iterateCount;++i) {
            var offset = i*3;
            r[0] = r[1] = r[2] = +0;
            for(var j = 0; j < 4; j++) {
                var weight = boneWeight[info.iterFlag[2] ? i*4+j : j];
                if (weight) {
                    var mo = boneIdx[info.iterFlag[1] ? i*4+j : j]*16;

                    mat4.multiplyOffsetVec3(boneXform, mo, pos, offset, tmp);
                    vec3.scale(tmp, tmp, weight);
                    vec3.add(r, r, tmp);
                }
            }
            result[offset] = r[0];
            result[offset+1] = r[1];
            result[offset+2] = r[2];
        }
    }
});

},{}],171:[function(require,module,exports){
var binarySearch = require("../../utils/utils").binarySearch;
var XC = require("../../interface/constants.js");

Xflow.registerOperator("xflow.slerpSeq", {
    outputs: [  {type: 'float4', name: 'result'}],
    params:  [  {type: 'float4', source: 'sequence'},
                {type: 'float', source: 'key'}],
    mapping: [  {name: 'value1', source: 'sequence', sequence: XC.SEQUENCE.PREV_BUFFER, keySource: 'key'},
                {name: 'value2',  source: 'sequence', sequence: XC.SEQUENCE.NEXT_BUFFER, keySource: 'key'},
                {name: 'weight',  source: 'sequence', sequence: XC.SEQUENCE.LINEAR_WEIGHT, keySource: 'key'}],
    evaluate: function(result, value1, value2, weight, info) {
        for(var i = 0; i < info.iterateCount; ++i){
            XML3D.math.quat.slerpOffset(  value1,info.iterFlag[0] ? i*4 : 0,
                                          value2,info.iterFlag[1] ? i*4 : 0,
                                          weight[0],
                                          result, i*4, true);
        }
    }
});


Xflow.registerOperator("xflow.slerpKeys", {
    outputs: [  {type: 'float4', name: 'result'}],
    params:  [  {type: 'float', source: 'keys', array: true},
        {type: 'float4', source: 'values', array: true},
        {type: 'float', source: 'key'}],
    alloc: function(sizes, keys, values, key)
    {
        sizes['result'] = 4;
    },
    evaluate: function(result, keys, values, key) {
        var maxIdx = Math.min(keys.length, Math.floor(values.length / 4));
        var idx = binarySearch(keys, key[0], maxIdx);

        if(idx < 0 || idx == maxIdx - 1){
            idx = Math.max(0,idx);
            result[0] = values[4*idx];
            result[1] = values[4*idx+1];
            result[2] = values[4*idx+2];
            result[3] = values[4*idx+3];
        }
        else{
            var weight = (key[0] - keys[idx]) / (keys[idx+1] - keys[idx]);
            XML3D.math.quat.slerpOffset(  values, idx*4,
                values,(idx+1)*4, weight,
                result, 0, true);
        }
    }
});

},{"../../interface/constants.js":136,"../../utils/utils":187}],172:[function(require,module,exports){

// Code portions from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
(function() {
    Xflow.Filters = {};

    var tmpCanvas = null;
    var tmpCtx = null;

    Xflow.Filters.createImageData = function(w,h) {
        if (!tmpCanvas)
            tmpCanvas = document.createElement('canvas');
        if (!tmpCtx)
            tmpCtx = tmpCanvas.getContext('2d');
        return tmpCtx.createImageData(w, h);
    };

    Xflow.Filters.createImageDataFloat32 = function(w, h) {
        return {width: w, height: h, data: new Float32Array(w * h * 4)};
    };

    Xflow.Filters.grayscale = function(inpixels, outpixels, args) {
            var s = inpixels.data;
            var d = outpixels.data;
            for (var i=0; i<s.length; i+=4) {
                var r = s[i];
                var g = s[i+1];
                var b = s[i+2];
                var a = s[i+3];
                // CIE luminance for the RGB
                // The human eye is bad at seeing red and blue, so we de-emphasize them.
                var v = 0.2126*r + 0.7152*g + 0.0722*b;
                d[i] = d[i+1] = d[i+2] = v
                d[i+3] = a;
            }
            return inpixels;
    };

    Xflow.Filters.convolute = function(inpixels, outpixels, weights, opaque) {
            var side = Math.round(Math.sqrt(weights.length));
            var halfSide = Math.floor(side/2);
            var src = inpixels.data;
            var sw = inpixels.width;
            var sh = inpixels.height;
            // pad output by the convolution matrix
            var w = sw;
            var h = sh;
            var dst = outpixels.data;
            // go through the destination image pixels
            var alphaFac = opaque ? 1 : 0;
            for (var y=0; y<h; y++) {
                for (var x=0; x<w; x++) {
                    var sy = y;
                    var sx = x;
                    var dstOff = (y*w+x)*4;
                    // calculate the weighed sum of the source image pixels that
                    // fall under the convolution matrix
                    var r=0, g=0, b=0, a=0;
                    for (var cy=0; cy<side; cy++) {
                        for (var cx=0; cx<side; cx++) {
                            var scy = sy + cy - halfSide;
                            var scx = sx + cx - halfSide;
                            if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                                var srcOff = (scy*sw+scx)*4;
                                var wt = weights[cy*side+cx];
                                r += src[srcOff] * wt;
                                g += src[srcOff+1] * wt;
                                b += src[srcOff+2] * wt;
                                a += src[srcOff+3] * wt;
                            }
                        }
                    }
                    dst[dstOff] = r;
                    dst[dstOff+1] = g;
                    dst[dstOff+2] = b;
                    dst[dstOff+3] = a + alphaFac*(255-a);
                }
            }
            return outpixels;
        };
/*
    Xflow.Filters.convoluteFloat32 = function(pixels, weights, opaque) {
        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side / 2);

        var src = pixels.data;
        var sw = pixels.width;
        var sh = pixels.height;

        var w = sw;
        var h = sh;
        var output = {
            width: w, height: h, data: new Float32Array(w * h * 4)
        };
        var dst = output.data;

        var alphaFac = opaque ? 1 : 0;

        for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
                var sy = y;
                var sx = x;
                var dstOff = (y * w + x) * 4;
                var r = 0, g = 0, b = 0, a = 0;
                for (var cy = 0; cy < side; cy++) {
                    for (var cx = 0; cx < side; cx++) {
                        var scy = Math.min(sh - 1, Math.max(0, sy + cy - halfSide));
                        var scx = Math.min(sw - 1, Math.max(0, sx + cx - halfSide));
                        var srcOff = (scy * sw + scx) * 4;
                        var wt = weights[cy * side + cx];
                        r += src[srcOff] * wt;
                        g += src[srcOff + 1] * wt;
                        b += src[srcOff + 2] * wt;
                        a += src[srcOff + 3] * wt;
                    }
                }
                dst[dstOff] = r;
                dst[dstOff + 1] = g;
                dst[dstOff + 2] = b;
                dst[dstOff + 3] = a + alphaFac * (255 - a);
            }
        }
        return output;
    }
*/
}());

function float4(x,y,z,w) {
    var v = new Float32Array(4);
    switch (arguments.length) {
        case 0:
            v[0] = 0;
            v[1] = 0;
            v[2] = 0;
            v[3] = 0;
            break;
        case 1:
            v[0] = x;
            v[1] = x;
            v[2] = x;
            v[3] = x;
            break;
        case 2:
            v[0] = x;
            v[1] = y;
            v[2] = 0;
            v[3] = 0;
            break;
        case 3:
            v[0] = x;
            v[1] = y;
            v[2] = z;
            v[3] = 0;
            break;
        default:
            v[0] = x;
            v[1] = y;
            v[2] = z;
            v[3] = w;
    }
    return v;
}

function hypot(a, b)
{
    return Math.sqrt(a*a + b*b);
}

function hypot4(a, b)
{
    return float4(hypot(a[0], b[0]),
                  hypot(a[1], b[1]),
                  hypot(a[2], b[2]),
                  hypot(a[3], b[3]));
}

function hypot4To(r, a, b)
{
    r[0] = hypot(a[0], b[0]);
    r[1] = hypot(a[1], b[1]);
    r[2] = hypot(a[2], b[2]);
    r[3] = hypot(a[3], b[3]);
}

function getTexel2D(imagedata, x, y) {
    var offset = (y * imagedata.width + x) * 4;
    var data = imagedata.data;
    var color = new Float32Array(4);
    color[0] = data[offset] / 255.0;
    color[1] = data[offset+1] / 255.0;
    color[2] = data[offset+2] / 255.0;
    color[3] = data[offset+3] / 255.0;
    return color;
}

function getTexel2DTo(color, imagedata, x, y) {
    var offset = (y * imagedata.width + x) * 4;
    var data = imagedata.data;
    color[0] = data[offset] / 255.0;
    color[1] = data[offset+1] / 255.0;
    color[2] = data[offset+2] / 255.0;
    color[3] = data[offset+3] / 255.0;
    return color;
}

function setTexel2D(imagedata, x, y, color) {
    var offset = (y * imagedata.width + x) * 4;
    var data = imagedata.data;
    data[offset] = color[0] * 255.0 ;
    data[offset+1] = color[1] * 255.0;
    data[offset+2] = color[2] * 255.0;
    data[offset+3] = color[3] * 255.0;
}

Xflow.registerOperator("xflow.sobelImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var width = image.width;
        var height = image.height;

        // Sobel filter, AnySL method
        var gx = float4(0.0);
        var gy = float4(0.0);
        var i00 = float4();
        var i00 = float4();
        var i10 = float4();
        var i20 = float4();
        var i01 = float4();
        var i11 = float4();
        var i21 = float4();
        var i02 = float4();
        var i12 = float4();
        var i22 = float4();
        var color = float4();

        for (var y = 0; y < height; ++y)
        {
            for (var x = 0; x < width; ++x)
            {
                /* Read each texel component and calculate the filtered value using neighbouring texel components */
                if ( x >= 1 && x < (width-1) && y >= 1 && y < height - 1)
                {
                    getTexel2DTo(i00, image, x-1, y-1);
                    getTexel2DTo(i10, image, x, y-1);
                    getTexel2DTo(i20, image, x+1, y-1);
                    getTexel2DTo(i01, image, x-1, y);
                    getTexel2DTo(i11, image, x, y);
                    getTexel2DTo(i21, image, x+1, y);
                    getTexel2DTo(i02, image, x-1, y+1);
                    getTexel2DTo(i12, image, x, y+1);
                    getTexel2DTo(i22, image, x+1, y+1);

                    gx[0] = i00[0] + 2 * i10[0] + i20[0] - i02[0]  - 2 * i12[0] - i22[0];
                    gx[1] = i00[1] + 2 * i10[1] + i20[1] - i02[1]  - 2 * i12[1] - i22[1];
                    gx[2] = i00[2] + 2 * i10[2] + i20[2] - i02[2]  - 2 * i12[2] - i22[2];

                    gy[0] = i00[0] - i20[0]  + 2*i01[0] - 2*i21[0] + i02[0]  -  i22[0];
                    gy[1] = i00[1] - i20[1]  + 2*i01[1] - 2*i21[1] + i02[1]  -  i22[1];
                    gy[2] = i00[2] - i20[2]  + 2*i01[2] - 2*i21[2] + i02[2]  -  i22[2];

                    /* taking root of sums of squares of Gx and Gy */
                    hypot4To(color, gx, gy);
                    color[0]/=2;
                    color[1]/=2;
                    color[2]/=2;
                    color[3]=1.0;
                    setTexel2D(result, x, y, color);
                }
            }
        }



// Sobel filter with separate steps
//
//        var vertical = Xflow.Filters.createImageDataFloat32(width, height);
//        Xflow.Filters.convolute(result, vertical,
//            [ -1, 0, 1,
//              -2, 0, 2,
//              -1, 0, 1 ]);
//        var horizontal = Xflow.Filters.createImageDataFloat32(width, height);
//        Xflow.Filters.convolute(result, horizontal,
//            [ -1, -2, -1,
//               0,  0,  0,
//               1,  2,  1 ]);
//
//        for (var i=0; i<result.data.length; i+=4) {
//            // make the vertical gradient red
//            var v = Math.abs(vertical.data[i]);
//            result.data[i] = v;
//            // make the horizontal gradient green
//            var h = Math.abs(horizontal.data[i]);
//            result.data[i+1] = h;
//            // and mix in some blue for aesthetics
//            result.data[i+2] = (v+h)/4;
//            result.data[i+3] = 255; // opaque alpha
//        }

        /* Copy image
        var destpix = result.data;
        var srcpix = image.data;

        for (var y = 0; y < height; ++y)
        {
            for (var x = 0; x < width; ++x)
            {
                var offset = (y * width + x) * 4;
                destpix[offset] =  srcpix[offset];
                destpix[offset+1] = srcpix[offset+1];
                destpix[offset+2] = srcpix[offset+2];
                destpix[offset+3] = srcpix[offset+3];
            }
        }
        */
        return true;
    }
});

},{}],173:[function(require,module,exports){

Xflow.registerOperator("xflow.sub", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value1'},
                {type: 'float3', source: 'value2'}],
    evaluate: function(result, value1, value2, info) {
        throw "Not used!";

        for(var i = 0; i< info.iterateCount*3; i++)
            result[i] = value1[i] - value2[i];

        return true;
    },

    evaluate_core: function(result, value1, value2){
        result[0] = value1[0] - value2[0];
        result[1] = value1[1] - value2[1];
        result[2] = value1[2] - value2[2];
    }
});

},{}],174:[function(require,module,exports){
/**
 * One operator execution within the @see{OperatorList}.
 * @param operator
 * @constructor
 */
var OperatorEntry = function (operator) {
    /**
     * Position in OperatorList
     * @type {number}
     */
    this.index = 0;

    /**
     * Operator object
     * @type {{}}
     */
    this.operator = operator;

    /**
     * operatorIndex: Position of the input's operator in the OperatorList if the input comes from
     * previously executed operator otherwise undefined
     * outputIndex: References the outputs of the operator object defined by the operatorIndex
     * mappedName: Original name as defined in operator invocation in DataNode (currently not used)
     * inputIndex: Only set if this is direct input and references into the inputs defined in @see{ProgramData}
     * @type {Array.<{operatorIndex: number?, outputIndex: number?, mappedName: string?, inputIndex: number?}>}
     */
    this.inputInfo = [];
    /**
     * finalOut: {number} Is set, if this output a final output (e.g. a varying in a vertex shader). References the outputs of the ProgramData.
     * transfer: {boolean} Is true if this is a transfer output i.e. this output is used as input by another operator,
     * lost: Data that is lost, i.e. not used in next executor. Reference to ProgramData's outputs
     * @type {Array.<{finalOut: number?, transfer: boolean?, lost: number?}>}
     */
    this.outputInfo = [];
};

/**
 * Is the input the result of a previously executed operator
 * @param mappingIndex Input index of the operator (can be mapped using a mapping declaration)
 * @returns {boolean}
 */
OperatorEntry.prototype.isTransferInput = function (mappingIndex) {
    return this.inputInfo[mappingIndex].operatorIndex !== undefined;
};

OperatorEntry.prototype.getTransferInputOperatorIndex = function (mappingIndex) {
    return this.inputInfo[mappingIndex].operatorIndex;
};
OperatorEntry.prototype.getTransferInputOutputIndex = function (mappingIndex) {
    return this.inputInfo[mappingIndex].outputIndex;
};

/**
 * Generate unique name for a specified transfer input
 * @param mappingIdx
 * @returns {string}
 */
OperatorEntry.prototype.getTransferInputId = function (mappingIdx) {
    var info = this.inputInfo[mappingIdx];
    return info.operatorIndex + "_" + info.outputIndex;
};

/**
 * Generate unique name for transfer output
 * @param outputIndex
 * @returns {string}
 */
OperatorEntry.prototype.getTransferOutputId = function (outputIndex) {
    return this.index + "_" + outputIndex;
};

/**
 * TODO: remove or integrate for debugging purposes
 * @unused
 * @param mappingIdx
 * @returns {string|*}
 */
OperatorEntry.prototype.getInputMappingName = function (mappingIdx) {
    return this.inputInfo[mappingIdx].mappedName;
};
OperatorEntry.prototype.getDirectInputIndex = function (mappingIdx) {
    return this.inputInfo[mappingIdx].inputIndex;
};

OperatorEntry.prototype.getOutputIndex = function (operatorOutputIdx) {
    return this.outputInfo[operatorOutputIdx].finalOut || this.outputInfo[operatorOutputIdx].lost || 0;
};


OperatorEntry.prototype.isFinalOutput = function (outputIndex) {
    return this.outputInfo[outputIndex] && this.outputInfo[outputIndex].finalOut !== undefined;
};
OperatorEntry.prototype.isTransferOutput = function (outputIndex) {
    return this.outputInfo[outputIndex] && this.outputInfo[outputIndex].transfer;
};
OperatorEntry.prototype.isLostOutput = function (outputIndex) {
    return this.outputInfo[outputIndex] && this.outputInfo[outputIndex].lost !== undefined;
};


OperatorEntry.prototype.setTransferInput = function (mappingIndex, operatorIndex, outputIndex) {
    this.inputInfo[mappingIndex] = {operatorIndex: operatorIndex, outputIndex: outputIndex};
};

OperatorEntry.prototype.setDirectInput = function (mappingIndex, inputIndex, mappedName) {
    this.inputInfo[mappingIndex] = {inputIndex: inputIndex, mappedName: mappedName};
};

OperatorEntry.prototype.setFinalOutput = function (operatorOutputIndex, globalOutputIndex) {
    this.outputInfo[operatorOutputIndex] = {finalOut: globalOutputIndex};
};
OperatorEntry.prototype.setTransferOutput = function (operatorOutputIndex) {
    this.outputInfo[operatorOutputIndex] = {transfer: true};
};
OperatorEntry.prototype.setLostOutput = function (operatorOutputIndex, globalOutputIndex) {
    this.outputInfo[operatorOutputIndex] = {lost: globalOutputIndex};
};

/**
 * Generate hash-able key for the entry
 * @returns {string}
 */
OperatorEntry.prototype.getKey = function () {
    var key = this.operator.name + "*O";
    for (var i = 0; i < this.outputInfo.length; ++i) {
        var info = this.outputInfo[i];
        key += "*" + ( info.transfer ? "_" : info.finalOut || (info.lost + "?"));
    }
    key += +"*I";
    for (i = 0; i < this.inputInfo.length; ++i) {
        info = this.inputInfo[i];
        key += "*" + (info.inputIndex ? info.inputInfo : info.operatorIndex + ">" + info.outputIndex);
    }
    return key;
};

module.exports = OperatorEntry;

},{}],175:[function(require,module,exports){
var C = require("../interface/constants.js");
var Base = require("../base.js");


/**
 * List of platform-specific operators, ordered by execution (last entry is last operator
 * executed).
 *
 * @param {C.PLATFORM} platform
 * @constructor
 */
var OperatorList = function (platform) {
    this.platform = platform;
    /**
     * @type {Array.<OperatorEntry>}
     */
    this.entries = [];

    /**
     * Map from position of input parameter to size and iterator type of parameters.
     * Size is only specified for uniform array input, required for programs that
     * have the array size specified.
     * @type {Object.<number,{size: number, iterate: C.ITERATION_TYPE}>}
     */
    this.inputInfo = {};
};

OperatorList.prototype.addEntry = function (entry) {
    entry.index = this.entries.length;
    this.entries.push(entry);
};

/**
 * Hashable key for whole list
 * @returns {string}
 */
OperatorList.prototype.getKey = function () {
    var keys = [];
    for (var i = 0; i < this.entries.length; ++i) {
        keys.push(this.entries[i].getKey());
    }
    var result = this.platform + ">" + keys.join("!") + "|";
    for (var i in this.inputInfo) {
        result += i + ">" + (this.inputInfo[i].iterate || 0) + "x" + (this.inputInfo[i].size || 0);
    }
    return result;
};

OperatorList.prototype.setInputIterateType = function (inputIndex, type) {
    if (!this.inputInfo[inputIndex]) this.inputInfo[inputIndex] = {};
    this.inputInfo[inputIndex].iterate = type;
};
OperatorList.prototype.setInputSize = function (inputIndex, size) {
    if (!this.inputInfo[inputIndex]) this.inputInfo[inputIndex] = {};
    this.inputInfo[inputIndex].size = size;
};


OperatorList.prototype.isInputIterate = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate == C.ITERATION_TYPE.MANY;
};
OperatorList.prototype.isInputUniform = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate == C.ITERATION_TYPE.ONE;
};
OperatorList.prototype.isInputNull = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate == C.ITERATION_TYPE.NULL;
};
OperatorList.prototype.getInputIterateType = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate;
};

OperatorList.prototype.getInputSize = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].size || 0;
};

OperatorList.prototype.getIterateCount = function (programData) {
    var count = -1;
    for (var i = 0; i < programData.inputs.length; ++i) {
        if (this.isInputIterate(i)) {
            var dataEntry = programData.getDataEntry(i);
            if (dataEntry && dataEntry.getIterateCount) {
                var size = dataEntry.getIterateCount();
                count = count < 0 ? size : Math.min(size, count);
            }
        }
    }
    return count < 0 ? 1 : count;
};

var c_sizes = {};

OperatorList.prototype.allocateOutput = function (programData, async) {
    for (var i = 0; i < this.entries.length; ++i) {
        var entry = this.entries[i];
        var operator = entry.operator;
        var operatorData = programData.operatorData[i];
        var iterateCount = this.getIterateCount(programData);
        if (operator.alloc) {
            var args = [c_sizes];
            addInputToArgs(args, entry, programData);
            args.push(iterateCount);
            operator.alloc.apply(operatorData, args);
        }
        for (var j = 0; j < operator.outputs.length; ++j) {
            var d = operator.outputs[j];
            var dataSlot = programData.outputs[entry.getOutputIndex(j)], dataEntry;
            dataEntry = async ? dataSlot.asyncDataEntry : dataSlot.dataEntry;

            if (d.noAlloc)
                continue;

            if (dataEntry.type == C.DATA_TYPE.TEXTURE) {
                // texture entry
                if (d.customAlloc) {
                    var texParams = c_sizes[d.name];
                    var newWidth = texParams.imageFormat.width;
                    var newHeight = texParams.imageFormat.height;
                    var newType = texParams.imageFormat.texelType;
                    var newFormat = texParams.imageFormat.texelFormat;
                    var newSamplerConfig = texParams.samplerConfig;
                    dataEntry._createImage(newWidth, newHeight, newFormat, newType, newSamplerConfig);
                } else if (d.sizeof) {
                    var srcEntry = null;
                    for (var k = 0; k < operator.mapping.length; ++k) {
                        if (operator.mapping[k].source == d.sizeof) {
                            srcEntry = programData.getDataEntry(entry.getDirectInputIndex(k));
                            break;
                        }
                    }
                    if (srcEntry) {
                        var newWidth = Math.max(srcEntry.width, 1);
                        var newHeight = Math.max(srcEntry.height, 1);
                        var newFormat = d.texelFormat || srcEntry.texelFormat;
                        var newType = d.texelType || srcEntry.texelType;
                        var newSamplerConfig = d.samplerConfig || srcEntry.getSamplerConfig();
                        dataEntry._createImage(newWidth, newHeight, newFormat, newType, newSamplerConfig);
                    } else
                        throw new Error("Unknown texture input parameter '" + d.sizeof + "' in operator '" + operator.name + "'");
                } else
                    throw new Error("Cannot create texture. Use customAlloc or sizeof parameter attribute");
            } else {

                var size = (d.customAlloc ? c_sizes[d.name] : iterateCount) * dataEntry.getTupleSize();

                if (!dataEntry._value || dataEntry._value.length != size) {
                    switch (dataEntry.type) {
                        case C.DATA_TYPE.FLOAT:
                        case C.DATA_TYPE.FLOAT2:
                        case C.DATA_TYPE.FLOAT3:
                        case C.DATA_TYPE.FLOAT4:
                        case C.DATA_TYPE.FLOAT4X4:
                            dataEntry._setValue(new Float32Array(size));
                            break;
                        case C.DATA_TYPE.INT:
                        case C.DATA_TYPE.INT4:
                        case C.DATA_TYPE.BOOL:
                            dataEntry._setValue(new Int32Array(size));
                            break;
                        default:
                            XML3D.debug.logWarning("Could not allocate output buffer of TYPE: " + dataEntry.type);
                    }
                } else {
                    dataEntry._notifyChanged();
                }
            }
        }
    }
};

/*
 OperatorList.prototype.checkInput = function(programData){
 for(var i = 0; i < this.entries.length; ++i){
 var entry = this.entries[i];
 var mapping = entry.operator.mapping;
 for(var j = 0; j < mapping.length; ++j){
 if(entry.isTransferInput(j)){
 var outputType = this.entries[entry.getTransferInputOperatorIndex(j)].operator.outputs[
 entry.getTransferInputOutputIndex(j)].type;

 if(outputType != entry.type){
 XML3D.debug.logError("Xflow: operator " + entry.operator.name + ": Input for " + entry.source +
 " has wrong type. Expected: " + C.getTypeName(entry.type)
 + ", but got: " +  C.getTypeName(outputType) );
 return false;
 }

 }
 else{
 var mappingName = entry.getInputMappingName(j);
 if(!entry.optional && !mappingName){
 XML3D.debug.logError("Xflow: operator " + entry.operator.name + ": Missing input argument for "
 + entry.source);
 return false;
 }
 if(mappingName){
 var channel = programData.getChannel(entry.getDirectInputIndex(j));
 if(!channel){
 XML3D.debug.logError("Xflow: operator " + entry.operator.name + ": Input of name '" + mappingName +
 "' not found. Used for parameter " + entry.source);
 return false;
 }
 var dataEntry = channel.getDataEntry();
 if(!entry.optional && (!dataEntry || dataEntry.getLength() == 0)){
 XML3D.debug.logError("Xflow: operator " + entry.operator.name + ": Input for " + entry.source +
 ' contains no data.');
 return false;
 }
 if(dataEntry && dataEntry.type != entry.type){
 XML3D.debug.logError("Xflow: operator " + entry.operator.name + ": Input for " + entry.source +
 " has wrong type. Expected: " + C.getTypeName(entry.type)
 + ", but got: " +  C.getTypeName(dataEntry.type) );
 return false;
 }
 }
 }
 }
 }
 }
 */

    // TODO: This function appears in multiple units
    function addInputToArgs(args, entry, programData){
        var mapping = entry.operator.mapping;
        for(var i = 0; i < mapping.length; ++i){
            var mapEntry = mapping[i];
            var dataEntry = programData.getDataEntry(entry.getDirectInputIndex(i));
            args.push(dataEntry ? dataEntry.getValue() : null);
        }
    };

module.exports = OperatorList;

},{"../base.js":135,"../interface/constants.js":136}],176:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");

//----------------------------------------------------------------------------------------------------------------------
// registerOperator && getOperator
//----------------------------------------------------------------------------------------------------------------------

var operators = {};

    /**
     * Registers Xflow operator.
     * The operators are stored in collections using their platform as a key. If no platform is defined, the operator
     * will be registered as a JavaScript-based operator.
     *
     * @param name
     * @param data
     */

var registerOperator = function(name, data){
    var opCollection, platform;

    initOperator(data);
    if(!operators[name]) {
        operators[name] = {};
    }

    platform = data['platform'] || C.PLATFORM.JAVASCRIPT;

    opCollection = operators[name];

    if (!name) {
        XML3D.logWarning("Xflow.registerOperator: Operator name undefined.");
        return;
    }

    if (!data) {
        XML3D.logWarning("Xflow.registerOperator: Operator data undefined.");
        return;
    }

    data.name = name;
    if(!opCollection[platform])
        opCollection[platform] = [];

    opCollection[platform].push(data);
};

var initAnonymousOperator = function(name, data){
    initOperator(data);
    data.name = name;
    return data;
};

var isOperatorAsync = function(operator){
    return !!operator.evaluate_async;
};

var getOperators = function(name, platform){
    platform = platform || C.PLATFORM.JAVASCRIPT;

    if (name && !operators[name]) {
        return null;
    }

    if(!operators[name][platform] || operators[name][platform].length == 0) {
        return null;
    }

    return operators[name][platform];
};

function initOperator(operator){
    var indexMap = {};
    // Init types of outputs and params
    for(var i= 0; i < operator.outputs.length; ++i){
        operator.outputs[i].type = C.DATA_TYPE_MAP[operator.outputs[i].type];
    }
    for(var i= 0; i < operator.params.length; ++i){
        operator.params[i].type = C.DATA_TYPE_MAP[operator.params[i].type];
        indexMap[operator.params[i].source] = i;
    }
    if(!operator.mapping)
        operator.mapping = operator.params;

    // Init interTypes of mapping
    for(var i = 0; i < operator.mapping.length; ++i){
        var mapping = operator.mapping[i];
        var paramIdx = indexMap[mapping.source];
        mapping.paramIdx = paramIdx;
        var type = operator.params[paramIdx].type;
        if(mapping.sequence)
            mapping.keyParamIdx = indexMap[mapping.keySource];
        if(mapping.sequence == C.SEQUENCE.LINEAR_WEIGHT)
            type = C.DATA_TYPE.FLOAT;
        mapping.internalType = type;
        mapping.name = mapping.name || mapping.source;
    }

    //Check/init platform
    operator.platform = operator.platform || C.PLATFORM.JAVASCRIPT;
}

//window.Xflow.registerOperator = registerOperator;

module.exports = {
    registerOperator: registerOperator,
    initAnonymousOperator: initAnonymousOperator,
    isOperatorAsync: isOperatorAsync,
    getOperators: getOperators
};

},{"../base.js":135,"../interface/constants.js":136}],177:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var VSProgram = require("./vs-program.js");
var CLProgram = require("./cl-program.js");

/**
 * Data for a OperatorList, generated by an Executor
 * @constructor
 */
var ProgramData = function(){
    /**
     * @type {Array.<ProgramInputConnection>}
     */
    this.inputs = [];

    /**
     *
     * @type {Array.<DataSlot>}
     */
    this.outputs = [];

    /**
     * iterateCount: How often we iterate with the default execution model
     * iterFlag: Per input: true if the input can be iterated, otherwise false
     * customData: Per instance data that users can persist between operator invocations
     * @type {Array.<{iterateCount: number, iterFlag: Array, customData: {}}>}
     */
    this.operatorData = [];
};

ProgramData.prototype.getChannel = function(index){
    return this.inputs[index].channel;
};

ProgramData.prototype.getDataEntry = function(index){
    var entry = this.inputs[index];
    var channel = entry.channel;
    if(!channel) return null;
    var key = 0;
    if(entry.sequenceKeySourceChannel){
        var keyDataEntry = entry.sequenceKeySourceChannel.getDataEntry();
        key = keyDataEntry && keyDataEntry._value ? keyDataEntry._value[0] : 0;
    }

    return channel.getDataEntry(entry.sequenceAccessType, key);
};

/**
 * @constructor
 */
var ProgramInputConnection = function(){
    /**
     * @type {Channel}
     */
    this.channel = null;

    /**
     * Is this input a uniform array
     * @type {boolean}
     */
    this.arrayAccess = false;

    /**
     * @type {C.SEQUENCE}
     */
    this.sequenceAccessType = C.SEQUENCE.NO_ACCESS;

    /**
     *
     * @type {Channel|null}
     */
    this.sequenceKeySourceChannel = null;
};

/**
 * Hash-able key to identify equal inputs within executor
 * @returns {string}
 */
ProgramInputConnection.prototype.getKey = function(){
    return (this.channel ? this.channel.id : "NULL") + ";" + this.arrayAccess + ";" + this.sequenceAccessType + ";" +
    ( this.sequenceKeySourceChannel ? this.sequenceKeySourceChannel.id : "");
};


var c_program_cache = {};

var createProgram = function(operatorList){
    var firstOperator;

    if(operatorList.entries.length === 0) {
        return null;
    }

    firstOperator = operatorList.entries[0].operator;

    var key = operatorList.getKey();
    if(!c_program_cache[key]){
        // GLSL operators are implemented in a different way, so platform information is fetched from the operatorList
        // as a fallback mode to not break the old implementations
        if(operatorList.platform === C.PLATFORM.GLSL){
            c_program_cache[key] = new VSProgram(operatorList);

        } else if (firstOperator.platform === C.PLATFORM.CL) {
            c_program_cache[key] = new CLProgram(operatorList);

        }else if(firstOperator.platform === C.PLATFORM.JAVASCRIPT && operatorList.entries.length === 1 ) {
            c_program_cache[key] = new SingleProgram(operatorList);

        }else {
            Base.notifyError("Could not create program from operatorList");
        }
    }
    return c_program_cache[key];
};



var SingleProgram = function(operatorList){
    this.list = operatorList;
    this.entry = operatorList.entries[0];
    this.operator = this.entry.operator;
    this._inlineLoop = null;
};

SingleProgram.prototype.run = function(programData, asyncCallback){
    var operatorData = prepareOperatorData(this.list, 0, programData);

    if(asyncCallback)
        applyAsyncOperator(this.entry, programData, operatorData, asyncCallback);
    else if(this.operator.evaluate_core){
        applyCoreOperation(this, programData, operatorData);
    }
    else{
        applyDefaultOperation(this.entry, programData, operatorData);
    }
};

function applyDefaultOperation(entry, programData, operatorData){
    var args = assembleFunctionArgs(entry, programData);
    args.push(operatorData);
    entry.operator.evaluate.apply(operatorData, args);
    handlePostProcessOutput(entry, programData, args, false);
}

function applyAsyncOperator(entry, programData, operatorData, asyncCallback){
    var args = assembleFunctionArgs(entry, programData, true);
    args.push(operatorData);
    args.push(function(){
        handlePostProcessOutput(entry, programData, args, true);
        asyncCallback();
    });
    entry.operator.evaluate_async.apply(operatorData, args);
}

function applyCoreOperation(program, programData, operatorData){
    var args = assembleFunctionArgs(program.entry, programData);
    args.push(operatorData.iterateCount);

    if(!program._inlineLoop){
        program._inlineLoop = createOperatorInlineLoop(program.operator, operatorData);
    }
    program._inlineLoop.apply(operatorData, args);
}

var c_VarPattern = /var\s+(.)+[;\n]/;
var c_InnerVarPattern = /[^=,\s]+\s*(=[^,]+)?(,)?/;
function createOperatorInlineLoop(operator, operatorData){

    var code = "function (";
    var funcData = parseFunction(operator.evaluate_core);
    code += funcData.args.join(",") + ",__xflowMax) {\n";
    code += "    var __xflowI = __xflowMax\n" +
        "    while(__xflowI--){\n";

    var body = funcData.body;
    body = replaceArrayAccess(body, funcData.args, operator, operatorData);
    code += body + "\n  }\n}";

    var inlineFunc = eval("(" + code + ")");
    return inlineFunc;
}

    var c_FunctionPattern = /function\s*([^(]*)\(([^)]*)\)\s*\{([\s\S]*)\}/;

function parseFunction(func){
    var result = {};
    var matches = func.toString().match(c_FunctionPattern);
    if(!matches){
        Base.notifyError("Xflow Internal: Could not parse function: " + func);
        return null;
    }
    result.args = matches[2].split(",");
    for(var i in result.args) result.args[i] = result.args[i].trim();
    result.body = matches[3];
    return result;
}

var c_bracketPattern = /([a-zA-Z_$][\w$]*)(\[)/;

function replaceArrayAccess(code, args, operator, operatorData){
    var result = "";
    var index = 0, bracketIndex = code.indexOf("[", index);
    while(bracketIndex != -1){
        var key = code.substr(index).match(c_bracketPattern)[1];

        var argIdx = args.indexOf(key);
        var addIndex = false, tupleCnt = 0;
        if(argIdx != -1){
            if(argIdx < operator.outputs.length){
                addIndex = true;
                tupleCnt = C.DATA_TYPE_TUPLE_SIZE[[operator.outputs[argIdx].type]];
            }
            else{
                var i = argIdx - operator.outputs.length;
                addIndex = operatorData.iterFlag[i];
                tupleCnt = C.DATA_TYPE_TUPLE_SIZE[operator.mapping[i].internalType];
            }
        }

        result += code.substring(index, bracketIndex) + "[";
        if(addIndex){
            result += tupleCnt + "*__xflowI + ";
        }
        index = bracketIndex + 1;
        bracketIndex = code.indexOf("[", index);
    }
    result +=  code.substring(index);
    return result;
}


function prepareOperatorData(list, idx, programData){
    var data = programData.operatorData[0];
    var entry = list.entries[idx];
    var mapping = entry.operator.mapping;
    data.iterFlag = {};
    for(var i = 0; i < mapping.length; ++i){
        var doIterate = (entry.isTransferInput(i) || list.isInputIterate(entry.getDirectInputIndex(i)));
        data.iterFlag[i] = doIterate;
    }
    data.iterateCount = list.getIterateCount(programData);
    if(!data.customData)
        data.customData = {};
    return data;
}

function assembleFunctionArgs(entry, programData, async){
    var args = [];
    var outputs = entry.operator.outputs;
    for(var i = 0; i < outputs.length; ++i){
        if(outputs[i].noAlloc){
            args.push({assign: null});
        }
        else{
            var dataSlot = programData.outputs[entry.getOutputIndex(i)];
            var dataEntry = async ? dataSlot.asyncDataEntry : dataSlot.dataEntry;
            args.push(dataEntry ? dataEntry.getValue() : null);
        }
    }
    addInputToArgs(args, entry, programData);
    return args;
}
function handlePostProcessOutput(entry, programData, parameters, async){
    var outputs = entry.operator.outputs;
    for(var i = 0; i < outputs.length; ++i){
        var dataSlot = programData.outputs[entry.getOutputIndex(i)];
        if(outputs[i].noAlloc){
            var dataEntry = async ? dataSlot.asyncDataEntry : dataSlot.dataEntry;
            if(dataEntry.type == C.DATA_TYPE.TEXTURE ){
                dataEntry._setImage(parameters[i].assign);
            }
            else{
                dataEntry._setValue(parameters[i].assign);
            }
        }
        if(async){
            dataSlot.swapAsync();
        }
    }
}


function addInputToArgs(args, entry, programData){
    var mapping = entry.operator.mapping;
    for(var i = 0; i < mapping.length; ++i){
        var mapEntry = mapping[i];
        var dataEntry = programData.getDataEntry(entry.getDirectInputIndex(i));
        args.push(dataEntry ? dataEntry.getValue() : null);
    }
}

module.exports = {
    createProgram: createProgram,
    ProgramData: ProgramData,
    ProgramInputConnection: ProgramInputConnection
};

},{"../base.js":135,"../interface/constants.js":136,"./cl-program.js":140,"./vs-program.js":178}],178:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var Utils = require("../utils/utils.js");
var VertexShader = require("../processing/vs-connect.js").VertexShader;

//----------------------------------------------------------------------------------------------------------------------
// OperatorList
//----------------------------------------------------------------------------------------------------------------------

var c_SHADER_CONSTANT_TYPES = {};
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.OBJECT_ID] = 'int';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM] = 'mat4';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM_NORMAL] = 'mat3';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM] = 'mat4';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM_NORMAL] = 'mat3';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM] = 'mat4';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM_NORMAL] = 'mat3';

var VSProgram = function(operatorList){
    this.list = operatorList;
    this._outputInfo = {};
    setOutputIterate(this);
};

VSProgram.prototype.getOutputNames = function(){
    return Object.keys(this._outputInfo);
};

VSProgram.prototype.getOutputType = function(name){
    return this._outputInfo[name].type;
};

VSProgram.prototype.isOutputUniform = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.ONE;
};

VSProgram.prototype.isOutputNull = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.NULL;
};

VSProgram.prototype.createVertexShader = function(programData, vsConfig){
    var result = new VertexShader(programData);
    constructVS(result, this, vsConfig);
    return result;
};

function setOutputIterate(program){
    var operatorList = program.list, entries = operatorList.entries;

    var baseEntry = entries[entries.length - 1], baseOperator = baseEntry.operator;

    for( var i = 0; i < baseOperator.params.length; ++i){
        var entry = baseOperator.params[i],
            name = entry.source,
            inputIndex = i,
            directInputIndex = baseEntry.getDirectInputIndex(inputIndex);
        program._outputInfo[name] = {type: entry.type};
        if( baseEntry.isTransferInput(inputIndex) ||
            operatorList.isInputIterate(directInputIndex))
        {
            program._outputInfo[name].iteration = C.ITERATION_TYPE.MANY;
        }
        else if(operatorList.isInputUniform(directInputIndex)){
            program._outputInfo[name].iteration = C.ITERATION_TYPE.ONE;
        }
        else{
            program._outputInfo[name].iteration = C.ITERATION_TYPE.NULL;
        }
    }
}

function constructVS(vs, program, vsConfig){
    var operatorList = program.list, entries = operatorList.entries;

    var usedNames = [],
        directInputNames = {},
        transferNames = {};

    var baseEntry = entries[entries.length - 1], acceptedBaseShaderInput = [], baseOperator = baseEntry.operator;

    if(!vsConfig)
        throw new Error("Could not find vsConfig! Attempt to create vertex shader programm without VS operator?");

    Utils.nameset.add(usedNames, vsConfig.getBlockedNames());

    var code = "";
    code += "// OUTPUT\n";
    // First: collect output names
    for(var name in vsConfig._addOutput){
        var entry = vsConfig._addOutput[name];
        code += "varying " + getGLSLType(entry.type) + " " + name + ";\n";
        Utils.nameset.add(usedNames, name);
    }
    var inputIndex = 0;
    for( var name in vsConfig._attributes){
        var configAttr = vsConfig._attributes[name],
            directInputIndex = baseEntry.getDirectInputIndex(inputIndex);
        for(var i = 0; i < configAttr.channeling.length; ++i){
            var channeling = configAttr.channeling[i];
            var outputInfo = {type: configAttr.type, iteration: 0, index: 0, sourceName: name},
                outputName = channeling.outputName;
            if( channeling.code ||
                baseEntry.isTransferInput(inputIndex) ||
                operatorList.isInputIterate(directInputIndex))
            {
                acceptedBaseShaderInput[inputIndex] = true;
                outputInfo.iteration = C.ITERATION_TYPE.MANY;
                var type = baseOperator.outputs[inputIndex].type;
                code += "varying " + getGLSLType(type) + " " + outputName + ";\n";
                Utils.nameset.add(usedNames, outputName);
                transferNames[baseEntry.getTransferOutputId(i)] = outputName;
            }
            else if(operatorList.isInputUniform(directInputIndex)){
                outputInfo.iteration = C.ITERATION_TYPE.ONE;
                outputInfo.index = directInputIndex;
            }
            else{
                outputInfo.iteration = C.ITERATION_TYPE.NULL;
            }
            Utils.nameset.add(vs._outputNames, outputName);
            vs._outputInfo[outputName] = outputInfo;
        }
        inputIndex++;
    }
    code += "\n";
    code += "// INPUT\n";
    // Add additional input
    for(var name in vsConfig._addInput){
        var entry = vsConfig._addInput[name];
        code += (entry.uniform ? "uniform " : "attribute " ) + getGLSLType(entry.type) + " " + name + ";\n";
        Utils.nameset.add(usedNames, name);
    }
    // Second: collect input names
    for(var i = 0; i < entries.length; ++i){
        var entry = entries[i], operator = entry.operator;
        for(var j = 0; j < operator.mapping.length; ++j){
            if( (i < entries.length - 1 || acceptedBaseShaderInput[j]) &&
                    !entry.isTransferInput(j) && !directInputNames[entry.getDirectInputIndex(j)])
            {
                var mapEntry = operator.mapping[j];
                var name = getFreeName(mapEntry.name, usedNames), inputIndex = entry.getDirectInputIndex(j),
                    uniform = !operatorList.isInputIterate(inputIndex);
                vs._inputInfo[name] = { index: inputIndex, uniform: uniform };
                Utils.nameset.add(vs._inputNames, name);
                directInputNames[inputIndex] = name;
                code += (uniform ? "uniform " : "attribute ") + getGLSLType(mapEntry.internalType) + " " + name;
                if(mapEntry.array)
                    code += "[" + operatorList.getInputSize(inputIndex) + "]";
                code += ";\n";
            }
        }
    }

    // Start main
    code += "\n// CODE\n";
    code += "void main(void){\n";

    // Create Code
    for(var i = 0; i < entries.length; ++i){
        var entry = entries[i], operator = entry.operator;
        // Declare transfer output names
        for(var j = 0; j < operator.outputs.length; ++j){
            if(!entry.isFinalOutput(j)){
                var name = getFreeName(operator.outputs[j].name, usedNames);
                transferNames[entry.getTransferOutputId(j)] = name;
                code += "\t" + getGLSLType(operator.outputs[j].type) + " " + name + ";\n";
            }
        }
        // Take Code Fragment
        var codeFragment = convertCodeFragment(operator.evaluate_glsl, entry,
                                transferNames, directInputNames, usedNames);
        code += codeFragment + "\n";
    }

    // Add attribute channeling code
    var mappingIndex = 0, conversionCode = "";
    for( var name in vsConfig._attributes){
        var entry = vsConfig._attributes[name];
        for(var i = 0; i < entry.channeling.length; ++i){
            var channeling = entry.channeling[i], outputName = channeling.outputName;
            if(vs._outputInfo[outputName].iteration == C.ITERATION_TYPE.MANY){
                if(channeling.code)
                    conversionCode += "\t" + channeling.code + "\n";
                else
                    conversionCode += "\t" + outputName + " = #I{" + name + "};\n";
            }
        }
        mappingIndex++;
    }
    for( var i = 0; i < vsConfig._codeFragments.length; ++i){
        conversionCode += "\t" + vsConfig._codeFragments[i] + "\n";
    }
    code += convertCodeFragment(conversionCode, baseEntry, transferNames, directInputNames, usedNames) + "\n";

    code += "}\n";
    vs._glslCode = code;
}

function convertCodeFragment(codeFragment, entry, transferNames, directInputNames, usedNames){
    var index, operator = entry.operator;
    while((index = codeFragment.indexOf("#I{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var mappingIndex = getMappingIndex(operator, codeFragment.substring(index+3,end));
        var replaceName = entry.isTransferInput(mappingIndex) ?
            transferNames[entry.getTransferInputId(mappingIndex)] :
            directInputNames[entry.getDirectInputIndex(mappingIndex)];
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    while((index = codeFragment.indexOf("#O{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var outputIndex = getOutputIndex(operator, codeFragment.substring(index+3,end));
        var replaceName = transferNames[entry.getTransferOutputId(outputIndex)];
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    var localNames = [];
    while((index = codeFragment.indexOf("#L{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var key = codeFragment.substring(index+3,end);
        if(!localNames[key]){
            localNames[key] = getFreeName(key, usedNames);
        }
        var replaceName = localNames[key];
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    while((index = codeFragment.indexOf("#G{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var replaceName = codeFragment.substring(index+3,end);
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    return codeFragment;
}

function getFreeName(name, usedNames){
    var result = name, i = 1;
    while(usedNames.indexOf(result) != -1){
        result = name + "_" + (++i);
    }
    Utils.nameset.add(usedNames, result);
    return result;
}

function getMappingIndex(operator, name){
    for(var i = 0; i < operator.mapping.length; ++i){
        if(operator.mapping[i].name == name)
            return i;
    }
    throw new Error("Invalid input name '" + name  + "' inside of code fragment" );
}

function getOutputIndex(operator, name){
    for(var i = 0; i < operator.outputs.length; ++i){
        if(operator.outputs[i].name == name)
            return i;
    }
}

function getGLSLType(xflowType){
    switch(xflowType){
        case C.DATA_TYPE.BOOL : return 'bool';
        case C.DATA_TYPE.BYTE : return 'uint';
        case C.DATA_TYPE.FLOAT : return 'float';
        case C.DATA_TYPE.FLOAT2 : return 'vec2';
        case C.DATA_TYPE.FLOAT3 : return 'vec3';
        case C.DATA_TYPE.FLOAT4 : return 'vec4';
        case C.DATA_TYPE.FLOAT3X3 : return 'mat3';
        case C.DATA_TYPE.FLOAT4X4 : return 'mat4';
        case C.DATA_TYPE.INT : return 'int';
        case C.DATA_TYPE.INT4 : return 'ivec4';
    }
    throw new Error("Type not supported for GLSL " + C.getTypeName(xflowType) );
}

module.exports = VSProgram;

},{"../base.js":135,"../interface/constants.js":136,"../processing/vs-connect.js":186,"../utils/utils.js":187}],179:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var Channels = require("./channel.js");
var RequestNode = require("./process-node.js").RequestNode;
var ProcessNode = require("./process-node.js").ProcessNode;
var DataSlot = require("./data-slot.js");
var Operator = require("../operator/operator.js");

var ChannelMap = Channels.ChannelMap;

//----------------------------------------------------------------------------------------------------------------------
// ChannelNode
//----------------------------------------------------------------------------------------------------------------------

/**
 * Is created for each substitution (via dataflow) of a DataNode.
 * Stores an optimized representation of the data with ChannelMaps and Channels
 * On construction a ChannelNode is marked outOfSync and synchronized only once data is requested.
 * When the structure of a DataNode is changed in any way (e.g. rename InputNode, add/remove children) a channelNode
 * is marked outOfSync.
 * @param {DataNode} dataNode
 * @param {Substitution} substitution
 * @constructor
 */
var ChannelNode = function(dataNode, substitution){
    this.owner = dataNode;
    this.platform = C.PLATFORM.JAVASCRIPT;
    this.substitution = substitution;   // Substitution is defined by the dataflow instance
    this.loading = false;   // is true if any value in the sub tree is loading and the result can't be calculated
    this.inputSlots = {};   // DataEntries from direct InputNode children of the DataNode
    this.inputChannels = new ChannelMap();    // channel map for input data prio to operator execution
    this.computedChannels = new ChannelMap(); // channel map extend by operator output
    this.outputChannels = new ChannelMap();   // channel map with applied filter => final output

    /**
     * Operator attached to DataNode (guaranteed to be resolved)
     * @type {Object}
     */
    this.operator = null;
    /**
     * Channel node of the dataflowNode (analogue to dataflowNode of DataNode)
     * @type {ChannelNode}
     */
    this.dataflowChannelNode = null;
    /**
     * Process node - only constructed if an operator/dataflow is defined
     * @type {ProcessNode}
     */
    this.processNode = null;
    /**
     * Request Nodes created for each result request on this dataNode.
     * @type {Object.<String,RequestNode>}
     */
    this.requestNodes = {};
    /**
     * Number of uses of channel node. This is only relevant for channel nodes created with substitution.
     * These nodes are cached and the useCount is used to clean this cache.
     * TODO: Use weakmap here to avoid explicit reference count
     * @type {number}
     */
    this.useCount = 1;
    /**
     * True if the channel node is out of sync and internal channel maps need to be reconstructed
     * @type {boolean}
     */
    this.outOfSync = true;
};

/**
 * If node is out of sync, reconstruct all channels
 */
ChannelNode.prototype.synchronize = function(){

    if(this.outOfSync){
        updatePlatform(this);
        synchronizeChildren(this);
        updateInputChannels(this);
        updateComputedChannels(this);
        updateOutputChannels(this);
        this.outOfSync = false;
    }
};

ChannelNode.prototype.clear = function(){
    this.useCount = 0;
     this.inputChannels.clear();
     this.outputChannels.clear();
     // TODO: Make sure everything is cleaned up there!
    return true;
};

ChannelNode.prototype.increaseRef = function(){
    this.useCount++;
};

ChannelNode.prototype.decreaseRef = function(){
    this.useCount--;
    if(this.useCount == 0){
        this.clear();
        return true;
    }
    return false;
};

ChannelNode.prototype.getOutputNames = function(){
    this.synchronize();
    return this.outputChannels.getNames();
};

ChannelNode.prototype.getChildDataIndex = function(filter){
    this.synchronize();
    return this.outputChannels.getChildDataIndexForFilter(filter);
};

ChannelNode.prototype.setStructureOutOfSync = function()
{
    if(!this.outOfSync){
        this.outOfSync = true;
        this.inputChannels.clear();
        this.computedChannels.clear();
        this.outputChannels.clear();
        this.processNode && this.processNode.clear();
        for(var key in this.requestNodes){
            this.requestNodes[key].setStructureOutOfSync();
        }
    }
};

ChannelNode.prototype.notifyDataChange = function(inputNode, changeType){
    var key = inputNode._name + ";" + inputNode._key;
    if(this.inputSlots[key])
        this.inputSlots[key].setDataEntry(inputNode._data, changeType);
};

ChannelNode.prototype.getResult = function(type, filter) {
    this.synchronize();

    var key = filter ? filter.join(";") : "[null]";
    if(!this.requestNodes[key]){
        this.requestNodes[key] = new RequestNode(this, filter);
    }
    return this.requestNodes[key].getResult(type);
};


ChannelNode.prototype.getOutputChannelInfo = function(name){
    this.synchronize();

    var channel = this.outputChannels.getChannel(name);
    if(!channel)
        return null;
    var result = {
        type: channel.getType(),
        seqLength: channel.getSequenceLength(),
        seqMinKey: channel.getSequenceMinKey(),
        seqMaxKey: channel.getSequenceMaxKey(),
        origin: 0,
        originalName: ""
    };
    var preFilterName = this.owner._filterMapping ? this.owner._filterMapping.getRenameSrcName(name) : name;
    var dataEntry = channel.getDataEntry();
    if(this.dataflowChannelNode){
        var protoInputChannel = this.inputChannels.getChannel(preFilterName);
        if(!protoInputChannel || dataEntry != protoInputChannel.getDataEntry()){
            result.origin = C.ORIGIN.PROTO;
            result.originalName = preFilterName;
            return result;
        }
    }
    if(this.operator){
        var inputChannel = this.inputChannels.getChannel(preFilterName);
        if(!inputChannel || dataEntry != inputChannel.getDataEntry()){
            result.origin = C.ORIGIN.COMPUTE;
            result.originalName = this.owner._computeOutputMapping.getScriptOutputNameInv(preFilterName, this.operator.outputs);
            return result;
        }
    }
    result.origin = C.ORIGIN.CHILD;
    result.originalName = preFilterName;
    return result;
};

/**
 * Select the platform to compute the attached platform
 * @param {ChannelNode} channelNode
 */
function updatePlatform(channelNode) {
    var platform;
    var owner = channelNode.owner;
    var graph = owner._graph;

    // Platforms other than JavaScript are available only for computing operators
    if(!channelNode.owner._computeOperator) {
        return;
    }

    //TODO: Improve platform selection logic.
    // Currently we use forced platform if graph platform is something other than JavaScript
    // and forced platform (owner._platform) is defined
    platform = owner._platform !== null ? owner._platform : C.PLATFORM.JAVASCRIPT;

    channelNode.platform = platform;
}

/**
 *
 * @param {ChannelNode} channelNode
 */
function synchronizeChildren(channelNode){
    var dataNode = channelNode.owner;
    channelNode.loading = dataNode.isSubtreeLoading();

    /**
     * If the channel node represents a substitution, we also need to
     * synchronize the main ChannelNode of the DataNode
     */
    if(channelNode.substitution) {
        dataNode._channelNode.synchronize();
    }

    // Now synchronize all children (either referenced data node, or real children)
    // TODO: Change here if we change behaviour of src attribute
    if(dataNode._sourceNode){
        dataNode._sourceNode._getOrCreateChannelNode(channelNode.substitution).synchronize();
    }
    else{
        for(var i = 0; i < dataNode._children.length; ++i){
            if(dataNode._children[i]._getOrCreateChannelNode){
                dataNode._children[i]._getOrCreateChannelNode(channelNode.substitution).synchronize();
            }
        }
    }
}

/**
 *
 * @param {ChannelNode} channelNode
 */
function updateInputChannels(channelNode){
    var owner = channelNode.owner;
    // TODO: Change here if we change behaviour of src attribute
    if(owner._sourceNode){
        channelNode.inputChannels.merge(owner._sourceNode._getOrCreateChannelNode(channelNode.substitution).outputChannels, 0);
    }
    else{
        var children = owner._children;
        // First the DataNodes than the input nodes in order to override the DataNode channels
        mergeInputChannelDataNodes(channelNode, children);
        mergeInputChannelInputNodes(channelNode, children);
    }
}

/**
 * @param {ChannelNode} channelNode
 * @param {Array.<GraphNode>} children
 */
function mergeInputChannelInputNodes(channelNode, children) {
    for (var i = 0; i < children.length; ++i) {
        if (!children[i]._getOrCreateChannelNode) {  // Child is an InputNode
            var child = children[i];
            var key = child._name + ";" + child._key;
            if (!channelNode.substitution) {  // No dataflow
                var slot = new DataSlot(child._data, child._key);
                channelNode.inputSlots[key] = slot;
                channelNode.inputChannels.addDataEntry(child._name, slot);
            } else {
                if (child._paramName && channelNode.substitution.hasChannel(child._paramName)) {
                    channelNode.inputChannels.addChannel(child._name, channelNode.substitution.getChannel(child._paramName));
                } else {
                    channelNode.inputChannels.addDataEntry(child._name, channelNode.owner._channelNode.inputSlots[key]);
                }
            }
        }
    }
}

/**
 * @param {ChannelNode} channelNode
 * @param {Array.<GraphNode>} children
 */
function mergeInputChannelDataNodes(channelNode, children) {
    for (var i = 0; i < children.length; ++i) {
        if (children[i]._getOrCreateChannelNode) {  // Child is a DataNode
            channelNode.inputChannels.merge(children[i]._getOrCreateChannelNode(channelNode.substitution).outputChannels, i);
        }
    }
}

function updateComputedChannels(channelNode){
    var owner = channelNode.owner;
    channelNode.computedChannels.merge(channelNode.inputChannels);

    var oldDataflowChannelNode = channelNode.dataflowChannelNode;

    if( owner._computeUsesDataflow && owner._dataflowNode){
        channelNode.operator = null;
        updateDataflowChannelNode(channelNode);
        updateComputedChannelsFromDataflow(channelNode);
    }
    else if(!owner._computeUsesDataflow && owner._computeOperator){
        channelNode.dataflowChannelNode = null;
        updateOperator(channelNode);
        updateComputedChannelsFromOperator(channelNode);
    }

    if(oldDataflowChannelNode && oldDataflowChannelNode != channelNode.dataflowChannelNode){
        oldDataflowChannelNode.owner._removeSubstitutionNode(oldDataflowChannelNode);
    }
}

/**
 * Find and set the operator for the given ChannelNode
 * @param channelNode
 */
function updateOperator(channelNode){
    var operatorName, operator;
    var owner = channelNode.owner;

    if(channelNode.loading){
        channelNode.operator = null;
        return;
    }
    if(typeof owner._computeOperator == "string"){
        operatorName = owner._computeOperator;
        operator = null;

        // Getting a correct operator for the selected platform. If operator is not available, we'll try to get
        // the default JavaScript platform operator
        if(operatorName){
            operator = findOperatorByName(channelNode, owner);
            if(operator) { // TODO: Is this good? We calculated the platform before, now it just gets overriden
                channelNode.platform = operator.platform;
            }
        }
        channelNode.operator = operator;
    }else{
        channelNode.operator = owner._computeOperator;
    }
}

var c_typeComparisons = [];

/**
 * Find operator based on name in dataNode, platform and input mapping (signature)
 * @param {ChannelNode} channelNode
 * @param {DataNode} dataNode
 * @returns {Object|null}
 */
function findOperatorByName(channelNode, dataNode){
    var operatorName = dataNode._computeOperator,
        inputMapping = dataNode._computeInputMapping,
        inputChannels = channelNode.inputChannels;

    var operators = Operator.getOperators(operatorName, channelNode.platform) ||
                Operator.getOperators(operatorName, C.PLATFORM.JAVASCRIPT);
    if(!operators){
        Base.notifyError("No operator with name '" + operatorName+"' found", channelNode.owner);
    }

    var i = operators.length;
    while(i--){
        if(checkOperator(operators[i], inputMapping, inputChannels)){
            return operators[i];
        }
    }
    c_typeComparisons.length = 0;
    i = operators.length;
    while(i--){
        checkOperator(operators[i], inputMapping, inputChannels, c_typeComparisons);
    }
    var errorMessage = "No operator '" + operatorName+"' with matching type signature found:\n\n"
                        + c_typeComparisons.join("\n");
    Base.notifyError(errorMessage, channelNode.owner);
    return null;
}

/**
 *
 * @param operator
 * @param inputMapping
 * @param inputChannels
 * @param {Array?} typeComparisonsOutput If array is give, save error information
 * @returns {boolean}
 */
function checkOperator(operator, inputMapping, inputChannels, typeComparisonsOutput){
    var inputs, errors;
    if(typeComparisonsOutput){
        inputs = []; errors = [];
    }
    for(var i = 0; i < operator.params.length; ++i){
        var inputEntry = operator.params[i], sourceName = inputEntry.source;
        var dataName = inputMapping ? inputMapping.getScriptInputName(i, sourceName) : sourceName;
        var errorHeader;
        if(typeComparisonsOutput){
            errorHeader = "For " + (i+1) + ". argument '" + sourceName + "': ";
            inputs.push( C.getTypeName(inputEntry.type) + " " + sourceName + (inputEntry.optional ? " [optional]" : ""));
        }
        if(dataName){
            var channel = inputChannels.getChannel(dataName);
            if(!channel && !inputEntry.optional){
                if(!typeComparisonsOutput)
                    return false;
                else{
                    errors.push(errorHeader + "DataEntry '" + dataName + "' does not exist");
                }
            }
            if(channel && channel.getType() != inputEntry.type){
                if(!typeComparisonsOutput)
                    return false;
                else{
                    errors.push(errorHeader + "DataEntry '" + dataName + "' has wrong type '" + C.getTypeName(channel.getType()) + "'");
                }
            }
        }
    }
    if(typeComparisonsOutput){
        typeComparisonsOutput.push(operator.name + "(" + inputs.join(", ") + ")\n\t * " + errors.join("\n\t * "));
    }
    return true;
}

/**
 *
 * @param channelNode
 */
function updateComputedChannelsFromOperator(channelNode){
    var owner = channelNode.owner;
    if(channelNode.operator){
        var procNode = channelNode.processNode = new ProcessNode(channelNode);
        var index = 0;
        for(var name in procNode.outputDataSlots){
            var destName = name;
            if(owner._computeOutputMapping) destName = owner._computeOutputMapping.getScriptOutputName(index, name);
            if(destName){
                channelNode.computedChannels.addOutputDataSlot(destName, procNode.outputDataSlots[name], procNode);
            }
            index++;
        }
    }
}

/**
 *
 * @param {ChannelNode} channelNode
 */
function updateDataflowChannelNode(channelNode){
    var owner = channelNode.owner;
    var subSubstitution = new Substitution(owner._dataflowNode, channelNode);
    channelNode.dataflowChannelNode = owner._dataflowNode._getOrCreateChannelNode(subSubstitution);
}

/**
 * @param {ChannelNode} channelNode
 */
function updateComputedChannelsFromDataflow(channelNode){
    var owner = channelNode.owner;
    if(channelNode.dataflowChannelNode){
        var dataflowCNode = channelNode.dataflowChannelNode;
        dataflowCNode.synchronize();
        // TODO: We have to make sure to get outputNames in the right order to apply output mapping correctly
        var outputNames = dataflowCNode.outputChannels.getNames();
        for(var i = 0; i < outputNames.length; ++i){
            var srcName = outputNames[i], destName = srcName;
            if(owner._computeOutputMapping)
                destName = owner._computeOutputMapping.getScriptOutputName(i, srcName);
            if(destName)
                channelNode.computedChannels.addChannel(destName, dataflowCNode.outputChannels.getChannel(srcName));
        }
    }
}

function updateOutputChannels(channelNode){
    var dataNode = channelNode.owner;
    if(dataNode._filterMapping) {
        // TODO: This is the only location where applyFilterOnChannelMap is used. Can be simplified (e.g. without callback)
        dataNode._filterMapping.applyFilterOnChannelMap(channelNode.outputChannels, channelNode.computedChannels, dataNode._filterType, setChannelFilterCallback);
    }
    else
        channelNode.outputChannels.merge(channelNode.computedChannels);
}

function setChannelFilterCallback(destMap, destName, srcMap, srcName){
    var channel = srcMap.getChannel(srcName);
    destMap.addChannel(destName, channel, srcMap.getChildDataIndex(srcName));
}

//----------------------------------------------------------------------------------------------------------------------
// Substitution
//----------------------------------------------------------------------------------------------------------------------

/**
 * TODO: Think of replacing this with a channel map
 * @param dataflowNode
 * @param userChannelNode
 * @constructor
 */
var Substitution = function(dataflowNode, userChannelNode){
    this.map = {};

    createSubstitution(this, dataflowNode, userChannelNode);
};

Substitution.prototype.hasChannel = function(name){
    return !!this.map[name];
};
Substitution.prototype.getChannel = function(name){
    return this.map[name];
};

/**
 * Create a hashable key for the substiution
 * @param subDataflowNode
 * @returns {string}
 */
Substitution.prototype.getKey = function(subDataflowNode){
    var key = "";
    var globalParamNames = subDataflowNode._getGlobalParamNames();
    for(var i = 0; i < globalParamNames.length; ++i){
        var channel = this.map[globalParamNames[i]];
        key+= (channel && channel.id || "-") + "!";
    }
    var paramNames = subDataflowNode._getParamNames();
    for(i = 0; i < paramNames.length; ++i){
        channel = this.map[paramNames[i]];
        key+= (channel && channel.id || "-") + ".";
    }
    return key;
};

/**
 *
 * @param {Substitution} substitution
 * @param {DataNode} dataflowNode
 * @param {ChannelNode} userChannelNode
 */
function createSubstitution(substitution, dataflowNode, userChannelNode){
    var userOwner = userChannelNode.owner;

    // Find channels for global parameters
    var globalParamNames = dataflowNode._getGlobalParamNames();
    for(var i = 0; i < globalParamNames.length; ++i){
        substitution.map[globalParamNames[i]] = userChannelNode.inputChannels.getChannel(globalParamNames[i]);
    }

    // Find channels for local parameters. These will override existing global parameters
    var paramNames = dataflowNode._getParamNames();
    for(i = 0; i < paramNames.length; ++i){
        var destName = paramNames[i], srcName = destName;
        if(userOwner._computeInputMapping){
            srcName = userOwner._computeInputMapping.getScriptInputName(i, destName);
        }
        substitution.map[destName] = userChannelNode.inputChannels.getChannel(srcName);
    }
}

module.exports = {
    ChannelNode:  ChannelNode,
    Substitution: Substitution
};

},{"../base.js":135,"../interface/constants.js":136,"../operator/operator.js":176,"./channel.js":180,"./data-slot.js":181,"./process-node.js":184}],180:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var BufferEntry = require("../interface/data.js").BufferEntry;


//----------------------------------------------------------------------------------------------------------------------
// DataSlot
//----------------------------------------------------------------------------------------------------------------------


//----------------------------------------------------------------------------------------------------------------------
// ChannelMap
//----------------------------------------------------------------------------------------------------------------------

/**
 * A map with channels.
 * @constructor
 */
var ChannelMap = function(){
    /**
     * A map of channels.
     * @type {Object.<string, {channel: Channel, childDataIndex: Number}>}
     */
    this.map = {};
};


/**
 * Return a list of all keys.
 * @returns {Array.<string>}
 */
ChannelMap.prototype.getNames = function()
{
    return Object.keys(this.map);
};

/**
 *
 * @param name
 * @returns {Channel}
 */
ChannelMap.prototype.getChannel = function(name)
{
    if(!this.map[name])
        return null;
    return this.map[name].channel;
};

ChannelMap.prototype.getChildDataIndex = function(name)
{
    if(!this.map[name])
        return undefined;
    return this.map[name].childDataIndex;
};
ChannelMap.prototype.getChildDataIndexForFilter = function(filter){
    var result;
    filter = filter || this.getNames();
    for(var i = 0; i < filter.length; ++i){
        var idx = this.getChildDataIndex(filter[i]);
        if(idx == undefined) continue;
        if(result != undefined && result != idx)
            result = -1;
        else
            result = idx;
    }
    return result;
};

/**
 * TODO: Add a mergeWithChildIndex method?
 * @param {ChannelMap} otherChannelMap
 * @param {number?} childDataIndex Index relative to DataNode. Used to mark if channel comes
 * from a specific child DataNode, undefined if ChannelMap should take over child index from otherChannelMap
 */
ChannelMap.prototype.merge = function(otherChannelMap, childDataIndex){
    for(var name in otherChannelMap.map){
        // Either use provided child index, otherwise use child index from ChannelMap to merge
        // For input channel map we define the childDataIndex directly, for applied filters we use the
        // childDataIndex of the provided ChannelMap (it's just a renaming)
        var index = childDataIndex == undefined ? otherChannelMap.getChildDataIndex(name) : childDataIndex;
        this.addChannel(name, otherChannelMap.getChannel(name), index);
    }
};
/**
 * Add a channel with a childDataIndex
 * The childDataIndex defines the origin of the channel.
 * If childDataIndex is undefined the value of the channel can't be determined from one single DataNode
 * @param {String} name
 * @param {Channel} channel
 * @param {Number?} childDataIndex
 */
ChannelMap.prototype.addChannel = function(name, channel, childDataIndex){
    // TODO: Check if this is ever called with a proper childDataIndex value
    if(!channel) return;
    if(childDataIndex == undefined) childDataIndex = -1;
    mergeChannelIntoChannel(this, name, channel, childDataIndex);
};

/**
 * Add DataSlot to the Channel
 * @param name
 * @param dataSlot
 */
ChannelMap.prototype.addDataEntry = function(name, dataSlot)
{
    mergeDataSlotIntoChannel(this, name, dataSlot, -1);
};
/**
 * Add an output DataSlot that originates from an operator
 * @param {String} name
 * @param {DataSlot} dataSlot
 * @param {ProcessNode} creatorNode
 */
ChannelMap.prototype.addOutputDataSlot = function(name, dataSlot, creatorNode){
    var finalChannel = mergeDataSlotIntoChannel(this, name, dataSlot, -1);
    finalChannel.creatorProcessNode = creatorNode;
};

/**
 * Empty the channel map.
 */
ChannelMap.prototype.clear = function(){
    for(var name in this.map){
        var channel = this.map[name];
        if(channel && channel.map == this)
            channel.clear();
    }
    this.map = {};
};

function initChannelSlot(channelMap, name){
    if(!channelMap.map[name]){
        channelMap.map[name] = {
            channel: null,
            childDataIndex: undefined
        }
    }
}

function mergeChannelIntoChannel(channelMap, name, newChannel, childDataIndex){
    initChannelSlot(channelMap, name);
    var currentChannel = channelMap.map[name].channel;
    if(!currentChannel || !currentChannel.willMergeWithChannel(newChannel)) {
        channelMap.map[name].channel = newChannel;
        channelMap.map[name].childDataIndex = childDataIndex;
        return newChannel;
    }
    currentChannel = getMapOwnedChannel(channelMap, currentChannel);
    currentChannel.addChannelEntries(newChannel);
    channelMap.map[name].channel = currentChannel;
    channelMap.map[name].childDataIndex = -1;
    return currentChannel;
}

function mergeDataSlotIntoChannel(channelMap, name, dataSlot, childDataIndex){
    initChannelSlot(channelMap, name);
    var currentChannel = channelMap.map[name].channel;
    if(!currentChannel || !currentChannel.willMergeWithDataSlot(dataSlot)){
        var channel = new Channel(channelMap, dataSlot);
        channelMap.map[name].channel = channel;
        channelMap.map[name].childDataIndex = childDataIndex;
        return channel;
    }
    currentChannel = getMapOwnedChannel(channelMap, currentChannel);
    currentChannel.addDataSlot(dataSlot);
    channelMap.map[name].channel = currentChannel;
    channelMap.map[name].childDataIndex = -1;
    return currentChannel;
}


function getMapOwnedChannel(map, channel){
    if(channel.map != map){
        var newChannel = new Channel(map);
        newChannel.addChannelEntries(channel);
        newChannel.creatorProcessNode = channel.creatorProcessNode;
        return newChannel
    }
    return channel;
}


//----------------------------------------------------------------------------------------------------------------------
// Channel
//----------------------------------------------------------------------------------------------------------------------


/**
 * A channel may inclue several DataSlots/DataEntries
 * A declared Sequence will result in on channel with multiple DataEntries.
 * @constructor
 * @param {ChannelMap} map Owner of the channel
 * @param {DataSlot=} dataSlot Optional DataSlot added to the channel
 */
var Channel = function(map, dataSlot){
    /**
     * DataSlot entries sorted by key value
     * @type {Array.<DataSlot>}
     */
    this.entries = [];
    /**
     * Owner ChannelMap that created with channel.
     * Note: a channel can still exist in several ChannelMaps
     * @type {ChannelMap}
     */
    this.map = map;
    /**
     * Unique ID for this channel. Is used for several optimizations.
     */
    this.id = generateChannelId();
    /**
     * Listeners of this channels (usually ProcessNodes and RequestNodes)
     * @type {Array}
     */
    this.listeners = [];
    /**
     * The ProcessNode that created/extended the content of this channel
     * There can be only one creatorProcessNode per channel because
     * then ouput DataSlots of an operator will always have key "0"
     * If two operators influence the same sequence, the second operator'
     * output will replace the first operator's output, effectively removing the dependency.
     * @type {null}
     */
    this.creatorProcessNode = null;

    if(dataSlot){
        this.addDataSlot(dataSlot);
    }
};

/**
 * Add a dataSlot to the channel, adding dependencies.
 * No notifications send etc.
 * Makes sure that resulting channel has dataSlots ordered by key
 * @param dataSlot
 */
Channel.prototype.addDataSlot = function(dataSlot){
    dataSlot.addChannel(this);
    for(var i = 0; i < this.entries.length; ++i){
        var entry = this.entries[i];
        // We use epsilon here to detect data entries with "equal" key
        if(entry.key >= dataSlot.key - C.EPSILON ){
            if(Math.abs(entry.key - dataSlot.key) <= C.EPSILON){
                entry.removeChannel(this);
                this.entries.splice(i, 1, dataSlot);
            }
            else{
                this.entries.splice(i, 0, dataSlot);
            }
            break;
        }
    }
    this.entries.push(dataSlot);
};

Channel.prototype.getSequenceLength = function(){
    return this.entries.length;
};
Channel.prototype.getSequenceMinKey = function(){
    return this.entries[0].key;
};
Channel.prototype.getSequenceMaxKey = function(){
    return this.entries[this.entries.length - 1].key;
};
/**
 * The DataType of the channel.
 * Since all DataEntries within a channel have the same type, we can simply return the type of the first entry.
 * @returns {DATA_TYPE}
 */
Channel.prototype.getType = function(){
    if(this.entries.length == 0)
        return C.DATA_TYPE.UNKNOWN;
    else
        return this.entries[0].dataEntry._type;
};
/**
 * Merge another channel into this channel.
 */
Channel.prototype.addChannelEntries = function(otherChannel){
    for(var i = 0; i < otherChannel.entries.length; ++i){
        var slot = otherChannel.entries[i];
        this.addDataSlot(slot);
    }
    // FIXME: otherChannel might be without creatorProcessNode but still define a DataSlot with key 0
    // In this case we have to set creatorProcessNode to null
    if(otherChannel.creatorProcessNode)
        this.creatorProcessNode = otherChannel.creatorProcessNode;
    //else
    //    this.creatorProcessNode = null;
};
/**
 * Return a DataEntry from this channel depending on sequenceKey.
 * @param {C.SEQUENCE?} sequenceAccessType
 * @param {number?} sequenceKey
 * @returns {DataEntry}
 */
Channel.prototype.getDataEntry = function(sequenceAccessType, sequenceKey){
    if(this.entries.length == 0)
        return null;
    if(!sequenceAccessType){
        return this.entries[0].dataEntry;
    }


    var i = 0, max = this.entries.length;
    // TODO: Do binary search here?
    while(i < max && this.entries[i].key < sequenceKey) ++i;
    if(sequenceAccessType == C.SEQUENCE.PREV_BUFFER){
        return this.entries[i ? i -1 : 0].dataEntry;
    }
    else if(sequenceAccessType == C.SEQUENCE.NEXT_BUFFER){
        return this.entries[i < max ? i : max - 1].dataEntry;
    }
    else if(sequenceAccessType == C.SEQUENCE.LINEAR_WEIGHT){
        var weight1 = this.entries[i ? i - 1 : 0].key;
        var weight2 = this.entries[i < max ? i : max - 1].key;
        var value = new Float32Array(1);
        value[0] = weight2 == weight1 ? 0 : (sequenceKey - weight1) / (weight2 - weight1);
        // TODO: Check if repeated BufferEntry and Float32Array allocation is a serious bottleneck
        return new BufferEntry(C.DATA_TYPE.FLOAT, value);
    }
    return null;
};

/**
 * Return true of the two channels need to be merged (instead of replacing this channel with otherChannel)
 * @param otherChannel
 * @returns {boolean}
 */
Channel.prototype.willMergeWithChannel = function(otherChannel){
    if(this.entries.length != otherChannel.entries.length) return true;
    if(this.getType() != otherChannel.getType())
        return false;
    for(var i = 0; i < this.entries.length; i++){
        if(Math.abs(this.entries[i].key - otherChannel.entries[i].key) > C.EPSILON)
            return true;
    }
    return false;
};
/**
 * Return true if we need to merge the channel with this dataSlot
 * (instead of creating a new channel fromthis dataSlot)
 * @param dataSlot
 * @returns {boolean}
 */
Channel.prototype.willMergeWithDataSlot = function(dataSlot){
    if(this.entries.length > 1) return true;
    if(this.getType() != dataSlot.dataEntry._type) return false;
    return (Math.abs(this.entries[0].key - dataSlot.key) > C.EPSILON);
};

Channel.prototype.notifyOnChange = function(state){
    for(var i = 0; i < this.listeners.length; i++){
        this.listeners[i].onXflowChannelChange(this, state);
    }
};

Channel.prototype.addListener = function(processNode){
    this.listeners.push(processNode);
};
Channel.prototype.removeListener = function(processNode){
    var idx = this.listeners.indexOf(processNode);
    if(idx != -1) this.listeners.splice(idx, 1);
};

Channel.prototype.clear = function(){
    for(var i = 0; i < this.entries.length; ++i){
        this.entries[i].removeChannel(this);
    }
};

var c_channelKeyIdx = 0;
function generateChannelId(){
    return ++c_channelKeyIdx;
}

module.exports = {
    Channel: Channel,
    ChannelMap: ChannelMap
};

},{"../base.js":135,"../interface/constants.js":136,"../interface/data.js":137}],181:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");

/**
 * A DataSlot wraps a dataEntry and adds a key value for sequences.
 * This structure is used internally within channels and process nodes
 * @constructor
 * @param {DataEntry} dataEntry
 * @param {number=} key
 */
var DataSlot = function(dataEntry, key){
    this.key = key || 0;            // sequence key
    this.dataEntry = dataEntry;     // dataEntry of the slot
    /**
     * alternative dataEntry for asynchronous processing
     * only used for output DataSlots of asynchronous operators
     * @type {DataEntry}
     */
    this.asyncDataEntry = null;
    /**
     * list of all channels that contain this DataSlot
     * @type {Array.<Channel>}
     */
    this.parentChannels = [];

};
DataSlot.prototype.addChannel = function(channel){
    this.parentChannels.push(channel);
};
DataSlot.prototype.removeChannel = function(channel){
    var idx = this.parentChannels.indexOf(channel);
    if(idx != -1) this.parentChannels.splice(idx, 1);
};
DataSlot.prototype.swapAsync = function(){
    var tmp = this.dataEntry;
    this.dataEntry = this.asyncDataEntry;
    this.asyncDataEntry = tmp;
};

DataSlot.prototype.setDataEntry = function(dataEntry, changeType){
    this.dataEntry = dataEntry;
    var state = changeType == C.RESULT_STATE.CHANGED_DATA_VALUE ? C.DATA_ENTRY_STATE.CHANGED_VALUE :
        C.DATA_ENTRY_STATE.CHANGED_SIZE;
    this.notifyOnChange(state);
};

DataSlot.prototype.notifyOnChange = function(state){
    for(var i = 0; i < this.parentChannels.length; ++i){
        this.parentChannels[i].notifyOnChange(state);
    }
};

module.exports = DataSlot;

},{"../base.js":135,"../interface/constants.js":136}],182:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var OperatorList = require("../operator/operator-list.js");
var Utils = require("../utils/utils.js");
var Operator = require("../operator/operator.js");
var OperatorEntry = require("../operator/operator-entry.js");
var Program = require("../operator/program.js");

//----------------------------------------------------------------------------------------------------------------------
// Executor
//----------------------------------------------------------------------------------------------------------------------

/**
 * Tries to combine multiple ProcessNodes into a Program. Currently only used for vertex shaders.
 *
 * @param {RequestNode|ProcessNode} ownerNode
 * @param {C.PLATFORM} platform
 * @constructor
 */
var Executor = function(ownerNode, platform){
    this.platform = platform;

    /**
     * Nodes that are merged by this executor
     * @type {Array.<ProcessNode|RequestNode>}
     */
    this.mergedNodes = [];

    /**
     * Subset of this.mergedNodes that directly provide results of the executor
     * @type {Array.<ProcessNode>}
     */
    this.mergedOutputNodes = [];

    /**
     * ProcessNodes to be executed before this executor can be
     * executed
     * @type {Array.<ProcessNode>}
     */
    this.subNodes = [];

    /**
     * TODO: Unused. Remove?
     * @type {Array}
     */
    this.unprocessedDataNames = [];

    /**
     *  TODO: Maybe we should just store the cl-platform objects in global object so they are more easily available and
     *  to avoid long prototype chains. Or we could pass the graph context to each node of the graph.
     *  However, it would be good to allow each Graph object to have at least own context, cmdQueue and kernelManager.
     *  e.g. passing graph information here requires a long prototype chain
     */
    this.operatorList =  new OperatorList(platform);
    this.programData =  new Program.ProgramData();

    /**
     *
     * @type {Program}
     */
    this.program = null;

    constructExecutor(this, ownerNode);
};

    Executor.prototype.isProcessed = function(){
        var i = this.mergedOutputNodes.length;
        while(i--){
            if(this.mergedOutputNodes[i].status != C.PROCESS_STATE.PROCESSED)
                return false;
        }
        return true;
    };


    Executor.prototype.run = function(asyncCallback){
        runSubNodes(this);
        updateIterateState(this); // TODO check if iterate State has changes in any way and only refetch program in that case

        this.program = Program.createProgram(this.operatorList);

        if(this.program){
            this.operatorList.allocateOutput(this.programData, !!asyncCallback);
            this.program.run(this.programData, asyncCallback);
        }
        if(this.platform != C.PLATFORM.ASYNC){
            var i = this.mergedOutputNodes.length;
            while(i--){
                this.mergedOutputNodes[i].status = C.PROCESS_STATE.PROCESSED;
            }
        }


    };

    Executor.prototype.getVertexShader = function(){
        runSubNodes(this);
        updateIterateState(this);

        this.program = Program.createProgram(this.operatorList);

        return this.program;
    };

/**
 * Construct Executor
 * @param executer
 * @param ownerNode
 */
function constructExecutor(executer, ownerNode){
    var cData = {
        blockedNodes: [],   // Bad Nodes that cannot be merge. Filled during pre scan
        doneNodes: [],      // Nodes that have been signed up for merging. TODO: Redundant with constructionOrder and subNodes? - maybe yes!
        constructionOrder: [], // Store nodes in order of construction of OperatorEntries.
        inputSlots: {},     // Collected input channels of all merged nodes. Used to avoid assigning same input buffer twice
        finalOutput: null,  // finalOutput channes in case we have a RequestNode
        firstOperator: null // Set to first operator that has been merged (will be executed last)
    };
    var requestNode = initRequestNode(cData, executer, ownerNode);

    var noOperators = false; // TODO: Remove this?
    constructPreScan(cData, ownerNode, executer.platform, noOperators);

    setConstructionOrderAndSubNodes(cData, executer, ownerNode);

    constructFromData(executer, cData);
}
/**
 * Only relevant if ownerNodes is a RequestNode
 * Sets finalOutput of construction data and unprocessedDataNames
 * @param cData
 * @param executer
 * @param ownerNode
 * @returns {boolean}
 */
function initRequestNode(cData, executer, ownerNode){
    if(true) { // FIXME: ownerNode instanceof RequestNode){
        cData.finalOutput = {};
        var filter = ownerNode.filter || ownerNode.owner.outputChannels.getNames();
        for(var i = 0; i < filter.length; ++i){
            var name = filter[i];
            var channel = ownerNode.owner.outputChannels.getChannel(name);
            if(channel && channel.creatorProcessNode)
                cData.finalOutput[name] = channel.getDataEntry();
        }
        Utils.nameset.add(executer.unprocessedDataNames, filter);
        return true;
    }
    return false;
}
/**
 * Goes to processing subtree at filled blockedNodes array in construction data.
 * All nodes that cannot be merged or have parents that can't be merged will be blocked
 * @param cData
 * @param node
 * @param platform
 * @param noOperators
 */
function constructPreScan(cData, node, platform, noOperators){
    if(cData.blockedNodes.indexOf(node) != -1)
        return;

    if(node.operator){
        if(noOperators || !canOperatorMerge(cData, node.operator, platform)){
            blockSubtree(cData, node);
            return;
        }
        else{
            if(!cData.firstOperator) cData.firstOperator = node.operator;
            var mapping = node.operator.mapping;
            for(var i = 0; i < mapping.length; ++i){
                if(mapping[i].sequence){
                    blockInput(cData, node, mapping[i].source);
                    blockInput(cData, node, mapping[i].keySource);
                }
                else if(mapping[i].array){
                    // TODO: Rename .array to .randomAccess
                    blockInput(cData, node, mapping[i].source);
                }
            }
        }
    }
    for(var i = 0; i < node.children.length; ++i){
        constructPreScan(cData, node.children[i], platform, noOperators);
    }
}

function canOperatorMerge(cData, operator, platform){
    // TODO: Detect merge support
    return (platform == C.PLATFORM.ASYNC || !Operator.isOperatorAsync(operator)) &&
        (!cData.firstOperator ||
        (platform == C.PLATFORM.GLSL && cData.firstOperator.evaluate_glsl && operator.evaluate_glsl));
}

function blockSubtree(cData, node){
    if(cData.blockedNodes.indexOf(node) != -1)
        return;

    cData.blockedNodes.push(node);
    for(var i = 0; i < node.children.length; ++i){
        blockSubtree(cData, node.children[i]);
    }
}
/**
 * Block all processNodes assigned to an input channel
 * @param cData
 * @param node
 * @param inputName
 */
    function blockInput(cData, node, inputName){
        var channel = node.inputChannels[inputName];
        if(channel && channel.creatorProcessNode){
            blockSubtree(cData, channel.creatorProcessNode);
        }
    }
/**
 * Fill doneNodes and constructionOrder arrays of construction data.
 * It also fills the subNodes array of the executer
 * @param cData construction data
 * @param executer
 * @param node
 */
    function setConstructionOrderAndSubNodes(cData, executer, node){
        if(cData.doneNodes.indexOf(node) != -1)
            return;

        cData.doneNodes.push(node);

        if(cData.blockedNodes.indexOf(node) != -1){
            executer.subNodes.push(node);
        }
        else{
            for(var i = 0; i < node.children.length; ++i){
                setConstructionOrderAndSubNodes(cData, executer, node.children[i]);
            }

            if(node.operator){ // RequestNodes don't have an operator. Consider this case.
                cData.constructionOrder.push(node);
            }
        }
    }
/**
 * Last step of construction: create OperatorList from constructionOrder array
 * Also fill mergedNodes and programData
 * @param executer
 * @param cData
 */
    function constructFromData(executer, cData){

        for(var i = 0; i < cData.constructionOrder.length; ++i){
            var node = cData.constructionOrder[i];

            var entry = new OperatorEntry(node.operator);

            constructInputConnection(executer, entry, cData, node);

            var isOutputNode = constructOutputConnection(executer, entry, cData, node);

            executer.programData.operatorData.push({});
            executer.operatorList.addEntry(entry);
            executer.mergedNodes.push(node);
            if(isOutputNode || (i == cData.constructionOrder.length-1))
                executer.mergedOutputNodes.push(node)

        }

        constructLostOutput(executer, cData);
    }
/**
 * Construct input info for OperatorEntry.
 * Will implicitly create ProgramInputConnections for ProgramData
 * @param {Executor} executer
 * @param {OperatorEntry} entry
 * @param {{}} cData
 * @param {ProcessNode} node
 */
    function constructInputConnection(executer, entry, cData, node){
        var mapping = node.operator.mapping;
        for(var j = 0; j < mapping.length; ++j){
            var channel = node.inputChannels[mapping[j].source];
            var operatorIndex;
            if(channel && channel.creatorProcessNode && (operatorIndex =
                executer.mergedNodes.indexOf(channel.creatorProcessNode) ) != -1 )
            {
                // it's transfer input
                var outputIndex = getOperatorOutputIndex(channel.creatorProcessNode, channel);
                entry.setTransferInput(j, operatorIndex, outputIndex);
                var prevOperator = executer.operatorList.entries[operatorIndex];
                if(!prevOperator.isFinalOutput(outputIndex)){
                    prevOperator.setTransferOutput(outputIndex);
                }
                continue;
            }
            // Handle direct input

            var mappedInputName = mapping[j].source;
            if(node.owner.owner._computeInputMapping)
                mappedInputName = node.owner.owner._computeInputMapping.getScriptInputName(mapping[j].paramIdx, mapping[j].source);

            var connection = new Program.ProgramInputConnection();
            connection.channel = channel;
            connection.arrayAccess = mapping[j].array || false; // TODO: rename to randomAccess
            connection.sequenceAccessType = mapping[j].sequence || 0;
            if(connection.sequenceAccessType)
                connection.sequenceKeySourceChannel = node.inputChannels[mapping[j].keySource];

            var connectionKey = connection.getKey();
            var inputSlotIdx = cData.inputSlots[connectionKey];
            if(channel && inputSlotIdx != undefined){
                // Direct input already exists
                entry.setDirectInput(j, inputSlotIdx, mappedInputName);
            }
            else{
                // new direct input
                inputSlotIdx = executer.programData.inputs.length;
                cData.inputSlots[connectionKey] = inputSlotIdx;
                executer.programData.inputs.push(connection);
                entry.setDirectInput(j, inputSlotIdx, mappedInputName);
            }
        }
    }

/**
 * Construct output info of OperatorEntry
 * @param {Executor} executer
 * @param {OperatorEntry} entry
 * @param {{}} cData
 * @param {ProcessNode} node
 */
    function constructOutputConnection(executer, entry, cData, node){
        var outputs = node.operator.outputs;
        var isOutputNode = true;
        for(var i = 0; i < outputs.length; ++i){
            var slot = node.outputDataSlots[outputs[i].name];
            var finalOutputName = getFinalOutputName(slot, cData);
            if(finalOutputName){
                var index =  executer.programData.outputs.length;
                executer.programData.outputs.push(slot);
                entry.setFinalOutput(i, index);
                if(finalOutputName !== true){
                    Utils.nameset.remove(executer.unprocessedDataNames, finalOutputName);
                }
            }
            else{
                isOutputNode = false;
            }
        }
        return isOutputNode; // TODO: Check if computation of isOutputNode is really correct?
    }


    function getOperatorOutputIndex(processNode, channel){
        var outputs = processNode.operator.outputs;
        for(var i = 0; i < outputs.length; ++i){
            if(channel.getDataEntry() == processNode.outputDataSlots[outputs[i].name].dataEntry){
                return i;
            }
        }
        return null;
    }

    function getFinalOutputName(dataSlot, cData){
        if(!cData.finalOutput) // If root of Executor is a ProcessNode we don't have finalOutput defined and all outputs are final.
            return true;
        for(var name in cData.finalOutput){
            if(cData.finalOutput[name] == dataSlot.dataEntry){
                return name;
            }
        }
        return false;
    }

    function constructLostOutput(executer, cData){
        for(var i = 0; i < cData.constructionOrder.length; ++i){
            var node = cData.constructionOrder[i];
            var entry = executer.operatorList.entries[i];

            var outputs = node.operator.outputs;
            for(var j = 0; j < outputs.length; ++j){
                if(!entry.isFinalOutput(j) && ! entry.isTransferOutput(j)){
                    var index = executer.programData.outputs.length;
                    executer.programData.outputs.push(node.outputDataSlots[outputs[j].name]);
                    entry.setLostOutput(j, index);
                }
            }
        }
    }


    function updateIterateState(executer){
        var inputs = executer.programData.inputs;
        for(var i = 0; i < executer.programData.inputs.length; ++i){
            var entry = executer.programData.getDataEntry(i);
            var iterateCount = entry ? entry.getIterateCount ? entry.getIterateCount() : 1 : 0;
            if(!iterateCount)
                executer.operatorList.setInputIterateType(i, C.ITERATION_TYPE.NULL);
            else if(!inputs[i].arrayAccess && iterateCount > 1)
                executer.operatorList.setInputIterateType(i, C.ITERATION_TYPE.MANY);
            else
                executer.operatorList.setInputIterateType(i, C.ITERATION_TYPE.ONE);

            if(inputs[i].arrayAccess && platformRequiresArraySize(executer. platform)){
                executer.operatorList.setInputSize(i, iterateCount);
            }
        }
    }
/**
 * Determine if the platform needs to declare uniform array sizes in the source code.
 * @param platform
 * @returns {boolean}
 */
    function platformRequiresArraySize(platform){
        return platform == C.PLATFORM.GLSL;
    }


    function runSubNodes(executer){
        for(var i = 0; i < executer.subNodes.length; ++i){
            executer.subNodes[i].process();
        }
    }

module.exports = Executor;

},{"../base.js":135,"../interface/constants.js":136,"../operator/operator-entry.js":174,"../operator/operator-list.js":175,"../operator/operator.js":176,"../operator/program.js":177,"../utils/utils.js":187}],183:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./../interface/constants.js");


var orderMappingParser = /^([^:,{}]+)(,[^:{},]+)*$/;
var nameMappingParser = /^\{(([^:,{}]+:[^:{},]+)(,[^:{},]+:[^:},]+)*)}$/;

/**
 * A mapping used for a filter or a compute properties of a DataNode
 * @abstract
 */
var Mapping = function(){
    /**
     * @type {Array<DataNode>}
     */
    this._owners = [];
};

/**
 * Parse a Mapping (both C.OrderMapping or C.ComputeMapping) from a syntax string.
 * @param {string} string The syntax string.
 * @param {C.DataNode} dataNode DataNode of the Mapping
 * @returns {?C.Mapping}
 */
Mapping.parse = function(string, dataNode){
    string = string.trim();
    var results = string.trim().match(orderMappingParser);
    if(results)
        return OrderMapping.parse(string, dataNode);
    results = string.trim().match(nameMappingParser);
    if(results)
        return NameMapping.parse(results[1], dataNode);
    Base.notifyError("Cannot parse name mapping '" + string + "'", dataNode);
    return null;
};

/**
 *
 * @param {DataNode} owner
 * @private
 */
Mapping.prototype._addOwner = function(owner){
    var idx = this._owners.indexOf(owner);
    if(idx == -1)
        this._owners.push(owner);
};

/**
 *
 * @param {DataNode} owner
 * @private
 */
Mapping.prototype._removeOwner = function(owner){
    var idx = this._owners.indexOf(owner);
    if(idx != -1)
        this._owners.splice(idx, -1);
};


//----------------------------------------------------------------------------------------------------------------------
// OrderMapping
//----------------------------------------------------------------------------------------------------------------------

/**
 * An OrderMapping used for a filter or compute properties of a DataNode
 * It describes a mapping of names referring to the order of arguments / output values.
 * OrderMapping syntax examples in compute:
 * position = C.morph(position, posAdd, weight)
 * @constructor
 * @extends {Mapping}
 */
var OrderMapping = function(){
    Mapping.call(this);
    this._names = [];
};
Base.createClass(OrderMapping, Mapping);

OrderMapping.parse = function(string, dataNode){
    var mapping = new OrderMapping(dataNode);
    var token = string.split(",");
    for(var i = 0; i < token.length; i++){
        mapping._names.push(token[i].trim());
    }
    return mapping;
};


Object.defineProperty(OrderMapping.prototype, "length", {
    set: function(){ throw new Error("length is read-only");
    },
    get: function(){ return this._names.length; }
});

OrderMapping.prototype.getName = function(idx){
    return this._names[idx];
};

OrderMapping.prototype.clear = function(){
    this._names = [];
    mappingNotifyOwner(this);
};

OrderMapping.prototype.setName = function(index, name){
    this._names[index] = name;
    mappingNotifyOwner(this);
};


//noinspection JSUnusedGlobalSymbols
OrderMapping.prototype.removeName = function(index){
    this._names.splice(index);
    mappingNotifyOwner(this);
};

OrderMapping.prototype.isEmpty = function(){
    return this._names.length == 0;
};

/**
 *
 * @param {ChannelMap} destMap
 * @param {ChannelMap} sourceMap
 * @param {exports.C.DATA_FILTER_TYPE} filterType
 * @param {function(ChannelMap, string, ChannelMap, string)} callback
 */
OrderMapping.prototype.applyFilterOnChannelMap = function(destMap, sourceMap, filterType, callback){
    var i;
    if(filterType == C.DATA_FILTER_TYPE.KEEP){
        for(i = 0; i < this._names.length; ++i){
            var name = this._names[i];
            if(sourceMap.map[name]) {
                callback(destMap, name, sourceMap, name);
            }
        }
    }
    else{
        for(i in sourceMap.map){
            var idx = this._names.indexOf(i);
            if(filterType == C.DATA_FILTER_TYPE.RENAME ||
                (filterType == C.DATA_FILTER_TYPE.REMOVE && idx == -1))
                callback(destMap, i, sourceMap, i);
        }
    }
};

/**
 * Return the name of the input value assigned to operator argument.
 * Returns null, if no mapping is defined.
 * @param {number} index Position of the operator argument
 * @returns {string|null}
 */
OrderMapping.prototype.getScriptInputName = function(index /*, destName */){
    if(this._names[index])
        return this._names[index];
    else
        return null;
};

/**
 * Returns the name of the output parameter as it should be used for the
 * following dataflow. Returns null, if no mapping is defined.
 * @param index
 * @returns {string|null}
 */
OrderMapping.prototype.getScriptOutputName = function(index /*, srcName */){
    if(this._names[index])
        return this._names[index];
    else
        return null;
};

/**
 * Returns the inverse name of the output parameter as it should be used for the
 * following dataflow. Returns null, if no mapping is defined.
 * @param {string} destName
 * @param {array<object>} operatorOutputs
 * @returns {string|null}
 */
OrderMapping.prototype.getScriptOutputNameInv = function(destName, operatorOutputs){
    var index = this._names.indexOf(destName);
    if(index == -1)
        return null;
    return operatorOutputs[index].name;
};

/**
 * Identity function. Used to implement interface. Usually you don't rename with order
 * mapping.
 * @param name
 * @returns {string}
 */
OrderMapping.prototype.getRenameSrcName = function(name){
    return name;
};

//----------------------------------------------------------------------------------------------------------------------
// NameMapping
//----------------------------------------------------------------------------------------------------------------------

/**
 * An NameMapping used for a filter or compute properties of a DataNode
 * It describes a mapping of names referring to the original names of the arguments / output values.
 * NameMapping syntax examples in compute:
 * {position: result} = C.morph({value: position, valueAdd: posAdd, weight: weight})
 * @constructor
 * @extends {Mapping}
 */
var NameMapping = function(){
    Mapping.call(this);
    this._destNames = [];
    this._srcNames = [];

};
Base.createClass(NameMapping, Mapping);

NameMapping.parse = function(string, dataNode)  {
    var mapping = new NameMapping(dataNode);
    var token = string.split(",");
    for(var i = 0; i < token.length; i++){
        var pair = token[i].split(":");
        var dest = pair[0].trim(); var src = pair[1].trim();
        mapping.setNamePair(dest, src);
    }
    return mapping;
};

Object.defineProperty(NameMapping.prototype, "length", {
    set: function(){ throw new Error("length is read-only");
    },
    get: function(){ return this._srcNames.length; }
});

NameMapping.prototype.getDestName = function(idx){
    return this._destNames[idx];
};
NameMapping.prototype.getSrcName = function(idx){
    return this._srcNames[idx];
};

NameMapping.prototype.getSrcNameFromDestName = function(destName){
    var idx = this._destNames.indexOf(destName);
    return idx == -1 ? null : this._srcNames[idx];
};
NameMapping.prototype.getDestNameFromSrcName = function(srcName){
    var idx = this._srcNames.indexOf(srcName);
    return idx == -1 ? null : this._destNames[idx];
};

NameMapping.prototype.clear = function(){
    this._srcNames = [];
    this._destNames = [];
    mappingNotifyOwner(this);
};

NameMapping.prototype.setNamePair = function(destName, srcName){
    var idx = this._destNames.indexOf(destName);
    if(idx != -1){
        this._destNames.splice(idx,1);
        this._srcNames.splice(idx,1);
    }
    this._destNames.push(destName);
    this._srcNames.push(srcName);
    mappingNotifyOwner(this);
};

//noinspection JSUnusedGlobalSymbols
NameMapping.prototype.removeNamePair = function(destName){
    var idx = this._destNames.indexOf(destName);
    if(idx != -1){
        this._destNames.splice(idx,1);
        this._srcNames.splice(idx,1);
    }
    mappingNotifyOwner(this);
};

NameMapping.prototype.isEmpty = function(){
    return this._destNames.length == 0;
};

/**
 * @see OrderMapping.applyFilterOnChannelMap
 * @param {ChannelMap} destMap
 * @param {ChannelMap} sourceMap
 * @param {C.DATA_FILTER_TYPE} filterType
 * @param {function} callback
 */
NameMapping.prototype.applyFilterOnChannelMap = function(destMap, sourceMap, filterType, callback) {
    var i;
    if(filterType == C.DATA_FILTER_TYPE.REMOVE){
        for(i in sourceMap.map)
            if(this._srcNames.indexOf(i) == -1)
                callback(destMap, i, sourceMap, i);
    }
    else{
        if(filterType == C.DATA_FILTER_TYPE.RENAME){
            for(i in sourceMap.map)
                if(this._srcNames.indexOf(i) == -1)
                    callback(destMap, i, sourceMap, i);
        }
        for(i in this._destNames){
            callback(destMap, this._destNames[i], sourceMap, this._srcNames[i]);
        }
    }
};

/**
 * Renames: Look-up the destination name and return the source name
 * @param {string} name
 * @returns {string}
 */
NameMapping.prototype.getRenameSrcName = function(name){
    return this.getSrcNameFromDestName(name) || name;
};

/**
 * Return the name of the input value assigned to operator argument
 * @param {number} index Position of the operator argument
 * @param {string} destinationName Name of the operator argument
 * @returns {string|null}
 */
NameMapping.prototype.getScriptInputName= function(index, destinationName){
    return this.getSrcNameFromDestName(destinationName);
};

/**
 * @see OrderMapping.getScriptOutputName
 */
NameMapping.prototype.getScriptOutputName = function(index, srcName){
    return this.getDestNameFromSrcName(srcName);
};

/**
 * @see OrderMapping.getScriptOutputNameInv
 */
NameMapping.prototype.getScriptOutputNameInv = function(destName /*, operatorOutputs */){
    var index = this._destNames.indexOf(destName);
    if(index == -1)
        return null;
    return this._srcNames[index];
};

/**
 * Notify all DataNodes that use the mapping passed to the function
 * @param {Mapping} mapping
 */
function mappingNotifyOwner(mapping){
    for(var i = 0; i < mapping._owners.length; ++i) {
        mapping._owners[i].notify(C.RESULT_STATE.CHANGED_STRUCTURE);
    }
    Base._flushResultCallbacks();
}
module.exports = {
    NameMapping: NameMapping,
    OrderMapping: OrderMapping,
    Mapping: Mapping
};

},{"../base.js":135,"./../interface/constants.js":136}],184:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var utils = require("../utils/utils.js");
var Executor = require("./executor.js");
var Result = require("./result.js");
var Operator = require("../operator/operator.js");
var Data = require("../interface/data.js");
var DataSlot = require("../processing/data-slot.js");

var BufferEntry = Data.BufferEntry;
var TextureEntry = Data.TextureEntry;
var ImageDataTextureEntry = Data.ImageDataTextureEntry;

//----------------------------------------------------------------------------------------------------------------------
// C.ProcessNode
//----------------------------------------------------------------------------------------------------------------------

var ASYNC_PROCESS_STATE = {
    IDLE : 0,
    RUNNING : 1,
    RESCHEDULED : 2,
    INIT: 3
};


/**
 * Optimized representation for the processing graph. Only created for ChannelNodes with operators.
 * Is connected directly to other ProcessNodes, ignoring channels that are not relevant for processing
 * @param {ChannelNode} channelNode
 * @constructor
 * @extends {GraphNode}
 */
var ProcessNode = function(channelNode){
    this.owner = channelNode;
    this.operator = channelNode.operator;

    /**
     * Input channels for the operator
     * @type {Object.<string, Channel>}
     */
    this.inputChannels = {};

    /**
     * Outputs of operator
     * @type {Object.<string, DataSlot>}
     */
    this.outputDataSlots = {};

    /**
     * @type {exports.C.PROCESS_STATE}
     */
    this.status = C.PROCESS_STATE.MODIFIED;

    /**
     * @type {ASYNC_PROCESS_STATE}
     */
    this.asyncProcessState = ASYNC_PROCESS_STATE.INIT;

    /**
     * Direct Children without transitive children of children
     * TODO: Use Set()?
     * @type {Array.<ProcessNode>}
     */
    this.children = [];

    /**
     * Children with transitive dependencies
     * TODO: Use Set()?
     * @type {Array.<ProcessNode>}
     */
    this.descendants = [];

    /**
     * Callback, the executor needs to call when the computation is ready
     * @type {Function}
     * @private
     */
    this._bindedAsyncCallback = null;

    /**
     * Index of array matches platform id (C.PLATFORM)
     * @type {Array.<Executor>}
     */
    this.executers = [];

    constructProcessNode(this, channelNode);

    if(Operator.isOperatorAsync(this.operator)){
        this._bindedAsyncCallback = this.receiveAsyncProcessing.bind(this);
    }
};

ProcessNode.prototype.onXflowChannelChange = function(channel, state){
    if (Operator.isOperatorAsync(this.operator)) {
        if (this.status == C.PROCESS_STATE.LOADING || this.asyncProcessState != ASYNC_PROCESS_STATE.INIT) {
            this.status = C.PROCESS_STATE.MODIFIED;
            this.updateState();
        }
    }
    else {

        if (state == C.DATA_ENTRY_STATE.CHANGED_VALUE && this.status > C.PROCESS_STATE.UNPROCESSED) {
            this.status = C.PROCESS_STATE.UNPROCESSED;
        } else {
            this.status = C.PROCESS_STATE.MODIFIED;
        }
        this.notifyOutputChanged(state);
    }
};

ProcessNode.prototype.startAsyncProcessing = function(){
    if(this.asyncProcessState == ASYNC_PROCESS_STATE.IDLE || this.asyncProcessState == ASYNC_PROCESS_STATE.INIT){
        this.asyncProcessState = ASYNC_PROCESS_STATE.RUNNING;
        var executer = getOrCreateExecuter(this, C.PLATFORM.ASYNC);
        executer.run(this._bindedAsyncCallback);
    }
    else{
        this.asyncProcessState = ASYNC_PROCESS_STATE.RESCHEDULED;
    }
};
ProcessNode.prototype.receiveAsyncProcessing = function(){
    this.status = C.PROCESS_STATE.PROCESSED;
    this.notifyOutputChanged(C.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE);
    if(this.asyncProcessState == ASYNC_PROCESS_STATE.RESCHEDULED){
        this.asyncProcessState = ASYNC_PROCESS_STATE.IDLE;
        this.status = C.PROCESS_STATE.MODIFIED;
        this.updateState();
    }
    else{
        this.asyncProcessState = ASYNC_PROCESS_STATE.IDLE;
    }
    Base._flushResultCallbacks();
};



ProcessNode.prototype.notifyOutputChanged = function(state){
    for(var name in this.outputDataSlots){
        this.outputDataSlots[name].notifyOnChange(state);
    }
};


ProcessNode.prototype.clear = function(){
    for(var name in this.inputChannels){
        this.inputChannels[name] && this.inputChannels[name].removeListener(this);
    }
};

ProcessNode.prototype.updateState = function(){
    if(this.status == C.PROCESS_STATE.MODIFIED){
        this.status = C.PROCESS_STATE.UNPROCESSED;

        XML3D.debug.assert(!this.owner.loading, "This should never happen");

        if(this.owner.loading)
            this.status = C.PROCESS_STATE.LOADING;
        else{
            for(var i = 0; i < this.children.length; ++i){
                this.status = Math.min(this.status, this.children[i].updateState());
            }
            if(this.status > C.PROCESS_STATE.LOADING && isInputLoading(this.operator, this.inputChannels))
                this.status = C.PROCESS_STATE.LOADING;

            if(this.status > C.PROCESS_STATE.INVALID &&
                !checkInput(this, this.operator, this.owner.owner._computeInputMapping, this.inputChannels))
                this.status = C.PROCESS_STATE.INVALID;

            if(this.status == C.PROCESS_STATE.UNPROCESSED && Operator.isOperatorAsync(this.operator)){
                this.status = this.asyncProcessState == ASYNC_PROCESS_STATE.INIT ? C.PROCESS_STATE.LOADING
                    : C.PROCESS_STATE.PROCESSED;
                this.startAsyncProcessing();
            }

        }
    }
    return this.status;
};

ProcessNode.prototype.process = function(){

    if(this.status == C.PROCESS_STATE.UNPROCESSED){
        var executer = getOrCreateExecuter(this, this.owner.platform);
        executer.run();
        this.status = C.PROCESS_STATE.PROCESSED;
    }
};

/**
 *
 * @param {ProcessNode} processNode
 * @param {ChannelNode} channelNode
 */
function constructProcessNode(processNode, channelNode){
    var dataNode = channelNode.owner;
    synchronizeInputChannels(processNode, channelNode, dataNode);
    synchronizeChildrenAndDescendants(processNode.children, processNode.descendants, processNode.inputChannels);
    synchronizeOutput(processNode.operator, processNode.outputDataSlots);
}

/**
 *
 * @param processNode
 * @param channelNode
 * @param dataNode
 */
function synchronizeInputChannels(processNode, channelNode, dataNode){
    var operator = processNode.operator, inputMapping = dataNode._computeInputMapping;
    for(var i = 0; i < operator.params.length; ++i){
        var sourceName = operator.params[i].source;
        var dataName = inputMapping ? inputMapping.getScriptInputName(i, sourceName) : sourceName;
        if(dataName){
            var channel = channelNode.inputChannels.getChannel(dataName);
            if(channel) channel.addListener(processNode);
            processNode.inputChannels[sourceName] = channel;
        }
    }
}

function isInputLoading(operator, inputChannels){
    for(var i in operator.params){
        var entry = operator.params[i];
        var channel = inputChannels[entry.source];
        if(!channel) continue;
        var dataEntry = channel.getDataEntry();
        if(!dataEntry) continue;
        if(dataEntry.isLoading && dataEntry.isLoading()) return true;
    }
    return false;
}

function checkInput(processNode, operator, inputMapping, inputChannels){
    var dataNode = processNode.owner.owner;
    for(var i in operator.params){
        var entry = operator.params[i];
        var dataName = inputMapping ? inputMapping.getScriptInputName(i, entry.source) : entry.source;
        if(!entry.optional && !dataName){
            Base.notifyError("Xflow: operator " + operator.name + ": Missing input argument for "
                + entry.source, dataNode);
            return false;
        }
        if(dataName){
            var channel = inputChannels[entry.source];
            if(!channel){
                if(!inputMapping) continue;
                Base.notifyError("Xflow: operator " + operator.name + ": Input of name '" + dataName +
                    "' not found. Used for parameter " + entry.source, dataNode);
                return false;
            }
            var dataEntry = channel.getDataEntry();

            if(!channel.creatorProcessNode){
                if(!entry.optional && (!dataEntry || dataEntry.isEmpty())){
                    Base.notifyError("Xflow: operator " + operator.name + ": Input for " + entry.source +
                        ' contains no data.', dataNode);
                    return false;
                }
            }
            if(dataEntry && dataEntry.type != entry.type){
                Base.notifyError("Xflow: operator " + operator.name + ": Input for " + entry.source +
                    " has wrong type. Expected: " + C.getTypeName(entry.type)
                    + ", but got: " +  C.getTypeName(dataEntry.type), dataNode);
                return false;
            }
        }
    }
    return true;
}

function synchronizeChildrenAndDescendants(children, descendants, inputChannels){
    var channel;
    for(var name in inputChannels){
        channel = inputChannels[name];
        if(channel && channel.creatorProcessNode){
            utils.set.add(children, channel.creatorProcessNode);
            utils.set.add(descendants, channel.creatorProcessNode.descendants);
        }
    }
    utils.set.remove(children, descendants);
    utils.set.add(descendants, children);
}

function synchronizeOutput(operator, outputs){
    var async = Operator.isOperatorAsync(operator);
    for(var i in operator.outputs){
        var dataEntry = operator.outputs[i];

        var entry, asyncEntry;
        var type = dataEntry.type;
        if(type != C.DATA_TYPE.TEXTURE){
            entry = new BufferEntry(type, null);
            if(async) asyncEntry = new BufferEntry(type, null);
        }
        else{
            entry = window.document ? new TextureEntry(null) : new ImageDataTextureEntry(null);
            if(async) asyncEntry = window.document ? new TextureEntry(null) : new ImageDataTextureEntry(null);
        }
        outputs[dataEntry.name] = new DataSlot(entry, 0);
        if(async) outputs[dataEntry.name].asyncDataEntry = asyncEntry;
    }
}

function getOrCreateExecuter(node, platform){
    if(!node.executers[platform]){
        node.executers[platform] = new Executor(node, platform);
    }
    return node.executers[platform];
}


//----------------------------------------------------------------------------------------------------------------------
// RequestNode
//----------------------------------------------------------------------------------------------------------------------
/**
 *
 * FIXME: RequestNodes are never deleted.
 * @param {ChannelNode} channelNode
 * @param {Array.<string>} filter
 * @constructor
 */
var RequestNode = function(channelNode, filter){
    this.owner = channelNode;
    this.filter = filter;

    /**
     *
     * @type {Object<C.PLATFORM, exports.Result>}
     */
    this.results = {};

    /**
     * @type {exports.C.PROCESS_STATE}
     */
    this.status = C.PROCESS_STATE.MODIFIED;

    /**
     * @type {Object.<string, Channel>}
     */
    this.channels = {};

    /**
     * @see ProcessNode.children
     * @type {Array}
     */
    this.children = [];

    /**
     * @see ProcessNode.executers
     * @type {Array}
     */
    this.executers = [];

    /**
     * @see ProcessNode.outOfSync
     * @type {boolean}
     */
    this.outOfSync = true;
};

RequestNode.prototype.synchronize = function(){
    if(this.outOfSync){
        this.outOfSync = false;
        synchronizeRequestChannels(this, this.owner);
        synchronizeChildrenAndDescendants(this.children, [], this.channels);
    }
};

RequestNode.prototype.updateState = function(){
    this.synchronize();
    if(this.status == C.PROCESS_STATE.MODIFIED){
        this.status = C.PROCESS_STATE.UNPROCESSED;

        if(this.owner.loading) {
            this.status = C.PROCESS_STATE.LOADING;
        } else {
            for(var i = 0; i < this.children.length; ++i){
                this.status = Math.min(this.status, this.children[i].updateState());
            }
        }
    }
    return this.status;
};

RequestNode.prototype.getResult = function(resultType){
    this.updateState();

    // TODO: This could be in getRequestComputeResult
    if(this.status == C.PROCESS_STATE.UNPROCESSED){
        if(resultType == C.RESULT_TYPE.COMPUTE){
            var executer = getOrCreateExecuter(this, this.owner.platform);
            if(!executer.isProcessed())
                executer.run();
        }
        this.status = C.PROCESS_STATE.PROCESSED;
    }
    var result = null;
    if (resultType == C.RESULT_TYPE.COMPUTE) {
        result = getRequestComputeResult(this);
    } else if (resultType == C.RESULT_TYPE.VS) {
        result = getRequestVSResult(this);
    }
    result.loading = (this.status == C.PROCESS_STATE.LOADING);
    return result;
};

RequestNode.prototype.setStructureOutOfSync = function(){
    this.outOfSync = true;
    this.status = C.PROCESS_STATE.MODIFIED;
    for(var type in this.results){
        this.results[type]._notifyChanged(C.RESULT_STATE.CHANGED_STRUCTURE);
    }
    for(var name in this.channels){
        this.channels[name].removeListener(this);
    }
    this.channels = [];
    this.children = [];
    this.executers = [];
};

RequestNode.prototype.onXflowChannelChange = function(channel, state){
    if(channel.creatorProcessNode)
        this.status = C.PROCESS_STATE.MODIFIED;
    var notifyState = (state == C.DATA_ENTRY_STATE.CHANGED_VALUE ? C.RESULT_STATE.CHANGED_DATA_VALUE
            : C.RESULT_STATE.CHANGED_DATA_SIZE);

    for(var type in this.results){
        this.results[type]._notifyChanged(notifyState);
    }
};

/**
 *
 * @param requestNode
 * @param channelNode
 */
function synchronizeRequestChannels(requestNode, channelNode){
    var names = requestNode.filter;
    if(!names){
        names = channelNode.outputChannels.getNames();
    }

    for(var i = 0; i < names.length; ++i){
        var name = names[i];
        var channel = channelNode.outputChannels.getChannel(name);
        if(channel){
            requestNode.channels[name] = channel;
            channel.addListener(requestNode);
        }
    }
}

/**
 *
 * @param {RequestNode} requestNode
 * @returns {Result}
 */
function getRequestComputeResult(requestNode)
{
    if(!requestNode.results[C.RESULT_TYPE.COMPUTE])
        requestNode.results[C.RESULT_TYPE.COMPUTE] = new Result.ComputeResult();

    var result = requestNode.results[C.RESULT_TYPE.COMPUTE];
    result._dataEntries = {}; result._outputNames = [];

    for(var name in requestNode.channels){
        var entry = requestNode.channels[name].getDataEntry();
        result._dataEntries[name] = entry && !entry.isEmpty() ? entry : null;
        result._outputNames.push(name);
    }
    return result;
}

/**
 *
 * @param requestNode
 * @returns {exports.VSDataResult}
 */
function getRequestVSResult(requestNode)
{
    var executer = getOrCreateExecuter(requestNode, C.PLATFORM.GLSL);
    if(!requestNode.results[C.RESULT_TYPE.VS])
        requestNode.results[C.RESULT_TYPE.VS] = new Result.VSDataResult();
    var result = requestNode.results[C.RESULT_TYPE.VS];

    var program = executer.getVertexShader();
    result._program = program;
    result._programData = executer.programData;
    return result;
}


module.exports = {
    RequestNode: RequestNode,
    ProcessNode: ProcessNode
};


},{"../base.js":135,"../interface/constants.js":136,"../interface/data.js":137,"../operator/operator.js":176,"../processing/data-slot.js":181,"../utils/utils.js":187,"./executor.js":182,"./result.js":185}],185:[function(require,module,exports){
var Base = require("../base.js");
require("../../utils/array.js");

var queueResultCallback = Base._queueResultCallback;

/**
 * Content of this file:
 * Result classes of an Xflow graph which are received through Requests.
 */

/**
 * Abstract Result structure containing a (processed) result of the Xflow graph.
 * @abstract
 */
var Result = function(){
    this.loading = false;
    /** Valid is false if an error occurred during the processing of the result */
    this.valid = false;
    this._listeners = [];
    this._requests = [];
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype.addListener = function(callback){
    this._listeners.push(callback);
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype.removeListener = function(callback){
    Array.erase(this._listeners, callback);
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype._addRequest = function(request){
    this._requests.push(request);
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype._removeRequest = function(request){
    Array.erase(this._requests, request);
};


Result.prototype._notifyChanged = function(state){
    this.valid = false;
    for(var i = 0; i < this._requests.length; ++i){
        this._requests[i]._onResultChanged(state);
    }
    queueResultCallback(this, state);
}

Result.prototype._onPostponedResultChanged = function(state){
    for(var i = 0; i < this._listeners.length; ++i){
        this._listeners[i](this, state);
    }
}



/**
 * ComputeResult contains a named map of typed values.
 * @constructor
 * @extends {Result}
 */
var ComputeResult = function(){
    Result.call(this);
    this._outputNames = [];
    /** @type {Object.<string,DataEntry>} */
    this._dataEntries = {};
};
Base.createClass(ComputeResult, Result);

Object.defineProperty(ComputeResult.prototype, "outputNames", {
    set: function(v){
        throw new Error("outputNames is readonly");
    },
    get: function(){ return this._outputNames; }
});

ComputeResult.prototype.getOutputData = function(name){
    return this._dataEntries[name];
};

/**
 * @returns {Object.<string,DataEntry>}
 */
ComputeResult.prototype.getOutputMap = function() {
    return this._dataEntries;
};



/**
 * VSDataResult is used to analyse the output of a VertexShader
 * Note that the VSDataResult is not used to generate the VertexShader directly.
 * For that, the VertexShader structure must be created from VertexShaderRequest
 * @constructor
 * @extends {Result}
 */
var VSDataResult = function(){
    Result.call(this);
    this._program = null;
    this._programData = null;
};
Base.createClass(VSDataResult, Result);

Object.defineProperty(VSDataResult.prototype, "outputNames", {
    set: function(v){
        throw new Error("shaderOutputNames is readonly");
    },
    get: function(){ return this._program.getOutputNames(); }
});

VSDataResult.prototype.isOutputUniform = function(name){
    return this._program.isOutputUniform(name);
}
VSDataResult.prototype.isOutputNull = function(name){
    return this._program.isOutputNull(name);
}
VSDataResult.prototype.getOutputType = function(name){
    return this._program.getOutputType(name);
}
VSDataResult.prototype.getVertexShader = function(vsConfig){
    return this._program.createVertexShader(this._programData, vsConfig);
}

module.exports = {
    ComputeResult:  ComputeResult,
    VSDataResult: VSDataResult
};

},{"../../utils/array.js":127,"../base.js":135}],186:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./../interface/constants.js");

var initAnonymousOperator = require("../operator/operator.js").initAnonymousOperator;

var shaderConstant = {};
shaderConstant[C.SHADER_CONSTANT_KEY.OBJECT_ID] = "objectID";
shaderConstant[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM] = "screenTransform";
shaderConstant[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM_NORMAL] = "screenTransformNormal";
shaderConstant[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM] = "viewTransform";
shaderConstant[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM_NORMAL] = "viewTransformNormal";
shaderConstant[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM] = "worldTransform";
shaderConstant[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM_NORMAL] = "worldTransformNormal";

var setShaderConstant = function(type, name){
    shaderConstant[type] = name;
};


/**
 * The output configuration of a VertexShader generated by Xflow
 * @constructor
 */
var VSConfig = function(){
    this._attributes = {};
    this._blockedNames = [];
    this._addInput = {};
    this._addOutput = {};
    this._codeFragments = [];
    this._outputChanneling = {};
};

VSConfig.prototype.addAttribute = function(type, name, optional){
    if(this._attributes[name]){
        if(this._attributes[name].type != type)
            throw new Error("Tries to add two attributes with different types of name '" + name + '"');
        this._attributes[name].optional = this._attributes[name].optional && optional;
        return;
    }
    this._attributes[name] = {type: type, optional: optional, channeling: []};
};

VSConfig.prototype.channelAttribute = function(inputName, outputName, code){
    this._attributes[inputName].channeling.push( { outputName : outputName, code : code });
};

VSConfig.prototype.addInputParameter = function(type, name, uniform){
    if(this._addInput[name])
        return;
    this._addInput[name] = { type: type, uniform: uniform };
    this._blockedNames.push(name);
};
VSConfig.prototype.addOutputParameter = function(type, name){
    if(this._addOutput[name])
        return;
    this._addOutput[name] = { type: type };
    this._blockedNames.push(name);
};
VSConfig.prototype.addCodeFragment = function(codeFragment){
    this._codeFragments.push(codeFragment);
};

VSConfig.prototype.addBlockedName = function(name){
    this._blockedNames.push(name);
};

VSConfig.prototype.getBlockedNames = function(){
    return this._blockedNames;
};

VSConfig.prototype.getFilter = function(){
    return Object.keys(this._attributes);
};
VSConfig.prototype.getKey = function(){
    var key = "";
    for(var name in this._attributes){
        var attr = this._attributes[name];
        key += ";" + attr.type + "," + name + "," + attr.optional;
    }
    return key;
};

var c_vs_operator_cache = {};

VSConfig.prototype.getOperator = function(){
    var key = this.getKey();
    if(c_vs_operator_cache[key])
        return c_vs_operator_cache[key];

    var outputs = [], params = [], glslCode = "\t// VS Connector\n";
    name = "VSConnect";
    for(var name in this._attributes){
        var attr = this._attributes[name];
        var type = C.getTypeName(attr.type);
        outputs.push( { type: type, name: name} );
        params.push( { type: type, source: name, optional: attr.optional} );
        name += "T" + type + "N" + name + "O" + attr.optional + ".";
    }
    var operator = initAnonymousOperator(name,
    {
        outputs: outputs,
        params:  params,
        evaluate_glsl: glslCode
    });
    c_vs_operator_cache[key] = operator;
    return operator;
};

var VertexShader = function(programData){
    this._programData = programData;
    this._glslCode = null;
    this._inputNames = [];
    this._outputNames = [];
    this._inputInfo = {};
    this._outputInfo = {};
};

Object.defineProperty(VertexShader.prototype, "inputNames", {
    set: function(v){
        throw new Error("inputNames is readonly");
    },
    get: function(){ return this._inputNames; }
});

Object.defineProperty(VertexShader.prototype, "outputNames", {
    set: function(v){
        throw new Error("outputNames is readonly");
    },
    get: function(){ return this._outputNames; }
});

VertexShader.prototype.isInputUniform = function(name){
    return this._inputInfo[name].uniform;
};
VertexShader.prototype.getInputData = function(name){
    return this._programData.getDataEntry(this._inputInfo[name].index);
};

VertexShader.prototype.isOutputNull = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.NULL;
};
VertexShader.prototype.isOutputFragmentUniform = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.ONE;
};
VertexShader.prototype.getUniformOutputData = function(name){
    return this._programData.getDataEntry(this._outputInfo[name].index);
};
VertexShader.prototype.getOutputType = function(name){
    return this._outputInfo[name].type;
};
VertexShader.prototype.getOutputSourceName = function(name){
    return this._outputInfo[name].sourceName;
};
VertexShader.prototype.getGLSLCode = function(){
    return this._glslCode;
};

module.exports = {
    shaderConstant: shaderConstant,
    setShaderConstant: setShaderConstant,
    VSConfig: VSConfig,
    VertexShader: VertexShader
};

},{"../base.js":135,"../operator/operator.js":176,"./../interface/constants.js":136}],187:[function(require,module,exports){
require("../../utils/array.js");
var set = {};


set.add = function(setArray, setToAdd){
    if(Array.isArray(setToAdd)){
        for(var i = 0; i < setToAdd.length; ++i){
            if(setArray.indexOf(setToAdd[i]) == -1)
                setArray.push(setToAdd[i]);
        }
    }
    else{
        if(setArray.indexOf(setToAdd) == -1)
            setArray.push(setToAdd);
    }
}
set.remove = function(setArray, setToRemove){
    var idx;
    if(Array.isArray(setToRemove)){
        for(var i = 0; i < setToRemove.length; ++i){
            if( (idx = setArray.indexOf(setToRemove[i])) != -1)
                setArray.splice(idx,1);
        }
    }
    else{
        if( (idx = setArray.indexOf(setToRemove)) != -1)
            setArray.splice(idx,1);
    }
}

set.intersection = function(dest, setA, setB){
    var size = setA.length;
    for(var i = 0; i < size; ++i){
        if(setB.indexOf(setA[i]) != -1)
            dest.push(setA[i]);
    }
}

set.isIntersecting = function(setA, setB){
    var i = setA.length;
    while(i--){
        if(setB.indexOf(setA[i]) != -1)
            return true;
    }
    return false;
}

set.isSubset = function(smallerSet, largerSet){
    var i = smallerSet.length;
    while(i--){
        if(largerSet.indexOf(smallerSet[i]) == -1)
            return false;
    }
    return true;
}

/**
 * Nameset Utilities for Xflow
 */
var nameset = {};

nameset.add = function(nameSet, toAdd){
    if(!toAdd) return;
    if(typeof toAdd == "string"){
        if(nameSet.indexOf(toAdd) == -1)
            nameSet.push(toAdd);
    }
    else{
        for(var i = 0; i < toAdd.length; ++i){
            if(nameSet.indexOf(toAdd[i]) == -1)
                nameSet.push(toAdd[i]);
        }
    }
}

nameset.remove = function(nameSet, toRemove){
    if(!toRemove) return;
    if(typeof toRemove == "string"){
        var removeIdx = nameSet.indexOf(toRemove);
        if(removeIdx != -1)
            nameSet.splice(removeIdx, 1);
    }
    else{
        for(var i = 0; i < toRemove.length; ++i){
            var removeIdx = nameSet.indexOf(toRemove[i]);
            if(removeIdx != -1)
                nameSet.splice(removeIdx, 1);
        }
    }
}

nameset.intersection = function(nameSetA, nameSetB){
    var i = nameSetA.length;
    while(i--){
        if(nameSetB.indexOf(nameSetA[i]) == -1){
            nameSetA.splice(i,1);
        }
    }
}


var binarySearch = function(keys, key, maxIndex){
    var min = 0, max = maxIndex - 1;
    while(min <= max){
        var i = Math.floor((min + max) / 2);
        if(keys[i] == key){
            return i;
        }
        else if(keys[i] < key)
            min = i + 1;
        else
            max = i - 1;
    }
    return max;
}

module.exports = {
    set: set,
    nameset: nameset,
    binarySearch: binarySearch
}
},{"../../utils/array.js":127}],188:[function(require,module,exports){

module.exports = require("./init.js");
},{"./init.js":30}],189:[function(require,module,exports){
module.exports = {
    XML3D: require("../../src/xml3d.js").XML3D,
    Frustum: require("../../src/renderer/renderer/tools/frustum"),
    Scene: require("../../src/renderer/renderer/scene/scene"),
    SceneConstants: require("../../src/renderer/renderer/scene/constants"),
    XflowConstants: require("../../src/xflow/interface/constants.js"),
    DataNode: require("../../src/xflow/interface/graph.js").DataNode,
    VSConfig: require("../../src/xflow/processing/vs-connect.js").VSConfig,
    VertexShaderRequest: require("../../src/xflow/interface/request.js").VertexShaderRequest,
    ComputeRequest: require("../../src/xflow/interface/request.js").ComputeRequest,
    Events: require("../../src/interface/notification.js"),
    URI: require("../../src/utils/uri.js"),
    AdapterHandle: require("../../src/base/adapterhandle.js"),
    Adapter: require("../../src/base/adapter.js"),
    addFragmentShaderHeader: require("../../src/renderer/webgl/shader/shader-utils.js").addFragmentShaderHeader,
    callAdapterFunc: require("../../src/utils/misc.js").callAdapterFunc
};

},{"../../src/base/adapter.js":7,"../../src/base/adapterhandle.js":8,"../../src/interface/notification.js":36,"../../src/renderer/renderer/scene/constants":59,"../../src/renderer/renderer/scene/scene":68,"../../src/renderer/renderer/tools/frustum":70,"../../src/renderer/webgl/shader/shader-utils.js":117,"../../src/utils/misc.js":131,"../../src/utils/uri.js":133,"../../src/xflow/interface/constants.js":136,"../../src/xflow/interface/graph.js":138,"../../src/xflow/interface/request.js":139,"../../src/xflow/processing/vs-connect.js":186,"../../src/xml3d.js":188}]},{},[189])(189)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlc1xcZ3J1bnQtYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXItcGFja1xcX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Rpc3QvZ2wtbWF0cml4LmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy90ZXh0dXJlLW1hbmFnZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGV4dHVyZS1tYW5hZ2VyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlc1xcdGV4dHVyZS1tYW5hZ2VyXFxub2RlX21vZHVsZXNcXHBlcmZvcm1hbmNlLW5vd1xcbGliXFxwZXJmb3JtYW5jZS1ub3cuanMiLCJzcmMvYXNzZXQvYXNzZXQuanMiLCJzcmMvYmFzZS9hZGFwdGVyLmpzIiwic3JjL2Jhc2UvYWRhcHRlcmhhbmRsZS5qcyIsInNyYy9iYXNlL2Zvcm1hdGhhbmRsZXIuanMiLCJzcmMvYmFzZS9yZXNvdXJjZW1hbmFnZXIuanMiLCJzcmMvY29udHJpYi9FdmVudERpc3BhdGNoZXIuanMiLCJzcmMvY29udHJpYi9nbHUuanMiLCJzcmMvY29udHJpYi9zdGFja3RyYWNlLTAuNC5qcyIsInNyYy9jb250cmliL3N0YXRlLW1hY2hpbmUuanMiLCJzcmMvZGF0YS9hZGFwdGVyL2Fzc2V0LmpzIiwic3JjL2RhdGEvYWRhcHRlci9iYXNlLmpzIiwic3JjL2RhdGEvYWRhcHRlci9jb21wdXRlLmpzIiwic3JjL2RhdGEvYWRhcHRlci9kYXRhLmpzIiwic3JjL2RhdGEvYWRhcHRlci9kYXRhZmxvdy5qcyIsInNyYy9kYXRhL2FkYXB0ZXIvZmFjdG9yeS5qcyIsInNyYy9kYXRhL2FkYXB0ZXIvamF2YXNjcmlwdC9mYWN0b3J5LmpzIiwic3JjL2RhdGEvYWRhcHRlci9qc29uL2ZhY3RvcnkuanMiLCJzcmMvZGF0YS9hZGFwdGVyL21pc2MuanMiLCJzcmMvZGF0YS9hZGFwdGVyL3NjcmlwdC5qcyIsInNyYy9kYXRhL2FkYXB0ZXIvdGV4dHVyZS5qcyIsInNyYy9kYXRhL2FkYXB0ZXIvdHJhbnNmb3JtLmpzIiwic3JjL2RhdGEvYWRhcHRlci92YWx1ZXMuanMiLCJzcmMvZGF0YS90cmFuc2Zvcm0tZmV0Y2hlci5qcyIsInNyYy9nbG9iYWwuanMiLCJzcmMvaW5pdC5qcyIsInNyYy9pbnRlcmZhY2UvYXR0cmlidXRlcy5qcyIsInNyYy9pbnRlcmZhY2UvY29uZmlndXJhdGlvbi5qcyIsInNyYy9pbnRlcmZhY2UvZG9tLmpzIiwic3JjL2ludGVyZmFjZS9lbGVtZW50cy5qcyIsInNyYy9pbnRlcmZhY2UvbWV0aG9kcy5qcyIsInNyYy9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzIiwic3JjL2ludGVyZmFjZS9wcm9wZXJ0aWVzLmpzIiwic3JjL21hdGgvYmJveC5qcyIsInNyYy9tYXRoL21hdGguanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci9iYXNlLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2FkYXB0ZXIvZGVmcy5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9hZGFwdGVyL2ZhY3RvcnkuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci9ncm91cC5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9hZGFwdGVyL2xpZ2h0LmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2FkYXB0ZXIvbGlnaHRzaGFkZXIuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci9tZXNoLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2FkYXB0ZXIvbW9kZWwuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci9zaGFkZXIuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci90cmFuc2Zvcm1hYmxlLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2FkYXB0ZXIvdmlldy5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9hZGFwdGVyL3htbDNkLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2NhbnZhcy1oYW5kbGVyLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2NvbmZpZ3VyZS5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9ldmVudHMvbW91c2UuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvZXZlbnRzL3RvdWNoLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2xpZ2h0cy9saWdodC1tYW5hZ2VyLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2xpZ2h0cy9saWdodC1tb2RlbHMuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvcmVuZGVyZXItZmFjdG9yeS5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9zY2VuZS9jb25zdGFudHMuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvc2NlbmUvZHJhd2FibGVjbG9zdXJlLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3NjZW5lL21hdGVyaWFsLWNvbmZpZ3VyYXRpb24uanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvc2NlbmUvcGFnZXIuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvc2NlbmUvcmVuZGVyZ3JvdXAuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvc2NlbmUvcmVuZGVybGlnaHQuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvc2NlbmUvcmVuZGVybm9kZS5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9zY2VuZS9yZW5kZXJvYmplY3QuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvc2NlbmUvcmVuZGVydmlldy5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9zY2VuZS9zY2VuZS5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci90b29scy9kYXRhY2hhbmdlbGlzdGVuZXIuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvdG9vbHMvZnJ1c3R1bS5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci90b29scy9vYmplY3Rzb3J0ZXIuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvdXRpbHMuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvYmFzZS9jb250ZXh0LmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL2Jhc2UvZnVsbHNjcmVlbnF1YWQuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvYmFzZS9tZXNoLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL2Jhc2UvcHJvZ3JhbS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9iYXNlL3JlbmRlcnRhcmdldC5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9iYXNlL3RleHR1cmUuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvYmFzZS91dGlscy5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9jYW52YXMtaGFuZGxlci5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvYWJzdHJhY3RzaGFkZXJjbG9zdXJlLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy9hYnN0cmFjdHNoYWRlcmNvbXBvc2VyLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy9ldmVudHMuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL2pzL2pzc2hhZGVyY2xvc3VyZS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvanMvanNzaGFkZXJjb21wb3Nlci5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvanMvanNzeXN0ZW1jb25maWd1cmF0aW9uLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy9zaGFkZXJjb21wb3NlcmZhY3RvcnkuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL3NoYWRvd21hcC1zZXJ2aWNlLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy91cm4vZGlmZnVzZS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvdXJuL21hdHRlLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy91cm4vcGhvbmcuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL3Vybi9wb2ludC5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvdXJuL3NoYWRlci1kZXNjcmlwdG9yLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy91cm4vc2hhZGVycy5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvdXJuL3VybnNoYWRlcmNsb3N1cmUuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL3Vybi91cm5zaGFkZXJjb21wb3Nlci5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvdXJuL3V0aWxpdHkuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLWludGVyZmFjZS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItcGFzc2VzL2Jhc2UuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy9ib3hibHVyLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3JlbmRlci1wYXNzZXMvZm9yd2FyZC5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItcGFzc2VzL2xpZ2h0LXBhc3MuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy9waWNrLW5vcm1hbC5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItcGFzc2VzL3BpY2stb2JqZWN0LmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3JlbmRlci1wYXNzZXMvcGljay1wb3NpdGlvbi5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItcGFzc2VzL3BvaW50bGlnaHQtcGFzcy5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItcGFzc2VzL3NjZW5lLXBhc3MuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy9zc2FvLXBhc3MuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy92ZXJ0ZXhhdHRyaWJ1dGUtcGFzcy5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItdHJlZXMvYmFzZS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItdHJlZXMvZm9yd2FyZC5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXJlci5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9zY2VuZS9kcmF3YWJsZS1mYWN0b3J5LmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3NjZW5lL2dsbGlnaHRzLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3NjZW5lL2dsc2NlbmUuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVyL3Byb2dyYW1mYWN0b3J5LmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlci9zaGFkZXItdXRpbHMuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvc3lzdGVtL3N5c3RlbS1ub3RpZmllci5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC94Zmxvdy91dGlscy5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC94Zmxvdy94Zmxvdy1tZXNoLmpzIiwic3JjL3R5cGVzL2JveC5qcyIsInNyYy90eXBlcy9kYXRhLW9ic2VydmVyLmpzIiwic3JjL3R5cGVzL21hdHJpeC5qcyIsInNyYy90eXBlcy9yYXkuanMiLCJzcmMvdHlwZXMvcm90YXRpb24uanMiLCJzcmMvdHlwZXMvdmVjMy5qcyIsInNyYy91dGlscy9hcnJheS5qcyIsInNyYy91dGlscy9jc3MuanMiLCJzcmMvdXRpbHMvY3NzTWF0cml4LmpzIiwic3JjL3V0aWxzL2RlYnVnLmpzIiwic3JjL3V0aWxzL21pc2MuanMiLCJzcmMvdXRpbHMvb3B0aW9ucy5qcyIsInNyYy91dGlscy91cmkuanMiLCJzcmMvdXRpbHMvd2ViY2wuanMiLCJzcmMveGZsb3cvYmFzZS5qcyIsInNyYy94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzIiwic3JjL3hmbG93L2ludGVyZmFjZS9kYXRhLmpzIiwic3JjL3hmbG93L2ludGVyZmFjZS9ncmFwaC5qcyIsInNyYy94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9jbC1wcm9ncmFtLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvYWRkLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvYnVmZmVyU2VsZWN0LmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvY2xhbXBJbWFnZS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2NvbnZvbHV0ZUltYWdlLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvY3JlYXRlSUdJbmRleC5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2NyZWF0ZVRyYW5zZm9ybS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2NyZWF0ZVRyYW5zZm9ybUludi5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2RlYnVnLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvZmxpcE5vcm1hbC5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2ZsaXBWZXJ0aWNhbEltYWdlLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvZm9yd2FyZEtpbmVtYXRpY3MuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9mb3J3YXJkS2luZW1hdGljc0ludi5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2Z1bk1pcnJvckltYWdlLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvZ2V0LmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvZ3JheXNjYWxlSW1hZ2UuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9pbmRleC5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2xlcnAzc2VxLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvbWFnbml0dWRlSW1hZ2UuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9tZXJnZTMuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9tb3JwaDMuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9tdWw0eDQuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9ub2lzZUltYWdlLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvbm9ybWFsaXplMy5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L3BvcGFydEltYWdlLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvcmdiZVBOR3RvRmxvYXQuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9zZWxlY3RCb29sLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvc2VsZWN0VHJhbnNmb3JtLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvc2VwaWFJbWFnZS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L3NraW5EaXJlY3Rpb24uanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9za2luUG9zaXRpb24uanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9zbGVycHNlcS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L3NvYmVsSW1hZ2UuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9zdWIzLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL29wZXJhdG9yLWVudHJ5LmpzIiwic3JjL3hmbG93L29wZXJhdG9yL29wZXJhdG9yLWxpc3QuanMiLCJzcmMveGZsb3cvb3BlcmF0b3Ivb3BlcmF0b3IuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvcHJvZ3JhbS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci92cy1wcm9ncmFtLmpzIiwic3JjL3hmbG93L3Byb2Nlc3NpbmcvY2hhbm5lbC1ub2RlLmpzIiwic3JjL3hmbG93L3Byb2Nlc3NpbmcvY2hhbm5lbC5qcyIsInNyYy94Zmxvdy9wcm9jZXNzaW5nL2RhdGEtc2xvdC5qcyIsInNyYy94Zmxvdy9wcm9jZXNzaW5nL2V4ZWN1dG9yLmpzIiwic3JjL3hmbG93L3Byb2Nlc3NpbmcvbWFwcGluZy5qcyIsInNyYy94Zmxvdy9wcm9jZXNzaW5nL3Byb2Nlc3Mtbm9kZS5qcyIsInNyYy94Zmxvdy9wcm9jZXNzaW5nL3Jlc3VsdC5qcyIsInNyYy94Zmxvdy9wcm9jZXNzaW5nL3ZzLWNvbm5lY3QuanMiLCJzcmMveGZsb3cvdXRpbHMvdXRpbHMuanMiLCJzcmMveG1sM2QuanMiLCJ0ZXN0cy9idWlsZC9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3OUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2lCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgZ2wtbWF0cml4IC0gSGlnaCBwZXJmb3JtYW5jZSBtYXRyaXggYW5kIHZlY3RvciBvcGVyYXRpb25zXG4gKiBAYXV0aG9yIEJyYW5kb24gSm9uZXNcbiAqIEBhdXRob3IgQ29saW4gTWFjS2VuemllIElWXG4gKiBAdmVyc2lvbiAyLjIuMlxuICovXG5cbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG5cbihmdW5jdGlvbihfZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBzaGltID0ge307XG4gIGlmICh0eXBlb2YoZXhwb3J0cykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIHNoaW0uZXhwb3J0cyA9IHt9O1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2hpbS5leHBvcnRzO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdsLW1hdHJpeCBsaXZlcyBpbiBhIGJyb3dzZXIsIGRlZmluZSBpdHMgbmFtZXNwYWNlcyBpbiBnbG9iYWxcbiAgICAgIHNoaW0uZXhwb3J0cyA9IHR5cGVvZih3aW5kb3cpICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IF9nbG9iYWw7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGdsLW1hdHJpeCBsaXZlcyBpbiBjb21tb25qcywgZGVmaW5lIGl0cyBuYW1lc3BhY2VzIGluIGV4cG9ydHNcbiAgICBzaGltLmV4cG9ydHMgPSBleHBvcnRzO1xuICB9XG5cbiAgKGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgICAvKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG5cbmlmKCFHTE1BVF9FUFNJTE9OKSB7XG4gICAgdmFyIEdMTUFUX0VQU0lMT04gPSAwLjAwMDAwMTtcbn1cblxuaWYoIUdMTUFUX0FSUkFZX1RZUEUpIHtcbiAgICB2YXIgR0xNQVRfQVJSQVlfVFlQRSA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJykgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbn1cblxuaWYoIUdMTUFUX1JBTkRPTSkge1xuICAgIHZhciBHTE1BVF9SQU5ET00gPSBNYXRoLnJhbmRvbTtcbn1cblxuLyoqXG4gKiBAY2xhc3MgQ29tbW9uIHV0aWxpdGllc1xuICogQG5hbWUgZ2xNYXRyaXhcbiAqL1xudmFyIGdsTWF0cml4ID0ge307XG5cbi8qKlxuICogU2V0cyB0aGUgdHlwZSBvZiBhcnJheSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZlY3RvcnMgYW5kIG1hdHJpY2VzXG4gKlxuICogQHBhcmFtIHtUeXBlfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XG4gKi9cbmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBHTE1BVF9BUlJBWV9UWVBFID0gdHlwZTtcbn1cblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMuZ2xNYXRyaXggPSBnbE1hdHJpeDtcbn1cblxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG5cbi8qKlxuKiBDb252ZXJ0IERlZ3JlZSBUbyBSYWRpYW5cbipcbiogQHBhcmFtIHtOdW1iZXJ9IEFuZ2xlIGluIERlZ3JlZXNcbiovXG5nbE1hdHJpeC50b1JhZGlhbiA9IGZ1bmN0aW9uKGEpe1xuICAgICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDIgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMyXG4gKi9cblxudmFyIHZlYzIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSkge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zdWIgPSB2ZWMyLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLm11bCA9IHZlYzIubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2NhbGVBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5kaXN0ID0gdmVjMi5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3FyRGlzdCA9IHZlYzIuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmxlbiA9IHZlYzIubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnNxckxlbiA9IHZlYzIuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMyLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMi5jcm9zcyA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgICBvdXRbMF0gPSBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICAgIHZhciByID0gR0xNQVRfUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGU7XG4gICAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDIgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MmQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDNcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDMgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCBcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjMnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMi4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzIuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcpJztcbn07XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLnZlYzIgPSB2ZWMyO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgMyBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzNcbiAqL1xuXG52YXIgdmVjMyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnN1YiA9IHZlYzMuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMubXVsID0gdmVjMy5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmRpdiA9IHZlYzMuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmRpc3QgPSB2ZWMzLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl07XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnNxckRpc3QgPSB2ZWMzLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMzLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMubGVuID0gdmVjMy5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMy5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnNxckxlbiA9IHZlYzMuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqejtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMy5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXTtcblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuXG4gICAgdmFyIHIgPSBHTE1BVF9SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gICAgdmFyIHogPSAoR0xNQVRfUkFORE9NKCkgKiAyLjApIC0gMS4wO1xuICAgIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZTtcblxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICAgIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICAgIHcgPSB3IHx8IDEuMDtcbiAgICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gICAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdO1xuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIC8vIGJlbmNobWFya3M6IGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3RhdGVYID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgIHZhciBwID0gW10sIHI9W107XG5cdCAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXHQgIHBbMF0gPSBhWzBdIC0gYlswXTtcblx0ICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuXG5cdCAgLy9wZXJmb3JtIHJvdGF0aW9uXG5cdCAgclswXSA9IHBbMF07XG5cdCAgclsxXSA9IHBbMV0qTWF0aC5jb3MoYykgLSBwWzJdKk1hdGguc2luKGMpO1xuXHQgIHJbMl0gPSBwWzFdKk1hdGguc2luKGMpICsgcFsyXSpNYXRoLmNvcyhjKTtcblxuXHQgIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblx0ICBvdXRbMF0gPSByWzBdICsgYlswXTtcblx0ICBvdXRbMV0gPSByWzFdICsgYlsxXTtcblx0ICBvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVkgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFsyXSpNYXRoLnNpbihjKSArIHBbMF0qTWF0aC5jb3MoYyk7XG4gIFx0clsxXSA9IHBbMV07XG4gIFx0clsyXSA9IHBbMl0qTWF0aC5jb3MoYykgLSBwWzBdKk1hdGguc2luKGMpO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVogPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFswXSpNYXRoLmNvcyhjKSAtIHBbMV0qTWF0aC5zaW4oYyk7XG4gIFx0clsxXSA9IHBbMF0qTWF0aC5zaW4oYykgKyBwWzFdKk1hdGguY29zKGMpO1xuICBcdHJbMl0gPSBwWzJdO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjMy5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDM7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbnZlYzMuYW5nbGUgPSBmdW5jdGlvbihhLCBiKSB7XG4gICBcbiAgICB2YXIgdGVtcEEgPSB2ZWMzLmZyb21WYWx1ZXMoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgdmFyIHRlbXBCID0gdmVjMy5mcm9tVmFsdWVzKGJbMF0sIGJbMV0sIGJbMl0pO1xuIFxuICAgIHZlYzMubm9ybWFsaXplKHRlbXBBLCB0ZW1wQSk7XG4gICAgdmVjMy5ub3JtYWxpemUodGVtcEIsIHRlbXBCKTtcbiBcbiAgICB2YXIgY29zaW5lID0gdmVjMy5kb3QodGVtcEEsIHRlbXBCKTtcblxuICAgIGlmKGNvc2luZSA+IDEuMCl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKTtcbiAgICB9ICAgICBcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzMuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJyknO1xufTtcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMudmVjMyA9IHZlYzM7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyA0IERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjNFxuICovXG5cbnZhciB2ZWM0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjNFxuICpcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHosIHcpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjNCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSwgeiwgdykge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuc3ViID0gdmVjNC5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICogYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5tdWwgPSB2ZWM0Lm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC8gYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZGl2ID0gdmVjNC5kaXZpZGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZGlzdCA9IHZlYzQuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWM0LnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zcXJEaXN0ID0gdmVjNC5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjNC5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5sZW4gPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWM0LnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnNxckxlbiA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IC1hWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICBvdXRbM10gPSAxLjAgLyBhWzNdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgICAgICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICAgICAgICBvdXRbM10gPSBhWzNdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzQuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl0sXG4gICAgICAgIGF3ID0gYVszXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgICAvL1RPRE86IFRoaXMgaXMgYSBwcmV0dHkgYXdmdWwgd2F5IG9mIGRvaW5nIHRoaXMuIEZpbmQgc29tZXRoaW5nIGJldHRlci5cbiAgICBvdXRbMF0gPSBHTE1BVF9SQU5ET00oKTtcbiAgICBvdXRbMV0gPSBHTE1BVF9SQU5ET00oKTtcbiAgICBvdXRbMl0gPSBHTE1BVF9SQU5ET00oKTtcbiAgICBvdXRbM10gPSBHTE1BVF9SQU5ET00oKTtcbiAgICB2ZWM0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgdmVjNC5zY2FsZShvdXQsIG91dCwgc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSwgdyA9IGFbM107XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICAgIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWM0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWM0LiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjNHMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjNC5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdOyB2ZWNbM10gPSBhW2krM107XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdOyBhW2krM10gPSB2ZWNbM107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWM0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWM0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMudmVjNCA9IHZlYzQ7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyAyeDIgTWF0cml4XG4gKiBAbmFtZSBtYXQyXG4gKi9cblxudmFyIG1hdDIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcbiAqXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5tYXQyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGExID0gYVsxXTtcbiAgICAgICAgb3V0WzFdID0gYVsyXTtcbiAgICAgICAgb3V0WzJdID0gYTE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVsyXTtcbiAgICAgICAgb3V0WzJdID0gYVsxXTtcbiAgICAgICAgb3V0WzNdID0gYVszXTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGEwICogYTMgLSBhMiAqIGExO1xuXG4gICAgaWYgKCFkZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcbiAgICBcbiAgICBvdXRbMF0gPSAgYTMgKiBkZXQ7XG4gICAgb3V0WzFdID0gLWExICogZGV0O1xuICAgIG91dFsyXSA9IC1hMiAqIGRldDtcbiAgICBvdXRbM10gPSAgYTAgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgICB2YXIgYTAgPSBhWzBdO1xuICAgIG91dFswXSA9ICBhWzNdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9ICBhMDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQyLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzJdICogYVsxXTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MidzXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0Mi5tdWwgPSBtYXQyLm11bHRpcGx5O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gICAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICAgIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqKi9cbm1hdDIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMCAqIHYwO1xuICAgIG91dFsxXSA9IGExICogdjA7XG4gICAgb3V0WzJdID0gYTIgKiB2MTtcbiAgICBvdXRbM10gPSBhMyAqIHYxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0Mi5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MignICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDIuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSkpXG59O1xuXG4vKipcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gVSB0aGUgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcbiAqL1xuXG5tYXQyLkxEVSA9IGZ1bmN0aW9uIChMLCBELCBVLCBhKSB7IFxuICAgIExbMl0gPSBhWzJdL2FbMF07IFxuICAgIFVbMF0gPSBhWzBdOyBcbiAgICBVWzFdID0gYVsxXTsgXG4gICAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXTsgXG4gICAgcmV0dXJuIFtMLCBELCBVXTsgICAgICAgXG59OyBcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMubWF0MiA9IG1hdDI7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyAyeDMgTWF0cml4XG4gKiBAbmFtZSBtYXQyZFxuICogXG4gKiBAZGVzY3JpcHRpb24gXG4gKiBBIG1hdDJkIGNvbnRhaW5zIHNpeCBlbGVtZW50cyBkZWZpbmVkIGFzOlxuICogPHByZT5cbiAqIFthLCBjLCB0eCxcbiAqICBiLCBkLCB0eV1cbiAqIDwvcHJlPlxuICogVGhpcyBpcyBhIHNob3J0IGZvcm0gZm9yIHRoZSAzeDMgbWF0cml4OlxuICogPHByZT5cbiAqIFthLCBjLCB0eCxcbiAqICBiLCBkLCB0eSxcbiAqICAwLCAwLCAxXVxuICogPC9wcmU+XG4gKiBUaGUgbGFzdCByb3cgaXMgaWdub3JlZCBzbyB0aGUgYXJyYXkgaXMgc2hvcnRlciBhbmQgb3BlcmF0aW9ucyBhcmUgZmFzdGVyLlxuICovXG5cbnZhciBtYXQyZCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MmRcbiAqXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MmQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbm1hdDJkLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MmQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDJkIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYWEgPSBhWzBdLCBhYiA9IGFbMV0sIGFjID0gYVsyXSwgYWQgPSBhWzNdLFxuICAgICAgICBhdHggPSBhWzRdLCBhdHkgPSBhWzVdO1xuXG4gICAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICAgIGlmKCFkZXQpe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gICAgb3V0WzFdID0gLWFiICogZGV0O1xuICAgIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgICBvdXRbM10gPSBhYSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDJkLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MmQnc1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gICAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDJkLm11bCA9IG1hdDJkLm11bHRpcGx5O1xuXG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDJkIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcbiAgICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICAgIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gICAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgICBvdXRbNF0gPSBhNDtcbiAgICBvdXRbNV0gPSBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqKi9cbm1hdDJkLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwICogdjA7XG4gICAgb3V0WzFdID0gYTEgKiB2MDtcbiAgICBvdXRbMl0gPSBhMiAqIHYxO1xuICAgIG91dFszXSA9IGEzICogdjE7XG4gICAgb3V0WzRdID0gYTQ7XG4gICAgb3V0WzVdID0gYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byB0cmFuc2xhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqKi9cbm1hdDJkLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMDtcbiAgICBvdXRbMV0gPSBhMTtcbiAgICBvdXRbMl0gPSBhMjtcbiAgICBvdXRbM10gPSBhMztcbiAgICBvdXRbNF0gPSBhMCAqIHYwICsgYTIgKiB2MSArIGE0O1xuICAgIG91dFs1XSA9IGExICogdjAgKyBhMyAqIHYxICsgYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyZC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MmQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0MmQuZnJvYiA9IGZ1bmN0aW9uIChhKSB7IFxuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgMSkpXG59OyBcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMubWF0MmQgPSBtYXQyZDtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDN4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDNcbiAqL1xuXG52YXIgbWF0MyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xuICpcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cbm1hdDMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDkpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcGllcyB0aGUgdXBwZXItbGVmdCAzeDMgdmFsdWVzIGludG8gdGhlIGdpdmVuIG1hdDMuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyAzeDMgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgICB0aGUgc291cmNlIDR4NCBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbNF07XG4gICAgb3V0WzRdID0gYVs1XTtcbiAgICBvdXRbNV0gPSBhWzZdO1xuICAgIG91dFs2XSA9IGFbOF07XG4gICAgb3V0WzddID0gYVs5XTtcbiAgICBvdXRbOF0gPSBhWzEwXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5tYXQzLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQzIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAxO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMTIgPSBhWzVdO1xuICAgICAgICBvdXRbMV0gPSBhWzNdO1xuICAgICAgICBvdXRbMl0gPSBhWzZdO1xuICAgICAgICBvdXRbM10gPSBhMDE7XG4gICAgICAgIG91dFs1XSA9IGFbN107XG4gICAgICAgIG91dFs2XSA9IGEwMjtcbiAgICAgICAgb3V0WzddID0gYTEyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbM107XG4gICAgICAgIG91dFsyXSA9IGFbNl07XG4gICAgICAgIG91dFszXSA9IGFbMV07XG4gICAgICAgIG91dFs0XSA9IGFbNF07XG4gICAgICAgIG91dFs1XSA9IGFbN107XG4gICAgICAgIG91dFs2XSA9IGFbMl07XG4gICAgICAgIG91dFs3XSA9IGFbNV07XG4gICAgICAgIG91dFs4XSA9IGFbOF07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMSxcbiAgICAgICAgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMCxcbiAgICAgICAgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxO1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gYjAxICogZGV0O1xuICAgIG91dFsxXSA9ICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldDtcbiAgICBvdXRbM10gPSBiMTEgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQ7XG4gICAgb3V0WzVdID0gKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0O1xuICAgIG91dFs2XSA9IGIyMSAqIGRldDtcbiAgICBvdXRbN10gPSAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXQ7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICAgIG91dFswXSA9IChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpO1xuICAgIG91dFsxXSA9IChhMDIgKiBhMjEgLSBhMDEgKiBhMjIpO1xuICAgIG91dFsyXSA9IChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpO1xuICAgIG91dFszXSA9IChhMTIgKiBhMjAgLSBhMTAgKiBhMjIpO1xuICAgIG91dFs0XSA9IChhMDAgKiBhMjIgLSBhMDIgKiBhMjApO1xuICAgIG91dFs1XSA9IChhMDIgKiBhMTAgLSBhMDAgKiBhMTIpO1xuICAgIG91dFs2XSA9IChhMTAgKiBhMjEgLSBhMTEgKiBhMjApO1xuICAgIG91dFs3XSA9IChhMDEgKiBhMjAgLSBhMDAgKiBhMjEpO1xuICAgIG91dFs4XSA9IChhMDAgKiBhMTEgLSBhMDEgKiBhMTApO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQzLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICAgIHJldHVybiBhMDAgKiAoYTIyICogYTExIC0gYTEyICogYTIxKSArIGEwMSAqICgtYTIyICogYTEwICsgYTEyICogYTIwKSArIGEwMiAqIChhMjEgKiBhMTAgLSBhMTEgKiBhMjApO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgYjAwID0gYlswXSwgYjAxID0gYlsxXSwgYjAyID0gYlsyXSxcbiAgICAgICAgYjEwID0gYlszXSwgYjExID0gYls0XSwgYjEyID0gYls1XSxcbiAgICAgICAgYjIwID0gYls2XSwgYjIxID0gYls3XSwgYjIyID0gYls4XTtcblxuICAgIG91dFswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcbiAgICBvdXRbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjE7XG4gICAgb3V0WzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuXG4gICAgb3V0WzNdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwO1xuICAgIG91dFs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgICBvdXRbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XG5cbiAgICBvdXRbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gICAgb3V0WzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xuICAgIG91dFs4XSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0My5tdWwgPSBtYXQzLm11bHRpcGx5O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDMgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMudHJhbnNsYXRlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG4gICAgICAgIHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICAgIG91dFswXSA9IGEwMDtcbiAgICBvdXRbMV0gPSBhMDE7XG4gICAgb3V0WzJdID0gYTAyO1xuXG4gICAgb3V0WzNdID0gYTEwO1xuICAgIG91dFs0XSA9IGExMTtcbiAgICBvdXRbNV0gPSBhMTI7XG5cbiAgICBvdXRbNl0gPSB4ICogYTAwICsgeSAqIGExMCArIGEyMDtcbiAgICBvdXRbN10gPSB4ICogYTAxICsgeSAqIGExMSArIGEyMTtcbiAgICBvdXRbOF0gPSB4ICogYTAyICsgeSAqIGExMiArIGEyMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MyBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGMgKiBhMDAgKyBzICogYTEwO1xuICAgIG91dFsxXSA9IGMgKiBhMDEgKyBzICogYTExO1xuICAgIG91dFsyXSA9IGMgKiBhMDIgKyBzICogYTEyO1xuXG4gICAgb3V0WzNdID0gYyAqIGExMCAtIHMgKiBhMDA7XG4gICAgb3V0WzRdID0gYyAqIGExMSAtIHMgKiBhMDE7XG4gICAgb3V0WzVdID0gYyAqIGExMiAtIHMgKiBhMDI7XG5cbiAgICBvdXRbNl0gPSBhMjA7XG4gICAgb3V0WzddID0gYTIxO1xuICAgIG91dFs4XSA9IGEyMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDMgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xubWF0My5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV07XG5cbiAgICBvdXRbMF0gPSB4ICogYVswXTtcbiAgICBvdXRbMV0gPSB4ICogYVsxXTtcbiAgICBvdXRbMl0gPSB4ICogYVsyXTtcblxuICAgIG91dFszXSA9IHkgKiBhWzNdO1xuICAgIG91dFs0XSA9IHkgKiBhWzRdO1xuICAgIG91dFs1XSA9IHkgKiBhWzVdO1xuXG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIG1hdDJkIGludG8gYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjb3B5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLmZyb21NYXQyZCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gYVsyXTtcbiAgICBvdXRbNF0gPSBhWzNdO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl0gPSBhWzRdO1xuICAgIG91dFs3XSA9IGFbNV07XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbM10gPSB5eCAtIHd6O1xuICAgIG91dFs2XSA9IHp4ICsgd3k7XG5cbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFs0XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs3XSA9IHp5IC0gd3g7XG5cbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFs1XSA9IHp5ICsgd3g7XG4gICAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge21hdDR9IGEgTWF0NCB0byBkZXJpdmUgdGhlIG5vcm1hbCBtYXRyaXggZnJvbVxuKlxuKiBAcmV0dXJucyB7bWF0M30gb3V0XG4qL1xubWF0My5ub3JtYWxGcm9tTWF0NCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcblxuICAgIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQzLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgKyBhWzhdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0My5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSkpXG59O1xuXG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLm1hdDMgPSBtYXQzO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgNHg0IE1hdHJpeFxuICogQG5hbWUgbWF0NFxuICovXG5cbnZhciBtYXQ0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xubWF0NC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xubWF0NC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgICAgICBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzFdID0gYVs0XTtcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgb3V0WzNdID0gYVsxMl07XG4gICAgICAgIG91dFs0XSA9IGEwMTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGEwMjtcbiAgICAgICAgb3V0WzldID0gYTEyO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhMDM7XG4gICAgICAgIG91dFsxM10gPSBhMTM7XG4gICAgICAgIG91dFsxNF0gPSBhMjM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVs0XTtcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgb3V0WzNdID0gYVsxMl07XG4gICAgICAgIG91dFs0XSA9IGFbMV07XG4gICAgICAgIG91dFs1XSA9IGFbNV07XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhWzJdO1xuICAgICAgICBvdXRbOV0gPSBhWzZdO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbM107XG4gICAgICAgIG91dFsxM10gPSBhWzddO1xuICAgICAgICBvdXRbMTRdID0gYVsxMV07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIG91dFswXSAgPSAgKGExMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzFdICA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbMl0gID0gIChhMDEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFszXSAgPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzRdICA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbNV0gID0gIChhMDAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFs2XSAgPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzddICA9ICAoYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbOF0gID0gIChhMTAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkpO1xuICAgIG91dFs5XSAgPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gICAgb3V0WzEwXSA9ICAoYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTFdID0gLShhMDAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gICAgb3V0WzEzXSA9ICAoYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpKTtcbiAgICBvdXRbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIG91dFsxNV0gPSAgKGEwMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDQuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG4gICAgdmFyIGIwICA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107ICBcbiAgICBvdXRbMF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzFdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsyXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbM10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbNF07IGIxID0gYls1XTsgYjIgPSBiWzZdOyBiMyA9IGJbN107XG4gICAgb3V0WzRdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs1XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbNl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzddID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzhdOyBiMSA9IGJbOV07IGIyID0gYlsxMF07IGIzID0gYlsxMV07XG4gICAgb3V0WzhdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs5XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTBdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxMV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbMTJdOyBiMSA9IGJbMTNdOyBiMiA9IGJbMTRdOyBiMyA9IGJbMTVdO1xuICAgIG91dFsxMl0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzEzXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTRdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxNV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDQubXVsID0gbWF0NC5tdWx0aXBseTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXSxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICAgIGlmIChhID09PSBvdXQpIHtcbiAgICAgICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICAgICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICAgICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFswXSA9IGEwMDsgb3V0WzFdID0gYTAxOyBvdXRbMl0gPSBhMDI7IG91dFszXSA9IGEwMztcbiAgICAgICAgb3V0WzRdID0gYTEwOyBvdXRbNV0gPSBhMTE7IG91dFs2XSA9IGExMjsgb3V0WzddID0gYTEzO1xuICAgICAgICBvdXRbOF0gPSBhMjA7IG91dFs5XSA9IGEyMTsgb3V0WzEwXSA9IGEyMjsgb3V0WzExXSA9IGEyMztcblxuICAgICAgICBvdXRbMTJdID0gYTAwICogeCArIGExMCAqIHkgKyBhMjAgKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYTAzICogeCArIGExMyAqIHkgKyBhMjMgKiB6ICsgYVsxNV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xubWF0NC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuXG4gICAgb3V0WzBdID0gYVswXSAqIHg7XG4gICAgb3V0WzFdID0gYVsxXSAqIHg7XG4gICAgb3V0WzJdID0gYVsyXSAqIHg7XG4gICAgb3V0WzNdID0gYVszXSAqIHg7XG4gICAgb3V0WzRdID0gYVs0XSAqIHk7XG4gICAgb3V0WzVdID0gYVs1XSAqIHk7XG4gICAgb3V0WzZdID0gYVs2XSAqIHk7XG4gICAgb3V0WzddID0gYVs3XSAqIHk7XG4gICAgb3V0WzhdID0gYVs4XSAqIHo7XG4gICAgb3V0WzldID0gYVs5XSAqIHo7XG4gICAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQsXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjMsXG4gICAgICAgIGIwMCwgYjAxLCBiMDIsXG4gICAgICAgIGIxMCwgYjExLCBiMTIsXG4gICAgICAgIGIyMCwgYjIxLCBiMjI7XG5cbiAgICBpZiAoTWF0aC5hYnMobGVuKSA8IEdMTUFUX0VQU0lMT04pIHsgcmV0dXJuIG51bGw7IH1cbiAgICBcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHggKj0gbGVuO1xuICAgIHkgKj0gbGVuO1xuICAgIHogKj0gbGVuO1xuXG4gICAgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgdCA9IDEgLSBjO1xuXG4gICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgIC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuICAgIGIwMCA9IHggKiB4ICogdCArIGM7IGIwMSA9IHkgKiB4ICogdCArIHogKiBzOyBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgICBiMTAgPSB4ICogeSAqIHQgLSB6ICogczsgYjExID0geSAqIHkgKiB0ICsgYzsgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gICAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7IGIyMSA9IHkgKiB6ICogdCAtIHggKiBzOyBiMjIgPSB6ICogeiAqIHQgKyBjO1xuXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gICAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICAgIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gICAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICAgIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gICAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICAgIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gICAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFswXSAgPSBhWzBdO1xuICAgICAgICBvdXRbMV0gID0gYVsxXTtcbiAgICAgICAgb3V0WzJdICA9IGFbMl07XG4gICAgICAgIG91dFszXSAgPSBhWzNdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICAgIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICAgIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzRdICA9IGFbNF07XG4gICAgICAgIG91dFs1XSAgPSBhWzVdO1xuICAgICAgICBvdXRbNl0gID0gYVs2XTtcbiAgICAgICAgb3V0WzddICA9IGFbN107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gICAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gICAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICAgIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN107XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFs4XSAgPSBhWzhdO1xuICAgICAgICBvdXRbOV0gID0gYVs5XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyArIGExMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyArIGExMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyArIGExMyAqIHM7XG4gICAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyAtIGEwMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyAtIGEwMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChvdXQsIHEsIHYpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgb3V0WzFdID0geHkgKyB3ejtcbiAgICBvdXRbMl0gPSB4eiAtIHd5O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geHkgLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICAgIG91dFs2XSA9IHl6ICsgd3g7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4eiArIHd5O1xuICAgIG91dFs5XSA9IHl6IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1hdDQuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFsyXSA9IHp4IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcblxuICAgIG91dFs0XSA9IHl4IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gICAgb3V0WzZdID0genkgKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuXG4gICAgb3V0WzhdID0genggKyB3eTtcbiAgICBvdXRbOV0gPSB6eSAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgICBvdXRbMTFdID0gMDtcblxuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJ1c3R1bSA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpLFxuICAgICAgICB0YiA9IDEgLyAodG9wIC0gYm90dG9tKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IChuZWFyICogMikgKiBybDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IChuZWFyICogMikgKiB0YjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcbiAgICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyICogMikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnBlcnNwZWN0aXZlID0gZnVuY3Rpb24gKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBmO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQub3J0aG8gPSBmdW5jdGlvbiAob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KSxcbiAgICAgICAgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAtMiAqIGxyO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gLTIgKiBidDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAyICogbmY7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gICAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gICAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHt2ZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHt2ZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5sb29rQXQgPSBmdW5jdGlvbiAob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuLFxuICAgICAgICBleWV4ID0gZXllWzBdLFxuICAgICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgICB1cHggPSB1cFswXSxcbiAgICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICAgIHVweiA9IHVwWzJdLFxuICAgICAgICBjZW50ZXJ4ID0gY2VudGVyWzBdLFxuICAgICAgICBjZW50ZXJ5ID0gY2VudGVyWzFdLFxuICAgICAgICBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gICAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IEdMTUFUX0VQU0lMT04gJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgR0xNQVRfRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCBHTE1BVF9FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiBtYXQ0LmlkZW50aXR5KG91dCk7XG4gICAgfVxuXG4gICAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICAgIHoyID0gZXlleiAtIGNlbnRlcno7XG5cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG5cbiAgICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB4MCA9IDA7XG4gICAgICAgIHgxID0gMDtcbiAgICAgICAgeDIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHgwICo9IGxlbjtcbiAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICB4MiAqPSBsZW47XG4gICAgfVxuXG4gICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICAgIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB5MCA9IDA7XG4gICAgICAgIHkxID0gMDtcbiAgICAgICAgeTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHkwICo9IGxlbjtcbiAgICAgICAgeTEgKj0gbGVuO1xuICAgICAgICB5MiAqPSBsZW47XG4gICAgfVxuXG4gICAgb3V0WzBdID0geDA7XG4gICAgb3V0WzFdID0geTA7XG4gICAgb3V0WzJdID0gejA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4MTtcbiAgICBvdXRbNV0gPSB5MTtcbiAgICBvdXRbNl0gPSB6MTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHgyO1xuICAgIG91dFs5XSA9IHkyO1xuICAgIG91dFsxMF0gPSB6MjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICAgIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gICAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0NC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0NCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgYVs2XSArICcsICcgKyBhWzddICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbOF0gKyAnLCAnICsgYVs5XSArICcsICcgKyBhWzEwXSArICcsICcgKyBhWzExXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVsxMl0gKyAnLCAnICsgYVsxM10gKyAnLCAnICsgYVsxNF0gKyAnLCAnICsgYVsxNV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQ0LmZyb2IgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpICsgTWF0aC5wb3coYVs5XSwgMikgKyBNYXRoLnBvdyhhWzEwXSwgMikgKyBNYXRoLnBvdyhhWzExXSwgMikgKyBNYXRoLnBvdyhhWzEyXSwgMikgKyBNYXRoLnBvdyhhWzEzXSwgMikgKyBNYXRoLnBvdyhhWzE0XSwgMikgKyBNYXRoLnBvdyhhWzE1XSwgMikgKSlcbn07XG5cblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMubWF0NCA9IG1hdDQ7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyBRdWF0ZXJuaW9uXG4gKiBAbmFtZSBxdWF0XG4gKi9cblxudmFyIHF1YXQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IHF1YXRcbiAqXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICovXG5xdWF0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldHMgYSBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCB0aGUgc2hvcnRlc3Qgcm90YXRpb24gZnJvbSBvbmVcbiAqIHZlY3RvciB0byBhbm90aGVyLlxuICpcbiAqIEJvdGggdmVjdG9ycyBhcmUgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGluaXRpYWwgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIGRlc3RpbmF0aW9uIHZlY3RvclxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0aW9uVG8gPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRtcHZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIHZhciB4VW5pdFZlYzMgPSB2ZWMzLmZyb21WYWx1ZXMoMSwwLDApO1xuICAgIHZhciB5VW5pdFZlYzMgPSB2ZWMzLmZyb21WYWx1ZXMoMCwxLDApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgICAgICB2YXIgZG90ID0gdmVjMy5kb3QoYSwgYik7XG4gICAgICAgIGlmIChkb3QgPCAtMC45OTk5OTkpIHtcbiAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeFVuaXRWZWMzLCBhKTtcbiAgICAgICAgICAgIGlmICh2ZWMzLmxlbmd0aCh0bXB2ZWMzKSA8IDAuMDAwMDAxKVxuICAgICAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeVVuaXRWZWMzLCBhKTtcbiAgICAgICAgICAgIHZlYzMubm9ybWFsaXplKHRtcHZlYzMsIHRtcHZlYzMpO1xuICAgICAgICAgICAgcXVhdC5zZXRBeGlzQW5nbGUob3V0LCB0bXB2ZWMzLCBNYXRoLlBJKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZG90ID4gMC45OTk5OTkpIHtcbiAgICAgICAgICAgIG91dFswXSA9IDA7XG4gICAgICAgICAgICBvdXRbMV0gPSAwO1xuICAgICAgICAgICAgb3V0WzJdID0gMDtcbiAgICAgICAgICAgIG91dFszXSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCBhLCBiKTtcbiAgICAgICAgICAgIG91dFswXSA9IHRtcHZlYzNbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB0bXB2ZWMzWzFdO1xuICAgICAgICAgICAgb3V0WzJdID0gdG1wdmVjM1syXTtcbiAgICAgICAgICAgIG91dFszXSA9IDEgKyBkb3Q7XG4gICAgICAgICAgICByZXR1cm4gcXVhdC5ub3JtYWxpemUob3V0LCBvdXQpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIHF1YXRlcm5pb24gd2l0aCB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW5cbiAqIGF4ZXMuIEVhY2ggYXhpcyBpcyBhIHZlYzMgYW5kIGlzIGV4cGVjdGVkIHRvIGJlIHVuaXQgbGVuZ3RoIGFuZFxuICogcGVycGVuZGljdWxhciB0byBhbGwgb3RoZXIgc3BlY2lmaWVkIGF4ZXMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSB2aWV3ICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgdmlld2luZyBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7dmVjM30gcmlnaHQgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwicmlnaHRcIiBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7dmVjM30gdXAgICAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwidXBcIiBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zZXRBeGVzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXRyID0gbWF0My5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvdXQsIHZpZXcsIHJpZ2h0LCB1cCkge1xuICAgICAgICBtYXRyWzBdID0gcmlnaHRbMF07XG4gICAgICAgIG1hdHJbM10gPSByaWdodFsxXTtcbiAgICAgICAgbWF0cls2XSA9IHJpZ2h0WzJdO1xuXG4gICAgICAgIG1hdHJbMV0gPSB1cFswXTtcbiAgICAgICAgbWF0cls0XSA9IHVwWzFdO1xuICAgICAgICBtYXRyWzddID0gdXBbMl07XG5cbiAgICAgICAgbWF0clsyXSA9IC12aWV3WzBdO1xuICAgICAgICBtYXRyWzVdID0gLXZpZXdbMV07XG4gICAgICAgIG1hdHJbOF0gPSAtdmlld1syXTtcblxuICAgICAgICByZXR1cm4gcXVhdC5ub3JtYWxpemUob3V0LCBxdWF0LmZyb21NYXQzKG91dCwgbWF0cikpO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBjbG9uZVxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmNsb25lID0gdmVjNC5jbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5mcm9tVmFsdWVzID0gdmVjNC5mcm9tVmFsdWVzO1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBxdWF0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgc291cmNlIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmNvcHkgPSB2ZWM0LmNvcHk7XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgcXVhdCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc2V0ID0gdmVjNC5zZXQ7XG5cbi8qKlxuICogU2V0IGEgcXVhdCB0byB0aGUgaWRlbnRpdHkgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcXVhdCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhbmQgcm90YXRpb24gYXhpcyxcbiAqIHRoZW4gcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyBhcm91bmQgd2hpY2ggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiovXG5xdWF0LnNldEF4aXNBbmdsZSA9IGZ1bmN0aW9uKG91dCwgYXhpcywgcmFkKSB7XG4gICAgcmFkID0gcmFkICogMC41O1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBvdXRbMF0gPSBzICogYXhpc1swXTtcbiAgICBvdXRbMV0gPSBzICogYXhpc1sxXTtcbiAgICBvdXRbMl0gPSBzICogYXhpc1syXTtcbiAgICBvdXRbM10gPSBNYXRoLmNvcyhyYWQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5hZGQgPSB2ZWM0LmFkZDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXSwgYncgPSBiWzNdO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5tdWwgPSBxdWF0Lm11bHRpcGx5O1xuXG4vKipcbiAqIFNjYWxlcyBhIHF1YXQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc2NhbGUgPSB2ZWM0LnNjYWxlO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBheiAqIGJ4O1xuICAgIG91dFsyXSA9IGF6ICogYncgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieSA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBheCAqIGJ5O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheSAqIGJ5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieiA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBheSAqIGJ6O1xuICAgIG91dFsxXSA9IGF5ICogYncgLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheiAqIGJ6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFcgY29tcG9uZW50IG9mIGEgcXVhdCBmcm9tIHRoZSBYLCBZLCBhbmQgWiBjb21wb25lbnRzLlxuICogQXNzdW1lcyB0aGF0IHF1YXRlcm5pb24gaXMgMSB1bml0IGluIGxlbmd0aC5cbiAqIEFueSBleGlzdGluZyBXIGNvbXBvbmVudCB3aWxsIGJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgVyBjb21wb25lbnQgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5jYWxjdWxhdGVXID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuXG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gTWF0aC5zcXJ0KE1hdGguYWJzKDEuMCAtIHggKiB4IC0geSAqIHkgLSB6ICogeikpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmRvdCA9IHZlYzQuZG90O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmxlcnAgPSB2ZWM0LmxlcnA7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc2xlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgLy8gYmVuY2htYXJrczpcbiAgICAvLyAgICBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXNsZXJwLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXSwgYncgPSBiWzNdO1xuXG4gICAgdmFyICAgICAgICBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTtcblxuICAgIC8vIGNhbGMgY29zaW5lXG4gICAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xuICAgIC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxuICAgIGlmICggY29zb20gPCAwLjAgKSB7XG4gICAgICAgIGNvc29tID0gLWNvc29tO1xuICAgICAgICBieCA9IC0gYng7XG4gICAgICAgIGJ5ID0gLSBieTtcbiAgICAgICAgYnogPSAtIGJ6O1xuICAgICAgICBidyA9IC0gYnc7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHNcbiAgICBpZiAoICgxLjAgLSBjb3NvbSkgPiAwLjAwMDAwMSApIHtcbiAgICAgICAgLy8gc3RhbmRhcmQgY2FzZSAoc2xlcnApXG4gICAgICAgIG9tZWdhICA9IE1hdGguYWNvcyhjb3NvbSk7XG4gICAgICAgIHNpbm9tICA9IE1hdGguc2luKG9tZWdhKTtcbiAgICAgICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgICAgIHNjYWxlMSA9IE1hdGguc2luKHQgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICB9IGVsc2UgeyAgICAgICAgXG4gICAgICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgcXVhdGVybmlvbnMgYXJlIHZlcnkgY2xvc2UgXG4gICAgICAgIC8vICAuLi4gc28gd2UgY2FuIGRvIGEgbGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICAgICAgc2NhbGUxID0gdDtcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlc1xuICAgIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gICAgb3V0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcbiAgICBvdXRbMl0gPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xuICAgIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgZG90ID0gYTAqYTAgKyBhMSphMSArIGEyKmEyICsgYTMqYTMsXG4gICAgICAgIGludkRvdCA9IGRvdCA/IDEuMC9kb3QgOiAwO1xuICAgIFxuICAgIC8vIFRPRE86IFdvdWxkIGJlIGZhc3RlciB0byByZXR1cm4gWzAsMCwwLDBdIGltbWVkaWF0ZWx5IGlmIGRvdCA9PSAwXG5cbiAgICBvdXRbMF0gPSAtYTAqaW52RG90O1xuICAgIG91dFsxXSA9IC1hMSppbnZEb3Q7XG4gICAgb3V0WzJdID0gLWEyKmludkRvdDtcbiAgICBvdXRbM10gPSBhMyppbnZEb3Q7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgcXVhdFxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5jb25qdWdhdGUgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVuZ3RoID0gdmVjNC5sZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmxlbiA9IHF1YXQubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zcXVhcmVkTGVuZ3RoID0gdmVjNC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc3FyTGVuID0gcXVhdC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubm9ybWFsaXplID0gdmVjNC5ub3JtYWxpemU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gM3gzIHJvdGF0aW9uIG1hdHJpeC5cbiAqXG4gKiBOT1RFOiBUaGUgcmVzdWx0YW50IHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIHlvdSBzaG91bGQgYmUgc3VyZVxuICogdG8gcmVub3JtYWxpemUgdGhlIHF1YXRlcm5pb24geW91cnNlbGYgd2hlcmUgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHttYXQzfSBtIHJvdGF0aW9uIG1hdHJpeFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZnJvbU1hdDMgPSBmdW5jdGlvbihvdXQsIG0pIHtcbiAgICAvLyBBbGdvcml0aG0gaW4gS2VuIFNob2VtYWtlJ3MgYXJ0aWNsZSBpbiAxOTg3IFNJR0dSQVBIIGNvdXJzZSBub3Rlc1xuICAgIC8vIGFydGljbGUgXCJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvblwiLlxuICAgIHZhciBmVHJhY2UgPSBtWzBdICsgbVs0XSArIG1bOF07XG4gICAgdmFyIGZSb290O1xuXG4gICAgaWYgKCBmVHJhY2UgPiAwLjAgKSB7XG4gICAgICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzJcbiAgICAgICAgZlJvb3QgPSBNYXRoLnNxcnQoZlRyYWNlICsgMS4wKTsgIC8vIDJ3XG4gICAgICAgIG91dFszXSA9IDAuNSAqIGZSb290O1xuICAgICAgICBmUm9vdCA9IDAuNS9mUm9vdDsgIC8vIDEvKDR3KVxuICAgICAgICBvdXRbMF0gPSAobVs1XS1tWzddKSpmUm9vdDtcbiAgICAgICAgb3V0WzFdID0gKG1bNl0tbVsyXSkqZlJvb3Q7XG4gICAgICAgIG91dFsyXSA9IChtWzFdLW1bM10pKmZSb290O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHx3fCA8PSAxLzJcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoIG1bNF0gPiBtWzBdIClcbiAgICAgICAgICBpID0gMTtcbiAgICAgICAgaWYgKCBtWzhdID4gbVtpKjMraV0gKVxuICAgICAgICAgIGkgPSAyO1xuICAgICAgICB2YXIgaiA9IChpKzEpJTM7XG4gICAgICAgIHZhciBrID0gKGkrMiklMztcbiAgICAgICAgXG4gICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KG1baSozK2ldLW1baiozK2pdLW1bayozK2tdICsgMS4wKTtcbiAgICAgICAgb3V0W2ldID0gMC41ICogZlJvb3Q7XG4gICAgICAgIGZSb290ID0gMC41IC8gZlJvb3Q7XG4gICAgICAgIG91dFszXSA9IChtW2oqMytrXSAtIG1bayozK2pdKSAqIGZSb290O1xuICAgICAgICBvdXRbal0gPSAobVtqKjMraV0gKyBtW2kqMytqXSkgKiBmUm9vdDtcbiAgICAgICAgb3V0W2tdID0gKG1bayozK2ldICsgbVtpKjMra10pICogZlJvb3Q7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBxdWF0ZW5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5xdWF0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdxdWF0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMucXVhdCA9IHF1YXQ7XG59XG47XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgfSkoc2hpbS5leHBvcnRzKTtcbn0pKHRoaXMpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50UXVldWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtpXSgpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgcXVldWUucHVzaChmdW4pO1xuICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSggJy4vbGliLycgKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG5vdyA9IHJlcXVpcmUoXCJwZXJmb3JtYW5jZS1ub3dcIik7XG5cbiAgICBmdW5jdGlvbiBmaW5kKGFyciwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmluZCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpc3QgPSBPYmplY3QoYXJyKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwobnVsbCwgdmFsdWUsIGksIGxpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICB2YXIgU2ltcGxlVGV4dHVyZU1hbmFnZXIgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdGhpcy5fdW5pdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAob3B0LnVuaXRzIHx8IDgpOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3VuaXRzW2ldID0ge3Nsb3Q6IGksIHVzZTogMH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2ltcGxlVGV4dHVyZU1hbmFnZXIuTk9UX0ZPVU5EID0gLTE7XG4gICAgU2ltcGxlVGV4dHVyZU1hbmFnZXIuRlVMTCA9IC0yO1xuXG4gICAgU2ltcGxlVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIF9zZXQ6IGZ1bmN0aW9uIChzbG90LCBuZXdFbnRyeSkge1xuICAgICAgICAgICAgdmFyIG9sZEVudHJ5ID0gdGhpcy5fdW5pdHNbc2xvdF07XG4gICAgICAgICAgICBpZiAob2xkRW50cnkuZGlzcG9zZSkge1xuICAgICAgICAgICAgICAgIG9sZEVudHJ5LmRpc3Bvc2Uob2xkRW50cnksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdHNbc2xvdF0gPSBuZXdFbnRyeTtcbiAgICAgICAgICAgICAgICB0aGlzLl91bml0c1tzbG90XS5zbG90ID0gc2xvdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdHNbc2xvdF0gPSB7c2xvdDogc2xvdCwgdXNlOiAwfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kOiBmdW5jdGlvbiAoaWQsIG9wdCkge1xuICAgICAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICAgICAgdmFyIGZpeGVkID0gISFvcHQuZml4ZWQ7XG4gICAgICAgICAgICB2YXIgZGlzcG9zZSA9IHR5cGVvZiBvcHQuZGlzcG9zZSA9PSBcImZ1bmN0aW9uXCIgPyBvcHQuZGlzcG9zZSA6IG51bGw7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRleHR1cmUgaXMgYWxyZWFkeSBib3VuZFxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IFNpbXBsZVRleHR1cmVNYW5hZ2VyLk5PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGVzID0gdGhpcy5fdW5pdHMuZmlsdGVyKGZ1bmN0aW9uICh1bml0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1bml0LmZpeGVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2FuZGlkYXRlcyxcIiwgY2FuZGlkYXRlcywgY2FuZGlkYXRlcy5sZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNpbXBsZVRleHR1cmVNYW5hZ2VyLkZVTEw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGNhbmRpZGF0ZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXYgPyAoY3Vyci51c2UgPCBwcmV2LnVzZSA/IGN1cnIgOiBwcmV2KSA6IGN1cnI7XG4gICAgICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTZWxlY3RlZCBlbnRyeVwiLCBzZWxlY3RlZCk7XG5cbiAgICAgICAgICAgIHZhciBzbG90ID0gc2VsZWN0ZWQuc2xvdDtcbiAgICAgICAgICAgIHRoaXMuX3NldChzbG90LCB7XG4gICAgICAgICAgICAgICAgZml4ZWQ6IGZpeGVkLCB1c2U6IG5vdygpLCBpZDogaWQsIGRpc3Bvc2U6IGRpc3Bvc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNsb3Q7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZ2V0RW50cnkoaWQpO1xuICAgICAgICAgICAgdGhpcy5fc2V0KGVudHJ5LnNsb3QsIG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBpZiB0aGUgdGV4dHVyZSBvZiB0aGUgZ2l2ZW4gaWQgaXMgYm91bmQgdG8gYW4gdW5pdFxuICAgICAgICAgKiBAcGFyYW0gaWRcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBoYXM6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRFbnRyeShpZCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRleHR1cmUgdW5pdCBmb3IgdGhlIGlkIG9yIFNpbXBsZVRleHR1cmVNYW5hZ2VyLk5PVF9GT1VORFxuICAgICAgICAgKiBpZiB0aGUgdGV4dHVyZSBpcyBjdXJyZW50bHkgbm90IGJvdW5kXG4gICAgICAgICAqIEBwYXJhbSBpZFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5nZXRFbnRyeShpZCk7XG4gICAgICAgICAgICBpZihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudXNlID0gbm93KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zbG90O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFNpbXBsZVRleHR1cmVNYW5hZ2VyLk5PVF9GT1VORDtcbiAgICAgICAgfSxcblxuICAgICAgICB1c2U6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZ2V0RW50cnkoaWQpO1xuICAgICAgICAgICAgaWYocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVzZSA9IG5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEVudHJ5OiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kKHRoaXMuX3VuaXRzLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkuaWQgPT09IGlkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIFNpbXBsZVRleHR1cmVNYW5hZ2VyOiBTaW1wbGVUZXh0dXJlTWFuYWdlclxuICAgIH07XG59KCk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBnZXROYW5vU2Vjb25kcywgaHJ0aW1lLCBsb2FkVGltZTtcblxuICBpZiAoKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwZXJmb3JtYW5jZSAhPT0gbnVsbCkgJiYgcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzICE9PSBudWxsKSAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGdldE5hbm9TZWNvbmRzKCkgLSBsb2FkVGltZSkgLyAxZTY7XG4gICAgfTtcbiAgICBocnRpbWUgPSBwcm9jZXNzLmhydGltZTtcbiAgICBnZXROYW5vU2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhyO1xuICAgICAgaHIgPSBocnRpbWUoKTtcbiAgICAgIHJldHVybiBoclswXSAqIDFlOSArIGhyWzFdO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBnZXROYW5vU2Vjb25kcygpO1xuICB9IGVsc2UgaWYgKERhdGUubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IERhdGUubm93KCk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuIiwidmFyIFNldCA9IHJlcXVpcmUoXCIuLi94Zmxvdy91dGlscy91dGlscy5qc1wiKS5zZXQ7XHJcbnZhciBEYXRhTm9kZSA9IHJlcXVpcmUoXCIuLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuRGF0YU5vZGU7XHJcblxyXG5mdW5jdGlvbiBBc3NldEVycm9yKG1lc3NhZ2UsIG5vZGUpe1xyXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbn1cclxuXHJcbnZhciBBc3NldCA9IGZ1bmN0aW9uKHJlZk5vZGUpe1xyXG4gICAgdGhpcy5uYW1lID0gbnVsbDtcclxuICAgIHRoaXMuc3JjQXNzZXQgPSBudWxsO1xyXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgdGhpcy5zdWJBc3NldHMgPSBbXTtcclxuICAgIHRoaXMucGlja0ZpbHRlciA9IG51bGw7XHJcbiAgICB0aGlzLnBhcmVudHMgPSBbXTtcclxuICAgIHRoaXMubGlzdGVuZXIgPSBbXTtcclxuICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5yZWZOb2RlID0gcmVmTm9kZSB8fCBudWxsO1xyXG4gICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgdGhpcy50cmFuc2Zvcm0gPSBudWxsO1xyXG5cclxuICAgIHRoaXMuYXNzZXRSZXN1bHQgPSBudWxsO1xyXG4gICAgdGhpcy5sb2FkTGV2ZWwgPSAwO1xyXG4gICAgdGhpcy5wcm9ncmVzc0xldmVsID0gSW5maW5pdHk7XHJcbn07XHJcblxyXG5Bc3NldC5wcm90b3R5cGUuY2hlY2tWYWxpZGl0eSA9IGZ1bmN0aW9uKCl7XHJcbiAgICBpZih0aGlzLmlzU3VidHJlZUxvYWRpbmcoKSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICBjaGVja1JlY3Vyc2l2ZSh0aGlzKTtcclxufTtcclxuZnVuY3Rpb24gY2hlY2tSZWN1cnNpdmUoYXNzZXQpe1xyXG4gICAgaWYoYXNzZXQuc3JjQXNzZXQpe1xyXG4gICAgICAgIGNoZWNrUmVjdXJzaXZlKGFzc2V0LnNyY0Fzc2V0KTtcclxuICAgIH1cclxuICAgIHZhciBsb2NhbE5hbWVzID0gW107XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXNzZXQuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHZhciBjaGlsZCA9IGFzc2V0LmNoaWxkcmVuW2ldLCBuYW1lID0gY2hpbGQubmFtZTtcclxuICAgICAgICBpZihuYW1lICYmIGxvY2FsTmFtZXMuaW5kZXhPZihuYW1lKSAhPSAtMSl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBBc3NldEVycm9yKFwiVHdvIHN1YmRhdGEgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSBuYW1lOiAnXCIgKyBuYW1lICsgXCInXCIsIGNoaWxkLnJlZk5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihuYW1lKSBsb2NhbE5hbWVzLnB1c2gobmFtZSk7XHJcbiAgICB9XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXNzZXQuc3ViQXNzZXRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICBjaGVja1JlY3Vyc2l2ZShhc3NldC5zdWJBc3NldHNbaV0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuQXNzZXQucHJvdG90eXBlLnNldExvYWRpbmcgPSBmdW5jdGlvbihsb2FkaW5nKXtcclxuICAgIGlmKGxvYWRpbmcgIT0gdGhpcy5sb2FkaW5nKXtcclxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBsb2FkaW5nO1xyXG4gICAgICAgIHVwZGF0ZUxvYWRpbmdTdGF0ZSh0aGlzKTtcclxuICAgICAgICBpbnZhbGlkYXRlQXNzZXQodGhpcyk7XHJcblxyXG4gICAgfVxyXG59O1xyXG5cclxuQXNzZXQucHJvdG90eXBlLmlzU3VidHJlZUxvYWRpbmcgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3NMZXZlbCA9PSAwO1xyXG59O1xyXG5Bc3NldC5wcm90b3R5cGUuZ2V0UHJvZ3Jlc3NMZXZlbCA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzc0xldmVsO1xyXG59O1xyXG5cclxuQXNzZXQucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICBpbnZhbGlkYXRlQXNzZXQodGhpcyk7XHJcbn07XHJcblxyXG5Bc3NldC5wcm90b3R5cGUuc2V0U2hhZGVyID0gZnVuY3Rpb24oc2hhZGVyKXtcclxuICAgIHRoaXMuc2hhZGVyID0gc2hhZGVyO1xyXG4gICAgaW52YWxpZGF0ZUFzc2V0KHRoaXMpO1xyXG59O1xyXG5cclxuQXNzZXQucHJvdG90eXBlLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHRyYW5zZm9ybSl7XHJcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgIGlmICh0aGlzLnJlZk5vZGUubG9jYWxOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwibW9kZWxcIikge1xyXG4gICAgICAgIGludmFsaWRhdGVBc3NldCh0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcbkFzc2V0LnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKXtcclxuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICBjaGlsZC5hc3NldFBhcmVudCA9IHRoaXM7XHJcbiAgICB1cGRhdGVMb2FkaW5nU3RhdGUodGhpcyk7XHJcbiAgICBpbnZhbGlkYXRlQXNzZXQodGhpcyk7XHJcblxyXG59O1xyXG5cclxuQXNzZXQucHJvdG90eXBlLnNldFBpY2tGaWx0ZXIgPSBmdW5jdGlvbihwaWNrRmlsdGVyU3RyaW5nKXtcclxuICAgIGlmKHR5cGVvZiBwaWNrRmlsdGVyU3RyaW5nID09IFwic3RyaW5nXCIpe1xyXG4gICAgICAgIHRoaXMucGlja0ZpbHRlciA9IG5ldyBBc3NldFBpY2tGaWx0ZXIoKTtcclxuICAgICAgICB0aGlzLnBpY2tGaWx0ZXIucGFyc2UocGlja0ZpbHRlclN0cmluZyk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5waWNrRmlsdGVyID0gbnVsbDtcclxuICAgIGludmFsaWRhdGVBc3NldCh0aGlzKTtcclxufTtcclxuXHJcbkFzc2V0LnByb3RvdHlwZS5hcHBlbmRTdWJBc3NldCA9IGZ1bmN0aW9uKHN1YkFzc2V0KXtcclxuICAgIHN1YkFzc2V0Ll9hZGRQYXJlbnQodGhpcyk7XHJcbiAgICB0aGlzLnN1YkFzc2V0cy5wdXNoKHN1YkFzc2V0KTtcclxuICAgIHVwZGF0ZUxvYWRpbmdTdGF0ZSh0aGlzKTtcclxuICAgIGludmFsaWRhdGVBc3NldCh0aGlzKTtcclxuXHJcbn07XHJcblxyXG5Bc3NldC5wcm90b3R5cGUuc2V0U3JjQXNzZXQgPSBmdW5jdGlvbihhc3NldCl7XHJcbiAgICBpZih0aGlzLnNyY0Fzc2V0KVxyXG4gICAgICAgIHRoaXMuc3JjQXNzZXQuX3JlbW92ZVBhcmVudCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnNyY0Fzc2V0ID0gYXNzZXQ7XHJcblxyXG4gICAgaWYodGhpcy5zcmNBc3NldClcclxuICAgICAgICB0aGlzLnNyY0Fzc2V0Ll9hZGRQYXJlbnQodGhpcyk7XHJcbiAgICB1cGRhdGVMb2FkaW5nU3RhdGUodGhpcyk7XHJcbiAgICBpbnZhbGlkYXRlQXNzZXQodGhpcyk7XHJcblxyXG59O1xyXG5cclxuQXNzZXQucHJvdG90eXBlLmNsZWFyQ2hpbGRyZW4gPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcclxuICAgIHdoaWxlKGktLSkgdGhpcy5jaGlsZHJlbltpXS5hc3NldFBhcmVudCA9IG51bGw7XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICB1cGRhdGVMb2FkaW5nU3RhdGUodGhpcyk7XHJcbiAgICBpbnZhbGlkYXRlQXNzZXQodGhpcyk7XHJcblxyXG59O1xyXG5Bc3NldC5wcm90b3R5cGUuY2xlYXJTdWJBc3NldHMgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGkgPSB0aGlzLnN1YkFzc2V0cy5sZW5ndGg7XHJcbiAgICB3aGlsZShpLS0pIHtcclxuICAgICAgICB0aGlzLnN1YkFzc2V0c1tpXS5fcmVtb3ZlUGFyZW50KHRoaXMpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zdWJBc3NldHMubGVuZ3RoID0gMDtcclxuICAgIHVwZGF0ZUxvYWRpbmdTdGF0ZSh0aGlzKTtcclxuICAgIGludmFsaWRhdGVBc3NldCh0aGlzKTtcclxuXHJcbn07XHJcblxyXG5Bc3NldC5wcm90b3R5cGUuX2FkZFBhcmVudCA9IGZ1bmN0aW9uKGFzc2V0KXtcclxuICAgIHRoaXMucGFyZW50cy5wdXNoKGFzc2V0KTtcclxufTtcclxuQXNzZXQucHJvdG90eXBlLl9yZW1vdmVQYXJlbnQgPSBmdW5jdGlvbihhc3NldCl7XHJcbiAgICB2YXIgaWR4ID0gdGhpcy5wYXJlbnRzLmluZGV4T2YoYXNzZXQpO1xyXG4gICAgaWYoaWR4ICE9IC0xKVxyXG4gICAgICAgIHRoaXMucGFyZW50cy5zcGxpY2UoaWR4LCAxKTtcclxufTtcclxuXHJcbkFzc2V0LnByb3RvdHlwZS5fY2FsbExvYWRMaXN0ZW5lcnMgPSBmdW5jdGlvbihuZXdMZXZlbCwgb2xkTGV2ZWwpe1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXI7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICBsaXN0ZW5lcnNbaV0ub25Bc3NldExvYWRDaGFuZ2UgJiYgbGlzdGVuZXJzW2ldLm9uQXNzZXRMb2FkQ2hhbmdlKHRoaXMsIG5ld0xldmVsLCBvbGRMZXZlbCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuQXNzZXQucHJvdG90eXBlLmFkZENoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpe1xyXG4gICAgU2V0LmFkZCh0aGlzLmxpc3RlbmVyLCBsaXN0ZW5lcik7XHJcbn07XHJcbkFzc2V0LnByb3RvdHlwZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKXtcclxuICAgIFNldC5yZW1vdmUodGhpcy5saXN0ZW5lciwgbGlzdGVuZXIpO1xyXG59O1xyXG5cclxuQXNzZXQucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uKCl7XHJcbiAgICBpZighdGhpcy5hc3NldFJlc3VsdCl7XHJcbiAgICAgICAgdGhpcy5hc3NldFJlc3VsdCA9IG5ldyBBc3NldFJlc3VsdCgpO1xyXG4gICAgICAgIHRoaXMuYXNzZXRSZXN1bHQuY29uc3RydWN0KHRoaXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuYXNzZXRSZXN1bHQ7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbnZhbGlkYXRlQXNzZXQoYXNzZXQpe1xyXG4gICAgaWYoYXNzZXQuYXNzZXRSZXN1bHQpe1xyXG4gICAgICAgIGFzc2V0LmFzc2V0UmVzdWx0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciBsaXN0ZW5lcnMgPSBhc3NldC5saXN0ZW5lcjtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIGxpc3RlbmVyc1tpXS5vbkFzc2V0Q2hhbmdlICYmIGxpc3RlbmVyc1tpXS5vbkFzc2V0Q2hhbmdlKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgdmFyIGkgPSBhc3NldC5wYXJlbnRzLmxlbmd0aDtcclxuICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgaW52YWxpZGF0ZUFzc2V0KGFzc2V0LnBhcmVudHNbaV0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTG9hZGluZ1N0YXRlKGFzc2V0KXtcclxuICAgIHZhciBwcm9ncmVzc0xldmVsID0gYXNzZXQubG9hZGluZyA/IGFzc2V0LmxvYWRMZXZlbCA6IEluZmluaXR5O1xyXG4gICAgaWYocHJvZ3Jlc3NMZXZlbCAmJiBhc3NldC5zcmNBc3NldCl7XHJcbiAgICAgICAgcHJvZ3Jlc3NMZXZlbCA9IE1hdGgubWluKHByb2dyZXNzTGV2ZWwsIE1hdGgubWF4KGFzc2V0LnNyY0Fzc2V0LmxvYWRMZXZlbCwgYXNzZXQuc3JjQXNzZXQucHJvZ3Jlc3NMZXZlbCkpO1xyXG4gICAgfVxyXG4gICAgdmFyIGkgPSBhc3NldC5zdWJBc3NldHMubGVuZ3RoO1xyXG4gICAgd2hpbGUocHJvZ3Jlc3NMZXZlbCAmJiBpLS0pe1xyXG4gICAgICAgIHByb2dyZXNzTGV2ZWwgPSBNYXRoLm1pbihwcm9ncmVzc0xldmVsLCBNYXRoLm1heChhc3NldC5zdWJBc3NldHNbaV0ubG9hZExldmVsLCBhc3NldC5zdWJBc3NldHNbaV0ucHJvZ3Jlc3NMZXZlbCkpO1xyXG4gICAgfVxyXG4gICAgdmFyIGkgPSBhc3NldC5jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICB3aGlsZShwcm9ncmVzc0xldmVsICYmIGktLSl7XHJcbiAgICAgICAgcHJvZ3Jlc3NMZXZlbCA9IE1hdGgubWluKHByb2dyZXNzTGV2ZWwsIGFzc2V0LmNoaWxkcmVuW2ldLnByb2dyZXNzTGV2ZWwpO1xyXG4gICAgfVxyXG4gICAgdmFyIG9sZExldmVsID0gYXNzZXQucHJvZ3Jlc3NMZXZlbDtcclxuICAgIGFzc2V0LnByb2dyZXNzTGV2ZWwgPSBwcm9ncmVzc0xldmVsO1xyXG5cclxuICAgIGlmKG9sZExldmVsICE9IGFzc2V0LnByb2dyZXNzTGV2ZWwpe1xyXG4gICAgICAgIGFzc2V0Ll9jYWxsTG9hZExpc3RlbmVycyhhc3NldC5wcm9ncmVzc0xldmVsLCBvbGRMZXZlbCk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFzc2V0LnBhcmVudHMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIHVwZGF0ZUxvYWRpbmdTdGF0ZShhc3NldC5wYXJlbnRzW2ldKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBTdWJEYXRhXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxudmFyIFN1YkRhdGEgPSBmdW5jdGlvbih4Zmxvd05vZGVPdXQsIHhmbG93Tm9kZUluLCByZWZOb2RlKXtcclxuICAgIHRoaXMueGZsb3dOb2RlT3V0ID0geGZsb3dOb2RlT3V0O1xyXG4gICAgdGhpcy54Zmxvd05vZGVJbiA9IHhmbG93Tm9kZUluO1xyXG4gICAgdGhpcy5yZWZOb2RlID0gcmVmTm9kZSB8fCBudWxsO1xyXG4gICAgdGhpcy5uYW1lID0gbnVsbDtcclxuICAgIHRoaXMubWF0Y2hGaWx0ZXIgPSBudWxsO1xyXG4gICAgdGhpcy5jbGFzc05hbWVzID0gW107XHJcbiAgICB0aGlzLnBvc3REYXRhZmxvdyA9IG51bGw7XHJcbiAgICB0aGlzLnBvc3RDb21wdXRlID0gbnVsbDtcclxuICAgIHRoaXMucG9zdEZpbHRlciA9IG51bGw7XHJcbiAgICB0aGlzLmluY2x1ZGVzID0gW107XHJcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XHJcbiAgICB0aGlzLm1lc2hUeXBlID0gbnVsbDtcclxuICAgIHRoaXMuYXNzZXRQYXJlbnQgPSBudWxsO1xyXG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLmxvYWRMZXZlbCA9IDA7XHJcbiAgICB0aGlzLnByb2dyZXNzTGV2ZWwgPSBJbmZpbml0eTtcclxuICAgIHhmbG93Tm9kZUluLmFkZExvYWRMaXN0ZW5lcih0aGlzLm9uWGZsb3dMb2FkRXZlbnQuYmluZCh0aGlzKSk7XHJcbiAgICB0aGlzLl91cGRhdGVMb2FkaW5nU3RhdGUoKTtcclxufTtcclxuXHJcblN1YkRhdGEucHJvdG90eXBlLnNldExvYWRpbmcgPSBmdW5jdGlvbihsb2FkaW5nKXtcclxuICAgIGlmKGxvYWRpbmcgIT0gdGhpcy5sb2FkaW5nKXtcclxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBsb2FkaW5nO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxvYWRpbmdTdGF0ZSgpO1xyXG4gICAgICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XHJcblxyXG4gICAgfVxyXG59O1xyXG5cclxuU3ViRGF0YS5wcm90b3R5cGUuX3VwZGF0ZUxvYWRpbmdTdGF0ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgcHJvZ3Jlc3NMZXZlbCA9IHRoaXMubG9hZGluZyA/IHRoaXMubG9hZExldmVsIDogSW5maW5pdHk7XHJcbiAgICBwcm9ncmVzc0xldmVsID0gTWF0aC5taW4ocHJvZ3Jlc3NMZXZlbCwgdGhpcy54Zmxvd05vZGVJbi5nZXRQcm9ncmVzc0xldmVsKCkpO1xyXG4gICAgdmFyIG9sZExldmVsID0gdGhpcy5wcm9ncmVzc0xldmVsO1xyXG4gICAgdGhpcy5wcm9ncmVzc0xldmVsID0gcHJvZ3Jlc3NMZXZlbDtcclxuXHJcbiAgICBpZihvbGRMZXZlbCAhPSB0aGlzLnByb2dyZXNzTGV2ZWwpe1xyXG4gICAgICAgIHRoaXMuYXNzZXRQYXJlbnQgJiYgdXBkYXRlTG9hZGluZ1N0YXRlKHRoaXMuYXNzZXRQYXJlbnQpO1xyXG4gICAgICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblN1YkRhdGEucHJvdG90eXBlLm9uWGZsb3dMb2FkRXZlbnQgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5fdXBkYXRlTG9hZGluZ1N0YXRlKCk7XHJcbn07XHJcblxyXG5TdWJEYXRhLnByb3RvdHlwZS5pc1N1YnRyZWVMb2FkaW5nID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLmxvYWRpbmc7XHJcbn07XHJcblxyXG5TdWJEYXRhLnByb3RvdHlwZS5pc01lc2ggPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuICEhdGhpcy5tZXNoVHlwZTtcclxufTtcclxuXHJcblN1YkRhdGEucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICBpbnZhbGlkYXRlUGFyZW50KHRoaXMpO1xyXG59O1xyXG5cclxuU3ViRGF0YS5wcm90b3R5cGUuc2V0TWF0Y2hGaWx0ZXIgPSBmdW5jdGlvbihtYXRjaFN0cmluZyl7XHJcbiAgICBpZih0eXBlb2YgbWF0Y2hTdHJpbmcgPT0gXCJzdHJpbmdcIil7XHJcbiAgICAgICAgdGhpcy5tYXRjaEZpbHRlciA9IG5ldyBBc3NldFBpY2tGaWx0ZXIoKTtcclxuICAgICAgICB0aGlzLm1hdGNoRmlsdGVyLnBhcnNlKG1hdGNoU3RyaW5nKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgICB0aGlzLm1hdGNoRmlsdGVyID0gbnVsbDtcclxuICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XHJcbn07XHJcblxyXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRDbGFzc05hbWVzID0gZnVuY3Rpb24oY2xhc3NOYW1lcyl7XHJcbiAgICB0aGlzLmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xyXG4gICAgaW52YWxpZGF0ZVBhcmVudCh0aGlzKTtcclxufTtcclxuU3ViRGF0YS5wcm90b3R5cGUuc2V0Q2xhc3NOYW1lc1N0cmluZyA9IGZ1bmN0aW9uKGNsYXNzTmFtZXNTdHJpbmcpe1xyXG4gICAgaWYoIWNsYXNzTmFtZXNTdHJpbmcpXHJcbiAgICAgICAgdGhpcy5zZXRDbGFzc05hbWVzKFtdKTtcclxuICAgIGVsc2V7XHJcbiAgICAgICAgdmFyIGFycmF5ID0gY2xhc3NOYW1lc1N0cmluZy5zcGxpdCgvXFxzKy8pO1xyXG4gICAgICAgIHZhciBpID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlKGktLSkgYXJyYXlbaV0gPSBhcnJheVtpXS50cmltKCk7XHJcbiAgICAgICAgdGhpcy5zZXRDbGFzc05hbWVzKGFycmF5KTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRQb3N0RGF0YWZsb3cgPSBmdW5jdGlvbihwb3N0RGF0YWZsb3cpe1xyXG4gICAgdGhpcy5wb3N0RGF0YWZsb3cgPSBwb3N0RGF0YWZsb3c7XHJcbiAgICBpbnZhbGlkYXRlUGFyZW50KHRoaXMpO1xyXG59O1xyXG5cclxuU3ViRGF0YS5wcm90b3R5cGUuc2V0UG9zdENvbXB1dGUgPSBmdW5jdGlvbihwb3N0Q29tcHV0ZSl7XHJcbiAgICB0aGlzLnBvc3RDb21wdXRlID0gcG9zdENvbXB1dGU7XHJcbiAgICBpbnZhbGlkYXRlUGFyZW50KHRoaXMpO1xyXG59O1xyXG5cclxuU3ViRGF0YS5wcm90b3R5cGUuc2V0UG9zdEZpbHRlciA9IGZ1bmN0aW9uKHBvc3RGaWx0ZXIpe1xyXG4gICAgdGhpcy5wb3N0RmlsdGVyID0gcG9zdEZpbHRlcjtcclxuICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XHJcbn07XHJcblxyXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRJbmNsdWRlcyA9IGZ1bmN0aW9uKGluY2x1ZGVzKXtcclxuICAgIHRoaXMuaW5jbHVkZXMgPSBpbmNsdWRlcztcclxuICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XHJcbn07XHJcblxyXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRTaGFkZXIgPSBmdW5jdGlvbihzaGFkZXIpe1xyXG4gICAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XHJcbiAgICBpbnZhbGlkYXRlUGFyZW50KHRoaXMpO1xyXG59O1xyXG5cclxuU3ViRGF0YS5wcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24odHJhbnNmb3JtKXtcclxuICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgaW52YWxpZGF0ZVBhcmVudCh0aGlzKTtcclxufTtcclxuXHJcblN1YkRhdGEucHJvdG90eXBlLnNldE1lc2hUeXBlID0gZnVuY3Rpb24obWVzaFR5cGUpe1xyXG4gICAgdGhpcy5tZXNoVHlwZSA9IG1lc2hUeXBlO1xyXG4gICAgaW52YWxpZGF0ZVBhcmVudCh0aGlzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGludmFsaWRhdGVQYXJlbnQoc3ViRGF0YSl7XHJcbiAgICBpZihzdWJEYXRhLmFzc2V0UGFyZW50KXtcclxuICAgICAgICBpbnZhbGlkYXRlQXNzZXQoc3ViRGF0YS5hc3NldFBhcmVudCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBBc3NldFJlc3VsdFxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbnZhciBBc3NldFJlc3VsdCA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnBhcmVudFJlc3VsdCA9IG51bGw7XHJcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xyXG4gICAgdGhpcy5uYW1lZEVudHJpZXMgPSB7fTtcclxuICAgIHRoaXMuYWxsRW50cmllcyA9IFtdO1xyXG4gICAgdGhpcy5tYXRjaEVudHJpZXMgPSBbXTtcclxuICAgIHRoaXMubmFtZWRTdWJSZXN1bHRzID0ge307XHJcbiAgICB0aGlzLmFsbFN1YlJlc3VsdHMgPSBbXTtcclxuXHJcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XHJcbiAgICB0aGlzLnBpY2tGaWx0ZXIgPSBudWxsO1xyXG59O1xyXG5cclxuQXNzZXRSZXN1bHQucHJvdG90eXBlLmNvbnN0cnVjdCA9IGZ1bmN0aW9uKGFzc2V0KXtcclxuICAgIGNvbnN0cnVjdEFzc2V0VGFibGUodGhpcywgYXNzZXQpO1xyXG59O1xyXG5cclxuQXNzZXRSZXN1bHQucHJvdG90eXBlLmdldERhdGFUcmVlID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiByZWNfZ2V0RGF0YVRyZWUodGhpcyk7XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gY29uc3RydWN0QXNzZXRUYWJsZSh0YWJsZSwgYXNzZXQpe1xyXG4gICAgdGFibGUubmFtZSA9IGFzc2V0Lm5hbWU7XHJcblxyXG4gICAgdmFyIHNyY0Fzc2V0ID0gYXNzZXQuc3JjQXNzZXQsIHNyY1Jlc3VsdCA9IHNyY0Fzc2V0ICYmIHNyY0Fzc2V0LmdldFJlc3VsdCgpO1xyXG4gICAgaWYoc3JjUmVzdWx0KXtcclxuICAgICAgICBjb3B5U3JjVGFibGUodGFibGUsIHNyY0Fzc2V0LmdldFJlc3VsdCgpLCBhc3NldC5waWNrRmlsdGVyKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgICB0YWJsZS5waWNrRmlsdGVyID0gYXNzZXQucGlja0ZpbHRlcjtcclxuXHJcbiAgICBpZihhc3NldC5zaGFkZXIpIHRhYmxlLnNoYWRlciA9IGFzc2V0LnNoYWRlcjtcclxuICAgIGlmKGFzc2V0LnRyYW5zZm9ybSkgdGFibGUudHJhbnNmb3JtID0gY29tYmluZVRyYW5zZm9ybSh0YWJsZS50cmFuc2Zvcm0sIGFzc2V0LnRyYW5zZm9ybSk7XHJcblxyXG5cclxuICAgIHZhciBzdWJBc3NldHMgPSBhc3NldC5zdWJBc3NldHM7XHJcbiAgICB2YXIgaSA9IHN1YkFzc2V0cy5sZW5ndGg7XHJcbiAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBzdWJBc3NldHNbaV0uZ2V0UmVzdWx0KCk7XHJcbiAgICAgICAgbWVyZ2VTdWJBc3NldFJlc3VsdCh0YWJsZSwgcmVzdWx0KTtcclxuICAgIH1cclxuICAgIHZhciBtYXRjaENoaWxkcmVuID0gW107XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBhc3NldC5jaGlsZHJlbjtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgdmFyIG5hbWUgPSBjaGlsZC5uYW1lO1xyXG4gICAgICAgIHZhciBlbnRyeTtcclxuICAgICAgICBpZihjaGlsZC5uYW1lICYmIGNoaWxkLm1hdGNoRmlsdGVyKXtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkFzc2V0IGVudHJ5IGRlZmluZXMgYm90aCBuYW1lIGFuZCBtYXRjaCBhdHRyaWJ1dGUuIE1hdGNoIGF0dHJpYnV0ZSB3aWxsIGJlIGlnbm9yZWRcIiwgY2hpbGQucmVmTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKG5hbWUpe1xyXG4gICAgICAgICAgICBpZighdGFibGUubmFtZWRFbnRyaWVzW25hbWVdKXtcclxuICAgICAgICAgICAgICAgIGVudHJ5ID0gbmV3IEFzc2V0VGFibGVFbnRyeShjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBhcHBseU1hdGNoRW50cmllcyhlbnRyeSwgdGFibGUubWF0Y2hFbnRyaWVzKTtcclxuICAgICAgICAgICAgICAgIHRhYmxlLm5hbWVkRW50cmllc1tuYW1lXSA9IGVudHJ5O1xyXG4gICAgICAgICAgICAgICAgdGFibGUuYWxsRW50cmllcy5wdXNoKGVudHJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBlbnRyeSA9IHRhYmxlLm5hbWVkRW50cmllc1tuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihjaGlsZC5tYXRjaEZpbHRlcil7XHJcbiAgICAgICAgICAgIG1hdGNoQ2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBlbnRyeSA9IG5ldyBBc3NldFRhYmxlRW50cnkoY2hpbGQpO1xyXG4gICAgICAgICAgICBhcHBseU1hdGNoRW50cmllcyhlbnRyeSwgdGFibGUubWF0Y2hFbnRyaWVzKTtcclxuICAgICAgICAgICAgdGFibGUuYWxsRW50cmllcy5wdXNoKGVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW50cnkucHVzaFBvc3RFbnRyeShjaGlsZCk7XHJcbiAgICB9XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWF0Y2hDaGlsZHJlbi5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gbWF0Y2hDaGlsZHJlbltpXTtcclxuICAgICAgICB2YXIgbWF0Y2hFbnRyeSA9IHtmaWx0ZXI6IGNoaWxkLm1hdGNoRmlsdGVyLCBzdWJkYXRhOiBjaGlsZH07XHJcbiAgICAgICAgdGFibGUubWF0Y2hFbnRyaWVzLnB1c2gobWF0Y2hFbnRyeSk7XHJcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHRhYmxlLmFsbEVudHJpZXMubGVuZ3RoOyArK2ope1xyXG4gICAgICAgICAgICBhcHBseU1hdGNoRW50cnkodGFibGUuYWxsRW50cmllc1tqXSwgbWF0Y2hFbnRyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseU1hdGNoRW50cmllcyhkZXN0RW50cnksIG1hdGNoRW50cmllcyl7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWF0Y2hFbnRyaWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICBhcHBseU1hdGNoRW50cnkoZGVzdEVudHJ5LCBtYXRjaEVudHJpZXNbaV0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseU1hdGNoRW50cnkoZGVzdEVudHJ5LCBtYXRjaEVudHJ5KXtcclxuICAgIHZhciBjaGlsZCA9IG1hdGNoRW50cnkuc3ViZGF0YTtcclxuICAgIGlmKGNoaWxkLmlzTWVzaCgpID09IGRlc3RFbnRyeS5pc01lc2goKSAmJiBtYXRjaEVudHJ5LmZpbHRlci5jaGVjayhkZXN0RW50cnkpKXtcclxuICAgICAgICBkZXN0RW50cnkucHVzaFBvc3RFbnRyeShjaGlsZCk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBjb3B5U3JjVGFibGUodGFibGUsIHNyY1RhYmxlLCBwaWNrRmlsdGVyKXtcclxuXHJcbiAgICBpZihzcmNUYWJsZS5tYXRjaEVudHJpZXMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgdmFyIGkgPSB0YWJsZS5hbGxFbnRyaWVzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0YWJsZS5hbGxFbnRyaWVzW2ldO1xyXG4gICAgICAgICAgICBpZighZW50cnkubmFtZSB8fCAhc3JjVGFibGUubmFtZWRFbnRyaWVzW2VudHJ5Lm5hbWVdKXtcclxuICAgICAgICAgICAgICAgIGFwcGx5TWF0Y2hFbnRyaWVzKGVudHJ5LCBzcmNUYWJsZS5tYXRjaEVudHJpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBpID0gc3JjVGFibGUuYWxsRW50cmllcy5sZW5ndGg7XHJcbiAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgIHZhciBzcmNFbnRyeSA9IHNyY1RhYmxlLmFsbEVudHJpZXNbaV07XHJcbiAgICAgICAgdmFyIGRlc3RFbnRyeSwgbmV3bHlDcmVhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgaWYoc3JjRW50cnkubmFtZSAmJiB0YWJsZS5uYW1lZEVudHJpZXNbc3JjRW50cnkubmFtZV0pe1xyXG4gICAgICAgICAgICBkZXN0RW50cnkgPSB0YWJsZS5uYW1lZEVudHJpZXNbc3JjRW50cnkubmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGRlc3RFbnRyeSA9IG5ldyBBc3NldFRhYmxlRW50cnkoKTtcclxuICAgICAgICAgICAgbmV3bHlDcmVhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGFibGUuYWxsRW50cmllcy5wdXNoKGRlc3RFbnRyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc3RFbnRyeS5wdXNoVGFibGVFbnRyeShzcmNFbnRyeSk7XHJcbiAgICAgICAgaWYobmV3bHlDcmVhdGVkKVxyXG4gICAgICAgICAgICBhcHBseU1hdGNoRW50cmllcyhkZXN0RW50cnksIHRhYmxlLm1hdGNoRW50cmllcyk7XHJcblxyXG4gICAgICAgIGlmKGRlc3RFbnRyeS5uYW1lKSB0YWJsZS5uYW1lZEVudHJpZXNbZGVzdEVudHJ5Lm5hbWVdID0gZGVzdEVudHJ5O1xyXG4gICAgfVxyXG5cclxuICAgIHRhYmxlLm1hdGNoRW50cmllcy5wdXNoLmFwcGx5KHRhYmxlLm1hdGNoRW50cmllcywgc3JjVGFibGUubWF0Y2hFbnRyaWVzKTtcclxuXHJcblxyXG4gICAgdmFyIGkgPSBzcmNUYWJsZS5hbGxTdWJSZXN1bHRzLmxlbmd0aDtcclxuICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgbWVyZ2VTdWJBc3NldFJlc3VsdCh0YWJsZSwgc3JjVGFibGUuYWxsU3ViUmVzdWx0c1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYocGlja0ZpbHRlciAmJiBzcmNUYWJsZS5waWNrRmlsdGVyKXtcclxuICAgICAgICB0YWJsZS5waWNrRmlsdGVyID0gbmV3IEFzc2V0UGlja0ZpbHRlcigpO1xyXG4gICAgICAgIHRhYmxlLnBpY2tGaWx0ZXIuaW50ZXJzZWN0aW9uKHBpY2tGaWx0ZXIsIHNyY1RhYmxlLnBpY2tGaWx0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICB0YWJsZS5waWNrRmlsdGVyID0gcGlja0ZpbHRlciB8fCBzcmNUYWJsZS5waWNrRmlsdGVyO1xyXG4gICAgfVxyXG4gICAgaWYoc3JjVGFibGUuc2hhZGVyKSB0YWJsZS5zaGFkZXIgPSBzcmNUYWJsZS5zaGFkZXI7XHJcbiAgICBpZihzcmNUYWJsZS50cmFuc2Zvcm0pIHRhYmxlLnRyYW5zZm9ybSA9IGNvbWJpbmVUcmFuc2Zvcm0odGFibGUudHJhbnNmb3JtLCBzcmNUYWJsZS50cmFuc2Zvcm0pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gbWVyZ2VTdWJBc3NldFJlc3VsdCh0YWJsZSwgc3JjU3ViVGFibGUpe1xyXG4gICAgdmFyIGRlc3RTdWJUYWJsZTtcclxuICAgIGlmKHNyY1N1YlRhYmxlLm5hbWUgJiYgdGFibGUubmFtZWRTdWJSZXN1bHRzW3NyY1N1YlRhYmxlLm5hbWVdKXtcclxuICAgICAgICBkZXN0U3ViVGFibGUgPSB0YWJsZS5uYW1lZFN1YlJlc3VsdHNbc3JjU3ViVGFibGUubmFtZV07XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIGRlc3RTdWJUYWJsZSA9IG5ldyBBc3NldFJlc3VsdCgpO1xyXG4gICAgICAgIGRlc3RTdWJUYWJsZS5wYXJlbnRSZXN1bHQgPSB0YWJsZTtcclxuICAgICAgICBkZXN0U3ViVGFibGUubmFtZSA9IHNyY1N1YlRhYmxlLm5hbWU7XHJcbiAgICAgICAgdGFibGUuYWxsU3ViUmVzdWx0cy5wdXNoKGRlc3RTdWJUYWJsZSk7XHJcbiAgICAgICAgaWYoZGVzdFN1YlRhYmxlLm5hbWUpIHRhYmxlLm5hbWVkU3ViUmVzdWx0c1tkZXN0U3ViVGFibGUubmFtZV0gPSBkZXN0U3ViVGFibGU7XHJcbiAgICB9XHJcbiAgICBjb3B5U3JjVGFibGUoZGVzdFN1YlRhYmxlLCBzcmNTdWJUYWJsZSwgZGVzdFN1YlRhYmxlLnBpY2tGaWx0ZXIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWNfZ2V0RGF0YVRyZWUodGFibGUpe1xyXG4gICAgdmFyIG5vZGUgPSB7XHJcbiAgICAgICAgbWVzaGVzOiBbXSxcclxuICAgICAgICBncm91cHM6IFtdLFxyXG4gICAgICAgIHRyYW5zZm9ybTogdGFibGUudHJhbnNmb3JtLFxyXG4gICAgICAgIHNoYWRlcjogdGFibGUuc2hhZGVyLFxyXG4gICAgICAgIHBvc3RUcmFuc2Zvcm1YZmxvd05vZGU6IG51bGxcclxuICAgIH07XHJcblxyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRhYmxlLmFsbEVudHJpZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRhYmxlLmFsbEVudHJpZXNbaV07XHJcbiAgICAgICAgaWYoZW50cnkubWVzaFR5cGUgJiYgKCF0YWJsZS5waWNrRmlsdGVyIHx8IHRhYmxlLnBpY2tGaWx0ZXIuY2hlY2soZW50cnkpKSApe1xyXG4gICAgICAgICAgICB1cGRhdGVBY2N1bXVsYXRlZE5vZGUodGFibGUsIGVudHJ5KTtcclxuICAgICAgICAgICAgbm9kZS5tZXNoZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB4Zmxvd05vZGU6IGVudHJ5LmFjY3VtdWxhdGVkWGZsb3dOb2RlLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogZW50cnkubWVzaFR5cGUsXHJcbiAgICAgICAgICAgICAgICBzaGFkZXI6IGVudHJ5LnNoYWRlcixcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogZW50cnkudHJhbnNmb3JtLFxyXG4gICAgICAgICAgICAgICAgcmVmTm9kZTogZW50cnkucmVmTm9kZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgcG9zdFRyYW5zZm9ybUVudHJ5ID0gdGFibGUubmFtZWRFbnRyaWVzW1wiX3Bvc3RUcmFuc2Zvcm1cIl07XHJcbiAgICBpZihwb3N0VHJhbnNmb3JtRW50cnkpe1xyXG4gICAgICAgIHVwZGF0ZUFjY3VtdWxhdGVkTm9kZSh0YWJsZSwgcG9zdFRyYW5zZm9ybUVudHJ5KTtcclxuICAgICAgICBub2RlLnBvc3RUcmFuc2Zvcm1YZmxvd05vZGUgPSBwb3N0VHJhbnNmb3JtRW50cnkuYWNjdW11bGF0ZWRYZmxvd05vZGU7XHJcbiAgICB9XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGFibGUuYWxsU3ViUmVzdWx0cy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIHN1Yk5vZGUgPSByZWNfZ2V0RGF0YVRyZWUodGFibGUuYWxsU3ViUmVzdWx0c1tpXSk7XHJcbiAgICAgICAgbm9kZS5ncm91cHMucHVzaChzdWJOb2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBub2RlO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVBY2N1bXVsYXRlZE5vZGUodGFibGUsIGVudHJ5KXtcclxuICAgIGlmKCFlbnRyeS5vdXRPZlN5bmMpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmKGVudHJ5LmFjY3VtdWxhdGVkWGZsb3dOb2RlKXtcclxuICAgICAgICBlbnRyeS5hY2N1bXVsYXRlZFhmbG93Tm9kZS5jbGVhckNoaWxkcmVuKCk7XHJcbiAgICAgICAgZW50cnkuYWNjdW11bGF0ZWRYZmxvd05vZGUuc2V0Q29tcHV0ZShcIlwiKTtcclxuICAgICAgICBlbnRyeS5hY2N1bXVsYXRlZFhmbG93Tm9kZS5zZXRGaWx0ZXIoXCJcIik7XHJcbiAgICAgICAgZW50cnkuYWNjdW11bGF0ZWRYZmxvd05vZGUuZGF0YWZsb3dOb2RlID0gbnVsbDtcclxuICAgICAgICBlbnRyeS5hY2N1bXVsYXRlZFhmbG93Tm9kZS5zZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgZW50cnkuYWNjdW11bGF0ZWRYZmxvd05vZGUgPSBuZXcgRGF0YU5vZGUoZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkYXRhTm9kZSA9IGVudHJ5LnBvc3RRdWV1ZS5sZW5ndGggPT0gMSA/IGVudHJ5LmFjY3VtdWxhdGVkWGZsb3dOb2RlIDogbmV3IERhdGFOb2RlKGZhbHNlKTtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlbnRyeS5wb3N0UXVldWUubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHZhciBpbmNsdWRlcyA9IGVudHJ5LnBvc3RRdWV1ZVtpXS5pbmNsdWRlcztcclxuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgaW5jbHVkZXMubGVuZ3RoOyArK2ope1xyXG4gICAgICAgICAgICB2YXIgYWRkRW50cnkgPSBnZXRJbmNsdWRlRW50cnkodGFibGUsIGluY2x1ZGVzW2pdKTtcclxuICAgICAgICAgICAgZGF0YU5vZGUuYXBwZW5kQ2hpbGQoYWRkRW50cnkuYWNjdW11bGF0ZWRYZmxvd05vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihlbnRyeS5wb3N0UXVldWVbaV0ueGZsb3dOb2RlKVxyXG4gICAgICAgICAgICBkYXRhTm9kZS5hcHBlbmRDaGlsZChlbnRyeS5wb3N0UXVldWVbaV0ueGZsb3dOb2RlKTtcclxuICAgIH1cclxuICAgIHZhciBub2RlID0gZGF0YU5vZGUsIHBhcmVudE5vZGUgPSBudWxsO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGVudHJ5LnBvc3RRdWV1ZS5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIHBvc3RFbnRyeSA9IGVudHJ5LnBvc3RRdWV1ZVtpXTtcclxuICAgICAgICBpZighbm9kZSkgbm9kZSA9IChpID09IGVudHJ5LnBvc3RRdWV1ZS5sZW5ndGggLSAxID8gZW50cnkuYWNjdW11bGF0ZWRYZmxvd05vZGUgOiBuZXcgRGF0YU5vZGUoZmFsc2UpKTtcclxuICAgICAgICBub2RlLnNldENvbXB1dGUocG9zdEVudHJ5LmNvbXB1dGUpO1xyXG4gICAgICAgIG5vZGUuc2V0RmlsdGVyKHBvc3RFbnRyeS5maWx0ZXIpO1xyXG4gICAgICAgIG5vZGUuZGF0YWZsb3dOb2RlID0gcG9zdEVudHJ5LmRhdGFmbG93O1xyXG4gICAgICAgIG5vZGUuc2V0TG9hZGluZyhwb3N0RW50cnkuZGF0YWZsb3dMb2FkaW5nKTtcclxuICAgICAgICBpZihwYXJlbnROb2RlKSBub2RlLmFwcGVuZENoaWxkKHBhcmVudE5vZGUpO1xyXG4gICAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xyXG4gICAgICAgIG5vZGUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZW50cnkub3V0T2ZTeW5jID0gZmFsc2U7XHJcbn1cclxuXHJcblxyXG52YXIgY19hY2N1bV9lbnRyaWVzID0gW10sXHJcbiAgICBjX2FjY3VtX25hbWVzID0gW107XHJcblxyXG5mdW5jdGlvbiBnZXRJbmNsdWRlRW50cnkodGFibGUsIGluY2x1ZGVTdHJpbmcpe1xyXG4gICAgdmFyIHNlZ21lbnRzID0gaW5jbHVkZVN0cmluZy5zcGxpdChcIi5cIik7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoIC0xOyArK2kpe1xyXG4gICAgICAgIHZhciBzZWcgPSBzZWdtZW50c1tpXTtcclxuICAgICAgICBpZihzZWcgPT0gXCJwYXJlbnRcIil7XHJcbiAgICAgICAgICAgIGlmKCF0YWJsZS5wYXJlbnRSZXN1bHQpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNsdWRlcyBlbnRyeSAnXCIgKyBpbmNsdWRlU3RyaW5nICsgXCInICh0b2tlbiBcIisgaSArXCIpIGFjY2Vzc2VzIG5vbiBleGlzdGVudCBwYXJlbnQuXCIpO1xyXG4gICAgICAgICAgICB0YWJsZSA9IHRhYmxlLnBhcmVudFJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgaWYoIXRhYmxlLm5hbWVkU3ViUmVzdWx0c1tzZWddKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jbHVkZXMgZW50cnkgJ1wiICsgaW5jbHVkZVN0cmluZyArIFwiJyAodG9rZW4gXCIrIGkgK1wiKSBhY2Nlc3NlcyBub24gZXhpc3RlbnQgc3ViIHJlc3VsdCAnXCIgKyBzZWcgKyBcIidcIik7XHJcbiAgICAgICAgICAgIHRhYmxlID0gdGFibGUubmFtZWRTdWJSZXN1bHRzW3NlZ107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGVudHJ5S2V5ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XHJcbiAgICB2YXIgZW50cnkgPSB0YWJsZS5uYW1lZEVudHJpZXNbZW50cnlLZXldO1xyXG4gICAgaWYoIWVudHJ5KXtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNsdWRlcyBlbnRyeSAnXCIgKyBpbmNsdWRlU3RyaW5nICsgXCInIGFjY2Vzc2VzIG5vbiBleGlzdGVudCBhc3NldCBlbnRyeSAnXCIgKyBlbnRyeUtleSArIFwiJ1wiICk7XHJcbiAgICB9XHJcblxyXG4gICAgY19hY2N1bV9uYW1lcy5wdXNoKGluY2x1ZGVTdHJpbmcpO1xyXG4gICAgaWYoY19hY2N1bV9lbnRyaWVzLmluZGV4T2YoZW50cnkpICE9IC0xKXtcclxuICAgICAgICB2YXIgcGF0aCA9IGNfYWNjdW1fbmFtZXMuam9pbihcIiA+IFwiKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWN1cnNpdmUgaW5jbHVkZSBkZXBlbmRlbmNpZXMgZGV0ZWN0ZWQ6IFwiICsgcGF0aCk7XHJcbiAgICB9XHJcbiAgICBjX2FjY3VtX2VudHJpZXMucHVzaChlbnRyeSk7XHJcblxyXG4gICAgdXBkYXRlQWNjdW11bGF0ZWROb2RlKHRhYmxlLCBlbnRyeSk7XHJcbiAgICBjX2FjY3VtX2VudHJpZXMucG9wKCk7XHJcbiAgICBjX2FjY3VtX25hbWVzLnBvcCgpO1xyXG4gICAgcmV0dXJuIGVudHJ5O1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBBc3NldFRhYmxlRW50cnkgKHN1YkRhdGEpe1xyXG4gICAgdGhpcy5uYW1lID0gbnVsbDtcclxuICAgIHRoaXMuY2xhc3NOYW1lcyA9IFtdO1xyXG4gICAgdGhpcy5tZXNoVHlwZSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5wb3N0UXVldWUgPSBbXTtcclxuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxuICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmFjY3VtdWxhdGVkWGZsb3dOb2RlID0gbnVsbDtcclxuICAgIHRoaXMub3V0T2ZTeW5jID0gdHJ1ZTtcclxuICAgIHRoaXMucmVmTm9kZSA9IG51bGw7XHJcbiAgICBpZihzdWJEYXRhKXtcclxuICAgICAgICB0aGlzLm5hbWUgPSBzdWJEYXRhLm5hbWU7XHJcbiAgICAgICAgU2V0LmFkZCh0aGlzLmNsYXNzTmFtZXMsIHN1YkRhdGEuY2xhc3NOYW1lcyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbkFzc2V0VGFibGVFbnRyeS5wcm90b3R5cGUuaXNNZXNoID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiAhIXRoaXMubWVzaFR5cGU7XHJcbn07XHJcblxyXG5Bc3NldFRhYmxlRW50cnkucHJvdG90eXBlLnB1c2hUYWJsZUVudHJ5ID0gZnVuY3Rpb24oc3JjRW50cnkpe1xyXG4gICAgdGhpcy5uYW1lID0gc3JjRW50cnkubmFtZTtcclxuICAgIFNldC5hZGQodGhpcy5jbGFzc05hbWVzLCBzcmNFbnRyeS5jbGFzc05hbWVzKTtcclxuICAgIGlmKHNyY0VudHJ5Lm1lc2hUeXBlKSB0aGlzLm1lc2hUeXBlID0gc3JjRW50cnkubWVzaFR5cGU7XHJcblxyXG4gICAgaWYoc3JjRW50cnkudHJhbnNmb3JtKSB0aGlzLnRyYW5zZm9ybSA9IGNvbWJpbmVUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm0sIHNyY0VudHJ5LnRyYW5zZm9ybSk7XHJcbiAgICBpZihzcmNFbnRyeS5zaGFkZXIpIHRoaXMuc2hhZGVyID0gc3JjRW50cnkuc2hhZGVyO1xyXG5cclxuICAgIHRoaXMucG9zdFF1ZXVlLnB1c2guYXBwbHkodGhpcy5wb3N0UXVldWUsIHNyY0VudHJ5LnBvc3RRdWV1ZSk7XHJcbn07XHJcblxyXG5cclxuQXNzZXRUYWJsZUVudHJ5LnByb3RvdHlwZS5wdXNoUG9zdEVudHJ5ID0gZnVuY3Rpb24oc3ViRGF0YSl7XHJcbiAgICB0aGlzLm5hbWUgPSBzdWJEYXRhLm5hbWU7XHJcbiAgICB0aGlzLnBvc3RRdWV1ZS5wdXNoKHtcclxuICAgICAgICBkYXRhZmxvdzogc3ViRGF0YS5wb3N0RGF0YWZsb3csXHJcbiAgICAgICAgZGF0YWZsb3dMb2FkaW5nOiBzdWJEYXRhLmxvYWRpbmcsXHJcbiAgICAgICAgY29tcHV0ZTogc3ViRGF0YS5wb3N0Q29tcHV0ZSxcclxuICAgICAgICBmaWx0ZXI6IHN1YkRhdGEucG9zdEZpbHRlcixcclxuICAgICAgICBpbmNsdWRlczogc3ViRGF0YS5pbmNsdWRlcyxcclxuICAgICAgICB4Zmxvd05vZGU6IHN1YkRhdGEueGZsb3dOb2RlSW5cclxuICAgIH0pO1xyXG4gICAgdGhpcy5yZWZOb2RlID0gc3ViRGF0YS5yZWZOb2RlO1xyXG4gICAgdGhpcy5hY2N1bXVsYXRlZFhmbG93Tm9kZSA9IHN1YkRhdGEueGZsb3dOb2RlT3V0O1xyXG4gICAgU2V0LmFkZCh0aGlzLmNsYXNzTmFtZXMsIHN1YkRhdGEuY2xhc3NOYW1lcyk7XHJcbiAgICBpZihzdWJEYXRhLm1lc2hUeXBlKSB0aGlzLm1lc2hUeXBlID0gc3ViRGF0YS5tZXNoVHlwZTtcclxuICAgIGlmKHN1YkRhdGEuc2hhZGVyKSB0aGlzLnNoYWRlciA9IHN1YkRhdGEuc2hhZGVyO1xyXG4gICAgaWYoc3ViRGF0YS50cmFuc2Zvcm0pIHRoaXMudHJhbnNmb3JtID0gY29tYmluZVRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybSwgc3ViRGF0YS50cmFuc2Zvcm0pO1xyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIGNvbWJpbmVUcmFuc2Zvcm0ob2xkVHJhbnNmb3JtLCBuZXdUcmFuc2Zvcm0pe1xyXG4gICAgLy8gVE9ETzogQmV0dGVyIG11bHRpcGx5IHRyYW5zZm9ybWF0aW9ucyBoZXJlXHJcbiAgICByZXR1cm4gbmV3VHJhbnNmb3JtO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gQXNzZXRQaWNrRmlsdGVyKCl7XHJcbiAgICB0aGlzLmFsbCA9IGZhbHNlO1xyXG4gICAgdGhpcy5uYW1lcyA9IFtdO1xyXG4gICAgdGhpcy5jbGFzc05hbWVzID0gW107XHJcbn1cclxuXHJcbkFzc2V0UGlja0ZpbHRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpe1xyXG4gICAgdmFyIGVudHJpZXMgPSBzdHJpbmcuc3BsaXQoXCIsXCIpO1xyXG4gICAgdmFyIGkgPSBlbnRyaWVzLmxlbmd0aDtcclxuICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXS50cmltKCk7XHJcbiAgICAgICAgaWYoZW50cnkgPT0gXCIqXCIpe1xyXG4gICAgICAgICAgICB0aGlzLmFsbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZW50cnkuaW5kZXhPZihcIi5cIikgPT0gMCl7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gZW50cnkuc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgICAgICB2YXIgaiA9IGNsYXNzTmFtZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZShqLS0pe1xyXG4gICAgICAgICAgICAgICAgaWYoIWNsYXNzTmFtZXNbal0udHJpbSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMuc3BsaWNlKGosMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWVzLnB1c2goY2xhc3NOYW1lcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIFNldC5hZGQodGhpcy5uYW1lcywgZW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkFzc2V0UGlja0ZpbHRlci5wcm90b3R5cGUuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oc2V0QSwgc2V0Qil7XHJcbiAgICBTZXQuaW50ZXJzZWN0aW9uKHRoaXMubmFtZXMsIHNldEEubmFtZXMsIHNldEIubmFtZXMpO1xyXG4gICAgU2V0LmludGVyc2VjdGlvbih0aGlzLmNsYXNzTmFtZXMsIHNldEEuY2xhc3NOYW1lcywgc2V0Qi5jbGFzc05hbWVzKTtcclxufTtcclxuXHJcbkFzc2V0UGlja0ZpbHRlci5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihlbnRyeSl7XHJcbiAgICBpZih0aGlzLmFsbClcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGlmKGVudHJ5LmNsYXNzTmFtZXMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmNsYXNzTmFtZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgICAgIGlmKFNldC5pc1N1YnNldCh0aGlzLmNsYXNzTmFtZXNbaV0sIGVudHJ5LmNsYXNzTmFtZXMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIChlbnRyeS5uYW1lICYmIHRoaXMubmFtZXMuaW5kZXhPZihlbnRyeS5uYW1lKSAhPSAtMSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEFzc2V0OiBBc3NldCxcclxuICAgIFN1YkRhdGE6IFN1YkRhdGEsXHJcbiAgICBBc3NldFJlc3VsdDogQXNzZXRSZXN1bHRcclxufTtcclxuIiwidmFyIHJlZ2lzdGVyRmFjdG9yeSA9IHJlcXVpcmUoXCIuL3Jlc291cmNlbWFuYWdlci5qc1wiKS5yZWdpc3RlckZhY3Rvcnk7XHJcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL3Jlc291cmNlbWFuYWdlci5qc1wiKS5SZXNvdXJjZTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9lbGVtZW50cy5qc1wiKS5jb25maWc7XHJcblxyXG4vKipcclxuICogQSBub3JtYWwgYWRhcHRlciB0aGF0IGRvZXNuJ3QgbmVlZCB0byBiZSBjb25uZWN0ZWQgdG8gYSBET00gbm9kZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtYTUwzRC5iYXNlLkFkYXB0ZXJGYWN0b3J5fSBmYWN0b3J5IC0gdGhlIGZhY3RvcnkgdGhpcyBhZGFwdGVyIHdhcyBjcmVhdGVkIGZyb21cclxuICovXHJcbnZhciBBZGFwdGVyID0gZnVuY3Rpb24oZmFjdG9yeSkge1xyXG4gICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb25uZWN0IGFuIGFkYXB0ZXJIYW5kbGUgdG8gYSBjZXJ0YWluIGtleS5cclxuICogVGhpcyB3aWxsIGVuYWJsZSB0aGUgQ29ubmVjdGVkQWRhcHRlck5vdGlmY2F0aW9ucyBmb3Igbm90aWZ5Q2hhbmdlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIHRoZSBrZXkgdGhhdCB3aWxsIGFsc28gYmUgcHJvdmlkZWQgaW4gY29ubmVjdEFkYXB0ZXJDaGFuZ2VkIGNhbGxiYWNrXHJcbiAqIEBwYXJhbSB7WE1MM0QuYmFzZS5BZGFwdGVySGFuZGxlfSBhZGFwdGVySGFuZGxlIGhhbmRsZSBvZiBhZGFwdGVyIHRvIGJlIGFkZGVkXHJcbiAqL1xyXG5BZGFwdGVyLnByb3RvdHlwZS5jb25uZWN0QWRhcHRlckhhbmRsZSA9IGZ1bmN0aW9uKGtleSwgYWRhcHRlckhhbmRsZSkge1xyXG4gICAgaWYgKCF0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGVzKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2JpbmRlZEFkYXB0ZXJIYW5kbGVDYWxsYmFjayA9IGFkYXB0ZXJIYW5kbGVDYWxsYmFjay5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGlzY29ubmVjdEFkYXB0ZXJIYW5kbGUoa2V5KTtcclxuXHJcbiAgICBpZiAoYWRhcHRlckhhbmRsZSkge1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZXNba2V5XSA9IGFkYXB0ZXJIYW5kbGU7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlc1trZXldLmFkZExpc3RlbmVyKHRoaXMuX2JpbmRlZEFkYXB0ZXJIYW5kbGVDYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICAgICAgZGVsZXRlIHRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZXNba2V5XTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogRGlzY29ubmVjdHMgdGhlIGFkYXB0ZXIgaGFuZGxlIGZyb20gdGhlIGdpdmVuIGtleS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIHRoZSBrZXkgdGhhdCB3YXMgcHJvdmlkZWQgd2hlbiB0aGlzIGFkYXB0ZXIgaGFuZGxlIHdhcyBjb25uZWN0ZWRcclxuICovXHJcbkFkYXB0ZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RBZGFwdGVySGFuZGxlID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICBpZiAodGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlcyAmJiB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGVzW2tleV0pIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGVzW2tleV0ucmVtb3ZlTGlzdGVuZXIodGhpcy5fYmluZGVkQWRhcHRlckhhbmRsZUNhbGxiYWNrKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlc1trZXldO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERpc2Nvbm5lY3RzIGFsbCBhZGFwdGVyIGhhbmRsZXMuXHJcbiAqL1xyXG5BZGFwdGVyLnByb3RvdHlwZS5jbGVhckFkYXB0ZXJIYW5kbGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZXMpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGVzW2ldLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2JpbmRlZEFkYXB0ZXJIYW5kbGVDYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlcyA9IG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjb25uZWN0ZWQgQWRhcHRlckhhbmRsZSBvZiBhIGNlcnRhaW4ga2V5LlxyXG4gKiBUaGlzIHdpbGwgb25seSByZXR1cm4gQWRhcHRlckhhbmRsZXMgcHJldmlvdXNseSBhZGRlZCB2aWEgY29ubmVjdEFkYXB0ZXJIYW5kbGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxyXG4gKiBAcmV0dXJuIHs/QWRhcHRlckhhbmRsZX0gdGhlIGFkYXB0ZXIgb2YgdGhhdCBrZXksIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZVxyXG4gKi9cclxuQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkQWRhcHRlckhhbmRsZSA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZXMgJiYgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlc1trZXldO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgY29ubmVjdGVkIGFkYXB0ZXIgb2YgYSBjZXJ0YWluIGtleS5cclxuICogVGhpcyB3aWxsIG9ubHkgcmV0dXJuIGFkYXB0ZXJzIG9mIEFkYXB0ZXJIYW5kbGVzIHByZXZpb3VzbHkgYWRkZWQgdmlhIGNvbm5lY3RBZGFwdGVyXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcclxuICogQHJldHVybiB7P1hNTDNELmJhc2UuQWRhcHRlcn0gdGhlIGFkYXB0ZXIgb2YgdGhhdCBrZXksIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZVxyXG4gKi9cclxuQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkQWRhcHRlciA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuZ2V0Q29ubmVjdGVkQWRhcHRlckhhbmRsZShrZXkpO1xyXG4gICAgcmV0dXJuIGhhbmRsZSAmJiBoYW5kbGUuZ2V0QWRhcHRlcigpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLCB3aGVuIHRoZSBhZGFwYXRlciBpcyBkZXRhY2hlZCBmcm9tIHRoZSBub2RlLlxyXG4gKiBBdCB0aGlzIHBvaW50LCB0aGUgYWRhcGF0ZXIgc2hvdWxkIGRpc2Nvbm5lY3QgZnJvbSBhbnkgb3RoZXIgYWRhcHRlciBhbmQgcHJlcGFyZSB0byBiZSBwcm9wZXJseSBnYXJiYWdlIGNvbGxlY3RlZFxyXG4gKi9cclxuQWRhcHRlci5wcm90b3R5cGUub25EaXNwb3NlID0gZnVuY3Rpb24oKSB7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgY29udmVydHMgYW4gQWRhcHRlckhhbmRsZU5vdGlmaWNhdGlvbiB0byBhIENvbm5lY3RlZEFkYXB0ZXJOb3RpZmljYXRpb25cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtFdmVudHMuQWRhcHRlckhhbmRsZU5vdGlmaWNhdGlvbn0gZXZ0XHJcbiAqL1xyXG5mdW5jdGlvbiBhZGFwdGVySGFuZGxlQ2FsbGJhY2soZXZ0KSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlcykge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGVzW2tleV0gPT0gZXZ0LmFkYXB0ZXJIYW5kbGUpIHtcclxuICAgICAgICAgICAgdmFyIHN1YkV2ZW50ID0gbmV3IEV2ZW50cy5Db25uZWN0ZWRBZGFwdGVyTm90aWZpY2F0aW9uKGV2dCwga2V5KTtcclxuICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VkKHN1YkV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQW4gQWRhcHRlciBjb25uZWN0ZWQgdG8gYSBET01Ob2RlIChwb3NzaWJseSBvZiBhbiBleHRlcm5hbCBkb2N1bWVudClcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7QWRhcHRlckZhY3Rvcnl9IGZhY3RvcnkgdGhlIEFkYXB0ZXJGYWN0b3J5IHRoaXMgYWRhcHRlciB3YXMgY3JlYXRlZCBmcm9tXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIC0gRE9NIG5vZGUgb2YgdGhpcyBBZGFwdGVyXHJcbiAqL1xyXG52YXIgTm9kZUFkYXB0ZXIgPSBmdW5jdGlvbihmYWN0b3J5LCBub2RlKSB7XHJcbiAgICBBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSk7XHJcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhOb2RlQWRhcHRlciwgQWRhcHRlcik7XHJcblxyXG4vKipcclxuICogY2FsbGVkIGJ5IHRoZSBmYWN0b3J5IGFmdGVyIGFkZGluZyB0aGUgYWRhcHRlciB0byB0aGUgbm9kZVxyXG4gKi9cclxuTm9kZUFkYXB0ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOb3RpZmljdGlvbiBkdWUgdG8gYSBjaGFuZ2UgaW4gRE9NLCByZWxhdGVkIGFkYXB0ZXJzIGFuZCBzbyBvbi5cclxuICogQHBhcmFtIHtFdmVudHMuTm90aWZpY2F0aW9ufSBlXHJcbiAqL1xyXG5Ob2RlQWRhcHRlci5wcm90b3R5cGUubm90aWZ5Q2hhbmdlZCA9IGZ1bmN0aW9uKGUpIHtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd8WE1MM0QuVVJJfSB1cmkgVXJpIHRvIHJlZmVycmVkIGFkYXB0ZXJIYW5kbGVcclxuICogQHBhcmFtIHtPYmplY3Q9fSBhc3BlY3RUeXBlIE9wdGlvbmFsOiB0aGUgdHlwZSBvZiBhZGFwdGVyICh1c2Ugc2FtZSBhZGFwdGVyIHR5cGUgYnkgZGVmYXVsdClcclxuICogQHBhcmFtIHtudW1iZXI9fSBjYW52YXNJZCBPcHRpb25hbDogdGhlIGNhbnZhcyBpZCBvZiB0aGUgYWRhcHRlciAodXNlIGNhbnZhcyBpZCBvZiB0aGlzIGFkYXB0ZXIgYnkgZGVmYXVsdClcclxuICogQHJldHVybnMgYW4gQWRhcHRlckhhbmRsZSB0byB0aGUgcmVmZXJyZWQgQWRhcHRlciBvZiB0aGUgc2FtZSBhc3BlY3QgYW5kIGNhbnZhc0lkXHJcbiAqL1xyXG5Ob2RlQWRhcHRlci5wcm90b3R5cGUuZ2V0QWRhcHRlckhhbmRsZSA9IGZ1bmN0aW9uKHVyaSwgYXNwZWN0VHlwZSwgY2FudmFzSWQpIHtcclxuICAgIGNhbnZhc0lkID0gY2FudmFzSWQgPT09IHVuZGVmaW5lZCA/IHRoaXMuZmFjdG9yeS5jYW52YXNJZCA6IGNhbnZhc0lkO1xyXG4gICAgcmV0dXJuIFJlc291cmNlLmdldEFkYXB0ZXJIYW5kbGUodGhpcy5ub2RlLm93bmVyRG9jdW1lbnQuX2RvY3VtZW50VVJMIHx8IHRoaXMubm9kZS5vd25lckRvY3VtZW50LlVSTCxcclxuICAgICAgICB1cmksIGFzcGVjdFR5cGUgfHwgdGhpcy5mYWN0b3J5LmFzcGVjdCwgY2FudmFzSWQpO1xyXG59O1xyXG4vKipcclxuICogbm90aWZpZXMgYWxsIGFkYXB0ZXIgdGhhdCByZWZlciB0byB0aGlzIGFkYXB0ZXIgdGhyb3VnaCBBZGFwdGVySGFuZGxlcy5cclxuICogQHBhcmFtIHtudW1iZXI/fSB0eXBlIFRoZSB0eXBlIG9mIGNoYW5nZVxyXG4gKi9cclxuTm9kZUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeU9wcG9zaXRlQWRhcHRlcnMgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICB0eXBlID0gdHlwZSB8fCBFdmVudHMuQURBUFRFUl9IQU5ETEVfQ0hBTkdFRDtcclxuICAgIHJldHVybiBSZXNvdXJjZS5ub3RpZnlOb2RlQWRhcHRlckNoYW5nZSh0aGlzLm5vZGUsXHJcbiAgICAgICAgdGhpcy5mYWN0b3J5LmFzcGVjdCwgdGhpcy5mYWN0b3J5LmNhbnZhc0lkLCB0eXBlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXB0aC1maXJzdCB0cmF2ZXJzYWwgb3ZlciBlbGVtZW50IGhpZXJhcmNoeVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE5vZGVBZGFwdGVyKX0gY2FsbGJhY2tcclxuICovXHJcbk5vZGVBZGFwdGVyLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICBjYWxsYmFjayh0aGlzKTtcclxuICAgIHZhciBjaGlsZCA9IHRoaXMubm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgIHdoaWxlIChjaGlsZCkge1xyXG4gICAgICAgIHZhciBhZGFwdGVyID0gdGhpcy5mYWN0b3J5LmdldEFkYXB0ZXIoY2hpbGQpO1xyXG4gICAgICAgIGFkYXB0ZXIgJiYgYWRhcHRlci50cmF2ZXJzZShjYWxsYmFjayk7XHJcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0RWxlbWVudFNpYmxpbmc7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2VcclxuICovXHJcbnZhciBJRmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xyXG59O1xyXG5cclxuLyoqIEB0eXBlIHtzdHJpbmd9ICovXHJcbklGYWN0b3J5LnByb3RvdHlwZS5hc3BlY3Q7XHJcblxyXG5cclxuLyoqXHJcbiAqIEFuIGFkYXB0ZXIgZmFjdG9yeSBpcyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYWRhcHRlciBmcm9tIGEgY2VydGFpbiBkYXRhIHNvdXJjZS5cclxuICogTm90ZSB0aGF0IGFueSBBZGFwdGVyRmFjdG9yeSBpcyByZWdpc3RlcmVkIHdpdGggUmVzb3VyY2VcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBpbXBsZW1lbnRzIHtJRmFjdG9yeX1cclxuICogQHBhcmFtIHtPYmplY3R9IGFzcGVjdCBUaGUgYXNwZWN0IHRoaXMgZmFjdG9yeSBzZXJ2ZXMgKGUuZy4gWE1MM0QuZGF0YSBvciBYTUwzRC53ZWJnbClcclxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IG1pbWV0eXBlcyBUaGUgbWltZXR5cGUgdGhpcyBmYWN0b3J5IGlzIGNvbXBhdGlibGUgdG9cclxuICogQHBhcmFtIHtudW1iZXJ9IGNhbnZhc0lkIFRoZSBpZCBvZiB0aGUgY29ycmVzcG9uZGluZyBjYW52YXMgaGFuZGxlci4gMCwgaWYgbm90IGRlcGVuZGVudCBvbiBhbnkgR0xDYW52YXNIYW5kbGVyXHJcbiAqL1xyXG52YXIgQWRhcHRlckZhY3RvcnkgPSBmdW5jdGlvbihhc3BlY3QsIG1pbWV0eXBlcywgY2FudmFzSWQpIHtcclxuICAgIHRoaXMuYXNwZWN0ID0gYXNwZWN0O1xyXG4gICAgdGhpcy5jYW52YXNJZCA9IGNhbnZhc0lkIHx8IDA7XHJcbiAgICB0aGlzLm1pbWV0eXBlcyA9IHR5cGVvZiBtaW1ldHlwZXMgPT0gXCJzdHJpbmdcIiA/IFsgbWltZXR5cGVzXSA6IG1pbWV0eXBlcztcclxuXHJcbiAgICByZWdpc3RlckZhY3RvcnkodGhpcyk7XHJcbn07XHJcblxyXG4gLyoqIEltcGxlbWVudGVkIGJ5IHN1YmNsYXNzXHJcbiAqIENyZWF0ZSBhZGFwdGVyIGZyb20gYW4gb2JqZWN0IChub2RlIGluIGNhc2Ugb2YgYW4geG1sLCBhbmQgb2JqZWN0IGluIGNhc2Ugb2YganNvbilcclxuICogQHBhcmFtIHtvYmplY3R9IG9ialxyXG4gKiBAcmV0dXJucyB7P0FkYXB0ZXJ9IGNyZWF0ZWQgYWRhcHRlciBvciBudWxsIGlmIG5vIGFkYXB0ZXIgY2FuIGJlIGNyZWF0ZWRcclxuICovXHJcbkFkYXB0ZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVBZGFwdGVyID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdGhlIGFkYXB0ZXIgZmFjdG9yeSBzdXBwb3J0cyBzcGVjaWZpZWQgbWltZXR5cGUuIENhbiBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcclxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgYWRhcHRlciBmYWN0b3J5IHN1cHBvcnRzIHNwZWNpZmllZCBtaW1ldHlwZVxyXG4gKi9cclxuQWRhcHRlckZhY3RvcnkucHJvdG90eXBlLnN1cHBvcnRzTWltZXR5cGUgPSBmdW5jdGlvbihtaW1ldHlwZSkge1xyXG4gICAgcmV0dXJuIHRoaXMubWltZXR5cGVzLmluZGV4T2YobWltZXR5cGUpICE9IC0xO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgTm9kZUFkYXBlckZhY3RvcnkgaXMgYSBBZGFwdGVyRmFjdG9yeSwgdGhhdCB3b3JrcyBzcGVjaWZpY2FsbHkgZm9yIERPTSBub2RlcyAvIGVsZW1lbnRzLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtPYmplY3R9IGFzcGVjdCBUaGUgYXNwZWN0IHRoaXMgZmFjdG9yeSBzZXJ2ZXMgKGUuZy4gWE1MM0QuZGF0YSBvciBYTUwzRC53ZWJnbClcclxuICogQHBhcmFtIHtudW1iZXJ9IGNhbnZhc0lkIFRoZSBpZCBvZiB0aGUgY29ycmVzcG9uZGluZyBjYW52YXMgaGFuZGxlci4gMCwgaWYgbm90IGRlcGVuZGVudCBvbiBhbnkgR0xDYW52YXNIYW5kbGVyXHJcbiAqL1xyXG52YXIgTm9kZUFkYXB0ZXJGYWN0b3J5ID0gZnVuY3Rpb24oYXNwZWN0LCBjYW52YXNJZCkge1xyXG4gICAgQWRhcHRlckZhY3RvcnkuY2FsbCh0aGlzLCBhc3BlY3QsIFtcInRleHQveG1sXCIsIFwiYXBwbGljYXRpb24veG1sXCJdLCBjYW52YXNJZCk7XHJcbn07XHJcblhNTDNELmNyZWF0ZUNsYXNzKE5vZGVBZGFwdGVyRmFjdG9yeSwgQWRhcHRlckZhY3RvcnkpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gZmlyc3QgY2hlY2tzLCBpZiBhbiBhZGFwdGVyIGhhcyBiZWVuIGFscmVhZHkgY3JlYXRlZCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgbm9kZVxyXG4gKiBJZiB5ZXMsIHRoaXMgYWRhcHRlciBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlLCBhIG5ldyBhZGFwdGVyIGlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxyXG4gKiBAcmV0dXJucyB7QWRhcHRlcn0gVGhlIGFkYXB0ZXIgb2YgdGhlIG5vZGVcclxuICovXHJcbk5vZGVBZGFwdGVyRmFjdG9yeS5wcm90b3R5cGUuZ2V0QWRhcHRlciA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIGlmKG5vZGUgJiYgbm9kZS5fY29uZmlndXJlZCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIGNvbmZpZy5lbGVtZW50KG5vZGUpO1xyXG4gICAgaWYgKCFub2RlIHx8IG5vZGUuX2NvbmZpZ3VyZWQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB2YXIgZWxlbUhhbmRsZXIgPSBub2RlLl9jb25maWd1cmVkO1xyXG4gICAgdmFyIGtleSA9IHRoaXMuYXNwZWN0ICsgXCJfXCIgKyB0aGlzLmNhbnZhc0lkO1xyXG4gICAgdmFyIGFkYXB0ZXIgPSBlbGVtSGFuZGxlci5hZGFwdGVyc1trZXldO1xyXG4gICAgaWYgKGFkYXB0ZXIgIT09IHVuZGVmaW5lZClcclxuICAgICAgICByZXR1cm4gYWRhcHRlcjtcclxuXHJcbiAgICAvLyBObyBhZGFwdGVyIGZvdW5kLCB0cnkgdG8gY3JlYXRlIG9uZVxyXG4gICAgYWRhcHRlciA9IHRoaXMuY3JlYXRlQWRhcHRlcihub2RlKTtcclxuICAgIGlmIChhZGFwdGVyKSB7XHJcbiAgICAgICAgZWxlbUhhbmRsZXIuYWRhcHRlcnNba2V5XSA9IGFkYXB0ZXI7XHJcbiAgICAgICAgYWRhcHRlci5pbml0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWRhcHRlcjtcclxufTtcclxuXHJcblhNTDNELnJlc291cmNlLkFkYXB0ZXJGYWN0b3J5ID0gQWRhcHRlckZhY3Rvcnk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuTm9kZUFkYXB0ZXIgOiBOb2RlQWRhcHRlcixcclxuQWRhcHRlckZhY3RvcnkgOiBBZGFwdGVyRmFjdG9yeSxcclxuTm9kZUFkYXB0ZXJGYWN0b3J5IDogTm9kZUFkYXB0ZXJGYWN0b3J5XHJcbn07XHJcbiIsInZhciBFdmVudHMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL25vdGlmaWNhdGlvbi5qc1wiKTtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogQW4gYWRhcHRlciBoYW5kbGUgaXMgYSBjb25uZWN0aW9uIHBpZWNlIGZvciBhbiBhZGFwdGVyIHRoYXQgaXMgcmVmZXJyZWQgdGhyb3VnaCBhIHVyaSAoZS5nLiBpZCByZWZlcmVuY2UpXHJcbiAqIEFkYXB0ZXJIYW5kbGVzIGFyZSBhbHdheXMgZmV0Y2hlZCBmcm9tIHRoZSBSZXNvdXJjZSBvYmplY3RcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgQWRhcHRlckhhbmRsZSA9IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICB0aGlzLmFkYXB0ZXIgPSBudWxsO1xyXG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcclxuICAgIHRoaXMuc3RhdHVzID0gMDsgLy8gU1RBVFVTLkxPQURJTkdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbnVtYWVyYXRpb24gb2Ygc3RhdGVzIGZvciB0aGUgYWRhcHRlciBoYW5kbGVcclxuICogQGVudW0ge251bWJlcn1cclxuICovXHJcbkFkYXB0ZXJIYW5kbGUuU1RBVFVTID0ge1xyXG4gICAgTE9BRElORzogMCxcclxuICAgIE5PVF9GT1VORDogMSxcclxuICAgIFJFQURZOiAyXHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWZmIGFuIGFkYXB0ZXIgaXMgYXZhaWxhYmxlXHJcbiAqL1xyXG5BZGFwdGVySGFuZGxlLnByb3RvdHlwZS5oYXNBZGFwdGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyICE9IG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMgez9YTUwzRC5iYXNlLkFkYXB0ZXJ9IHRoZSBhZGFwdGVyIGNvbm5lY3RlZCB0byB0aGUgaGFuZGxlLiBDYW4gYmUgbnVsbFxyXG4gKi9cclxuQWRhcHRlckhhbmRsZS5wcm90b3R5cGUuZ2V0QWRhcHRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBieSBSZXNvdXJjZVxyXG4gKiBAcGFyYW0ge1hNTDNELmJhc2UuQWRhcHRlcn0gYWRhcHRlciBUaGUgYWRhcHRlciBjb25uZWN0ZWQgdG8gdGhlIEFkYXB0ZXJIYW5kbGVyXHJcbiAqIEBwYXJhbSB7QWRhcHRlckhhbmRsZS5TVEFUVVN9IHN0YXR1c1xyXG4gKi9cclxuQWRhcHRlckhhbmRsZS5wcm90b3R5cGUuc2V0QWRhcHRlciA9IGZ1bmN0aW9uKGFkYXB0ZXIsIHN0YXR1cykge1xyXG4gICAgdGhpcy5hZGFwdGVyID0gYWRhcHRlcjtcclxuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xyXG4gICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoRXZlbnRzLkFEQVBURVJfSEFORExFX0NIQU5HRUQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIG5vdGlmeSBhbGwgbGlzdGVuZXJzIG9mIHRoaXMgQWRhcHRlckhhbmRsZSBhYm91dCBzb21lIGNoYW5nZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgQSB0eXBlIG51bWJlciB3aXRoIHRoZSB0eXBlIG9mIGNoYW5nZSAodXN1YWxseSBFdmVudHMuQURBUFRFUl9IQU5ETEVfQ0hBTkdFRClcclxuICovXHJcbkFkYXB0ZXJIYW5kbGUucHJvdG90eXBlLm5vdGlmeUxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIHZhciBldmVudCA9IG5ldyBFdmVudHMuQWRhcHRlckhhbmRsZU5vdGlmaWNhdGlvbih0aGlzLCB0eXBlKTtcclxuICAgIHZhciBpID0gdGhpcy5saXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2ldKGV2ZW50KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgYSBsaXN0ZW5lciB0byB0aGUgQWRhcHRlckhhbmRsZSB0aGF0IGlzIG5vdGlmaWVkIGFib3V0IGNoYW5nZXMuXHJcbiAqIExpc3RlbmVycyBjYW5ub3QgYmUgaW5zZXJ0ZWQgdHdpY2UuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gc29tZXRoaW5nIGNvbmNlcmluZyB0aGUgYWRhcHRlciBjaGFuZ2VzXHJcbiAqL1xyXG5BZGFwdGVySGFuZGxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XHJcbiAgICB2YXIgaWR4ID0gdGhpcy5saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICBpZiAoaWR4ID09IC0xKVxyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhIGxpc3RlbmVyIGZyb20gdGhlIEFkYXB0ZXJIYW5kbGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcclxuICovXHJcbkFkYXB0ZXJIYW5kbGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcclxuICAgIHZhciBpZHggPSB0aGlzLmxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgIGlmIChpZHggIT0gLTEpXHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkYXB0ZXJIYW5kbGU7IiwidmFyIEFkYXB0ZXJGYWN0b3J5ID0gcmVxdWlyZShcIi4vYWRhcHRlci5qc1wiKS5BZGFwdGVyRmFjdG9yeTtcclxudmFyIHJlZ2lzdGVyRm9ybWF0ID0gcmVxdWlyZShcIi4vcmVzb3VyY2VtYW5hZ2VyLmpzXCIpLnJlZ2lzdGVyRm9ybWF0O1xyXG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9lbGVtZW50cy5qc1wiKS5jb25maWc7XHJcblxyXG4vKipcclxuICogQSBmb3JtYXQgaGFuZGxlciBpcyBwcm92aWRlIGZ1bmN0aW9uYWxpdHkgZm9yIGRldGVjdGluZyBmb3JtYXQgb2YgcmVzb3VyY2VzXHJcbiAqIGFuZCBwcm92aWRpbmcgZm9ybWF0LXNwZWNpZmljIHNlcnZpY2VzLlxyXG4gKiBGb3JtYXRIYW5kbGVycyBhcmUgcmVnaXN0ZXJlZCB3aXRoIFhNTDNELmJhc2UucmVnaXN0ZXJGb3JtYXQoKSBmdW5jdGlvbi5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgRm9ybWF0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5mYWN0b3J5Q2xhc3NlcyA9IHt9OyAvLyBhIG1hcCBmcm9tIGFuIGFzcGVjdCBuYW1lIHRvIGEgZmFjdG9yeSBjbGFzc1xyXG4gICAgdGhpcy5mYWN0b3J5Q2FjaGUgPSB7fTsgLy8gbWFwcyB1bmlxdWUga2V5cyAoYXNwZWN0ICsgXCJfXCIgKyBjYW52YXNJZCkgdG8gdGhlIGZhY3RvcnkgaW5zdGFuY2VcclxufTtcclxuXHJcbkZvcm1hdEhhbmRsZXIucHJvdG90eXBlLnJlZ2lzdGVyRmFjdG9yeUNsYXNzID0gZnVuY3Rpb24gKGZhY3RvcnlDbGFzcykge1xyXG4gICAgaWYgKCFmYWN0b3J5Q2xhc3MucHJvdG90eXBlLmFzcGVjdCB8fCAhWE1MM0QuaXNTdXBlcmNsYXNzT2YoQWRhcHRlckZhY3RvcnksIGZhY3RvcnlDbGFzcykpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFjdG9yeUNsYXNzIG11c3QgYmUgYSBzdWJjbGFzcyBvZiBYTUwzRC5iYXNlLkFkYXB0ZXJGYWN0b3J5XCIpO1xyXG4gICAgdGhpcy5mYWN0b3J5Q2xhc3Nlc1tmYWN0b3J5Q2xhc3MucHJvdG90eXBlLmFzcGVjdF0gPSBmYWN0b3J5Q2xhc3M7XHJcbn07XHJcblxyXG5Gb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRGYWN0b3J5Q2xhc3NCeUFzcGVjdCA9IGZ1bmN0aW9uIChhc3BlY3QpIHtcclxuICAgIHJldHVybiB0aGlzLmZhY3RvcnlDbGFzc2VzW2FzcGVjdF07XHJcbn07XHJcblxyXG5Gb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRGYWN0b3J5ID0gZnVuY3Rpb24gKGFzcGVjdCwgY2FudmFzSWQpIHtcclxuICAgIGNhbnZhc0lkID0gY2FudmFzSWQgfHwgMDtcclxuICAgIHZhciBrZXkgPSBhc3BlY3QgKyBcIl9cIiArIGNhbnZhc0lkO1xyXG4gICAgdmFyIGZhY3RvcnkgPSB0aGlzLmZhY3RvcnlDYWNoZVtrZXldO1xyXG4gICAgaWYgKCFmYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIGZhY3RvcnlDbGFzcyA9IHRoaXMuZ2V0RmFjdG9yeUNsYXNzQnlBc3BlY3QoYXNwZWN0KTtcclxuICAgICAgICBpZiAoIWZhY3RvcnlDbGFzcylcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgZmFjdG9yeSA9IG5ldyBmYWN0b3J5Q2xhc3MoY2FudmFzSWQpO1xyXG4gICAgICAgIHRoaXMuZmFjdG9yeUNhY2hlW2tleV0gPSBmYWN0b3J5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhY3Rvcnk7XHJcbn07XHJcblxyXG4vL25vaW5zcGVjdGlvbiBKU1VudXNlZExvY2FsU3ltYm9sc1xyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHJlc3BvbnNlIGRhdGEgZm9ybWF0IGlzIHN1cHBvcnRlZC5cclxuICogcmVzcG9uc2UsIHJlc3BvbnNlVHlwZSwgYW5kIG1pbWV0eXBlIHZhbHVlcyBhcmUgcmV0dXJuZWQgYnkgWE1MSHR0cFJlcXVlc3QuXHJcbiAqIERhdGEgdHlwZSBvZiB0aGUgcmVzcG9uc2UgaXMgb25lIG9mIEFycmF5QnVmZmVyLCBCbG9iLCBEb2N1bWVudCwgU3RyaW5nLCBPYmplY3QuXHJcbiAqIHJlc3BvbnNlVHlwZSBpcyBvbmUgb2YgXCJcIiwgXCJhcnJheWJ1ZmZlclwiLCBcImJsb2JcIiwgXCJkb2N1bWVudFwiLCBcImpzb25cIiwgXCJ0ZXh0XCJcclxuICpcclxuICogQG92ZXJyaWRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2VUeXBlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtaW1ldHlwZVxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuRm9ybWF0SGFuZGxlci5wcm90b3R5cGUuaXNGb3JtYXRTdXBwb3J0ZWQgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHJlc3BvbnNlVHlwZSwgbWltZXR5cGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyByZXNwb25zZSBkYXRhIHRvIGZvcm1hdCBkYXRhLlxyXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdmFsdWUgb2YgcmVzcG9uc2UuXHJcbiAqXHJcbiAqIEBvdmVycmlkZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcclxuICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlVHlwZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbWltZXR5cGVcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKi9cclxuRm9ybWF0SGFuZGxlci5wcm90b3R5cGUuZ2V0Rm9ybWF0RGF0YSA9IGZ1bmN0aW9uIChyZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBtaW1ldHlwZSwgY2FsbGJhY2spIHtcclxuICAgIGNhbGxiYWNrKHRydWUsIHJlc3BvbnNlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBkYXRhIGZvciBhIGZyYWdtZW50IGZyb20gZG9jdW1lbnQgZGF0YSBhbmQgZnJhZ21lbnQgcmVmZXJlbmNlLlxyXG4gKlxyXG4gKiBAb3ZlcnJpZGVcclxuICogQHBhcmFtIHtPYmplY3R9IGRvY3VtZW50RGF0YVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZnJhZ21lbnQgRnJhZ21lbnQgd2l0aG91dCBwb3VuZCBrZXkgd2hpY2ggZGVmaW5lcyB0aGUgcGFydCBvZiB0aGUgZG9jdW1lbnRcclxuICogQHJldHVybiB7Kn1cclxuICovXHJcbkZvcm1hdEhhbmRsZXIucHJvdG90eXBlLmdldEZyYWdtZW50RGF0YSA9IGZ1bmN0aW9uIChkb2N1bWVudERhdGEsIGZyYWdtZW50KSB7XHJcbiAgICBpZiAoIWZyYWdtZW50KVxyXG4gICAgICAgIHJldHVybiBkb2N1bWVudERhdGE7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBYTUxGb3JtYXRIYW5kbGVyIHN1cHBvcnRzIGFsbCBYTUwgYW5kIEhUTUwtYmFzZWQgZG9jdW1lbnRzLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgRm9ybWF0SGFuZGxlclxyXG4gKi9cclxudmFyIFhNTEZvcm1hdEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBGb3JtYXRIYW5kbGVyLmNhbGwodGhpcyk7XHJcbn07XHJcblhNTDNELmNyZWF0ZUNsYXNzKFhNTEZvcm1hdEhhbmRsZXIsIEZvcm1hdEhhbmRsZXIpO1xyXG5cclxuWE1MRm9ybWF0SGFuZGxlci5wcm90b3R5cGUuaXNGb3JtYXRTdXBwb3J0ZWQgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHJlc3BvbnNlVHlwZSwgbWltZXR5cGUpIHtcclxuICAgIHJldHVybiByZXNwb25zZSAmJiByZXNwb25zZS5ub2RlVHlwZSA9PT0gOSAmJiAobWltZXR5cGUubWF0Y2goL3htbC8pKTtcclxufTtcclxuXHJcblhNTEZvcm1hdEhhbmRsZXIucHJvdG90eXBlLmdldEZvcm1hdERhdGEgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHJlc3BvbnNlVHlwZSwgbWltZXR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICBjYWxsYmFjayh0cnVlLCByZXNwb25zZSk7XHJcbn07XHJcblxyXG5YTUxGb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRGcmFnbWVudERhdGEgPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhLCBmcmFnbWVudCkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50RGF0YS5xdWVyeVNlbGVjdG9yQWxsKFwiKltpZD0nXCIgKyBmcmFnbWVudCArIFwiJ11cIilbMF07XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBGb3JtYXRIYW5kbGVyXHJcbiAqL1xyXG52YXIgWE1MM0RGb3JtYXRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgWE1MRm9ybWF0SGFuZGxlci5jYWxsKHRoaXMpO1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhYTUwzREZvcm1hdEhhbmRsZXIsIFhNTEZvcm1hdEhhbmRsZXIpO1xyXG5cclxuWE1MM0RGb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5pc0Zvcm1hdFN1cHBvcnRlZCA9IGZ1bmN0aW9uIChyZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBtaW1ldHlwZSkge1xyXG4gICAgdmFyIHhtbDNkcyA9IFtdO1xyXG4gICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgWE1MRG9jdW1lbnQpIHtcclxuICAgICAgICB4bWwzZHMgPSByZXNwb25zZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInhtbDNkXCIpO1xyXG4gICAgICAgIGlmICgheG1sM2RzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBBbHNvIGNoZWNrIGNhc2VzIHdoZXJlIHRoZSBYTUwzRCBlbGVtZW50IG1heSBoYXZlIGJlZW4gZml0dGVkIHdpdGggYSBOUyBwcmVmaXggKGVnLiBuczE6eG1sM2QpXHJcbiAgICAgICAgICAgIHhtbDNkcyA9IHJlc3BvbnNlLmdldEVsZW1lbnRzQnlUYWdOYW1lTlMoWE1MM0QueG1sM2ROUywgXCJ4bWwzZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4geG1sM2RzLmxlbmd0aCAhPT0gMDtcclxufTtcclxuXHJcblhNTDNERm9ybWF0SGFuZGxlci5wcm90b3R5cGUuZ2V0Rm9ybWF0RGF0YSA9IGZ1bmN0aW9uIChyZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBtaW1ldHlwZSwgY2FsbGJhY2spIHtcclxuICAgIC8vIENvbmZpZ3VyZSBhbGwgeG1sM2QgZWxlbWVudHM6XHJcbiAgICB2YXIgeG1sM2RFbGVtZW50cyA9IHJlc3BvbnNlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJ4bWwzZFwiKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeG1sM2RFbGVtZW50cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvbmZpZy5lbGVtZW50KHhtbDNkRWxlbWVudHNbaV0pO1xyXG4gICAgfVxyXG4gICAgY2FsbGJhY2sodHJ1ZSwgcmVzcG9uc2UpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBGb3JtYXRIYW5kbGVyXHJcbiAqL1xyXG52YXIgSlNPTkZvcm1hdEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBGb3JtYXRIYW5kbGVyLmNhbGwodGhpcyk7XHJcbn07XHJcblhNTDNELmNyZWF0ZUNsYXNzKEpTT05Gb3JtYXRIYW5kbGVyLCBGb3JtYXRIYW5kbGVyKTtcclxuXHJcbkpTT05Gb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5pc0Zvcm1hdFN1cHBvcnRlZCA9IGZ1bmN0aW9uIChyZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBtaW1ldHlwZSkge1xyXG4gICAgcmV0dXJuIG1pbWV0eXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIjtcclxufTtcclxuXHJcbnZhciB4bWwzZEZvcm1hdEhhbmRsZXIgPSBuZXcgWE1MM0RGb3JtYXRIYW5kbGVyKCk7XHJcbnJlZ2lzdGVyRm9ybWF0KHhtbDNkRm9ybWF0SGFuZGxlcik7XHJcblhNTDNELnhtbDNkRm9ybWF0SGFuZGxlciA9IHhtbDNkRm9ybWF0SGFuZGxlcjtcclxuWE1MM0QucmVzb3VyY2UuRm9ybWF0SGFuZGxlciA9IEZvcm1hdEhhbmRsZXI7XHJcblhNTDNELnJlc291cmNlLkpTT05Gb3JtYXRIYW5kbGVyID0gSlNPTkZvcm1hdEhhbmRsZXI7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEpTT05Gb3JtYXRIYW5kbGVyOiBKU09ORm9ybWF0SGFuZGxlcixcclxuICAgIFhNTEZvcm1hdEhhbmRsZXI6IFhNTEZvcm1hdEhhbmRsZXIsXHJcbiAgICBYTUwzREZvcm1hdEhhbmRsZXI6IFhNTDNERm9ybWF0SGFuZGxlcixcclxuICAgIEZvcm1hdEhhbmRsZXI6IEZvcm1hdEhhbmRsZXIsXHJcbiAgICB4bWwzZEZvcm1hdEhhbmRsZXI6IHhtbDNkRm9ybWF0SGFuZGxlclxyXG59OyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIEFkYXB0ZXJIYW5kbGUgPSByZXF1aXJlKFwiLi9hZGFwdGVyaGFuZGxlLmpzXCIpO1xyXG52YXIgVVJJUmVzb2x2ZXIgPSByZXF1aXJlKFwiLi4vdXRpbHMvdXJpLmpzXCIpLlVSSVJlc29sdmVyO1xyXG52YXIgVVJJID0gcmVxdWlyZShcIi4uL3V0aWxzL3VyaS5qc1wiKS5VUkk7XHJcbnZhciBPcHRpb25zID0gcmVxdWlyZShcIi4uL3V0aWxzL29wdGlvbnMuanNcIik7XHJcblxyXG52YXIgT1BUSU9OX1JFU09VUkNFX0NPUlMgPSBcInJlc291cmNlLWNyb3Nzb3JpZ2luLWF0dHJpYnV0ZVwiO1xyXG5PcHRpb25zLnJlZ2lzdGVyKE9QVElPTl9SRVNPVVJDRV9DT1JTLCBcImFub255bW91c1wiKTtcclxuXHJcbnZhciBjX2NhY2hlZERvY3VtZW50cyA9IHt9O1xyXG52YXIgY19mYWN0b3JpZXMgPSB7fTtcclxudmFyIGNfY2FjaGVkQWRhcHRlckhhbmRsZXMgPSB7fTtcclxudmFyIGNfY2FudmFzSWRDb3VudGVycyA9IHt9O1xyXG52YXIgY19mb3JtYXRIYW5kbGVycyA9IFtdO1xyXG5cclxudmFyIGNfYmluYXJ5Q29udGVudFR5cGVzID0gW1wiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsIFwidGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZFwiXTtcclxudmFyIGNfYmluYXJ5RXh0ZW5zaW9ucyA9IFtcIi5iaW5cIiwgXCIuYnNvblwiXTtcclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlciBhIGZhY3Rvcnkgd2l0aCB0aGUgcmVzb3VyY2UgbWFuYWdlclxyXG4gKiBAcGFyYW0ge0FkYXB0ZXJGYWN0b3J5fSBmYWN0b3J5IC0gdGhlIGZhY3RvcnkgdG8gYmUgcmVnaXN0ZXJlZFxyXG4gKi9cclxudmFyIHJlZ2lzdGVyRmFjdG9yeSA9IGZ1bmN0aW9uKGZhY3RvcnkpIHtcclxuICAgIHZhciBjYW52YXNJZCA9IGZhY3RvcnkuY2FudmFzSWQ7XHJcbiAgICBpZiAoIWNfZmFjdG9yaWVzW2NhbnZhc0lkXSlcclxuICAgICAgICBjX2ZhY3Rvcmllc1tjYW52YXNJZF0gPSBbXTtcclxuICAgIGNfZmFjdG9yaWVzW2NhbnZhc0lkXS5wdXNoKGZhY3RvcnkpO1xyXG59O1xyXG5cclxudmFyIHJlZ2lzdGVyRm9ybWF0ID0gZnVuY3Rpb24oZm9ybWF0SGFuZGxlcikge1xyXG4gICAgaWYgKGZvcm1hdEhhbmRsZXIpXHJcbiAgICAgICAgY19mb3JtYXRIYW5kbGVycy5wdXNoKGZvcm1hdEhhbmRsZXIpO1xyXG59O1xyXG5cclxudmFyIGZpbmRGb3JtYXQgPSBmdW5jdGlvbihyZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBtaW1ldHlwZSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjX2Zvcm1hdEhhbmRsZXJzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGZvcm1hdEhhbmRsZXIgPSBjX2Zvcm1hdEhhbmRsZXJzW2ldO1xyXG4gICAgICAgIGlmIChjX2Zvcm1hdEhhbmRsZXJzW2ldLmlzRm9ybWF0U3VwcG9ydGVkKHJlc3BvbnNlLCByZXNwb25zZVR5cGUsIG1pbWV0eXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0SGFuZGxlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBSZXNvdXJjZSA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZ2V0Q291bnRlck9iamVjdChjYW52YXNJZCkge1xyXG4gICAgcmV0dXJuIGNfY2FudmFzSWRDb3VudGVyc1tjYW52YXNJZF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE9yQ3JlYXRlQ291bnRlck9iamVjdChjYW52YXNJZCkge1xyXG4gICAgdmFyIGNvdW50ZXJPYmplY3QgPSBjX2NhbnZhc0lkQ291bnRlcnNbY2FudmFzSWRdO1xyXG4gICAgaWYgKCFjb3VudGVyT2JqZWN0KSB7XHJcbiAgICAgICAgY291bnRlck9iamVjdCA9IHtjb3VudGVyOiAwLCBsaXN0ZW5lcnM6IFtdfTtcclxuICAgICAgICBjX2NhbnZhc0lkQ291bnRlcnNbY2FudmFzSWRdID0gY291bnRlck9iamVjdDtcclxuICAgIH1cclxuICAgIHJldHVybiBjb3VudGVyT2JqZWN0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBub3RpZnlMb2FkQ29tcGxldGVMaXN0ZW5lcnMoY291bnRlck9iamVjdCkge1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IGNvdW50ZXJPYmplY3QubGlzdGVuZXJzO1xyXG4gICAgLy9jb3VudGVyT2JqZWN0Lmxpc3RlbmVycyA9IG5ldyBBcnJheSgpO1xyXG4gICAgdmFyIGkgPSBsaXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGxpc3RlbmVyc1tpXSh0aGlzKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbG9hZENvbXBsZXRlKGNhbnZhc0lkKSB7XHJcbiAgICAvLyBub3RpZnkgYWxsIGxvYWQgY29tcGxldGUgbGlzdGVuZXJzXHJcbiAgICB2YXIgY291bnRlck9iamVjdCA9IGdldENvdW50ZXJPYmplY3QoY2FudmFzSWQpO1xyXG4gICAgaWYgKGNvdW50ZXJPYmplY3QpIHtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5hc3NlcnQoY291bnRlck9iamVjdC5jb3VudGVyID4gMCwgXCJjb3VudGVyIG11c3QgYmUgPiAwXCIpO1xyXG4gICAgICAgIGNvdW50ZXJPYmplY3QuY291bnRlci0tO1xyXG4gICAgICAgIGlmIChjb3VudGVyT2JqZWN0LmNvdW50ZXIgPT0gMCkge1xyXG4gICAgICAgICAgICBub3RpZnlMb2FkQ29tcGxldGVMaXN0ZW5lcnMoY291bnRlck9iamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5SZXNvdXJjZS5pc0xvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uKGNhbnZhc0lkKSB7XHJcbiAgICB2YXIgY291bnRlck9iamVjdCA9IGdldENvdW50ZXJPYmplY3QoY2FudmFzSWQpO1xyXG4gICAgcmV0dXJuICFjb3VudGVyT2JqZWN0IHx8IGNvdW50ZXJPYmplY3QuY291bnRlciA9PSAwO1xyXG59O1xyXG5cclxuLypcclxuICogUmVnaXN0ZXIgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYWxsIHJlc291cmNlcyBmb3Igc3BlY2lmaWVkIGNhbnZhc0lkIGFyZSBsb2FkZWQuXHJcbiAqIExpc3RlbmVyIGlzIGZpcmVkIG9ubHkgb25jZS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGNhbnZhc0lkXHJcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gbGlzdGVuZXJcclxuICovXHJcblJlc291cmNlLmFkZExvYWRDb21wbGV0ZUxpc3RlbmVyID0gZnVuY3Rpb24oY2FudmFzSWQsIGxpc3RlbmVyKSB7XHJcbiAgICB2YXIgY291bnRlck9iamVjdCA9IGdldE9yQ3JlYXRlQ291bnRlck9iamVjdChjYW52YXNJZCk7XHJcblxyXG4gICAgLypcclxuICAgIGlmIChjb3VudGVyT2JqZWN0ID09PSB1bmRlZmluZWQgfHwgY291bnRlck9iamVjdC5jb3VudGVyID09IDApIHtcclxuICAgICAgICBsaXN0ZW5lcihjYW52YXNJZCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgKi9cclxuXHJcbiAgICB2YXIgaWR4ID0gY291bnRlck9iamVjdC5saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICBpZiAoaWR4ID09IC0xKSB7XHJcbiAgICAgICAgY291bnRlck9iamVjdC5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vL25vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNJZFxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lclxyXG4gKi9cclxuUmVzb3VyY2UucmVtb3ZlTG9hZENvbXBsZXRlTGlzdGVuZXIgPSBmdW5jdGlvbihjYW52YXNJZCwgbGlzdGVuZXIpIHtcclxuICAgIHZhciBjb3VudGVyT2JqZWN0ID0gZ2V0Q291bnRlck9iamVjdChjYW52YXNJZCk7XHJcbiAgICBpZiAoY291bnRlck9iamVjdCkge1xyXG4gICAgICAgIHZhciBpZHggPSBjb3VudGVyT2JqZWN0Lmxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgICAgICBpZiAoaWR4ICE9IC0xKVxyXG4gICAgICAgICAgICBjb3VudGVyT2JqZWN0Lmxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBzdHJpbmdFbmRzV2l0aFN1ZmZpeChzdHIsIHN1ZmZpeCkge1xyXG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHN1ZmZpeCwgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcclxufVxyXG5cclxuLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXHJcblJlc291cmNlLmFkZEJpbmFyeUNvbnRlbnRUeXBlID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgaWYgKGNfYmluYXJ5Q29udGVudFR5cGVzLmluZGV4T2YodHlwZSkgPT0gLTEpXHJcbiAgICAgICAgY19iaW5hcnlDb250ZW50VHlwZXMucHVzaCh0eXBlKTtcclxufTtcclxuXHJcbi8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xyXG5SZXNvdXJjZS5yZW1vdmVCaW5hcnlDb250ZW50VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIHZhciBpZHggPSBjX2JpbmFyeUNvbnRlbnRUeXBlcy5pbmRleE9mKHR5cGUpO1xyXG4gICAgaWYgKGlkeCAhPSAtMSlcclxuICAgICAgICBjX2JpbmFyeUNvbnRlbnRUeXBlcy5zcGxpY2UoaWR4LCAxKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGlzQmluYXJ5Q29udGVudFR5cGUoY29udGVudFR5cGUpIHtcclxuICAgIGZvciAodmFyIGkgaW4gY19iaW5hcnlDb250ZW50VHlwZXMpIHtcclxuICAgICAgICBpZiAoY29udGVudFR5cGUgPT0gY19iaW5hcnlDb250ZW50VHlwZXNbaV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5SZXNvdXJjZS5hZGRCaW5hcnlFeHRlbnNpb24gPSBmdW5jdGlvbihleHRlbnNpb24pIHtcclxuICAgIGlmIChjX2JpbmFyeUV4dGVuc2lvbnMuaW5kZXhPZihleHRlbnNpb24pID09IC0xKVxyXG4gICAgICAgIGNfYmluYXJ5RXh0ZW5zaW9ucy5wdXNoKGV4dGVuc2lvbik7XHJcbn07XHJcblxyXG4vL25vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcclxuUmVzb3VyY2UucmVtb3ZlQmluYXJ5RXh0ZW5zaW9uID0gZnVuY3Rpb24oZXh0ZW5zaW9uKSB7XHJcbiAgICB2YXIgaWR4ID0gY19iaW5hcnlFeHRlbnNpb25zLmluZGV4T2YoZXh0ZW5zaW9uKTtcclxuICAgIGlmIChpZHggIT0gLTEpXHJcbiAgICAgICAgY19iaW5hcnlFeHRlbnNpb25zLnNwbGljZShpZHgsIDEpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gaXNCaW5hcnlFeHRlbnNpb24odXJsKSB7XHJcbiAgICBmb3IgKHZhciBpIGluIGNfYmluYXJ5RXh0ZW5zaW9ucykge1xyXG4gICAgICAgIGlmIChzdHJpbmdFbmRzV2l0aFN1ZmZpeCh1cmwsIGNfYmluYXJ5RXh0ZW5zaW9uc1tpXSkpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogTG9hZCBhIGRvY3VtZW50IHZpYSBYTUxIdHRwUmVxdWVzdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCBvZiB0aGUgZG9jdW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGxvYWREb2N1bWVudCh1cmwpIHtcclxuICAgIHZhciB4bWxIdHRwID0gbnVsbDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgeG1sSHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHhtbEh0dHAgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKHhtbEh0dHApIHtcclxuICAgICAgICB4bWxIdHRwLl91cmwgPSB1cmw7XHJcbiAgICAgICAgeG1sSHR0cC5fY29udGVudENoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICB4bWxIdHRwLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGlzQmluYXJ5RXh0ZW5zaW9uKHVybCkpXHJcbiAgICAgICAgICAgIHhtbEh0dHAucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG5cclxuICAgICAgICB4bWxIdHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoeG1sSHR0cC5fYWJvcnRlZCkgLy8gVGhpcyBjaGVjayBpcyBwb3NzaWJseSBub3QgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGNvbXBhdGliaWxpdHkgYmV0d2VlbiBjb250ZW50IGFuZCByZXF1ZXN0IG1vZGVcclxuICAgICAgICAgICAgaWYgKCF4bWxIdHRwLl9jb250ZW50Q2hlY2tlZCAmJlxyXG4gICAgICAgICAgICAgICAgLy8gMiAtIEhFQURFUlNfUkVDRUlWRUQsIDMgLSBMT0FESU5HLCA0IC0gRE9ORVxyXG4gICAgICAgICAgICAgICAgKCh4bWxIdHRwLnJlYWR5U3RhdGUgPT0gMiB8fCB4bWxIdHRwLnJlYWR5U3RhdGUgPT0gMyB8fCB4bWxIdHRwLnJlYWR5U3RhdGUgPT0gNCkgJiZcclxuICAgICAgICAgICAgICAgICAgICB4bWxIdHRwLnN0YXR1cyA9PSAyMDApKSB7XHJcbiAgICAgICAgICAgICAgICB4bWxIdHRwLl9jb250ZW50Q2hlY2tlZCA9IHRydWU7IC8vIHdlIGNoZWNrIG9ubHkgb25jZVxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBjaGFuZ2UgcmVxdWVzdCBtb2RlXHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSB4bWxIdHRwLmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmFyeUNvbnRlbnQgPSBpc0JpbmFyeUNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmluYXJ5UmVxdWVzdCA9ICh4bWxIdHRwLnJlc3BvbnNlVHlwZSA9PSBcImFycmF5YnVmZmVyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gY29udGVudCBpcyBub3QgdGhlIHNhbWUgYXMgcmVxdWVzdCwgd2UgbmVlZCB0byByZXBlYXQgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlDb250ZW50ICE9IGJpbmFyeVJlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cC5fYWJvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IHhtbEh0dHAub25yZWFkeXN0YXRlY2hhbmdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxIdHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSB4bWxIdHRwLl91cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdlIGRvIG5vdCByZWN5Y2xlIFhNTEh0dHBSZXF1ZXN0ICFcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgVGhpcyBkb2VzIHdvcmsgb25seSB3aGVuIHJlc3BvbnNlVHlwZSBpcyBjaGFuZ2VkIHRvIFwiYXJyYXlidWZmZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgaG93ZXZlciB0aGUgc2l6ZSBvZiB0aGUgeG1sSHR0cC5yZXNwb25zZSBidWZmZXIgaXMgdGhlbiB3cm9uZyAhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIEl0IGRvZXMgbm90IHdvcmsgYXQgYWxsIChhdCBsZWFzdCBpbiBDaHJvbWUpIHdoZW4gd2UgdXNlIG92ZXJyaWRlTWltZVR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgd2l0aCBcInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWRcIiBhcmd1bWVudC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgVGhlIGxhdHRlciBtb2RlIHJlcXVpcmUgY3JlYXRpb24gb2YgdGhlIGZyZXNoIFhNTEh0dHBSZXF1ZXN0LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxIdHRwLl91cmwgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAuX2NvbnRlbnRDaGVja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cC5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmluYXJ5Q29udGVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxIdHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGNiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxIdHRwLnNlbmQobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmVxdWVzdCBtb2RlIGFuZCBjb250ZW50IHR5cGUgYXJlIGNvbXBhdGlibGUgaGVyZSAoYm90aCBiaW5hcnkgb3IgYm90aCB0ZXh0KVxyXG4gICAgICAgICAgICBpZiAoeG1sSHR0cC5yZWFkeVN0YXRlID09IDQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh4bWxIdHRwLnN0YXR1cyA9PSAyMDApIHtcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIkxvYWRlZDogXCIgKyB4bWxIdHRwLl91cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELnhtbEh0dHBDYWxsYmFjayAmJiBYTUwzRC54bWxIdHRwQ2FsbGJhY2soeG1sSHR0cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlKHhtbEh0dHApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJDb3VsZCBub3QgbG9hZCBleHRlcm5hbCBkb2N1bWVudCAnXCIgKyB4bWxIdHRwLl91cmwgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIic6IFwiICsgeG1sSHR0cC5zdGF0dXMgKyBcIiAtIFwiICsgeG1sSHR0cC5zdGF0dXNUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlRG9jdW1lbnRIYW5kbGVzKHhtbEh0dHAuX3VybCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHhtbEh0dHAuc2VuZChudWxsKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUHJvY2VzcyByZXNwb25zZSBvZiBhamF4IHJlcXVlc3QgZnJvbSBsb2FkRG9jdW1lbnQoKVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fSBodHRwUmVxdWVzdFxyXG4gKi9cclxuZnVuY3Rpb24gcHJvY2Vzc1Jlc3BvbnNlKGh0dHBSZXF1ZXN0KSB7XHJcbiAgICB2YXIgbWltZXR5cGUgPSBodHRwUmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcihcImNvbnRlbnQtdHlwZVwiKTtcclxuICAgIGlmICghbWltZXR5cGUpIHtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBsb2FkIGV4dGVybmFsIGRvY3VtZW50IGJlY2F1c2UgdGhlIHNlcnZlciBkaWQgbm90IHByb3ZpZGUgYSBjb250ZW50LXR5cGUgaGVhZGVyOiBcIitodHRwUmVxdWVzdC5fdXJsKTtcclxuICAgICAgICBpbnZhbGlkYXRlRG9jdW1lbnRIYW5kbGVzKGh0dHBSZXF1ZXN0Ll91cmwpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHNldERvY3VtZW50RGF0YShodHRwUmVxdWVzdCwgaHR0cFJlcXVlc3QuX3VybCwgbWltZXR5cGUpO1xyXG59XHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGRhdGEgb2YgYSByZWNlaXZlZCBkb2N1bWVudFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fSBodHRwUmVxdWVzdCBUaGUgWE1MSHR0cFJlcXVlc3Qgb2YgdGhlIGxvYWRlZCBkb2N1bWVudFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCBvZiB0aGUgbG9hZGVkIGRvY3VtZW50XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtaW1ldHlwZSBUaGUgbWltZXR5cGUgb2YgdGhlIGxvYWRlZCBkb2N1bWVudFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0RG9jdW1lbnREYXRhKGh0dHBSZXF1ZXN0LCB1cmwsIG1pbWV0eXBlKSB7XHJcbiAgICB2YXIgZG9jQ2FjaGUgPSBjX2NhY2hlZERvY3VtZW50c1t1cmxdO1xyXG4gICAgZG9jQ2FjaGUubWltZXR5cGUgPSBtaW1ldHlwZTtcclxuXHJcbiAgICB2YXIgY2xlYW5lZE1pbWV0eXBlID0gbWltZXR5cGU7XHJcblxyXG4gICAgaWYgKG1pbWV0eXBlLmluZGV4T2YoJzsnKSA+IDApXHJcbiAgICAgICAgY2xlYW5lZE1pbWV0eXBlID0gbWltZXR5cGUuc3Vic3RyKDAsIG1pbWV0eXBlLmluZGV4T2YoJzsnKSk7XHJcblxyXG4gICAgdmFyIHJlc3BvbnNlID0gbnVsbDtcclxuICAgIGlmIChodHRwUmVxdWVzdC5yZXNwb25zZVR5cGUgPT0gXCJhcnJheWJ1ZmZlclwiKSB7XHJcbiAgICAgICAgcmVzcG9uc2UgPSBodHRwUmVxdWVzdC5yZXNwb25zZTtcclxuICAgIH0gZWxzZSBpZiAoY2xlYW5lZE1pbWV0eXBlID09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XHJcbiAgICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKGh0dHBSZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XHJcbiAgICB9IGVsc2UgaWYgKGNsZWFuZWRNaW1ldHlwZS5tYXRjaCgveG1sLykpIHtcclxuICAgICAgICByZXNwb25zZSA9IGh0dHBSZXF1ZXN0LnJlc3BvbnNlWE1MO1xyXG4gICAgICAgIC8vV29ya2Fyb3VuZCBmb3IgSUUgXCJidWdcIiB3aGVyZSBleHRlcm5hbCBkb2N1bWVudHMgYWx3YXlzIHJlcG9ydCB0aGVpciBkb2N1bWVudC5VUkwgYXMgYmVpbmcgaWRlbnRpY2FsIHRvIHdpbmRvdy5sb2NhdGlvbi5ocmVmXHJcbiAgICAgICAgcmVzcG9uc2UuX2RvY3VtZW50VVJMID0gdXJsO1xyXG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbnZhbGlkIGV4dGVybmFsIFhNTCBkb2N1bWVudCAnXCIgKyBodHRwUmVxdWVzdC5fdXJsICtcclxuICAgICAgICAgICAgICAgIFwiJzogWE1MIFN5bnRheCBlcnJvclwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoY2xlYW5lZE1pbWV0eXBlID09IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgfHwgbWltZXR5cGUgPT0gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkXCIpIHtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlBvc3NpYmx5IHdyb25nIGxvYWRpbmcgb2YgcmVzb3VyY2UgXCIgKyB1cmwgKyBcIi4gTWltZXR5cGUgaXMgXCIgKyBtaW1ldHlwZSArIFwiIGJ1dCByZXNwb25zZSBpcyBub3QgYW4gQXJyYXlCdWZmZXJcIik7XHJcbiAgICAgICAgcmVzcG9uc2UgPSBodHRwUmVxdWVzdC5yZXNwb25zZTtcclxuICAgIH0gZWxzZSBpZiAoY2xlYW5lZE1pbWV0eXBlID09IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiIHx8IG1pbWV0eXBlID09IFwidGV4dC9qYXZhc2NyaXB0XCIpIHtcclxuICAgICAgICByZXNwb25zZSA9IGh0dHBSZXF1ZXN0LnJlc3BvbnNlO1xyXG4gICAgfWVsc2Uge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiVW5pZGVudGlmaWVkIHJlc3BvbnNlIHR5cGUgKHJlc3BvbnNlID0gJ1wiICsgaHR0cFJlcXVlc3QucmVzcG9uc2UgKyBcIicsIHJlc3BvbnNlVHlwZSA9ICdcIiArIGh0dHBSZXF1ZXN0LnJlc3BvbnNlVHlwZSArIFwiJylcIik7XHJcbiAgICAgICAgcmVzcG9uc2UgPSBodHRwUmVxdWVzdC5yZXNwb25zZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZm9ybWF0SGFuZGxlciA9IGZpbmRGb3JtYXQocmVzcG9uc2UsIGh0dHBSZXF1ZXN0LnJlc3BvbnNlVHlwZSwgY2xlYW5lZE1pbWV0eXBlKTtcclxuICAgIGlmICghZm9ybWF0SGFuZGxlcikge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiTm8gZm9ybWF0IGhhbmRsZXIgZm9yIHJlc291cmNlIChyZXNwb25zZSA9ICdcIiArIHJlc3BvbnNlICsgXCInLCByZXNwb25zZVR5cGUgPSAnXCIgKyBodHRwUmVxdWVzdC5yZXNwb25zZVR5cGUgKyBcIicpXCIpO1xyXG4gICAgICAgIGludmFsaWRhdGVEb2N1bWVudEhhbmRsZXModXJsKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBkb2NDYWNoZS5mb3JtYXQgPSBmb3JtYXRIYW5kbGVyO1xyXG4gICAgZm9ybWF0SGFuZGxlci5nZXRGb3JtYXREYXRhKHJlc3BvbnNlLCBodHRwUmVxdWVzdC5yZXNwb25zZVR5cGUsIGNsZWFuZWRNaW1ldHlwZSwgZnVuY3Rpb24oc3VjY2VzcywgcmVzdWx0KXtcclxuICAgICAgICBpZihzdWNjZXNzKXtcclxuICAgICAgICAgICAgZG9jQ2FjaGUucmVzcG9uc2UgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIHVwZGF0ZURvY3VtZW50SGFuZGxlcyh1cmwpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGludmFsaWRhdGVEb2N1bWVudEhhbmRsZXModXJsKTtcclxuICAgICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIGFsbCBleGlzdGluZyBoYW5kbGVzIG9mIGEgcmVjZWl2ZWQgZG9jdW1lbnRcclxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIG9mIHRoZSBkb2N1bWVudFxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlRG9jdW1lbnRIYW5kbGVzKHVybCkge1xyXG4gICAgdmFyIGRvY0NhY2hlID0gY19jYWNoZWREb2N1bWVudHNbdXJsXTtcclxuICAgIHZhciBmcmFnbWVudHMgPSBkb2NDYWNoZS5mcmFnbWVudHM7XHJcbiAgICBkb2NDYWNoZS5mcmFnbWVudHMgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdXBkYXRlRXh0ZXJuYWxIYW5kbGVzKHVybCwgZnJhZ21lbnRzW2ldKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEludmFsaWRhdGUgYWxsIGhhbmRsZXMgb2YgYSBkb2N1bWVudCwgdGhhdCBjb3VsZCBub3QgYmUgbG9hZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgb2YgdGhlIGRvY3VtZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpbnZhbGlkYXRlRG9jdW1lbnRIYW5kbGVzKHVybCkge1xyXG4gICAgdmFyIGRvY0NhY2hlID0gY19jYWNoZWREb2N1bWVudHNbdXJsXTtcclxuICAgIHZhciBmcmFnbWVudHMgPSBkb2NDYWNoZS5mcmFnbWVudHM7XHJcbiAgICBkb2NDYWNoZS5mcmFnbWVudHMgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGZ1bGxVcmwgPSB1cmwgKyAoZnJhZ21lbnRzW2ldID8gXCIjXCIgKyBmcmFnbWVudHNbaV0gOiBcIlwiKTtcclxuICAgICAgICBpbnZhbGlkYXRlSGFuZGxlcyhmdWxsVXJsKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBhbGwgaGFuZGxlcyBvZiBhIHBhcnQgZnJvbSBhbiBleHRlcm5hbCBkb2N1bWVudFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgb2YgdGhlIGRvY3VtZW50XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmcmFnbWVudCBGcmFnbWVudCB3aXRob3V0IHBvdW5kIGtleSB3aGljaCBkZWZpbmVzIHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudFxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlRXh0ZXJuYWxIYW5kbGVzKHVybCwgZnJhZ21lbnQpIHtcclxuXHJcbiAgICB2YXIgcmVzcG9uc2UgPSBjX2NhY2hlZERvY3VtZW50c1t1cmxdLnJlc3BvbnNlO1xyXG4gICAgdmFyIG1pbWV0eXBlID0gY19jYWNoZWREb2N1bWVudHNbdXJsXS5taW1ldHlwZTtcclxuICAgIHZhciBmb3JtYXQgPSBjX2NhY2hlZERvY3VtZW50c1t1cmxdLmZvcm1hdDtcclxuXHJcbiAgICB2YXIgZnVsbFVybCA9IHVybCArIChmcmFnbWVudCA/IFwiI1wiICsgZnJhZ21lbnQgOiBcIlwiKTtcclxuICAgIGlmICghcmVzcG9uc2UpIHtcclxuICAgICAgICAvLyBJbiB0aGUgY2FzZSB0aGUgbG9hZGVkIGRvY3VtZW50IGlzIG5vdCBzdXBwb3J0ZWQgd2Ugc3RpbGwgbmVlZCB0byBkZWNyZW1lbnQgY291bnRlciBvYmplY3RcclxuICAgICAgICBpbnZhbGlkYXRlSGFuZGxlcyhmdWxsVXJsKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ2V0IHBhcnQgb2YgdGhlIHJlc291cmNlIHJlcHJlc2VudGVkIGJ5IHRoZSBmcmFnbWVudFxyXG4gICAgdmFyIGRhdGEgPSBmb3JtYXQuZ2V0RnJhZ21lbnREYXRhKHJlc3BvbnNlLCBmcmFnbWVudCk7XHJcblxyXG4gICAgaWYgKGRhdGEpIHtcclxuICAgICAgICB1cGRhdGVNaXNzaW5nSGFuZGxlcyhmdWxsVXJsLCBmb3JtYXQsIGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaW52YWxpZGF0ZUhhbmRsZXMoZnVsbFVybCk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogVXBkYXRlIGFsbCBBZGFwdGVySGFuZGxlcyB3aXRob3V0IGFkYXB0ZXJzIG9mIGEgY2VydGFpbiB1cmxcclxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgY29tcGxldGUgdXJsICsgZnJhZ21lbnRcclxuICogQHBhcmFtIHtGb3JtYXRIYW5kbGVyfSBmb3JtYXRIYW5kbGVyIEZvcm1hdCBoYW5kbGVyXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIERhdGEgb2YgdGhlIGRvY3VtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHVybC4gUG9zc2libHkgYSBET00gZWxlbWVudFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBsb2NhbENoYW5nZSBJZiB0cnVlLCB0aGVuIHRoaXMgaXMgYWJvdXQgYSBsb2NhbCBpZCBjaGFuZ2UuIGRvIG5vdCBjYWxsIGxvYWRDb21wbGV0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlTWlzc2luZ0hhbmRsZXModXJsLCBmb3JtYXRIYW5kbGVyLCBkYXRhLCBsb2NhbENoYW5nZSkge1xyXG4gICAgZm9yICh2YXIgYWRhcHRlclR5cGUgaW4gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmxdKSB7XHJcbiAgICAgICAgZm9yICh2YXIgY2FudmFzSWQgaW4gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmxdW2FkYXB0ZXJUeXBlXSkge1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmxdW2FkYXB0ZXJUeXBlXVtjYW52YXNJZF07XHJcbiAgICAgICAgICAgIGlmICghaGFuZGxlLmhhc0FkYXB0ZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlSGFuZGxlKGhhbmRsZSwgYWRhcHRlclR5cGUsICtjYW52YXNJZCwgZm9ybWF0SGFuZGxlciwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZighbG9jYWxDaGFuZ2UpIGxvYWRDb21wbGV0ZShjYW52YXNJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbnZhbGlkYXRlIGFsbCBBZGFwdGVySGFuZGxlcyB3aXRob3V0IGFkYXB0ZXJzIG9mIGEgY2VydGFpbiB1cmxcclxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgY29tcGxldGUgdXJsICsgZnJhZ21lbnRcclxuICovXHJcbmZ1bmN0aW9uIGludmFsaWRhdGVIYW5kbGVzKHVybCkge1xyXG4gICAgZm9yICh2YXIgYWRhcHRlclR5cGUgaW4gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmxdKSB7XHJcbiAgICAgICAgZm9yICh2YXIgY2FudmFzSWQgaW4gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmxdW2FkYXB0ZXJUeXBlXSkge1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmxdW2FkYXB0ZXJUeXBlXVtjYW52YXNJZF07XHJcbiAgICAgICAgICAgIGhhbmRsZS5zZXRBZGFwdGVyKG51bGwsIEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORCk7XHJcbiAgICAgICAgICAgIGxvYWRDb21wbGV0ZShjYW52YXNJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIGEgc3BlY2lmaWMgQWRhcHRlckhhbmRsZSB3aXRoIHRoZSBwcm92aWRlZCBkYXRhLlxyXG4gKiBJbnRlcm5hbGx5IGFuIGFkYXB0ZXIgd2lsbCBiZSBjcmVhdGVkIHdpdGggJ2RhdGEnIGFuZCBhZGRlZCB0byAnaGFuZGxlJ1xyXG4gKiBBbGwgb3RoZXIgYXJndW1lbnQgYXJlIHJlcXVpcmVkIHRvIGZpbmQgdGhlIGNvcnJlY3QgZmFjdG9yeVxyXG4gKiBAcGFyYW0ge0FkYXB0ZXJIYW5kbGV9IGhhbmRsZSBUaGUgQWRhcHRlckhhbmRsZSB0byBiZSB1cGRhdGVkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhZGFwdGVyVHlwZSBUaGUgdHlwZSAvIGFzcGVjdCBvZiB0aGUgYWRhcHRlciAoZS5nLiBYTUwzRC5kYXRhIG9yIFhNTDNELndlYmdsKVxyXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzSWQgSWQgb2YgY29ycmVzcG9uZGluZyBjYW52YXMgaGFuZGxlci4gMCBpZiBub3QgZGVwZW5kZW50IG9mIGNhbnZhcyBoYW5kbGVyXHJcbiAqIEBwYXJhbSB7Rm9ybWF0SGFuZGxlcn0gZm9ybWF0IEZvcm1hdCBoYW5kbGVyIG9mIHRoZSBjb3JyZXNwb25kaW5nIGRvY3VtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIERhdGEgZm9yIHRoaXMgaGFuZGxlLiBQb3NzaWJseSBhIERPTSBlbGVtZW50XHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVIYW5kbGUoaGFuZGxlLCBhZGFwdGVyVHlwZSwgY2FudmFzSWQsIGZvcm1hdCwgZGF0YSkge1xyXG5cclxuICAgIHZhciBmYWN0b3J5ID0gZm9ybWF0LmdldEZhY3RvcnkoYWRhcHRlclR5cGUsIGNhbnZhc0lkKTtcclxuXHJcbiAgICBpZighZmFjdG9yeSkge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiRm9ybWF0IGRvZXMgbm90IHN1cHBvcnQgYWRhcHRlclR5cGUgXCIgKyBhZGFwdGVyVHlwZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhZGFwdGVyID0gZmFjdG9yeS5nZXRBZGFwdGVyID8gZmFjdG9yeS5nZXRBZGFwdGVyKGRhdGEpIDogZmFjdG9yeS5jcmVhdGVBZGFwdGVyKGRhdGEpO1xyXG4gICAgaWYgKGFkYXB0ZXIpIHtcclxuICAgICAgICBoYW5kbGUuc2V0QWRhcHRlcihhZGFwdGVyLCBBZGFwdGVySGFuZGxlLlNUQVRVUy5SRUFEWSk7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgYWRhcHRlciBvZiBhbGwgQWRhcHRlckhhbmRsZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gVVJMLlxyXG4gKiBUaGlzIGlzIGNhbGxlZCBlLmcuIHdoZW4gYSBub2RlIGlzIHJlbW92ZSBmcm9tIHRoZSBkb2N1bWVudCwgb3IgYW4gaWQgY2hhbmdlc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgb2YgYWxsIEFkYXB0ZXJIYW5kbGVzIHRvIGJlIGNsZWFyZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjbGVhckhhbmRsZXModXJsKSB7XHJcbiAgICBmb3IgKHZhciBhZGFwdGVyVHlwZSBpbiBjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VybF0pIHtcclxuICAgICAgICBmb3IgKHZhciBjYW52YXNJZCBpbiBjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VybF1bYWRhcHRlclR5cGVdKSB7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VybF1bYWRhcHRlclR5cGVdW2NhbnZhc0lkXTtcclxuICAgICAgICAgICAgaWYgKGhhbmRsZS5oYXNBZGFwdGVyKCkpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZS5zZXRBZGFwdGVyKG51bGwsIEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZHMgcmV0dXJucyBhbiBhYnNvbHV0ZSBVUkkgY29tcGF0aWJsZSB3aXRoIHRoZSByZXNvdXJjZSBtYW5hZ2VyLlxyXG4gKiBUaGlzIG1lYW5zOiBBbnkgcmVmZXJlbmNlIGZyb20gYW4gZXh0ZXJuYWwgZG9jdW1lbnQgd2lsbCBiZSBhYnNvbHV0ZSBhbmQgYW55IGlkIHJlZmVyZW5jZSBmcm9tIHRoZSBjdXJyZW50XHJcbiAqIGRvY3VtZW50IHdpbGwgcmVtYWluIGFuIGlkIHJlZmVyZW5jZS5cclxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2VVUkkgLSB0aGUgYmFzZSBVUkkgdGhhdCB0aGUgdXJpIGlzIHJlbGF0aXZlIHRvXHJcbiAqIEBwYXJhbSB7VVJJfSB1cmkgLSBUaGUgVVJJIHVzZWQgdG8gZmluZCB0aGUgcmVmZXJyZWQgQWRhcHRlckhhbmRsZS4gQ2FuIGJlIHJlbGF0aXZlXHJcbiAqIEByZXR1cm5zIHtVUkl9IFRoZSAoc29tZXRpbWVzKSBhYnNvbHV0ZSBVUklcclxuICovXHJcblJlc291cmNlLmdldEFic29sdXRlVVJJID0gZnVuY3Rpb24oYmFzZVVSSSwgdXJpKXtcclxuICAgIGlmICghdXJpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIGlmICh0eXBlb2YgdXJpID09IFwic3RyaW5nXCIpIHVyaSA9IG5ldyBVUkkodXJpKTtcclxuICAgIGlmIChiYXNlVVJJICE9IGRvY3VtZW50LlVSTCB8fCAhdXJpLmlzTG9jYWwoKSkge1xyXG4gICAgICAgIHVyaSA9IHVyaS5nZXRBYnNvbHV0ZVVSSShiYXNlVVJJKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1cmk7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGFueSBhZGFwdGVyLCBpbnRlcm5hbCBvciBleHRlcm5hbC5cclxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHRyaWdnZXIgdGhlIGxvYWRpbmcgb2YgZG9jdW1lbnRzLCBpZiByZXF1aXJlZC5cclxuICogQW4gQWRhcHRlckhhbmRsZSB3aWxsIGJlIGFsd2F5cyBiZSByZXR1cm5lZCwgZXhwZWN0IHdoZW4gYW4gaW52YWxpZCAoZW1wdHkpIHVyaSBpcyBwYXNzZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlVVJJIC0gdGhlIGJhc2UgVVJJIGZyb20gd2hpY2ggdG8gbG9vayB1cCB0aGUgcmVmZXJlbmNlXHJcbiAqIEBwYXJhbSB7VVJJfSB1cmkgLSBUaGUgVVJJIHVzZWQgdG8gZmluZCB0aGUgcmVmZXJyZWQgQWRhcHRlckhhbmRsZS4gQ2FuIGJlIHJlbGF0aXZlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhZGFwdGVyVHlwZSBUaGUgdHlwZSBvZiBhZGFwdGVyIHJlcXVpcmVkIChlLmcuIFhNTDNELmRhdGEgb3IgWE1MM0Qud2ViZ2wpXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gY2FudmFzSWQgSWQgb2YgR0xDYW52YXNIYW5kbGVyIGhhbmRsZXIgdGhpcyBhZGFwdGVyIGRlcGVuZHMgb24sIDAgaWYgbm90IGRlcGVuZGluZyBvbiBhbnkgR0xDYW52YXNIYW5kbGVyXHJcbiAqIEByZXR1cm5zIHs/QWRhcHRlckhhbmRsZX0gVGhlIHJlcXVlc3RlZCBBZGFwdGVySGFuZGxlci4gTm90ZTogbWlnaHQgYmUgbnVsbFxyXG4gKi9cclxuUmVzb3VyY2UuZ2V0QWRhcHRlckhhbmRsZSA9IGZ1bmN0aW9uKGJhc2VVUkksIHVyaSwgYWRhcHRlclR5cGUsIGNhbnZhc0lkKSB7XHJcbiAgICBjYW52YXNJZCA9IGNhbnZhc0lkIHx8IDA7XHJcbiAgICB1cmkgPSBSZXNvdXJjZS5nZXRBYnNvbHV0ZVVSSShiYXNlVVJJLCB1cmkpO1xyXG5cclxuICAgIGlmICghdXJpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIGlmICghY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmldKVxyXG4gICAgICAgIGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJpXSA9IHt9O1xyXG5cclxuICAgIGlmICghY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmldW2FkYXB0ZXJUeXBlXSkge1xyXG4gICAgICAgIGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJpXVthZGFwdGVyVHlwZV0gPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGFuZGxlID0gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmldW2FkYXB0ZXJUeXBlXVtjYW52YXNJZF07XHJcbiAgICBpZiAoaGFuZGxlKVxyXG4gICAgICAgIHJldHVybiBoYW5kbGU7XHJcblxyXG4gICAgaGFuZGxlID0gbmV3IEFkYXB0ZXJIYW5kbGUodXJpKTtcclxuICAgIGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJpXVthZGFwdGVyVHlwZV1bY2FudmFzSWRdID0gaGFuZGxlO1xyXG5cclxuICAgIGlmICh1cmkuaXNMb2NhbCgpKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBVUklSZXNvbHZlci5yZXNvbHZlTG9jYWwodXJpKTtcclxuICAgICAgICBpZiAobm9kZSlcclxuICAgICAgICAgICAgdXBkYXRlSGFuZGxlKGhhbmRsZSwgYWRhcHRlclR5cGUsIGNhbnZhc0lkLCBYTUwzRC54bWwzZEZvcm1hdEhhbmRsZXIsIG5vZGUpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgaGFuZGxlLnNldEFkYXB0ZXIobnVsbCwgQWRhcHRlckhhbmRsZS5TVEFUVVMuTk9UX0ZPVU5EKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBjb3VudGVyT2JqZWN0ID0gZ2V0T3JDcmVhdGVDb3VudGVyT2JqZWN0KGNhbnZhc0lkKTtcclxuICAgICAgICBjb3VudGVyT2JqZWN0LmNvdW50ZXIrKztcclxuXHJcbiAgICAgICAgdmFyIGRvY1VSSSA9IHVyaS50b1N0cmluZ1dpdGhvdXRGcmFnbWVudCgpO1xyXG4gICAgICAgIHZhciBkb2NEYXRhID0gY19jYWNoZWREb2N1bWVudHNbZG9jVVJJXTtcclxuICAgICAgICBpZiAoZG9jRGF0YSAmJiBkb2NEYXRhLnJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUV4dGVybmFsSGFuZGxlcyhkb2NVUkksIHVyaS5mcmFnbWVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFkb2NEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBsb2FkRG9jdW1lbnQoZG9jVVJJKTtcclxuICAgICAgICAgICAgICAgIGNfY2FjaGVkRG9jdW1lbnRzW2RvY1VSSV0gPSBkb2NEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50czogW11cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG9jRGF0YS5mcmFnbWVudHMucHVzaCh1cmkuZnJhZ21lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBoYW5kbGU7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGFueSBhZGFwdGVyLCBpbnRlcm5hbCBvciBleHRlcm5hbC5cclxuICpcclxuICogQHBhcmFtIG5vZGVcclxuICogQHBhcmFtIGFkYXB0ZXJUeXBlXHJcbiAqIEBwYXJhbSBjYW52YXNJZFxyXG4gKiBAcmV0dXJuIHtYTUwzRC5iYXNlLkFkYXB0ZXI/fVxyXG4gKi9cclxuUmVzb3VyY2UuZ2V0QWRhcHRlciA9IGZ1bmN0aW9uKG5vZGUsIGFkYXB0ZXJUeXBlLCBjYW52YXNJZCkge1xyXG4gICAgdmFyIGZhY3RvcnkgPSBYTUwzRC54bWwzZEZvcm1hdEhhbmRsZXIuZ2V0RmFjdG9yeShhZGFwdGVyVHlwZSwgY2FudmFzSWQpO1xyXG4gICAgaWYgKGZhY3RvcnkpIHtcclxuICAgICAgICByZXR1cm4gZmFjdG9yeS5nZXRBZGFwdGVyKG5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhbiBpZCBvZiBhbiBlbGVtZW50IGNoYW5nZXMgb3IgaWYgdGhhdCBlbGVtZW50IGlzIG5vdyByZWFjaGFibGVcclxuICogb3Igbm90IHJlYWNoYWJsZSBhbnltb3JlLiBJdCB3aWxsIHVwZGF0ZSBhbGwgQWRhcHRlckhhbmRsZXMgY29ubmVjdGVkIHRvIHRoZSBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCBvZiB3aGljaCBpZCBoYXMgY2hhbmdlZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJldmlvdXNJZCBQcmV2aW91cyBpZCBvZiBlbGVtZW50XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdJZCBOZXcgaWQgb2YgZWxlbWVudFxyXG4gKi9cclxuUmVzb3VyY2Uubm90aWZ5Tm9kZUlkQ2hhbmdlID0gZnVuY3Rpb24obm9kZSwgcHJldmlvdXNJZCwgbmV3SWQpIHtcclxuICAgIHZhciBwYXJlbnQgPSBub2RlO1xyXG4gICAgd2hpbGUgKHBhcmVudC5wYXJlbnROb2RlKSBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcclxuICAgIGlmIChwYXJlbnQgIT0gd2luZG93LmRvY3VtZW50KVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAvLyBjbGVhciBjYWNoZWQgYWRhcHRlcnMgb2YgcHJldmlvdXMgaWRcIlxyXG4gICAgaWYgKHByZXZpb3VzSWQpIHtcclxuICAgICAgICBjbGVhckhhbmRsZXMoXCIjXCIgKyBwcmV2aW91c0lkKTtcclxuICAgIH1cclxuICAgIGlmIChuZXdJZCkge1xyXG4gICAgICAgIHVwZGF0ZU1pc3NpbmdIYW5kbGVzKFwiI1wiICsgbmV3SWQsIFhNTDNELnhtbDNkRm9ybWF0SGFuZGxlciwgbm9kZSwgdHJ1ZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgdG8gbm90aWZ5IGFuIEFkYXB0ZXJIYW5kbGVyIGFib3V0IGEgY2hhbmdlIChjYW4gYmUgdHJpZ2dlcmVkIHRocm91Z2ggYWRhcHRlcnMpXHJcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG9ubHkgd29ya3Mgd2l0aCBub2RlcyBpbnNpZGUgd2luZG93LmRvY3VtZW50XHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IG9mIEFkYXB0ZXJIYW5kbGVyLiBNdXN0IGJlIGZyb20gd2luZG93LmRvY3VtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhZGFwdGVyVHlwZSBUeXBlL0FzcGVjdCBvZiBBZGFwdGVySGFuZGxlciAoZS5nLiBYTUwzRC5kYXRhIG9yIFhNTDNELndlYmdsKVxyXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzSWQgR0xDYW52YXNIYW5kbGVyIGlkIG9mIEFkYXB0ZXJIYW5kbGVyLCAwIGlmIG5vdCBkZXBlbmRpbmcgb24gR0xDYW52YXNIYW5kbGVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFR5cGUgb2YgTm90aWZpY2F0aW9uLiBVc3VhbGx5IEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEXHJcbiAqL1xyXG5SZXNvdXJjZS5ub3RpZnlOb2RlQWRhcHRlckNoYW5nZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGFkYXB0ZXJUeXBlLCBjYW52YXNJZCwgdHlwZSkge1xyXG4gICAgY2FudmFzSWQgPSBjYW52YXNJZCB8fCAwO1xyXG4gICAgdmFyIHVyaSA9IFwiI1wiICsgZWxlbWVudC5pZDtcclxuICAgIGlmIChjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VyaV0gJiYgY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmldW2FkYXB0ZXJUeXBlXSAmJlxyXG4gICAgICAgIGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJpXVthZGFwdGVyVHlwZV1bY2FudmFzSWRdKSB7XHJcbiAgICAgICAgY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmldW2FkYXB0ZXJUeXBlXVtjYW52YXNJZF0ubm90aWZ5TGlzdGVuZXJzKHR5cGUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBMb2FkIGRhdGEgdmlhIFhNTEh0dHBSZXF1ZXN0XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIG9mIHRoZSBkb2N1bWVudFxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCl9IGxvYWRMaXN0ZW5lciBHZXRzIHRoZSByZXNwb25zZSBvZiB0aGUgWEhSXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oWE1MSHR0cFJlcXVlc3QpfSBlcnJvckxpc3RlbmVyIEdldCB0aGUgWEhSIG9iamVjdCBmb3IgZnVydGhlciBhbmFseXNpc1xyXG4gKi9cclxuUmVzb3VyY2UubG9hZERhdGEgPSBmdW5jdGlvbih1cmwsIGxvYWRMaXN0ZW5lciwgZXJyb3JMaXN0ZW5lcikge1xyXG4gICAgdmFyIHhtbEh0dHAgPSBudWxsO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB4bWxIdHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgeG1sSHR0cCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoeG1sSHR0cCkge1xyXG4gICAgICAgIHhtbEh0dHAuX3VybCA9IHVybDtcclxuICAgICAgICB4bWxIdHRwLl9jb250ZW50Q2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHhtbEh0dHAub3BlbignR0VUJywgdXJsLCB0cnVlKTtcclxuICAgICAgICBpZiAoaXNCaW5hcnlFeHRlbnNpb24odXJsKSlcclxuICAgICAgICAgICAgeG1sSHR0cC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcblxyXG4gICAgICAgIHhtbEh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh4bWxIdHRwLl9hYm9ydGVkKSAvLyBUaGlzIGNoZWNrIGlzIHBvc3NpYmx5IG5vdCBuZWVkZWRcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgLy8gY2hlY2sgY29tcGF0aWJpbGl0eSBiZXR3ZWVuIGNvbnRlbnQgYW5kIHJlcXVlc3QgbW9kZVxyXG4gICAgICAgICAgICBpZiAoIXhtbEh0dHAuX2NvbnRlbnRDaGVja2VkICYmXHJcbiAgICAgICAgICAgICAgICAvLyAyIC0gSEVBREVSU19SRUNFSVZFRCwgMyAtIExPQURJTkcsIDQgLSBET05FXHJcbiAgICAgICAgICAgICAgICAoKHhtbEh0dHAucmVhZHlTdGF0ZSA9PSAyIHx8IHhtbEh0dHAucmVhZHlTdGF0ZSA9PSAzIHx8IHhtbEh0dHAucmVhZHlTdGF0ZSA9PSA0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHhtbEh0dHAuc3RhdHVzID09IDIwMCkpIHtcclxuICAgICAgICAgICAgICAgIHhtbEh0dHAuX2NvbnRlbnRDaGVja2VkID0gdHJ1ZTsgLy8gd2UgY2hlY2sgb25seSBvbmNlXHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGNoYW5nZSByZXF1ZXN0IG1vZGVcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IHhtbEh0dHAuZ2V0UmVzcG9uc2VIZWFkZXIoXCJjb250ZW50LXR5cGVcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmluYXJ5Q29udGVudCA9IGlzQmluYXJ5Q29udGVudFR5cGUoY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5hcnlSZXF1ZXN0ID0gKHhtbEh0dHAucmVzcG9uc2VUeXBlID09IFwiYXJyYXlidWZmZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBjb250ZW50IGlzIG5vdCB0aGUgc2FtZSBhcyByZXF1ZXN0LCB3ZSBuZWVkIHRvIHJlcGVhdCByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmFyeUNvbnRlbnQgIT0gYmluYXJ5UmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxIdHRwLl9hYm9ydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0geG1sSHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IHhtbEh0dHAuX3VybDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cC5hYm9ydCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogV2UgZG8gbm90IHJlY3ljbGUgWE1MSHR0cFJlcXVlc3QgIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBUaGlzIGRvZXMgd29yayBvbmx5IHdoZW4gcmVzcG9uc2VUeXBlIGlzIGNoYW5nZWQgdG8gXCJhcnJheWJ1ZmZlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBob3dldmVyIHRoZSBzaXplIG9mIHRoZSB4bWxIdHRwLnJlc3BvbnNlIGJ1ZmZlciBpcyB0aGVuIHdyb25nICFcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgSXQgZG9lcyBub3Qgd29yayBhdCBhbGwgKGF0IGxlYXN0IGluIENocm9tZSkgd2hlbiB3ZSB1c2Ugb3ZlcnJpZGVNaW1lVHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICB3aXRoIFwidGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZFwiIGFyZ3VtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBUaGUgbGF0dGVyIG1vZGUgcmVxdWlyZSBjcmVhdGlvbiBvZiB0aGUgZnJlc2ggWE1MSHR0cFJlcXVlc3QuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxIdHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAuX3VybCA9IHVybDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cC5fY29udGVudENoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxIdHRwLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlDb250ZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gY2I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAuc2VuZChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZXF1ZXN0IG1vZGUgYW5kIGNvbnRlbnQgdHlwZSBhcmUgY29tcGF0aWJsZSBoZXJlIChib3RoIGJpbmFyeSBvciBib3RoIHRleHQpXHJcbiAgICAgICAgICAgIGlmICh4bWxIdHRwLnJlYWR5U3RhdGUgPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHhtbEh0dHAuc3RhdHVzID09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiTG9hZGVkOiBcIiArIHhtbEh0dHAuX3VybCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW1ldHlwZSA9IHhtbEh0dHAuZ2V0UmVzcG9uc2VIZWFkZXIoXCJjb250ZW50LXR5cGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhtbEh0dHAucmVzcG9uc2VUeXBlID09IFwiYXJyYXlidWZmZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHhtbEh0dHAucmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtaW1ldHlwZSA9PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IEpTT04ucGFyc2UoeG1sSHR0cC5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWltZXR5cGUgPT0gXCJhcHBsaWNhdGlvbi94bWxcIiB8fCBtaW1ldHlwZSA9PSBcInRleHQveG1sXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB4bWxIdHRwLnJlc3BvbnNlWE1MO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWltZXR5cGUgPT0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiB8fCBtaW1ldHlwZSA9PSBcInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlBvc3NpYmx5IHdyb25nIGxvYWRpbmcgb2YgcmVzb3VyY2UgXCIgKyB1cmwgKyBcIi4gTWltZXR5cGUgaXMgXCIgKyBtaW1ldHlwZSArIFwiIGJ1dCByZXNwb25zZSBpcyBub3QgYW4gQXJyYXlCdWZmZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0geG1sSHR0cC5yZXNwb25zZVRleHQ7IC8vIEZJWE1FIGlzIHRoaXMgY29ycmVjdCA/XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2FkTGlzdGVuZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRMaXN0ZW5lcihyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBsb2FkIGV4dGVybmFsIGRvY3VtZW50ICdcIiArIHhtbEh0dHAuX3VybCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJzogXCIgKyB4bWxIdHRwLnN0YXR1cyArIFwiIC0gXCIgKyB4bWxIdHRwLnN0YXR1c1RleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvckxpc3RlbmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckxpc3RlbmVyKHhtbEh0dHApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB4bWxIdHRwLnNlbmQobnVsbCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgdG8gbG9hZCBhbiBJbWFnZS5cclxuICpcclxuICogQHBhcmFtIHtVUkl9IHVyaSBJbWFnZSBVUklcclxuICogQHBhcmFtIHtmdW5jdGlvbihFdmVudCwgSFRNTEltYWdlRWxlbWVudCl9IGxvYWRMaXN0ZW5lciBGdW5jdGlvbiBjYWxsZWQgd2hlbiBpbWFnZSB3YXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggZXZlbnQgYXMgdGhlIGZpcnN0IGFuZCBpbWFnZSBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci5cclxuICogQHBhcmFtIHtmdW5jdGlvbihFdmVudCwgSFRNTEltYWdlRWxlbWVudCl9IGVycm9yTGlzdGVuZXIgRnVuY3Rpb24gY2FsbGVkIHdoZW4gaW1hZ2UgY291bGQgbm90IGJlIGxvYWRlZC5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGV2ZW50IGFzIHRoZSBmaXJzdCBhbmQgaW1hZ2UgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuXHJcbiAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9XHJcbiAqL1xyXG5SZXNvdXJjZS5nZXRJbWFnZSA9IGZ1bmN0aW9uKHVyaSwgbG9hZExpc3RlbmVyLCBlcnJvckxpc3RlbmVyKSB7XHJcbiAgICAvLyB3ZSB1c2UgY2FudmFzSWQgMCB0byByZXByZXNlbnQgaW1hZ2VzIGxvYWRlZCBpbiBhIGRvY3VtZW50XHJcbiAgICBnZXRPckNyZWF0ZUNvdW50ZXJPYmplY3QoMCkuY291bnRlcisrO1xyXG5cclxuICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGxvYWRMaXN0ZW5lcihlLCBpbWFnZSk7XHJcbiAgICAgICAgbG9hZENvbXBsZXRlKDApO1xyXG4gICAgfTtcclxuICAgIGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgZXJyb3JMaXN0ZW5lcihlLCBpbWFnZSk7XHJcbiAgICAgICAgbG9hZENvbXBsZXRlKDApO1xyXG4gICAgfTtcclxuICAgIGlmKCF1cmkuaGFzU2FtZU9yaWdpbihkb2N1bWVudC5sb2NhdGlvbi5ocmVmKSkge1xyXG4gICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gT3B0aW9ucy5nZXRWYWx1ZShPUFRJT05fUkVTT1VSQ0VfQ09SUyk7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIllvdSBhcmUgdXNpbmcgYW4gY3Jvc3Mtb3JpZ2luIGltYWdlIGFzIHRleHR1cmUuIFRoaXMgbWlnaHQgY2F1c2UgdHJvdWJsZXMgY2F1c2UgdGhlIGNhbnZhcyBpcyAndGFpbnRlZCcuXCIpXHJcbiAgICB9XHJcblxyXG4gICAgaW1hZ2Uuc3JjID0gdXJpLnRvU3RyaW5nKCk7IC8vIGhlcmUgbG9hZGluZyBzdGFydHNcclxuICAgIHJldHVybiBpbWFnZTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgdG8gbG9hZCBhIFZpZGVvLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1VSSX0gdXJpIFZpZGVvIFVSSVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGF1dG9wbGF5XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxyXG4gKiBAcGFyYW0ge09iamVjdH0gbGlzdGVuZXJzICBEaWN0aW9uYXJ5IG9mIGFsbCBsaXN0ZW5lcnMgdG8gcmVnaXN0ZXIgd2l0aCB2aWRlbyBlbGVtZW50LlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0ZW5lcnMgd2lsbCBiZSBjYWxsZWQgd2l0aCBldmVudCBhcyB0aGUgZmlyc3QgYW5kIHZpZGVvIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLlxyXG4gKiBAcmV0dXJuIHtIVE1MVmlkZW9FbGVtZW50fVxyXG4gKi9cclxuUmVzb3VyY2UuZ2V0VmlkZW8gPSBmdW5jdGlvbih1cmksIGF1dG9wbGF5LCBsb29wLCBsaXN0ZW5lcnMpIHtcclxuICAgIC8vIHdlIHVzZSBjYW52YXNJZCAwIHRvIHJlcHJlc2VudCB2aWRlb3MgbG9hZGVkIGluIGEgZG9jdW1lbnRcclxuICAgIGdldE9yQ3JlYXRlQ291bnRlck9iamVjdCgwKS5jb3VudGVyKys7XHJcblxyXG4gICAgLy8gRklYTUU6IEluIEhUTUwsIHdlIGNyZWF0ZSBhIGNvbmZpZ3VyZWQgdmlkZW8sIHBsYXkvcGF1c2Ugd29uJ3Qgd29ya1xyXG4gICAgdmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xyXG5cclxuICAgIHZhciBsb2FkQ29tcGxldGVDYWxsYmFjayA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgbG9hZENvbXBsZXRlKDApO1xyXG4gICAgICAgIHZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIGxvYWRDb21wbGV0ZUNhbGxiYWNrLCB0cnVlKTtcclxuICAgICAgICB2aWRlby5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgbG9hZENvbXBsZXRlQ2FsbGJhY2ssIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIXVyaS5oYXNTYW1lT3JpZ2luKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYpKSB7XHJcbiAgICAgICAgdmlkZW8uY3Jvc3NPcmlnaW4gPSBPcHRpb25zLmdldFZhbHVlKE9QVElPTl9SRVNPVVJDRV9DT1JTKTtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiWW91IGFyZSB1c2luZyBhbiBjcm9zcy1vcmlnaW4gdmlkZW8gYXMgdGV4dHVyZS4gVGhpcyBtaWdodCBjYXVzZSB0cm91YmxlcyBjYXVzZSB0aGUgY2FudmFzIGlzICd0YWludGVkJy5cIiwgdXJpKVxyXG4gICAgfVxyXG5cclxuICAgIHZpZGVvLmF1dG9wbGF5ID0gYXV0b3BsYXk7XHJcbiAgICB2aWRlby5sb29wID0gbG9vcDtcclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDYWxsYmFjayhsaXN0ZW5lcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcihldmVudCwgdmlkZW8pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGxpc3RlbmVycykge1xyXG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjcmVhdGVDYWxsYmFjayhsaXN0ZW5lcnNbZXZlbnROYW1lXSksIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIGxvYWRDb21wbGV0ZUNhbGxiYWNrLCB0cnVlKTtcclxuICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBsb2FkQ29tcGxldGVDYWxsYmFjaywgdHJ1ZSk7XHJcblxyXG4gICAgdmlkZW8uc3JjID0gdXJpLnRvU3RyaW5nKCk7IC8vIGhlcmUgbG9hZGluZyBzdGFydHNcclxuICAgIHJldHVybiB2aWRlbztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgcmVnaXN0ZXJGYWN0b3J5OiByZWdpc3RlckZhY3RvcnksXHJcbiAgICByZWdpc3RlckZvcm1hdDogcmVnaXN0ZXJGb3JtYXQsXHJcbiAgICBmaW5kRm9ybWF0OiBmaW5kRm9ybWF0LFxyXG4gICAgUmVzb3VyY2U6IFJlc291cmNlXHJcbn07XHJcbiIsIlxyXG4gICAgLyoqXHJcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gICAgICovXHJcblxyXG52YXIgRXZlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogRXZlbnREaXNwYXRjaGVyLFxyXG5cclxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG5cclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cclxuICAgICAgICBpZiAobGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCkge1xyXG5cclxuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0gPSBbXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZihsaXN0ZW5lcikgPT09IC0xKSB7XHJcblxyXG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKGxpc3RlbmVyKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaGFzRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cclxuICAgICAgICBpZiAobGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKGxpc3RlbmVyKSAhPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKGxpc3RlbmVyKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0uc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG4gICAgICAgIHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyBldmVudC50eXBlIF07XHJcblxyXG4gICAgICAgIGlmIChsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVyQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJBcnJheVsgaSBdLmNhbGwodGhpcywgZXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnREaXNwYXRjaGVyOyIsIi8qanNsaW50IHdoaXRlOiBmYWxzZSwgb25ldmFyOiBmYWxzZSwgdW5kZWY6IHRydWUsIG5vbWVuOiB0cnVlLCBlcWVxZXE6IHRydWUsIHBsdXNwbHVzOiB0cnVlLCBiaXR3aXNlOiB0cnVlLCByZWdleHA6IHRydWUsIG5ld2NhcDogdHJ1ZSwgaW1tZWQ6IHRydWUsIHN1YjogdHJ1ZSwgbm9tZW46IGZhbHNlICovXHJcblxyXG4vKipcclxuKiBUaGlzIGZpbGUgY29udGFpbnMgY29kZSB0aGF0IG1heSBiZSB1bmRlciB0aGUgZm9sbG93aW5nIGxpY2Vuc2U6XHJcbipcclxuKiBTR0kgRlJFRSBTT0ZUV0FSRSBMSUNFTlNFIEIgKFZlcnNpb24gMi4wLCBTZXB0LiAxOCwgMjAwOClcclxuKiBDb3B5cmlnaHQgKEMpIDE5OTEtMjAwMCBTaWxpY29uIEdyYXBoaWNzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbipcclxuKiBTZWUgaHR0cDovL29zcy5zZ2kuY29tL3Byb2plY3RzL0ZyZWVCLyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuKlxyXG4qIEFsbCBjb2RlIGluIHRoaXMgZmlsZSB3aGljaCBpcyBOT1QgdW5kZXIgdGhlIFNHSSBGUkVFIFNPRlRXQVJFIExJQ0VOU0UgQlxyXG4qIGlzIGZyZWUgYW5kIHVuZW5jdW1iZXJlZCBzb2Z0d2FyZSByZWxlYXNlZCBpbnRvIHRoZSBwdWJsaWMgZG9tYWluLlxyXG4qXHJcbiogQW55b25lIGlzIGZyZWUgdG8gY29weSwgbW9kaWZ5LCBwdWJsaXNoLCB1c2UsIGNvbXBpbGUsIHNlbGwsIG9yXHJcbiogZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlLCBlaXRoZXIgaW4gc291cmNlIGNvZGUgZm9ybSBvciBhcyBhIGNvbXBpbGVkXHJcbiogYmluYXJ5LCBmb3IgYW55IHB1cnBvc2UsIGNvbW1lcmNpYWwgb3Igbm9uLWNvbW1lcmNpYWwsIGFuZCBieSBhbnlcclxuKiBtZWFucy5cclxuKlxyXG4qIEluIGp1cmlzZGljdGlvbnMgdGhhdCByZWNvZ25pemUgY29weXJpZ2h0IGxhd3MsIHRoZSBhdXRob3Igb3IgYXV0aG9yc1xyXG4qIG9mIHRoaXMgc29mdHdhcmUgZGVkaWNhdGUgYW55IGFuZCBhbGwgY29weXJpZ2h0IGludGVyZXN0IGluIHRoZVxyXG4qIHNvZnR3YXJlIHRvIHRoZSBwdWJsaWMgZG9tYWluLiBXZSBtYWtlIHRoaXMgZGVkaWNhdGlvbiBmb3IgdGhlIGJlbmVmaXRcclxuKiBvZiB0aGUgcHVibGljIGF0IGxhcmdlIGFuZCB0byB0aGUgZGV0cmltZW50IG9mIG91ciBoZWlycyBhbmRcclxuKiBzdWNjZXNzb3JzLiBXZSBpbnRlbmQgdGhpcyBkZWRpY2F0aW9uIHRvIGJlIGFuIG92ZXJ0IGFjdCBvZlxyXG4qIHJlbGlucXVpc2htZW50IGluIHBlcnBldHVpdHkgb2YgYWxsIHByZXNlbnQgYW5kIGZ1dHVyZSByaWdodHMgdG8gdGhpc1xyXG4qIHNvZnR3YXJlIHVuZGVyIGNvcHlyaWdodCBsYXcuXHJcbipcclxuKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4qIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4qIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuKiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUlxyXG4qIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLFxyXG4qIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxyXG4qIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuKi9cclxuXHJcbnZhciBHTFUgPSB7fTtcclxuLyoqXHJcbiogVW5wcm9qZWN0IGEgc2NyZWVuIHBvaW50LlxyXG4qXHJcbiogQHBhcmFtIHtudW1iZXJ9IHdpblggdGhlIHdpbmRvdyBwb2ludCBmb3IgdGhlIHggdmFsdWUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHdpblkgdGhlIHdpbmRvdyBwb2ludCBmb3IgdGhlIHkgdmFsdWUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHdpblogdGhlIHdpbmRvdyBwb2ludCBmb3IgdGhlIHogdmFsdWUuXHJcbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbW9kZWwgdGhlIG1vZGVsLXZpZXcgbWF0cml4LlxyXG4qIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHByb2ogdGhlIHByb2plY3Rpb24gbWF0cml4LlxyXG4qIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZpZXcgdGhlIHZpZXdwb3J0IGNvb3JkaW5hdGUgYXJyYXkuXHJcbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb2JqUG9zIHRoZSBtb2RlbCBwb2ludCByZXN1bHQuXHJcbiogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdW5wcm9qZWN0IG9wZXJhdGlvbiB3YXMgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4qL1xyXG5HTFUudW5Qcm9qZWN0ID0gZnVuY3Rpb24od2luWCwgd2luWSwgd2luWiwgbW9kZWwsIHByb2osIHZpZXcsIG9ialBvcykge1xyXG5cclxuICAgIC8qKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXHJcbiAgICB2YXIgaW5wID0gW1xyXG4gICAgICAgIHdpblgsXHJcbiAgICAgICAgd2luWSxcclxuICAgICAgICB3aW5aLFxyXG4gICAgICAgIDEuMFxyXG4gICAgXTtcclxuXHJcbiAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xyXG4gICAgdmFyIGZpbmFsTWF0cml4ID0gW107XHJcblxyXG4gICAgR0xVLm11bHRNYXRyaWNlcyhtb2RlbCwgcHJvaiwgZmluYWxNYXRyaXgpO1xyXG4gICAgaWYgKCFHTFUuaW52ZXJ0TWF0cml4KGZpbmFsTWF0cml4LCBmaW5hbE1hdHJpeCkpIHtcclxuICAgICAgICByZXR1cm4gKGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBNYXAgeCBhbmQgeSBmcm9tIHdpbmRvdyBjb29yZGluYXRlcyAqL1xyXG4gICAgaW5wWzBdID0gKGlucFswXSAtIHZpZXdbMF0pIC8gdmlld1syXTtcclxuICAgIGlucFsxXSA9IChpbnBbMV0gLSB2aWV3WzFdKSAvIHZpZXdbM107XHJcblxyXG4gICAgLyogTWFwIHRvIHJhbmdlIC0xIHRvIDEgKi9cclxuICAgIGlucFswXSA9IGlucFswXSAqIDIgLSAxO1xyXG4gICAgaW5wWzFdID0gaW5wWzFdICogMiAtIDE7XHJcbiAgICBpbnBbMl0gPSBpbnBbMl0gKiAyIC0gMTtcclxuXHJcbiAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xyXG4gICAgdmFyIG91dCA9IFtdO1xyXG5cclxuICAgIEdMVS5tdWx0TWF0cml4VmVjKGZpbmFsTWF0cml4LCBpbnAsIG91dCk7XHJcblxyXG4gICAgaWYgKG91dFszXSA9PT0gMC4wKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIG91dFswXSAvPSBvdXRbM107XHJcbiAgICBvdXRbMV0gLz0gb3V0WzNdO1xyXG4gICAgb3V0WzJdIC89IG91dFszXTtcclxuXHJcbiAgICBvYmpQb3NbMF0gPSBvdXRbMF07XHJcbiAgICBvYmpQb3NbMV0gPSBvdXRbMV07XHJcbiAgICBvYmpQb3NbMl0gPSBvdXRbMl07XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuKiBNdWx0aXBseSB0aGUgbWF0cml4IGJ5IHRoZSBzcGVjaWZpZWQgdmVjdG9yLlxyXG4qXHJcbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF0cml4IHRoZSBtYXRyaXguXHJcbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaW5wIHRoZSB2ZWN0b3IuXHJcbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0IHRoZSBvdXRwdXQuXHJcbiovXHJcbkdMVS5tdWx0TWF0cml4VmVjID0gZnVuY3Rpb24obWF0cml4LCBpbnAsIG91dCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpID0gaSArIDEpIHtcclxuICAgICAgICBvdXRbaV0gPVxyXG4gICAgICAgICAgICBpbnBbMF0gKiBtYXRyaXhbMCAqIDQgKyBpXSArXHJcbiAgICAgICAgICAgIGlucFsxXSAqIG1hdHJpeFsxICogNCArIGldICtcclxuICAgICAgICAgICAgaW5wWzJdICogbWF0cml4WzIgKiA0ICsgaV0gK1xyXG4gICAgICAgICAgICBpbnBbM10gKiBtYXRyaXhbMyAqIDQgKyBpXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4qIE11bHRpcGx5IHRoZSBzcGVjaWZpZWQgbWF0cmljZXMuXHJcbipcclxuKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhIHRoZSBmaXJzdCBtYXRyaXguXHJcbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYiB0aGUgc2Vjb25kIG1hdHJpeC5cclxuKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByIHRoZSByZXN1bHQuXHJcbiovXHJcbkdMVS5tdWx0TWF0cmljZXMgPSBmdW5jdGlvbihhLCBiLCByKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkgPSBpICsgMSkge1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaiA9IGogKyAxKSB7XHJcbiAgICAgICAgICAgIHJbaSAqIDQgKyBqXSA9XHJcbiAgICAgICAgICAgICAgICBhW2kgKiA0ICsgMF0gKiBiWzAgKiA0ICsgal0gK1xyXG4gICAgICAgICAgICAgICAgYVtpICogNCArIDFdICogYlsxICogNCArIGpdICtcclxuICAgICAgICAgICAgICAgIGFbaSAqIDQgKyAyXSAqIGJbMiAqIDQgKyBqXSArXHJcbiAgICAgICAgICAgICAgICBhW2kgKiA0ICsgM10gKiBiWzMgKiA0ICsgal07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiogSW52ZXJ0IGEgbWF0cml4LlxyXG4qXHJcbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbSB0aGUgbWF0cml4LlxyXG4qIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGludk91dCB0aGUgaW52ZXJ0ZWQgb3V0cHV0LlxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4qL1xyXG5HTFUuaW52ZXJ0TWF0cml4ID0gZnVuY3Rpb24obSwgaW52T3V0KSB7XHJcbiAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xyXG4gICAgdmFyIGludiA9IFtdO1xyXG5cclxuICAgIGludlswXSA9IG1bNV0gKiBtWzEwXSAqIG1bMTVdIC0gbVs1XSAqIG1bMTFdICogbVsxNF0gLSBtWzldICogbVs2XSAqIG1bMTVdICtcclxuICAgICAgICBtWzldICogbVs3XSAqIG1bMTRdICsgbVsxM10gKiBtWzZdICogbVsxMV0gLSBtWzEzXSAqIG1bN10gKiBtWzEwXTtcclxuICAgIGludls0XSA9IC1tWzRdICogbVsxMF0gKiBtWzE1XSArIG1bNF0gKiBtWzExXSAqIG1bMTRdICsgbVs4XSAqIG1bNl0gKiBtWzE1XSAtXHJcbiAgICAgICAgbVs4XSAqIG1bN10gKiBtWzE0XSAtIG1bMTJdICogbVs2XSAqIG1bMTFdICsgbVsxMl0gKiBtWzddICogbVsxMF07XHJcbiAgICBpbnZbOF0gPSBtWzRdICogbVs5XSAqIG1bMTVdIC0gbVs0XSAqIG1bMTFdICogbVsxM10gLSBtWzhdICogbVs1XSAqIG1bMTVdICtcclxuICAgICAgICBtWzhdICogbVs3XSAqIG1bMTNdICsgbVsxMl0gKiBtWzVdICogbVsxMV0gLSBtWzEyXSAqIG1bN10gKiBtWzldO1xyXG4gICAgaW52WzEyXSA9IC1tWzRdICogbVs5XSAqIG1bMTRdICsgbVs0XSAqIG1bMTBdICogbVsxM10gKyBtWzhdICogbVs1XSAqIG1bMTRdIC1cclxuICAgICAgICBtWzhdICogbVs2XSAqIG1bMTNdIC0gbVsxMl0gKiBtWzVdICogbVsxMF0gKyBtWzEyXSAqIG1bNl0gKiBtWzldO1xyXG4gICAgaW52WzFdID0gLW1bMV0gKiBtWzEwXSAqIG1bMTVdICsgbVsxXSAqIG1bMTFdICogbVsxNF0gKyBtWzldICogbVsyXSAqIG1bMTVdIC1cclxuICAgICAgICBtWzldICogbVszXSAqIG1bMTRdIC0gbVsxM10gKiBtWzJdICogbVsxMV0gKyBtWzEzXSAqIG1bM10gKiBtWzEwXTtcclxuICAgIGludls1XSA9IG1bMF0gKiBtWzEwXSAqIG1bMTVdIC0gbVswXSAqIG1bMTFdICogbVsxNF0gLSBtWzhdICogbVsyXSAqIG1bMTVdICtcclxuICAgICAgICBtWzhdICogbVszXSAqIG1bMTRdICsgbVsxMl0gKiBtWzJdICogbVsxMV0gLSBtWzEyXSAqIG1bM10gKiBtWzEwXTtcclxuICAgIGludls5XSA9IC1tWzBdICogbVs5XSAqIG1bMTVdICsgbVswXSAqIG1bMTFdICogbVsxM10gKyBtWzhdICogbVsxXSAqIG1bMTVdIC1cclxuICAgICAgICBtWzhdICogbVszXSAqIG1bMTNdIC0gbVsxMl0gKiBtWzFdICogbVsxMV0gKyBtWzEyXSAqIG1bM10gKiBtWzldO1xyXG4gICAgaW52WzEzXSA9IG1bMF0gKiBtWzldICogbVsxNF0gLSBtWzBdICogbVsxMF0gKiBtWzEzXSAtIG1bOF0gKiBtWzFdICogbVsxNF0gK1xyXG4gICAgICAgIG1bOF0gKiBtWzJdICogbVsxM10gKyBtWzEyXSAqIG1bMV0gKiBtWzEwXSAtIG1bMTJdICogbVsyXSAqIG1bOV07XHJcbiAgICBpbnZbMl0gPSBtWzFdICogbVs2XSAqIG1bMTVdIC0gbVsxXSAqIG1bN10gKiBtWzE0XSAtIG1bNV0gKiBtWzJdICogbVsxNV0gK1xyXG4gICAgICAgIG1bNV0gKiBtWzNdICogbVsxNF0gKyBtWzEzXSAqIG1bMl0gKiBtWzddIC0gbVsxM10gKiBtWzNdICogbVs2XTtcclxuICAgIGludls2XSA9IC1tWzBdICogbVs2XSAqIG1bMTVdICsgbVswXSAqIG1bN10gKiBtWzE0XSArIG1bNF0gKiBtWzJdICogbVsxNV0gLVxyXG4gICAgICAgIG1bNF0gKiBtWzNdICogbVsxNF0gLSBtWzEyXSAqIG1bMl0gKiBtWzddICsgbVsxMl0gKiBtWzNdICogbVs2XTtcclxuICAgIGludlsxMF0gPSBtWzBdICogbVs1XSAqIG1bMTVdIC0gbVswXSAqIG1bN10gKiBtWzEzXSAtIG1bNF0gKiBtWzFdICogbVsxNV0gK1xyXG4gICAgICAgIG1bNF0gKiBtWzNdICogbVsxM10gKyBtWzEyXSAqIG1bMV0gKiBtWzddIC0gbVsxMl0gKiBtWzNdICogbVs1XTtcclxuICAgIGludlsxNF0gPSAtbVswXSAqIG1bNV0gKiBtWzE0XSArIG1bMF0gKiBtWzZdICogbVsxM10gKyBtWzRdICogbVsxXSAqIG1bMTRdIC1cclxuICAgICAgICBtWzRdICogbVsyXSAqIG1bMTNdIC0gbVsxMl0gKiBtWzFdICogbVs2XSArIG1bMTJdICogbVsyXSAqIG1bNV07XHJcbiAgICBpbnZbM10gPSAtbVsxXSAqIG1bNl0gKiBtWzExXSArIG1bMV0gKiBtWzddICogbVsxMF0gKyBtWzVdICogbVsyXSAqIG1bMTFdIC1cclxuICAgICAgICBtWzVdICogbVszXSAqIG1bMTBdIC0gbVs5XSAqIG1bMl0gKiBtWzddICsgbVs5XSAqIG1bM10gKiBtWzZdO1xyXG4gICAgaW52WzddID0gbVswXSAqIG1bNl0gKiBtWzExXSAtIG1bMF0gKiBtWzddICogbVsxMF0gLSBtWzRdICogbVsyXSAqIG1bMTFdICtcclxuICAgICAgICBtWzRdICogbVszXSAqIG1bMTBdICsgbVs4XSAqIG1bMl0gKiBtWzddIC0gbVs4XSAqIG1bM10gKiBtWzZdO1xyXG4gICAgaW52WzExXSA9IC1tWzBdICogbVs1XSAqIG1bMTFdICsgbVswXSAqIG1bN10gKiBtWzldICsgbVs0XSAqIG1bMV0gKiBtWzExXSAtXHJcbiAgICAgICAgbVs0XSAqIG1bM10gKiBtWzldIC0gbVs4XSAqIG1bMV0gKiBtWzddICsgbVs4XSAqIG1bM10gKiBtWzVdO1xyXG4gICAgaW52WzE1XSA9IG1bMF0gKiBtWzVdICogbVsxMF0gLSBtWzBdICogbVs2XSAqIG1bOV0gLSBtWzRdICogbVsxXSAqIG1bMTBdICtcclxuICAgICAgICBtWzRdICogbVsyXSAqIG1bOV0gKyBtWzhdICogbVsxXSAqIG1bNl0gLSBtWzhdICogbVsyXSAqIG1bNV07XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB2YXIgZGV0ID0gbVswXSAqIGludlswXSArIG1bMV0gKiBpbnZbNF0gKyBtWzJdICogaW52WzhdICsgbVszXSAqIGludlsxMl07XHJcblxyXG4gICAgaWYgKGRldCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBkZXQgPSAxLjAgLyBkZXQ7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSA9IGkgKyAxKSB7XHJcbiAgICAgICAgaW52T3V0W2ldID0gaW52W2ldICogZGV0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHTFU7IiwiLy8gRG9tYWluIFB1YmxpYyBieSBFcmljIFdlbmRlbGluIGh0dHA6Ly9lcml3ZW4uY29tLyAoMjAwOClcclxuLy8gICAgICAgICAgICAgICAgICBMdWtlIFNtaXRoIGh0dHA6Ly9sdWNhc3NtaXRoLm5hbWUvICgyMDA4KVxyXG4vLyAgICAgICAgICAgICAgICAgIExvaWMgRGFjaGFyeSA8bG9pY0BkYWNoYXJ5Lm9yZz4gKDIwMDgpXHJcbi8vICAgICAgICAgICAgICAgICAgSm9oYW4gRXVwaHJvc2luZSA8cHJvcHB5QGFtaW5jaGUuY29tPiAoMjAwOClcclxuLy8gICAgICAgICAgICAgICAgICBPeXZpbmQgU2VhbiBLaW5zZXkgaHR0cDovL2tpbnNleS5uby9ibG9nICgyMDEwKVxyXG4vLyAgICAgICAgICAgICAgICAgIFZpY3RvciBIb215YWtvdiA8dmljdG9yLWhvbXlha292QHVzZXJzLnNvdXJjZWZvcmdlLm5ldD4gKDIwMTApXHJcblxyXG5cclxuLyoqXHJcbiAqIE1haW4gZnVuY3Rpb24gZ2l2aW5nIGEgZnVuY3Rpb24gc3RhY2sgdHJhY2Ugd2l0aCBhIGZvcmNlZCBvciBwYXNzZWQgaW5cclxuICogRXJyb3JcclxuICpcclxuICogQGNmZyB7RXJyb3J9IGUgVGhlIGVycm9yIHRvIGNyZWF0ZSBhIHN0YWNrdHJhY2UgZnJvbSAob3B0aW9uYWwpXHJcbiAqIEBjZmcge0Jvb2xlYW59IGd1ZXNzIElmIHdlIHNob3VsZCB0cnkgdG8gcmVzb2x2ZSB0aGUgbmFtZXMgb2YgYW5vbnltb3VzXHJcbiAqIGZ1bmN0aW9uc1xyXG4gKiBAcmV0dXJuIHtBcnJheX0gb2YgU3RyaW5ncyB3aXRoIGZ1bmN0aW9ucywgbGluZXMsIGZpbGVzLCBhbmQgYXJndW1lbnRzXHJcbiAqIHdoZXJlIHBvc3NpYmxlXHJcbiAqL1xyXG52YXIgcHJpbnRTdGFja1RyYWNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcclxuICAgICAgICBndWVzcyA6IHRydWVcclxuICAgIH07XHJcbiAgICB2YXIgZXggPSBvcHRpb25zLmUgfHwgbnVsbCwgZ3Vlc3MgPSAhIW9wdGlvbnMuZ3Vlc3M7XHJcbiAgICB2YXIgcCA9IG5ldyBwcmludFN0YWNrVHJhY2UuaW1wbGVtZW50YXRpb24oKSwgcmVzdWx0ID0gcC5ydW4oZXgpO1xyXG4gICAgcmV0dXJuIChndWVzcykgPyBwLmd1ZXNzQW5vbnltb3VzRnVuY3Rpb25zKHJlc3VsdCkgOiByZXN1bHQ7XHJcbn07XHJcblxyXG5wcmludFN0YWNrVHJhY2UuaW1wbGVtZW50YXRpb24gPSBmdW5jdGlvbigpIHt9O1xyXG5cclxucHJpbnRTdGFja1RyYWNlLmltcGxlbWVudGF0aW9uLnByb3RvdHlwZSA9IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXggVGhlIGVycm9yIHRvIGNyZWF0ZSBhIHN0YWNrdHJhY2UgZnJvbSAob3B0aW9uYWwpXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSBGb3JjZWQgbW9kZSAob3B0aW9uYWwsIG1vc3RseSBmb3IgdW5pdCB0ZXN0cylcclxuICAgICAqL1xyXG4gICAgcnVuIDogZnVuY3Rpb24oZXgsIG1vZGUpIHtcclxuICAgICAgICBleCA9IGV4IHx8IHRoaXMuY3JlYXRlRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgLy8gZXhhbWluZSBleGNlcHRpb24gcHJvcGVydGllcyB3L28gZGVidWdnZXJcclxuICAgICAgICAvLyBmb3IgKHZhciBwcm9wIGluIGV4KSB7YWxlcnQoXCJFeFsnXCIgKyBwcm9wICsgXCInXT1cIiArIGV4W3Byb3BdKTt9XHJcbiAgICAgICAgbW9kZSA9IG1vZGUgfHwgdGhpcy5tb2RlKGV4KTtcclxuICAgICAgICBpZiAobW9kZSA9PT0gJ290aGVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdGhlcihhcmd1bWVudHMuY2FsbGVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1ttb2RlXShleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVFeGNlcHRpb24gOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLnVuZGVmKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW9kZSBjb3VsZCBkaWZmZXIgZm9yIGRpZmZlcmVudCBleGNlcHRpb24sIGUuZy4gZXhjZXB0aW9ucyBpbiBDaHJvbWVcclxuICAgICAqIG1heSBvciBtYXkgbm90IGhhdmUgYXJndW1lbnRzIG9yIHN0YWNrLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gbW9kZSBvZiBvcGVyYXRpb24gZm9yIHRoZSBleGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgbW9kZSA6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBpZiAoZVsnYXJndW1lbnRzJ10gJiYgZS5zdGFjaykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2Nocm9tZSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlLnN0YWNrICYmIGUuc291cmNlVVJMKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnc2FmYXJpJztcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5vcGVyYSkge1xyXG4gICAgICAgICAgICAvLyBlLm1lc3NhZ2UuaW5kZXhPZihcIkJhY2t0cmFjZTpcIikgPiAtMSAtPiBvcGVyYVxyXG4gICAgICAgICAgICAvLyAhZS5zdGFja3RyYWNlIC0+IG9wZXJhXHJcbiAgICAgICAgICAgIGlmICghZS5zdGFja3RyYWNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29wZXJhOSc7IC8vIHVzZSBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAnb3BlcmEjc291cmNlbG9jJyBpbiBlIC0+IG9wZXJhOSwgb3BlcmExMGFcclxuICAgICAgICAgICAgaWYgKGUubWVzc2FnZS5pbmRleE9mKCdcXG4nKSA+IC0xICYmIGUubWVzc2FnZS5zcGxpdCgnXFxuJykubGVuZ3RoID4gZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnb3BlcmE5JzsgLy8gdXNlIGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGUuc3RhY2t0cmFjZSAmJiAhZS5zdGFjayAtPiBvcGVyYTEwYVxyXG4gICAgICAgICAgICBpZiAoIWUuc3RhY2spIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnb3BlcmExMGEnOyAvLyB1c2UgZS5zdGFja3RyYWNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZS5zdGFja3RyYWNlICYmIGUuc3RhY2sgLT4gb3BlcmExMGJcclxuICAgICAgICAgICAgaWYgKGUuc3RhY2t0cmFjZS5pbmRleE9mKFwiY2FsbGVkIGZyb20gbGluZVwiKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnb3BlcmExMGInOyAvLyB1c2UgZS5zdGFja3RyYWNlLCBmb3JtYXQgZGlmZmVycyBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdvcGVyYTEwYSdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBlLnN0YWNrdHJhY2UgJiYgZS5zdGFjayAtPiBvcGVyYTExXHJcbiAgICAgICAgICAgIHJldHVybiAnb3BlcmExMSc7IC8vIHVzZSBlLnN0YWNrdHJhY2UsIGZvcm1hdCBkaWZmZXJzIGZyb21cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnb3BlcmExMGEnLCAnb3BlcmExMGInXHJcbiAgICAgICAgfSBlbHNlIGlmIChlLnN0YWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZmlyZWZveCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnb3RoZXInO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgY29udGV4dCwgZnVuY3Rpb24gbmFtZSwgYW5kIGNhbGxiYWNrIGZ1bmN0aW9uLCBvdmVyd3JpdGUgaXRcclxuICAgICAqIHNvIHRoYXQgaXQgY2FsbHMgcHJpbnRTdGFja1RyYWNlKCkgZmlyc3Qgd2l0aCBhIGNhbGxiYWNrIGFuZCB0aGVuXHJcbiAgICAgKiBydW5zIHRoZSByZXN0IG9mIHRoZSBib2R5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IG9mIGV4ZWN1dGlvbiAoZS5nLiB3aW5kb3cpXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZnVuY3Rpb25OYW1lIHRvIGluc3RydW1lbnRcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBhIHN0YWNrIHRyYWNlIG9uIGludm9jYXRpb25cclxuICAgICAqL1xyXG4gICAgaW5zdHJ1bWVudEZ1bmN0aW9uIDogZnVuY3Rpb24oY29udGV4dCwgZnVuY3Rpb25OYW1lLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHdpbmRvdztcclxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBjb250ZXh0W2Z1bmN0aW9uTmFtZV07XHJcbiAgICAgICAgY29udGV4dFtmdW5jdGlvbk5hbWVdID0gZnVuY3Rpb24gaW5zdHJ1bWVudGVkKCkge1xyXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHByaW50U3RhY2tUcmFjZSgpLnNsaWNlKDQpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRbZnVuY3Rpb25OYW1lXS5faW5zdHJ1bWVudGVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb250ZXh0W2Z1bmN0aW9uTmFtZV0uX2luc3RydW1lbnRlZCA9IG9yaWdpbmFsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgY29udGV4dCBhbmQgZnVuY3Rpb24gbmFtZSBvZiBhIGZ1bmN0aW9uIHRoYXQgaGFzIGJlZW5cclxuICAgICAqIGluc3RydW1lbnRlZCwgcmV2ZXJ0IHRoZSBmdW5jdGlvbiB0byBpdCdzIG9yaWdpbmFsIChub24taW5zdHJ1bWVudGVkKVxyXG4gICAgICogc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgb2YgZXhlY3V0aW9uIChlLmcuIHdpbmRvdylcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmdW5jdGlvbk5hbWUgdG8gZGUtaW5zdHJ1bWVudFxyXG4gICAgICovXHJcbiAgICBkZWluc3RydW1lbnRGdW5jdGlvbiA6IGZ1bmN0aW9uKGNvbnRleHQsIGZ1bmN0aW9uTmFtZSkge1xyXG4gICAgICAgIGlmIChjb250ZXh0W2Z1bmN0aW9uTmFtZV0uY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uICYmIGNvbnRleHRbZnVuY3Rpb25OYW1lXS5faW5zdHJ1bWVudGVkXHJcbiAgICAgICAgICAgICAgICAmJiBjb250ZXh0W2Z1bmN0aW9uTmFtZV0uX2luc3RydW1lbnRlZC5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgY29udGV4dFtmdW5jdGlvbk5hbWVdID0gY29udGV4dFtmdW5jdGlvbk5hbWVdLl9pbnN0cnVtZW50ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIEVycm9yIG9iamVjdCwgcmV0dXJuIGEgZm9ybWF0dGVkIEFycmF5IGJhc2VkIG9uIENocm9tZSdzXHJcbiAgICAgKiBzdGFjayBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGUgLSBFcnJvciBvYmplY3QgdG8gaW5zcGVjdFxyXG4gICAgICogQHJldHVybiBBcnJheTxTdHJpbmc+IG9mIGZ1bmN0aW9uIGNhbGxzLCBmaWxlcyBhbmQgbGluZSBudW1iZXJzXHJcbiAgICAgKi9cclxuICAgIGNocm9tZSA6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICB2YXIgc3RhY2sgPSAoZS5zdGFjayArICdcXG4nKS5yZXBsYWNlKC9eXFxTW15cXChdKz9bXFxuJF0vZ20sICcnKS5yZXBsYWNlKC9eXFxzKyhhdCBldmFsICk/YXRcXHMrL2dtLCAnJykucmVwbGFjZSgvXihbXlxcKF0rPykoW1xcbiRdKS9nbSxcclxuICAgICAgICAgICAgICAgICd7YW5vbnltb3VzfSgpQCQxJDInKS5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKChbXlxcKV0rKVxcKS9nbSwgJ3thbm9ueW1vdXN9KClAJDEnKS5zcGxpdCgnXFxuJyk7XHJcbiAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgcmV0dXJuIHN0YWNrO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIEVycm9yIG9iamVjdCwgcmV0dXJuIGEgZm9ybWF0dGVkIEFycmF5IGJhc2VkIG9uIFNhZmFyaSdzXHJcbiAgICAgKiBzdGFjayBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGUgLSBFcnJvciBvYmplY3QgdG8gaW5zcGVjdFxyXG4gICAgICogQHJldHVybiBBcnJheTxTdHJpbmc+IG9mIGZ1bmN0aW9uIGNhbGxzLCBmaWxlcyBhbmQgbGluZSBudW1iZXJzXHJcbiAgICAgKi9cclxuICAgIHNhZmFyaSA6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICByZXR1cm4gZS5zdGFjay5yZXBsYWNlKC9cXFtuYXRpdmUgY29kZVxcXVxcbi9tLCAnJykucmVwbGFjZSgvXkAvZ20sICd7YW5vbnltb3VzfSgpQCcpLnNwbGl0KCdcXG4nKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBFcnJvciBvYmplY3QsIHJldHVybiBhIGZvcm1hdHRlZCBBcnJheSBiYXNlZCBvbiBGaXJlZm94J3NcclxuICAgICAqIHN0YWNrIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZSAtIEVycm9yIG9iamVjdCB0byBpbnNwZWN0XHJcbiAgICAgKiBAcmV0dXJuIEFycmF5PFN0cmluZz4gb2YgZnVuY3Rpb24gY2FsbHMsIGZpbGVzIGFuZCBsaW5lIG51bWJlcnNcclxuICAgICAqL1xyXG4gICAgZmlyZWZveCA6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICByZXR1cm4gZS5zdGFjay5yZXBsYWNlKC8oPzpcXG5AOjApP1xccyskL20sICcnKS5yZXBsYWNlKC9eW1xcKEBdL2dtLCAne2Fub255bW91c30oKUAnKS5zcGxpdCgnXFxuJyk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9wZXJhMTEgOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgdmFyIEFOT04gPSAne2Fub255bW91c30nLCBsaW5lUkUgPSAvXi4qbGluZSAoXFxkKyksIGNvbHVtbiAoXFxkKykoPzogaW4gKC4rKSk/IGluIChcXFMrKTokLztcclxuICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpLCByZXN1bHQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gbWF0Y2hbNF0gKyAnOicgKyBtYXRjaFsxXSArICc6JyArIG1hdGNoWzJdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZuTmFtZSA9IG1hdGNoWzNdIHx8IFwiZ2xvYmFsIGNvZGVcIjtcclxuICAgICAgICAgICAgICAgIGZuTmFtZSA9IGZuTmFtZS5yZXBsYWNlKC88YW5vbnltb3VzIGZ1bmN0aW9uOiAoXFxTKyk+LywgXCIkMVwiKS5yZXBsYWNlKC88YW5vbnltb3VzIGZ1bmN0aW9uPi8sIEFOT04pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZm5OYW1lICsgJ0AnICsgbG9jYXRpb24gKyAnIC0tICcgKyBsaW5lc1tpICsgMV0ucmVwbGFjZSgvXlxccysvLCAnJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuXHJcbiAgICBvcGVyYTEwYiA6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAvLyBcIjxhbm9ueW1vdXMgZnVuY3Rpb246IHJ1bj4oW2FyZ3VtZW50cyBub3RcclxuICAgICAgICAvLyBhdmFpbGFibGVdKUBmaWxlOi8vbG9jYWxob3N0L0c6L2pzL3N0YWNrdHJhY2UuanM6MjdcXG5cIiArXHJcbiAgICAgICAgLy8gXCJwcmludFN0YWNrVHJhY2UoW2FyZ3VtZW50cyBub3RcclxuICAgICAgICAvLyBhdmFpbGFibGVdKUBmaWxlOi8vbG9jYWxob3N0L0c6L2pzL3N0YWNrdHJhY2UuanM6MThcXG5cIiArXHJcbiAgICAgICAgLy8gXCJAZmlsZTovL2xvY2FsaG9zdC9HOi9qcy90ZXN0L2Z1bmN0aW9uYWwvdGVzdGNhc2UxLmh0bWw6MTVcIlxyXG4gICAgICAgIHZhciBsaW5lUkUgPSAvXiguKilAKC4rKTooXFxkKykkLztcclxuICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpLCByZXN1bHQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZuTmFtZSA9IG1hdGNoWzFdID8gKG1hdGNoWzFdICsgJygpJykgOiBcImdsb2JhbCBjb2RlXCI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmbk5hbWUgKyAnQCcgKyBtYXRjaFsyXSArICc6JyArIG1hdGNoWzNdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBFcnJvciBvYmplY3QsIHJldHVybiBhIGZvcm1hdHRlZCBBcnJheSBiYXNlZCBvbiBPcGVyYSAxMCdzXHJcbiAgICAgKiBzdGFja3RyYWNlIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZSAtIEVycm9yIG9iamVjdCB0byBpbnNwZWN0XHJcbiAgICAgKiBAcmV0dXJuIEFycmF5PFN0cmluZz4gb2YgZnVuY3Rpb24gY2FsbHMsIGZpbGVzIGFuZCBsaW5lIG51bWJlcnNcclxuICAgICAqL1xyXG4gICAgb3BlcmExMGEgOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgLy8gXCIgTGluZSAyNyBvZiBsaW5rZWQgc2NyaXB0XHJcbiAgICAgICAgLy8gZmlsZTovL2xvY2FsaG9zdC9HOi9qcy9zdGFja3RyYWNlLmpzXFxuXCJcclxuICAgICAgICAvLyBcIiBMaW5lIDExIG9mIGlubGluZSMxIHNjcmlwdCBpblxyXG4gICAgICAgIC8vIGZpbGU6Ly9sb2NhbGhvc3QvRzovanMvdGVzdC9mdW5jdGlvbmFsL3Rlc3RjYXNlMS5odG1sOiBJblxyXG4gICAgICAgIC8vIGZ1bmN0aW9uIGZvb1xcblwiXHJcbiAgICAgICAgdmFyIEFOT04gPSAne2Fub255bW91c30nLCBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKSg/OjogSW4gZnVuY3Rpb24gKFxcUyspKT8kL2k7XHJcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKSwgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmbk5hbWUgPSBtYXRjaFszXSB8fCBBTk9OO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZm5OYW1lICsgJygpQCcgKyBtYXRjaFsyXSArICc6JyArIG1hdGNoWzFdICsgJyAtLSAnICsgbGluZXNbaSArIDFdLnJlcGxhY2UoL15cXHMrLywgJycpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gT3BlcmEgNy54LTkuMnggb25seSFcclxuICAgIG9wZXJhOSA6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAvLyBcIiBMaW5lIDQzIG9mIGxpbmtlZCBzY3JpcHRcclxuICAgICAgICAvLyBmaWxlOi8vbG9jYWxob3N0L0c6L2pzL3N0YWNrdHJhY2UuanNcXG5cIlxyXG4gICAgICAgIC8vIFwiIExpbmUgNyBvZiBpbmxpbmUjMSBzY3JpcHQgaW5cclxuICAgICAgICAvLyBmaWxlOi8vbG9jYWxob3N0L0c6L2pzL3Rlc3QvZnVuY3Rpb25hbC90ZXN0Y2FzZTEuaHRtbFxcblwiXHJcbiAgICAgICAgdmFyIEFOT04gPSAne2Fub255bW91c30nLCBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKS9pO1xyXG4gICAgICAgIHZhciBsaW5lcyA9IGUubWVzc2FnZS5zcGxpdCgnXFxuJyksIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDIsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChBTk9OICsgJygpQCcgKyBtYXRjaFsyXSArICc6JyArIG1hdGNoWzFdICsgJyAtLSAnICsgbGluZXNbaSArIDFdLnJlcGxhY2UoL15cXHMrLywgJycpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gU2FmYXJpIDUtLCBJRSA5LSwgYW5kIG90aGVyc1xyXG4gICAgb3RoZXIgOiBmdW5jdGlvbihjdXJyKSB7XHJcbiAgICAgICAgdmFyIEFOT04gPSAne2Fub255bW91c30nLCBmblJFID0gL2Z1bmN0aW9uXFxzKihbXFx3XFwtJF0rKT9cXHMqXFwoL2ksIHN0YWNrID0gW10sIGZuLCBhcmdzLCBtYXhTdGFja1NpemUgPSAxMDtcclxuICAgICAgICB3aGlsZSAoY3VyciAmJiBjdXJyWydhcmd1bWVudHMnXSAmJiBzdGFjay5sZW5ndGggPCBtYXhTdGFja1NpemUpIHtcclxuICAgICAgICAgICAgZm4gPSBmblJFLnRlc3QoY3Vyci50b1N0cmluZygpKSA/IFJlZ0V4cC4kMSB8fCBBTk9OIDogQU5PTjtcclxuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1cnJbJ2FyZ3VtZW50cyddIHx8IFtdKTtcclxuICAgICAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoXSA9IGZuICsgJygnICsgdGhpcy5zdHJpbmdpZnlBcmd1bWVudHMoYXJncykgKyAnKSc7XHJcbiAgICAgICAgICAgIGN1cnIgPSBjdXJyLmNhbGxlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0YWNrO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFyZ3VtZW50cyBhcnJheSBhcyBhIFN0cmluZywgc3Vic2l0dXRpbmcgdHlwZSBuYW1lcyBmb3JcclxuICAgICAqIG5vbi1zdHJpbmcgdHlwZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcmd1bWVudHN9IGFyZ3NcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvZiBTdHJpbmdzIHdpdGggc3RyaW5naWZpZWQgYXJndW1lbnRzXHJcbiAgICAgKi9cclxuICAgIHN0cmluZ2lmeUFyZ3VtZW50cyA6IGZ1bmN0aW9uKGFyZ3MpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XHJcbiAgICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gJ3VuZGVmaW5lZCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSAnbnVsbCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoIDwgMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSAnWycgKyB0aGlzLnN0cmluZ2lmeUFyZ3VtZW50cyhhcmcpICsgJ10nO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9ICdbJyArIHRoaXMuc3RyaW5naWZ5QXJndW1lbnRzKHNsaWNlLmNhbGwoYXJnLCAwLCAxKSkgKyAnLi4uJyArIHRoaXMuc3RyaW5naWZ5QXJndW1lbnRzKHNsaWNlLmNhbGwoYXJnLCAtMSkpICsgJ10nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSAnI29iamVjdCc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSAnI2Z1bmN0aW9uJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSAnXCInICsgYXJnICsgJ1wiJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBhcmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcsJyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNvdXJjZUNhY2hlIDoge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHRoZSB0ZXh0IGZyb20gYSBnaXZlbiBVUkxcclxuICAgICAqL1xyXG4gICAgYWpheCA6IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgICAgIHZhciByZXEgPSB0aGlzLmNyZWF0ZVhNTEhUVFBPYmplY3QoKTtcclxuICAgICAgICBpZiAocmVxKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXEub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAvLyByZXEub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbicpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVxLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvamF2YXNjcmlwdCcpO1xyXG4gICAgICAgICAgICAgICAgcmVxLnNlbmQobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxLnN0YXR1cyA9PSAyMDAgPyByZXEucmVzcG9uc2VUZXh0IDogJyc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLnJlc3BvbnNlVGV4dDtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcnkgWEhSIG1ldGhvZHMgaW4gb3JkZXIgYW5kIHN0b3JlIFhIUiBmYWN0b3J5LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gPEZ1bmN0aW9uPiBYSFIgZnVuY3Rpb24gb3IgZXF1aXZhbGVudFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVYTUxIVFRQT2JqZWN0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHhtbGh0dHAsIFhNTEh0dHBGYWN0b3JpZXMgPSBbIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTtcclxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDMuWE1MSFRUUCcpO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XHJcbiAgICAgICAgfSBdO1xyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IFhNTEh0dHBGYWN0b3JpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHhtbGh0dHAgPSBYTUxIdHRwRmFjdG9yaWVzW2ldKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgbWVtb2l6YXRpb24gdG8gY2FjaGUgdGhlIGZhY3RvcnlcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlWE1MSFRUUE9iamVjdCA9IFhNTEh0dHBGYWN0b3JpZXNbaV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geG1saHR0cDtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgVVJMLCBjaGVjayBpZiBpdCBpcyBpbiB0aGUgc2FtZSBkb21haW4gKHNvIHdlIGNhbiBnZXQgdGhlXHJcbiAgICAgKiBzb3VyY2UgdmlhIEFqYXgpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1cmwgPFN0cmluZz4gc291cmNlIHVybFxyXG4gICAgICogQHJldHVybiBGYWxzZSBpZiB3ZSBuZWVkIGEgY3Jvc3MtZG9tYWluIHJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgaXNTYW1lRG9tYWluIDogZnVuY3Rpb24odXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiB1cmwuaW5kZXhPZihsb2NhdGlvbi5ob3N0bmFtZSkgIT09IC0xOyAvLyBsb2NhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1bm5pbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9kZWpzLlxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBzb3VyY2UgY29kZSBmcm9tIGdpdmVuIFVSTCBpZiBpbiB0aGUgc2FtZSBkb21haW4uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVybCA8U3RyaW5nPiBKUyBzb3VyY2UgVVJMXHJcbiAgICAgKiBAcmV0dXJuIDxBcnJheT4gQXJyYXkgb2Ygc291cmNlIGNvZGUgbGluZXNcclxuICAgICAqL1xyXG4gICAgZ2V0U291cmNlIDogZnVuY3Rpb24odXJsKSB7XHJcbiAgICAgICAgLy8gVE9ETyByZXVzZSBzb3VyY2UgZnJvbSBzY3JpcHQgdGFncz9cclxuICAgICAgICBpZiAoISh1cmwgaW4gdGhpcy5zb3VyY2VDYWNoZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2VDYWNoZVt1cmxdID0gdGhpcy5hamF4KHVybCkuc3BsaXQoJ1xcbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VDYWNoZVt1cmxdO1xyXG4gICAgfSxcclxuXHJcbiAgICBndWVzc0Fub255bW91c0Z1bmN0aW9ucyA6IGZ1bmN0aW9uKHN0YWNrKSB7XHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHJlU3RhY2sgPSAvXFx7YW5vbnltb3VzXFx9XFwoLipcXClAKC4qKS8sIHJlUmVmID0gL14oLio/KSg/OjooXFxkKykpKD86OihcXGQrKSk/KD86IC0tIC4rKT8kLywgZnJhbWUgPSBzdGFja1tpXSwgcmVmID0gcmVTdGFjay5leGVjKGZyYW1lKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZWYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gcmVSZWYuZXhlYyhyZWZbMV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG0pIHsgLy8gSWYgZmFsc2V5LCB3ZSBkaWQgbm90IGdldCBhbnkgZmlsZS9saW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlID0gbVsxXSwgbGluZW5vID0gbVsyXSwgY2hhcm5vID0gbVszXSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlICYmIHRoaXMuaXNTYW1lRG9tYWluKGZpbGUpICYmIGxpbmVubykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdGhpcy5ndWVzc0Fub255bW91c0Z1bmN0aW9uKGZpbGUsIGxpbmVubywgY2hhcm5vKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tbaV0gPSBmcmFtZS5yZXBsYWNlKCd7YW5vbnltb3VzfScsIGZ1bmN0aW9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGFjaztcclxuICAgIH0sXHJcblxyXG4gICAgZ3Vlc3NBbm9ueW1vdXNGdW5jdGlvbiA6IGZ1bmN0aW9uKHVybCwgbGluZU5vLCBjaGFyTm8pIHtcclxuICAgICAgICB2YXIgcmV0O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldCA9IHRoaXMuZmluZEZ1bmN0aW9uTmFtZSh0aGlzLmdldFNvdXJjZSh1cmwpLCBsaW5lTm8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0ID0gJ2dldFNvdXJjZSBmYWlsZWQgd2l0aCB1cmw6ICcgKyB1cmwgKyAnLCBleGNlcHRpb246ICcgKyBlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbmRGdW5jdGlvbk5hbWUgOiBmdW5jdGlvbihzb3VyY2UsIGxpbmVObykge1xyXG4gICAgICAgIC8vIEZJWE1FIGZpbmRGdW5jdGlvbk5hbWUgZmFpbHMgZm9yIGNvbXByZXNzZWQgc291cmNlXHJcbiAgICAgICAgLy8gKG1vcmUgdGhhbiBvbmUgZnVuY3Rpb24gb24gdGhlIHNhbWUgbGluZSlcclxuICAgICAgICAvLyBUT0RPIHVzZSBjYXB0dXJlZCBhcmdzXHJcbiAgICAgICAgLy8gZnVuY3Rpb24ge25hbWV9KHthcmdzfSkgbVsxXT1uYW1lIG1bMl09YXJnc1xyXG4gICAgICAgIHZhciByZUZ1bmN0aW9uRGVjbGFyYXRpb24gPSAvZnVuY3Rpb25cXHMrKFteKF0qPylcXHMqXFwoKFteKV0qKVxcKS87XHJcbiAgICAgICAgLy8ge25hbWV9ID0gZnVuY3Rpb24gKHthcmdzfSkgVE9ETyBhcmdzIGNhcHR1cmVcclxuICAgICAgICAvLyAvWydcIl0/KFswLTlBLVphLXpfXSspWydcIl0/XFxzKls6PV1cXHMqZnVuY3Rpb24oPzpbXihdKikvXHJcbiAgICAgICAgdmFyIHJlRnVuY3Rpb25FeHByZXNzaW9uID0gL1snXCJdPyhbMC05QS1aYS16X10rKVsnXCJdP1xccypbOj1dXFxzKmZ1bmN0aW9uXFxiLztcclxuICAgICAgICAvLyB7bmFtZX0gPSBldmFsKClcclxuICAgICAgICB2YXIgcmVGdW5jdGlvbkV2YWx1YXRpb24gPSAvWydcIl0/KFswLTlBLVphLXpfXSspWydcIl0/XFxzKls6PV1cXHMqKD86ZXZhbHxuZXcgRnVuY3Rpb24pXFxiLztcclxuICAgICAgICAvLyBXYWxrIGJhY2t3YXJkcyBpbiB0aGUgc291cmNlIGxpbmVzIHVudGlsIHdlIGZpbmRcclxuICAgICAgICAvLyB0aGUgbGluZSB3aGljaCBtYXRjaGVzIG9uZSBvZiB0aGUgcGF0dGVybnMgYWJvdmVcclxuICAgICAgICB2YXIgY29kZSA9IFwiXCIsIGxpbmUsIG1heExpbmVzID0gTWF0aC5taW4obGluZU5vLCAyMCksIG0sIGNvbW1lbnRQb3M7XHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbWF4TGluZXM7ICsraSkge1xyXG4gICAgICAgICAgICAvLyBsaW5lTm8gaXMgMS1iYXNlZCwgc291cmNlW10gaXMgMC1iYXNlZFxyXG4gICAgICAgICAgICBsaW5lID0gc291cmNlW2xpbmVObyAtIGkgLSAxXTtcclxuICAgICAgICAgICAgY29tbWVudFBvcyA9IGxpbmUuaW5kZXhPZignLy8nKTtcclxuICAgICAgICAgICAgaWYgKGNvbW1lbnRQb3MgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGNvbW1lbnRQb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRPRE8gY2hlY2sgb3RoZXIgdHlwZXMgb2YgY29tbWVudHM/IENvbW1lbnRlZCBjb2RlIG1heSBsZWFkIHRvIGZhbHNlIHBvc2l0aXZlXHJcbiAgICAgICAgICAgIGlmIChsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlID0gbGluZSArIGNvZGU7XHJcbiAgICAgICAgICAgICAgICBtID0gcmVGdW5jdGlvbkV4cHJlc3Npb24uZXhlYyhjb2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbVsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG0gPSByZUZ1bmN0aW9uRGVjbGFyYXRpb24uZXhlYyhjb2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBtWzFdICsgXCIoXCIgKyAobVsyXSB8fCBcIlwiKSArIFwiKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbSA9IHJlRnVuY3Rpb25FdmFsdWF0aW9uLmV4ZWMoY29kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobSAmJiBtWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1bMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcoPyknO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBwcmludFN0YWNrVHJhY2U7IiwiXHJcbnZhciBTdGF0ZU1hY2hpbmUgPSB7XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBWRVJTSU9OOiBcIjIuMi4wXCIsXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBSZXN1bHQ6IHtcclxuICAgICAgU1VDQ0VFREVEOiAgICAxLCAvLyB0aGUgZXZlbnQgdHJhbnNpdGlvbmVkIHN1Y2Nlc3NmdWxseSBmcm9tIG9uZSBzdGF0ZSB0byBhbm90aGVyXHJcbiAgICAgIE5PVFJBTlNJVElPTjogMiwgLy8gdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbCBidXQgbm8gc3RhdGUgdHJhbnNpdGlvbiB3YXMgbmVjZXNzYXJ5XHJcbiAgICAgIENBTkNFTExFRDogICAgMywgLy8gdGhlIGV2ZW50IHdhcyBjYW5jZWxsZWQgYnkgdGhlIGNhbGxlciBpbiBhIGJlZm9yZUV2ZW50IGNhbGxiYWNrXHJcbiAgICAgIEFTWU5DOiAgICAgICAgNCAvLyB0aGUgZXZlbnQgaXMgYXN5bmNocm9ub3VzIGFuZCB0aGUgY2FsbGVyIGlzIGluIGNvbnRyb2wgb2Ygd2hlbiB0aGUgdHJhbnNpdGlvbiBvY2N1cnNcclxuICAgIH0sXHJcblxyXG4gICAgRXJyb3I6IHtcclxuICAgICAgSU5WQUxJRF9UUkFOU0lUSU9OOiAxMDAsIC8vIGNhbGxlciB0cmllZCB0byBmaXJlIGFuIGV2ZW50IHRoYXQgd2FzIGlubmFwcm9wcmlhdGUgaW4gdGhlIGN1cnJlbnQgc3RhdGVcclxuICAgICAgUEVORElOR19UUkFOU0lUSU9OOiAyMDAsIC8vIGNhbGxlciB0cmllZCB0byBmaXJlIGFuIGV2ZW50IHdoaWxlIGFuIGFzeW5jIHRyYW5zaXRpb24gd2FzIHN0aWxsIHBlbmRpbmdcclxuICAgICAgSU5WQUxJRF9DQUxMQkFDSzogICAzMDAgLy8gY2FsbGVyIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIHRocmV3IGFuIGV4Y2VwdGlvblxyXG4gICAgfSxcclxuXHJcbiAgICBXSUxEQ0FSRDogJyonLFxyXG4gICAgQVNZTkM6ICdhc3luYycsXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGNmZywgdGFyZ2V0KSB7XHJcblxyXG4gICAgICB2YXIgaW5pdGlhbCAgID0gKHR5cGVvZiBjZmcuaW5pdGlhbCA9PSAnc3RyaW5nJykgPyB7IHN0YXRlOiBjZmcuaW5pdGlhbCB9IDogY2ZnLmluaXRpYWw7IC8vIGFsbG93IGZvciBhIHNpbXBsZSBzdHJpbmcsIG9yIGFuIG9iamVjdCB3aXRoIHsgc3RhdGU6ICdmb28nLCBldmVudDogJ3NldHVwJywgZGVmZXI6IHRydWV8ZmFsc2UgfVxyXG4gICAgICB2YXIgZnNtICAgICAgID0gdGFyZ2V0IHx8IGNmZy50YXJnZXQgIHx8IHt9O1xyXG4gICAgICB2YXIgZXZlbnRzICAgID0gY2ZnLmV2ZW50cyB8fCBbXTtcclxuICAgICAgdmFyIGNhbGxiYWNrcyA9IGNmZy5jYWxsYmFja3MgfHwge307XHJcbiAgICAgIHZhciBtYXAgICAgICAgPSB7fTtcclxuXHJcbiAgICAgIHZhciBhZGQgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgdmFyIGZyb20gPSAoZS5mcm9tIGluc3RhbmNlb2YgQXJyYXkpID8gZS5mcm9tIDogKGUuZnJvbSA/IFtlLmZyb21dIDogW1N0YXRlTWFjaGluZS5XSUxEQ0FSRF0pOyAvLyBhbGxvdyAnd2lsZGNhcmQnIHRyYW5zaXRpb24gaWYgJ2Zyb20nIGlzIG5vdCBzcGVjaWZpZWRcclxuICAgICAgICBtYXBbZS5uYW1lXSA9IG1hcFtlLm5hbWVdIHx8IHt9O1xyXG4gICAgICAgIGZvciAodmFyIG4gPSAwIDsgbiA8IGZyb20ubGVuZ3RoIDsgbisrKVxyXG4gICAgICAgICAgbWFwW2UubmFtZV1bZnJvbVtuXV0gPSBlLnRvIHx8IGZyb21bbl07IC8vIGFsbG93IG5vLW9wIHRyYW5zaXRpb24gaWYgJ3RvJyBpcyBub3Qgc3BlY2lmaWVkXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAoaW5pdGlhbCkge1xyXG4gICAgICAgIGluaXRpYWwuZXZlbnQgPSBpbml0aWFsLmV2ZW50IHx8ICdzdGFydHVwJztcclxuICAgICAgICBhZGQoeyBuYW1lOiBpbml0aWFsLmV2ZW50LCBmcm9tOiAnbm9uZScsIHRvOiBpbml0aWFsLnN0YXRlIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IodmFyIG4gPSAwIDsgbiA8IGV2ZW50cy5sZW5ndGggOyBuKyspXHJcbiAgICAgICAgYWRkKGV2ZW50c1tuXSk7XHJcblxyXG4gICAgICBmb3IodmFyIG5hbWUgaW4gbWFwKSB7XHJcbiAgICAgICAgaWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcclxuICAgICAgICAgIGZzbVtuYW1lXSA9IFN0YXRlTWFjaGluZS5idWlsZEV2ZW50KG5hbWUsIG1hcFtuYW1lXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvcih2YXIgbmFtZSBpbiBjYWxsYmFja3MpIHtcclxuICAgICAgICBpZiAoY2FsbGJhY2tzLmhhc093blByb3BlcnR5KG5hbWUpKVxyXG4gICAgICAgICAgZnNtW25hbWVdID0gY2FsbGJhY2tzW25hbWVdXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZzbS5jdXJyZW50ID0gJ25vbmUnO1xyXG4gICAgICBmc20uaXMgICAgICA9IGZ1bmN0aW9uKHN0YXRlKSB7IHJldHVybiB0aGlzLmN1cnJlbnQgPT0gc3RhdGU7IH07XHJcbiAgICAgIGZzbS5jYW4gICAgID0gZnVuY3Rpb24oZXZlbnQpIHsgcmV0dXJuICF0aGlzLnRyYW5zaXRpb24gJiYgKG1hcFtldmVudF0uaGFzT3duUHJvcGVydHkodGhpcy5jdXJyZW50KSB8fCBtYXBbZXZlbnRdLmhhc093blByb3BlcnR5KFN0YXRlTWFjaGluZS5XSUxEQ0FSRCkpOyB9XHJcbiAgICAgIGZzbS5jYW5ub3QgID0gZnVuY3Rpb24oZXZlbnQpIHsgcmV0dXJuICF0aGlzLmNhbihldmVudCk7IH07XHJcbiAgICAgIGZzbS5lcnJvciAgID0gY2ZnLmVycm9yIHx8IGZ1bmN0aW9uKG5hbWUsIGZyb20sIHRvLCBhcmdzLCBlcnJvciwgbXNnLCBlKSB7IHRocm93IGUgfHwgbXNnOyB9OyAvLyBkZWZhdWx0IGJlaGF2aW9yIHdoZW4gc29tZXRoaW5nIHVuZXhwZWN0ZWQgaGFwcGVucyBpcyB0byB0aHJvdyBhbiBleGNlcHRpb24sIGJ1dCBjYWxsZXIgY2FuIG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgaWYgZGVzaXJlZCAoc2VlIGdpdGh1YiBpc3N1ZSAjMyBhbmQgIzE3KVxyXG5cclxuICAgICAgaWYgKGluaXRpYWwgJiYgIWluaXRpYWwuZGVmZXIpXHJcbiAgICAgICAgZnNtW2luaXRpYWwuZXZlbnRdKCk7XHJcblxyXG4gICAgICByZXR1cm4gZnNtO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBkb0NhbGxiYWNrOiBmdW5jdGlvbihmc20sIGZ1bmMsIG5hbWUsIGZyb20sIHRvLCBhcmdzKSB7XHJcbiAgICAgIGlmIChmdW5jKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGZzbSwgW25hbWUsIGZyb20sIHRvXS5jb25jYXQoYXJncykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICByZXR1cm4gZnNtLmVycm9yKG5hbWUsIGZyb20sIHRvLCBhcmdzLCBTdGF0ZU1hY2hpbmUuRXJyb3IuSU5WQUxJRF9DQUxMQkFDSywgXCJhbiBleGNlcHRpb24gb2NjdXJyZWQgaW4gYSBjYWxsZXItcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb25cIiwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGJlZm9yZUV2ZW50OiBmdW5jdGlvbihmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKSB7IHJldHVybiBTdGF0ZU1hY2hpbmUuZG9DYWxsYmFjayhmc20sIGZzbVsnb25iZWZvcmUnICsgbmFtZV0sICAgICAgICAgICAgICAgICAgICAgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpOyB9LFxyXG4gICAgYWZ0ZXJFdmVudDogIGZ1bmN0aW9uKGZzbSwgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpIHsgcmV0dXJuIFN0YXRlTWFjaGluZS5kb0NhbGxiYWNrKGZzbSwgZnNtWydvbmFmdGVyJyAgKyBuYW1lXSB8fCBmc21bJ29uJyArIG5hbWVdLCBuYW1lLCBmcm9tLCB0bywgYXJncyk7IH0sXHJcbiAgICBsZWF2ZVN0YXRlOiAgZnVuY3Rpb24oZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncykgeyByZXR1cm4gU3RhdGVNYWNoaW5lLmRvQ2FsbGJhY2soZnNtLCBmc21bJ29ubGVhdmUnICArIGZyb21dLCAgICAgICAgICAgICAgICAgICAgIG5hbWUsIGZyb20sIHRvLCBhcmdzKTsgfSxcclxuICAgIGVudGVyU3RhdGU6ICBmdW5jdGlvbihmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKSB7IHJldHVybiBTdGF0ZU1hY2hpbmUuZG9DYWxsYmFjayhmc20sIGZzbVsnb25lbnRlcicgICsgdG9dICAgfHwgZnNtWydvbicgKyB0b10sICAgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpOyB9LFxyXG4gICAgY2hhbmdlU3RhdGU6IGZ1bmN0aW9uKGZzbSwgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpIHsgcmV0dXJuIFN0YXRlTWFjaGluZS5kb0NhbGxiYWNrKGZzbSwgZnNtWydvbmNoYW5nZXN0YXRlJ10sICAgICAgICAgICAgICAgICAgICAgICBuYW1lLCBmcm9tLCB0bywgYXJncyk7IH0sXHJcblxyXG5cclxuICAgIGJ1aWxkRXZlbnQ6IGZ1bmN0aW9uKG5hbWUsIG1hcCkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmcm9tICA9IHRoaXMuY3VycmVudDtcclxuICAgICAgICB2YXIgdG8gICAgPSBtYXBbZnJvbV0gfHwgbWFwW1N0YXRlTWFjaGluZS5XSUxEQ0FSRF0gfHwgZnJvbTtcclxuICAgICAgICB2YXIgYXJncyAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpOyAvLyB0dXJuIGFyZ3VtZW50cyBpbnRvIHB1cmUgYXJyYXlcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbilcclxuICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKG5hbWUsIGZyb20sIHRvLCBhcmdzLCBTdGF0ZU1hY2hpbmUuRXJyb3IuUEVORElOR19UUkFOU0lUSU9OLCBcImV2ZW50IFwiICsgbmFtZSArIFwiIGluYXBwcm9wcmlhdGUgYmVjYXVzZSBwcmV2aW91cyB0cmFuc2l0aW9uIGRpZCBub3QgY29tcGxldGVcIik7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNhbm5vdChuYW1lKSlcclxuICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKG5hbWUsIGZyb20sIHRvLCBhcmdzLCBTdGF0ZU1hY2hpbmUuRXJyb3IuSU5WQUxJRF9UUkFOU0lUSU9OLCBcImV2ZW50IFwiICsgbmFtZSArIFwiIGluYXBwcm9wcmlhdGUgaW4gY3VycmVudCBzdGF0ZSBcIiArIHRoaXMuY3VycmVudCk7XHJcblxyXG4gICAgICAgIGlmIChmYWxzZSA9PT0gU3RhdGVNYWNoaW5lLmJlZm9yZUV2ZW50KHRoaXMsIG5hbWUsIGZyb20sIHRvLCBhcmdzKSlcclxuICAgICAgICAgIHJldHVybiBTdGF0ZU1hY2hpbmUuUmVzdWx0LkNBTkNFTExFRDtcclxuXHJcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XHJcbiAgICAgICAgICBTdGF0ZU1hY2hpbmUuYWZ0ZXJFdmVudCh0aGlzLCBuYW1lLCBmcm9tLCB0bywgYXJncyk7XHJcbiAgICAgICAgICByZXR1cm4gU3RhdGVNYWNoaW5lLlJlc3VsdC5OT1RSQU5TSVRJT047XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBwcmVwYXJlIGEgdHJhbnNpdGlvbiBtZXRob2QgZm9yIHVzZSBFSVRIRVIgbG93ZXIgZG93biwgb3IgYnkgY2FsbGVyIGlmIHRoZXkgd2FudCBhbiBhc3luYyB0cmFuc2l0aW9uIChpbmRpY2F0ZWQgYnkgYW4gQVNZTkMgcmV0dXJuIHZhbHVlIGZyb20gbGVhdmVTdGF0ZSlcclxuICAgICAgICB2YXIgZnNtID0gdGhpcztcclxuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGZzbS50cmFuc2l0aW9uID0gbnVsbDsgLy8gdGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgZXZlciBiZSBjYWxsZWQgb25jZVxyXG4gICAgICAgICAgZnNtLmN1cnJlbnQgPSB0bztcclxuICAgICAgICAgIFN0YXRlTWFjaGluZS5lbnRlclN0YXRlKCBmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKTtcclxuICAgICAgICAgIFN0YXRlTWFjaGluZS5jaGFuZ2VTdGF0ZShmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKTtcclxuICAgICAgICAgIFN0YXRlTWFjaGluZS5hZnRlckV2ZW50KCBmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbi5jYW5jZWwgPSBmdW5jdGlvbigpIHsgLy8gcHJvdmlkZSBhIHdheSBmb3IgY2FsbGVyIHRvIGNhbmNlbCBhc3luYyB0cmFuc2l0aW9uIGlmIGRlc2lyZWQgKGlzc3VlICMyMilcclxuICAgICAgICAgIGZzbS50cmFuc2l0aW9uID0gbnVsbDtcclxuICAgICAgICAgIFN0YXRlTWFjaGluZS5hZnRlckV2ZW50KGZzbSwgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBsZWF2ZSA9IFN0YXRlTWFjaGluZS5sZWF2ZVN0YXRlKHRoaXMsIG5hbWUsIGZyb20sIHRvLCBhcmdzKTtcclxuICAgICAgICBpZiAoZmFsc2UgPT09IGxlYXZlKSB7XHJcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgcmV0dXJuIFN0YXRlTWFjaGluZS5SZXN1bHQuQ0FOQ0VMTEVEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcImFzeW5jXCIgPT09IGxlYXZlKSB7XHJcbiAgICAgICAgICByZXR1cm4gU3RhdGVNYWNoaW5lLlJlc3VsdC5BU1lOQztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uKVxyXG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oKTsgLy8gaW4gY2FzZSB1c2VyIG1hbnVhbGx5IGNhbGxlZCB0cmFuc2l0aW9uKCkgYnV0IGZvcmdvdCB0byByZXR1cm4gQVNZTkNcclxuICAgICAgICAgIHJldHVybiBTdGF0ZU1hY2hpbmUuUmVzdWx0LlNVQ0NFRURFRDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxufTsgLy8gU3RhdGVNYWNoaW5lXHJcblxyXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuLyppZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZGVmaW5lKSB7XHJcbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7IHJldHVybiBTdGF0ZU1hY2hpbmU7IH0pO1xyXG59XHJcbmVsc2UgeyovXHJcbndpbmRvdy5TdGF0ZU1hY2hpbmUgPSBTdGF0ZU1hY2hpbmU7XHJcbi8qfSovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlTWFjaGluZTtcclxuXHJcbiIsInZhciBET01UcmFuc2Zvcm1GZXRjaGVyID0gcmVxdWlyZShcIi4uL3RyYW5zZm9ybS1mZXRjaGVyLmpzXCIpO1xyXG52YXIgRGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xyXG52YXIgRGF0YU5vZGUgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLkRhdGFOb2RlO1xyXG52YXIgZ2V0Q29tcHV0ZURhdGFmbG93VXJsID0gcmVxdWlyZShcIi4uLy4uL3hmbG93L2ludGVyZmFjZS9ncmFwaC5qc1wiKS5nZXRDb21wdXRlRGF0YWZsb3dVcmw7XHJcbnZhciBBc3NldCA9IHJlcXVpcmUoXCIuLi8uLi9hc3NldC9hc3NldC5qc1wiKS5Bc3NldDtcclxudmFyIFN1YkRhdGEgPSByZXF1aXJlKFwiLi4vLi4vYXNzZXQvYXNzZXQuanNcIikuU3ViRGF0YTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgZGlzcGF0Y2hDdXN0b21FdmVudCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9taXNjLmpzXCIpLmRpc3BhdGNoQ3VzdG9tRXZlbnQ7XHJcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL3Jlc291cmNlbWFuYWdlci5qc1wiKS5SZXNvdXJjZTtcclxuXHJcbnZhciBOb2RlQWRhcHRlciA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXIuanNcIikuTm9kZUFkYXB0ZXI7XHJcbnZhciBjcmVhdGVDbGFzcyA9IFhNTDNELmNyZWF0ZUNsYXNzO1xyXG52YXIgQWRhcHRlckhhbmRsZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXJoYW5kbGUuanNcIik7XHJcblxyXG5cclxudmFyIEFzc2V0QWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XHJcbiAgICBOb2RlQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpO1xyXG5cclxuICAgIC8vIE5vZGUgaGFuZGxlcyBmb3Igc3JjIGFuZCBwcm90b1xyXG4gICAgdGhpcy5hc3NldCA9IG51bGw7XHJcbiAgICBpZiAobm9kZS5sb2NhbE5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJtb2RlbFwiKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1GZXRjaGVyID0gbmV3IERPTVRyYW5zZm9ybUZldGNoZXIodGhpcywgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2Zvcm1cIik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5jcmVhdGVDbGFzcyhBc3NldEFkYXB0ZXIsIE5vZGVBZGFwdGVyKTtcclxuXHJcbkFzc2V0QWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuYXNzZXQgPSBuZXcgQXNzZXQodGhpcy5ub2RlKTtcclxuICAgIHRoaXMuYXNzZXQuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcyk7XHJcbiAgICB0aGlzLmFzc2V0LnNldE5hbWUodGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcIm5hbWVcIikpO1xyXG4gICAgdXBkYXRlQWRhcHRlckhhbmRsZSh0aGlzLCBcInNyY1wiLCB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwic3JjXCIpKTtcclxuICAgIHVwZGF0ZVBpY2tGaWx0ZXIodGhpcyk7XHJcbiAgICB1cGRhdGVDaGlsZHJlbih0aGlzKTtcclxuICAgIHNldFNoYWRlclVybCh0aGlzLCB0aGlzLmFzc2V0KTtcclxuICAgIHRoaXMudHJhbnNmb3JtRmV0Y2hlciAmJiB0aGlzLnRyYW5zZm9ybUZldGNoZXIudXBkYXRlKCk7XHJcbn07XHJcblxyXG5Bc3NldEFkYXB0ZXIucHJvdG90eXBlLm9uQXNzZXRMb2FkQ2hhbmdlID0gZnVuY3Rpb24gKGFzc2V0LCBuZXdMZXZlbCwgb2xkTGV2ZWwpIHtcclxuICAgIGlmIChuZXdMZXZlbCA9PSBJbmZpbml0eSkge1xyXG4gICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQodGhpcy5ub2RlLCAnbG9hZCcsIGZhbHNlLCB0cnVlLCBudWxsKTtcclxuICAgIH0gZWxzZSBpZiAobmV3TGV2ZWwgPiBvbGRMZXZlbCkge1xyXG4gICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQodGhpcy5ub2RlLCAncHJvZ3Jlc3MnLCBmYWxzZSwgdHJ1ZSwgbnVsbCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Bc3NldEFkYXB0ZXIucHJvdG90eXBlLmdldEFzc2V0Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hc3NldC5nZXRQcm9ncmVzc0xldmVsKCkgPT0gSW5maW5pdHk7XHJcbn07XHJcbkFzc2V0QWRhcHRlci5wcm90b3R5cGUuZ2V0QXNzZXRQcm9ncmVzc0xldmVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXNzZXQuZ2V0UHJvZ3Jlc3NMZXZlbCgpO1xyXG59O1xyXG5cclxuQXNzZXRBZGFwdGVyLnByb3RvdHlwZS5nZXRBc3NldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmFzc2V0O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4oYWRhcHRlcikge1xyXG4gICAgYWRhcHRlci5hc3NldC5jbGVhckNoaWxkcmVuKCk7XHJcbiAgICBhZGFwdGVyLmFzc2V0LmNsZWFyU3ViQXNzZXRzKCk7XHJcbiAgICBmb3IgKHZhciBjaGlsZCA9IGFkYXB0ZXIubm9kZS5maXJzdEVsZW1lbnRDaGlsZDsgY2hpbGQgIT09IG51bGw7IGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nKSB7XHJcbiAgICAgICAgdmFyIHN1YmFkYXB0ZXIgPSBhZGFwdGVyLmZhY3RvcnkuZ2V0QWRhcHRlcihjaGlsZCk7XHJcbiAgICAgICAgaWYgKHN1YmFkYXB0ZXIgJiYgc3ViYWRhcHRlci5nZXRBc3NldCkge1xyXG4gICAgICAgICAgICBhZGFwdGVyLmFzc2V0LmFwcGVuZFN1YkFzc2V0KHN1YmFkYXB0ZXIuZ2V0QXNzZXQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdWJhZGFwdGVyICYmIHN1YmFkYXB0ZXIuYXNzZXRFbnRyeSkge1xyXG4gICAgICAgICAgICBhZGFwdGVyLmFzc2V0LmFwcGVuZENoaWxkKHN1YmFkYXB0ZXIuYXNzZXRFbnRyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVBZGFwdGVySGFuZGxlKGFkYXB0ZXIsIGtleSwgdXJsKSB7XHJcbiAgICB2YXIgYWRhcHRlckhhbmRsZSA9IGFkYXB0ZXIuZ2V0QWRhcHRlckhhbmRsZSh1cmwpLCBzdGF0dXMgPSAoYWRhcHRlckhhbmRsZSAmJiBhZGFwdGVySGFuZGxlLnN0YXR1cyk7XHJcblxyXG4gICAgaWYgKHN0YXR1cyA9PT0gQWRhcHRlckhhbmRsZS5TVEFUVVMuTk9UX0ZPVU5EKSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IG9mIHVybCAnXCIgKyBhZGFwdGVySGFuZGxlLnVybCArIFwiJyBmb3IgXCIgKyBrZXksIGFkYXB0ZXIubm9kZSk7XHJcbiAgICB9XHJcbiAgICBhZGFwdGVyLmNvbm5lY3RBZGFwdGVySGFuZGxlKGtleSwgYWRhcHRlckhhbmRsZSk7XHJcbiAgICBhZGFwdGVyLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkKGtleSwgYWRhcHRlckhhbmRsZSA/IGFkYXB0ZXJIYW5kbGUuZ2V0QWRhcHRlcigpIDogbnVsbCwgc3RhdHVzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlQXNzZXRMb2FkU3RhdGUoZGF0YUFkYXB0ZXIpIHtcclxuICAgIHZhciBsb2FkaW5nID0gZmFsc2UsIGhhbmRsZTtcclxuXHJcbiAgICBoYW5kbGUgPSBkYXRhQWRhcHRlci5nZXRDb25uZWN0ZWRBZGFwdGVySGFuZGxlKFwic3JjXCIpO1xyXG4gICAgaWYgKGhhbmRsZSAmJiBoYW5kbGUuc3RhdHVzID09PSBBZGFwdGVySGFuZGxlLlNUQVRVUy5MT0FESU5HKSB7XHJcbiAgICAgICAgbG9hZGluZyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBkYXRhQWRhcHRlci5hc3NldC5zZXRMb2FkaW5nKGxvYWRpbmcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVQaWNrRmlsdGVyKGFkYXB0ZXIpIHtcclxuICAgIGlmICghYWRhcHRlci5ub2RlLmhhc0F0dHJpYnV0ZShcInBpY2tcIikpXHJcbiAgICAgICAgYWRhcHRlci5hc3NldC5zZXRQaWNrRmlsdGVyKG51bGwpOyBlbHNlIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBhZGFwdGVyLm5vZGUuZ2V0QXR0cmlidXRlKFwicGlja1wiKTtcclxuICAgICAgICBhZGFwdGVyLmFzc2V0LnNldFBpY2tGaWx0ZXIodmFsdWUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5Bc3NldEFkYXB0ZXIucHJvdG90eXBlLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUsIGFkYXB0ZXIpIHtcclxuICAgIGlmIChhdHRyaWJ1dGVOYW1lID09IFwic3JjXCIpXHJcbiAgICAgICAgdGhpcy5hc3NldC5zZXRTcmNBc3NldChhZGFwdGVyICYmIGFkYXB0ZXIuZ2V0QXNzZXQoKSB8fCBudWxsKTtcclxuICAgIHVwZGF0ZUFzc2V0TG9hZFN0YXRlKHRoaXMpO1xyXG59O1xyXG5cclxuQXNzZXRBZGFwdGVyLnByb3RvdHlwZS5vblRyYW5zZm9ybUNoYW5nZSA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgbWF0cml4KSB7XHJcbiAgICB0aGlzLmFzc2V0LnNldFRyYW5zZm9ybShtYXRyaXgpO1xyXG59O1xyXG5cclxuXHJcbkFzc2V0QWRhcHRlci5wcm90b3R5cGUubm90aWZ5Q2hhbmdlZCA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgIGlmIChldnQudHlwZSA9PSBFdmVudHMuQURBUFRFUl9IQU5ETEVfQ0hBTkdFRCkge1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkQWRhcHRlckNoYW5nZWQoZXZ0LmtleSwgZXZ0LmFkYXB0ZXIpO1xyXG4gICAgICAgIGlmIChldnQuaGFuZGxlU3RhdHVzID09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORCkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBmaW5kIDxhc3NldD4gZWxlbWVudCBvZiB1cmwgJ1wiICsgZXZ0LnVybCArIFwiJyBmb3IgXCIgKyBldnQua2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGV2dC50eXBlID09IEV2ZW50cy5OT0RFX0lOU0VSVEVEKSB7XHJcbiAgICAgICAgdXBkYXRlQ2hpbGRyZW4odGhpcyk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChldnQudHlwZSA9PSBFdmVudHMuTk9ERV9SRU1PVkVEKSB7XHJcbiAgICAgICAgdXBkYXRlQ2hpbGRyZW4odGhpcyk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChldnQudHlwZSA9PSBFdmVudHMuVkFMVUVfTU9ESUZJRUQpIHtcclxuICAgICAgICB2YXIgYXR0ciA9IGV2dC5tdXRhdGlvbi5hdHRyaWJ1dGVOYW1lO1xyXG4gICAgICAgIHN3aXRjaCAoYXR0cikge1xyXG4gICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5hc3NldC5zZXROYW1lKHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic2hhZGVyXCI6XHJcbiAgICAgICAgICAgICAgICBzZXRTaGFkZXJVcmwodGhpcywgdGhpcy5hc3NldCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInN0eWxlXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2Zvcm1cIjpcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtRmV0Y2hlciAmJiB0aGlzLnRyYW5zZm9ybUZldGNoZXIudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInNyY1wiOlxyXG4gICAgICAgICAgICAgICAgdXBkYXRlQWRhcHRlckhhbmRsZSh0aGlzLCBcInNyY1wiLCB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwic3JjXCIpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicGlja1wiOlxyXG4gICAgICAgICAgICAgICAgdXBkYXRlUGlja0ZpbHRlcih0aGlzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGVsc2UgaWYgKGV2dC50eXBlID09IEV2ZW50cy5USElTX1JFTU9WRUQpIHtcclxuICAgICAgICB0aGlzLmNsZWFyQWRhcHRlckhhbmRsZXMoKTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBBc3NldERhdGFBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIHRoaXMuYXNzZXREYXRhID0gdHJ1ZTtcclxuICAgIERhdGFBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcblxyXG4gICAgLy8gTm9kZSBoYW5kbGVzIGZvciBzcmMgYW5kIHByb3RvXHJcbiAgICB0aGlzLmFzc2V0RW50cnkgPSBudWxsO1xyXG4gICAgdGhpcy5vdXRwdXRYZmxvd05vZGUgPSBudWxsO1xyXG59O1xyXG5jcmVhdGVDbGFzcyhBc3NldERhdGFBZGFwdGVyLCBEYXRhQWRhcHRlcik7XHJcblxyXG5Bc3NldERhdGFBZGFwdGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgRGF0YUFkYXB0ZXIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcclxuICAgIHRoaXMub3V0cHV0WGZsb3dOb2RlID0gbmV3IERhdGFOb2RlKGZhbHNlKTtcclxuICAgIHRoaXMuYXNzZXRFbnRyeSA9IG5ldyBTdWJEYXRhKHRoaXMub3V0cHV0WGZsb3dOb2RlLCB0aGlzLmdldFhmbG93Tm9kZSgpLCB0aGlzLm5vZGUpO1xyXG4gICAgdGhpcy5hc3NldEVudHJ5LnNldE5hbWUodGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcIm5hbWVcIikpO1xyXG4gICAgdXBkYXRlQ2xhc3NOYW1lcyh0aGlzKTtcclxuICAgIHVwZGF0ZVBvc3RDb21wdXRlKHRoaXMpO1xyXG4gICAgdGhpcy5hc3NldEVudHJ5LnNldFBvc3RGaWx0ZXIodGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcImZpbHRlclwiKSk7XHJcbiAgICB1cGRhdGVJbmNsdWRlcyh0aGlzLmFzc2V0RW50cnksIHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJpbmNsdWRlc1wiKSk7XHJcbn07XHJcblxyXG5Bc3NldERhdGFBZGFwdGVyLnByb3RvdHlwZS5jb25uZWN0ZWRBZGFwdGVyQ2hhbmdlZCA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lLCBhZGFwdGVyKSB7XHJcbiAgICBpZiAoYXR0cmlidXRlTmFtZSA9PSBcInBvc3REYXRhZmxvd1wiKSB7XHJcbiAgICAgICAgdGhpcy5hc3NldEVudHJ5LnNldFBvc3REYXRhZmxvdyhhZGFwdGVyICYmIGFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCkgfHwgbnVsbCk7XHJcbiAgICAgICAgdXBkYXRlU3ViRGF0YUxvYWRTdGF0ZSh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgRGF0YUFkYXB0ZXIucHJvdG90eXBlLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkLmNhbGwodGhpcywgYXR0cmlidXRlTmFtZSwgYWRhcHRlcik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Bc3NldERhdGFBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgRGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQuY2FsbCh0aGlzLCBldnQpO1xyXG4gICAgaWYgKGV2dC50eXBlID09IEV2ZW50cy5WQUxVRV9NT0RJRklFRCkge1xyXG4gICAgICAgIHZhciBhdHRyID0gZXZ0Lm11dGF0aW9uLmF0dHJpYnV0ZU5hbWU7XHJcbiAgICAgICAgc3dpdGNoIChhdHRyKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2V0RW50cnkuc2V0TmFtZSh0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImNvbXB1dGVcIjpcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVBvc3RDb21wdXRlKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjbGFzc1wiOlxyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ2xhc3NOYW1lcyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2V0RW50cnkuc2V0UG9zdEZpbHRlcih0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwiZmlsdGVyXCIpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiaW5jbHVkZXNcIjpcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUluY2x1ZGVzKHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJpbmNsdWRlc1wiKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59O1xyXG5cclxuQXNzZXREYXRhQWRhcHRlci5wcm90b3R5cGUub25UcmFuc2Zvcm1DaGFuZ2UgPSBmdW5jdGlvbiAoYXR0ck5hbWUsIG1hdHJpeCkge1xyXG4gICAgdGhpcy5hc3NldEVudHJ5LnNldFRyYW5zZm9ybShtYXRyaXgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdXBkYXRlSW5jbHVkZXMoYXNzZXRFbnRyeSwgaW5jbHVkZVN0cmluZykge1xyXG4gICAgaWYgKCFpbmNsdWRlU3RyaW5nKVxyXG4gICAgICAgIGFzc2V0RW50cnkuc2V0SW5jbHVkZXMoW10pOyBlbHNlXHJcbiAgICAgICAgYXNzZXRFbnRyeS5zZXRJbmNsdWRlcyhpbmNsdWRlU3RyaW5nLnRyaW0oKS5zcGxpdCgvXFxzKixcXHMqLykpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVDbGFzc05hbWVzKGFkYXB0ZXIpIHtcclxuICAgIHZhciBjbGFzc05hbWVzID0gYWRhcHRlci5ub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO1xyXG4gICAgYWRhcHRlci5hc3NldEVudHJ5LnNldENsYXNzTmFtZXNTdHJpbmcoY2xhc3NOYW1lcylcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlUG9zdENvbXB1dGUoYWRhcHRlcikge1xyXG4gICAgdmFyIGNvbXB1dGVTdHJpbmcgPSBhZGFwdGVyLm5vZGUuZ2V0QXR0cmlidXRlKFwiY29tcHV0ZVwiKTtcclxuICAgIHZhciBkYXRhZmxvd1VybCA9IGdldENvbXB1dGVEYXRhZmxvd1VybChjb21wdXRlU3RyaW5nKTtcclxuICAgIGlmIChkYXRhZmxvd1VybCkge1xyXG4gICAgICAgIHVwZGF0ZUFkYXB0ZXJIYW5kbGUoYWRhcHRlciwgXCJwb3N0RGF0YWZsb3dcIiwgZGF0YWZsb3dVcmwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBhZGFwdGVyLmRpc2Nvbm5lY3RBZGFwdGVySGFuZGxlKFwicG9zdERhdGFmbG93XCIpO1xyXG4gICAgICAgIHVwZGF0ZVN1YkRhdGFMb2FkU3RhdGUoYWRhcHRlcik7XHJcbiAgICB9XHJcbiAgICBhZGFwdGVyLmFzc2V0RW50cnkuc2V0UG9zdENvbXB1dGUoY29tcHV0ZVN0cmluZyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVN1YkRhdGFMb2FkU3RhdGUoZGF0YUFkYXB0ZXIpIHtcclxuICAgIHZhciBsb2FkaW5nID0gZmFsc2UsIGhhbmRsZTtcclxuXHJcbiAgICBoYW5kbGUgPSBkYXRhQWRhcHRlci5nZXRDb25uZWN0ZWRBZGFwdGVySGFuZGxlKFwicG9zdERhdGFmbG93XCIpO1xyXG4gICAgaWYgKGhhbmRsZSAmJiBoYW5kbGUuc3RhdHVzID09PSBBZGFwdGVySGFuZGxlLlNUQVRVUy5MT0FESU5HKSB7XHJcbiAgICAgICAgbG9hZGluZyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBkYXRhQWRhcHRlci5hc3NldEVudHJ5LnNldExvYWRpbmcobG9hZGluZyk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBzZXRTaGFkZXJVcmwoYWRhcHRlciwgZGVzdCkge1xyXG4gICAgdmFyIG5vZGUgPSBhZGFwdGVyLm5vZGU7XHJcbiAgICB2YXIgc2hhZGVyVXJsID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJzaGFkZXJcIik7XHJcbiAgICBpZiAoc2hhZGVyVXJsKSB7XHJcbiAgICAgICAgdmFyIHNoYWRlcklkID0gUmVzb3VyY2UuZ2V0QWJzb2x1dGVVUkkobm9kZS5vd25lckRvY3VtZW50Ll9kb2N1bWVudFVSTCB8fCBub2RlLm93bmVyRG9jdW1lbnQuVVJMLCBzaGFkZXJVcmwpO1xyXG4gICAgICAgIGRlc3Quc2V0U2hhZGVyKHNoYWRlcklkLnRvU3RyaW5nKCkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBkZXN0LnNldFNoYWRlcihudWxsKTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIEFzc2V0TWVzaEFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgQXNzZXREYXRhQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpO1xyXG4gICAgdGhpcy50cmFuc2Zvcm1GZXRjaGVyID0gbmV3IERPTVRyYW5zZm9ybUZldGNoZXIodGhpcywgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2Zvcm1cIik7XHJcbn07XHJcbmNyZWF0ZUNsYXNzKEFzc2V0TWVzaEFkYXB0ZXIsIEFzc2V0RGF0YUFkYXB0ZXIpO1xyXG5cclxuQXNzZXRNZXNoQWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIEFzc2V0RGF0YUFkYXB0ZXIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcclxuICAgIHNldFNoYWRlclVybCh0aGlzLCB0aGlzLmFzc2V0RW50cnkpO1xyXG4gICAgdGhpcy5hc3NldEVudHJ5LnNldE1lc2hUeXBlKHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpIHx8IFwidHJpYW5nbGVzXCIpO1xyXG4gICAgdGhpcy5hc3NldEVudHJ5LnNldE1hdGNoRmlsdGVyKHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJtYXRjaFwiKSk7XHJcbiAgICB0aGlzLnRyYW5zZm9ybUZldGNoZXIudXBkYXRlKCk7XHJcbn07XHJcbkFzc2V0TWVzaEFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICBBc3NldERhdGFBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkLmNhbGwodGhpcywgZXZ0KTtcclxuICAgIGlmIChldnQudHlwZSA9PSBFdmVudHMuVkFMVUVfTU9ESUZJRUQpIHtcclxuICAgICAgICB2YXIgYXR0ciA9IGV2dC5tdXRhdGlvbi5hdHRyaWJ1dGVOYW1lO1xyXG4gICAgICAgIHN3aXRjaCAoYXR0cikge1xyXG4gICAgICAgICAgICBjYXNlIFwic2hhZGVyXCI6XHJcbiAgICAgICAgICAgICAgICBzZXRTaGFkZXJVcmwodGhpcywgdGhpcy5hc3NldEVudHJ5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibWF0Y2hcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXRFbnRyeS5zZXRNYXRjaEZpbHRlcih0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwibWF0Y2hcIikpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwidHJhbnNmb3JtXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUZldGNoZXIudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInR5cGVcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXRFbnRyeS5zZXRNZXNoVHlwZSh0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSB8fCBcInRyaWFuZ2xlc1wiKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEFzc2V0QWRhcHRlcjogQXNzZXRBZGFwdGVyLCBBc3NldE1lc2hBZGFwdGVyOiBBc3NldE1lc2hBZGFwdGVyLCBBc3NldERhdGFBZGFwdGVyOiBBc3NldERhdGFBZGFwdGVyXHJcbn07XHJcbiIsInZhciBDb21wdXRlUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5Db21wdXRlUmVxdWVzdDtcclxudmFyIHNldFNoYWRlckNvbnN0YW50ID0gcmVxdWlyZShcIi4uLy4uL3hmbG93L3Byb2Nlc3NpbmcvdnMtY29ubmVjdC5qc1wiKS5zZXRTaGFkZXJDb25zdGFudDtcclxudmFyIHJlZ2lzdGVyRXJyb3JDYWxsYmFjayA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9iYXNlLmpzXCIpLnJlZ2lzdGVyRXJyb3JDYWxsYmFjaztcclxudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcbnZhciBVUkkgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvdXJpLmpzXCIpLlVSSTtcclxuXHJcbnZhciBOb2RlQWRhcHRlciA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXIuanNcIikuTm9kZUFkYXB0ZXI7XHJcbnZhciBjcmVhdGVDbGFzcyA9IFhNTDNELmNyZWF0ZUNsYXNzO1xyXG5cclxuLyoqXHJcbiAqIEBleHRlbmRzIE5vZGVBZGFwdGVyXHJcbiAqIEBhYnN0cmFjdFxyXG4gKlxyXG4gKiBAcGFyYW0gZmFjdG9yeVxyXG4gKiBAcGFyYW0gbm9kZVxyXG4gKi9cclxudmFyIEJhc2VEYXRhQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XHJcbiAgICBOb2RlQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpO1xyXG4gICAgdGhpcy54Zmxvd0RhdGFOb2RlID0gbnVsbDtcclxufTtcclxuY3JlYXRlQ2xhc3MoQmFzZURhdGFBZGFwdGVyLCBOb2RlQWRhcHRlcik7XHJcblxyXG5cclxuQmFzZURhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRYZmxvd05vZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy54Zmxvd0RhdGFOb2RlO1xyXG59O1xyXG5cclxuQmFzZURhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRDb21wdXRlUmVxdWVzdCA9IGZ1bmN0aW9uIChmaWx0ZXIsIGNhbGxiYWNrKSB7XHJcbiAgICByZXR1cm4gbmV3IENvbXB1dGVSZXF1ZXN0KHRoaXMueGZsb3dEYXRhTm9kZSwgZmlsdGVyLCBjYWxsYmFjayk7XHJcbn07XHJcblxyXG5CYXNlRGF0YUFkYXB0ZXIucHJvdG90eXBlLmdldENvbXB1dGVSZXN1bHQgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy54Zmxvd0RhdGFOb2RlLl9nZXRSZXN1bHQoWEMuUkVTVUxUX1RZUEUuQ09NUFVURSwgZmlsdGVyKTtcclxufTtcclxuXHJcbkJhc2VEYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0T3V0cHV0TmFtZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy54Zmxvd0RhdGFOb2RlLmdldE91dHB1dE5hbWVzKCk7XHJcbn07XHJcblxyXG5CYXNlRGF0YUFkYXB0ZXIucHJvdG90eXBlLmdldE91dHB1dENoYW5uZWxJbmZvID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHJldHVybiB0aGlzLnhmbG93RGF0YU5vZGUuZ2V0T3V0cHV0Q2hhbm5lbEluZm8obmFtZSk7XHJcbn07XHJcblxyXG5zZXRTaGFkZXJDb25zdGFudChYQy5TSEFERVJfQ09OU1RBTlRfS0VZLk9CSkVDVF9JRCwgXCJvYmplY3RJRFwiKTtcclxuc2V0U2hhZGVyQ29uc3RhbnQoWEMuU0hBREVSX0NPTlNUQU5UX0tFWS5TQ1JFRU5fVFJBTlNGT1JNLCBcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIik7XHJcbnNldFNoYWRlckNvbnN0YW50KFhDLlNIQURFUl9DT05TVEFOVF9LRVkuU0NSRUVOX1RSQU5TRk9STV9OT1JNQUwsIFwibW9kZWxWaWV3UHJvamVjdGlvbk5vcm1hbE1hdHJpeFwiKTtcclxuc2V0U2hhZGVyQ29uc3RhbnQoWEMuU0hBREVSX0NPTlNUQU5UX0tFWS5WSUVXX1RSQU5TRk9STSwgXCJtb2RlbFZpZXdNYXRyaXhcIik7XHJcbnNldFNoYWRlckNvbnN0YW50KFhDLlNIQURFUl9DT05TVEFOVF9LRVkuVklFV19UUkFOU0ZPUk1fTk9STUFMLCBcIm1vZGVsVmlld01hdHJpeE5cIik7XHJcbnNldFNoYWRlckNvbnN0YW50KFhDLlNIQURFUl9DT05TVEFOVF9LRVkuV09STERfVFJBTlNGT1JNLCBcIm1vZGVsTWF0cml4XCIpO1xyXG5yZWdpc3RlckVycm9yQ2FsbGJhY2soZnVuY3Rpb24obWVzc2FnZSwgeGZsb3dOb2RlKXtcclxuICAgIG1lc3NhZ2UgPSBcIlhmbG93OiBcIiArIG1lc3NhZ2U7XHJcbiAgICB2YXIgdXNlckRhdGEgPSB4Zmxvd05vZGUgPyB4Zmxvd05vZGUudXNlckRhdGEgOiBudWxsO1xyXG4gICAgaWYgKHVzZXJEYXRhICYmIHVzZXJEYXRhLm93bmVyRG9jdW1lbnQpIHtcclxuICAgICAgICBpZiAodXNlckRhdGEub3duZXJEb2N1bWVudCA9PT0gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IobWVzc2FnZSwgdXNlckRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh1c2VyRGF0YS5pZCkge1xyXG4gICAgICAgICAgICB2YXIgdXJpID0gbmV3IFVSSShcIiNcIiArIHVzZXJEYXRhLmlkKTtcclxuICAgICAgICAgICAgdXJpID0gdXJpLmdldEFic29sdXRlVVJJKHVzZXJEYXRhLm93bmVyRG9jdW1lbnQuX2RvY3VtZW50VVJMIHx8IHVzZXJEYXRhLm93bmVyRG9jdW1lbnQuVVJMKTtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IobWVzc2FnZSwgXCJFeHRlcm5hbCBOb2RlOiBcIiArIHVyaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihtZXNzYWdlLCBcIkV4dGVybmFsIERvY3VtZW50OiBcIiArIHVzZXJEYXRhLm93bmVyRG9jdW1lbnQuVVJMKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdXNlckRhdGEgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKG1lc3NhZ2UsIHVzZXJEYXRhKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFzZURhdGFBZGFwdGVyO1xyXG4iLCJ2YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XHJcbnZhciBOb2RlQWRhcHRlciA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXIuanNcIikuTm9kZUFkYXB0ZXI7XHJcblxyXG4vKipcclxuICogRGF0YUFkYXB0ZXIgaGFuZGxpbmcgYSA8Y29tcHV0ZT4gZWxlbWVudFxyXG4gKiBAcGFyYW0ge0FkYXB0ZXJGYWN0b3J5fSBmYWN0b3J5XHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBDb21wdXRlRGF0YUFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgTm9kZUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoQ29tcHV0ZURhdGFBZGFwdGVyLCBOb2RlQWRhcHRlcik7XHJcblxyXG5Db21wdXRlRGF0YUFkYXB0ZXIucHJvdG90eXBlLmdldENvbXB1dGVDb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubm9kZS52YWx1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gZXZ0IG5vdGlmaWNhdGlvbiBvZiB0eXBlIFhNTDNELk5vdGlmaWNhdGlvblxyXG4gKi9cclxuQ29tcHV0ZURhdGFBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgc3dpdGNoIChldnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgRXZlbnRzLlZBTFVFX01PRElGSUVEOlxyXG4gICAgICAgIGNhc2UgRXZlbnRzLk5PREVfSU5TRVJURUQ6XHJcbiAgICAgICAgY2FzZSBFdmVudHMuTk9ERV9SRU1PVkVEOlxyXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5ub2RlLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRBZGFwdGVyID0gdGhpcy5mYWN0b3J5LmdldEFkYXB0ZXIocGFyZW50KTtcclxuICAgICAgICAgICAgICAgIHBhcmVudEFkYXB0ZXIgJiYgcGFyZW50QWRhcHRlci51cGRhdGVYZmxvd05vZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb21wdXRlRGF0YUFkYXB0ZXI7XHJcbiIsInZhciBCYXNlRGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xyXG52YXIgRGF0YU5vZGUgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLkRhdGFOb2RlO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgZGlzcGF0Y2hDdXN0b21FdmVudCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9taXNjLmpzXCIpLmRpc3BhdGNoQ3VzdG9tRXZlbnQ7XHJcbnZhciBBZGFwdGVySGFuZGxlID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvYWRhcHRlcmhhbmRsZS5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgRGF0YUFkYXB0ZXIgaW1wbGVtZW50cyB0aGVcclxuICogRGF0YUNvbGxlY3RvciBjb25jZXB0IGFuZCBzZXJ2ZXMgYXMgYmFzaXMgb2YgYWxsIERhdGFBZGFwdGVyIGNsYXNzZXMuIEluXHJcbiAqIGdlbmVyYWwsIGEgRGF0YUFkYXB0ZXIgaXMgYXNzb2NpYXRlZCB3aXRoIGFuIGVsZW1lbnQgbm9kZSB3aGljaCB1c2VzXHJcbiAqIGdlbmVyaWMgZGF0YSBhbmQgc2hvdWxkIGJlIGluc3RhbnRpYXRlZCB2aWFcclxuICogWE1MM0REYXRhQWRhcHRlckZhY3RvcnkgdG8gZW5zdXJlIHByb3BlciBmdW5jdGlvbmFsaXR5LlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBZGFwdGVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKlxyXG4gKiBAcGFyYW0gZmFjdG9yeVxyXG4gKiBAcGFyYW0gbm9kZVxyXG4gKi9cclxudmFyIERhdGFBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIEJhc2VEYXRhQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpO1xyXG4gICAgLy8gTm9kZSBoYW5kbGVzIGZvciBzcmMgYW5kIHByb3RvXHJcbiAgICB0aGlzLnhmbG93RGF0YU5vZGUgPSBudWxsO1xyXG4gICAgdGhpcy5leHRlcm5hbFNjcmlwdHMgPSB7fTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoRGF0YUFkYXB0ZXIsIEJhc2VEYXRhQWRhcHRlcik7XHJcblxyXG5EYXRhQWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMueGZsb3dEYXRhTm9kZSA9IG5ldyBEYXRhTm9kZShmYWxzZSk7XHJcbiAgICB0aGlzLnhmbG93RGF0YU5vZGUuYWRkTG9hZExpc3RlbmVyKHRoaXMub25YZmxvd0xvYWRFdmVudC5iaW5kKHRoaXMpKTtcclxuICAgIHRoaXMueGZsb3dEYXRhTm9kZS51c2VyRGF0YSA9IHRoaXMubm9kZTtcclxuXHJcbiAgICAvLyBTZXR0aW5nIHBsYXRmb3JtIGFuZCBub2RlIHR5cGUgaW5mb3JtYXRpb24gZm9yIGEgZGF0YSBzZXF1ZW5jZVxyXG4gICAgdGhpcy54Zmxvd0RhdGFOb2RlLnNldFBsYXRmb3JtKHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJwbGF0Zm9ybVwiKSk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVBZGFwdGVySGFuZGxlKFwic3JjXCIsIHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJzcmNcIikpO1xyXG4gICAgaWYoIXRoaXMuYXNzZXREYXRhKXtcclxuICAgICAgICB0aGlzLnhmbG93RGF0YU5vZGUuc2V0RmlsdGVyKHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJmaWx0ZXJcIikpO1xyXG4gICAgICAgIHVwZGF0ZUNvbXB1dGUodGhpcyk7XHJcbiAgICB9XHJcbiAgICByZWN1cnNpdmVEYXRhQWRhcHRlckNvbnN0cnVjdGlvbih0aGlzKTtcclxufTtcclxuXHJcbkRhdGFBZGFwdGVyLnByb3RvdHlwZS51cGRhdGVBZGFwdGVySGFuZGxlID0gZnVuY3Rpb24oa2V5LCB1cmwpIHtcclxuICAgIHZhciBvbGRBZGFwdGVySGFuZGxlID0gdGhpcy5nZXRDb25uZWN0ZWRBZGFwdGVySGFuZGxlKGtleSk7XHJcblxyXG4gICAgdmFyIGFkYXB0ZXJIYW5kbGUgPSB0aGlzLmdldEFkYXB0ZXJIYW5kbGUodXJsKSxcclxuICAgICAgICBzdGF0dXMgPSAoYWRhcHRlckhhbmRsZSAmJiBhZGFwdGVySGFuZGxlLnN0YXR1cyk7XHJcblxyXG4gICAgaWYob2xkQWRhcHRlckhhbmRsZSA9PSBhZGFwdGVySGFuZGxlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGlmIChzdGF0dXMgPT09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORCkge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQ291bGQgbm90IGZpbmQgZWxlbWVudCBvZiB1cmwgJ1wiICsgYWRhcHRlckhhbmRsZS51cmwgKyBcIicgZm9yIFwiICsga2V5LCB0aGlzLm5vZGUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jb25uZWN0QWRhcHRlckhhbmRsZShrZXksIGFkYXB0ZXJIYW5kbGUpO1xyXG4gICAgdGhpcy5jb25uZWN0ZWRBZGFwdGVyQ2hhbmdlZChrZXksIGFkYXB0ZXJIYW5kbGUgPyBhZGFwdGVySGFuZGxlLmdldEFkYXB0ZXIoKSA6IG51bGwsIHN0YXR1cyk7XHJcbn07XHJcblxyXG5EYXRhQWRhcHRlci5wcm90b3R5cGUub25YZmxvd0xvYWRFdmVudCA9IGZ1bmN0aW9uKG5vZGUsIG5ld0xldmVsLCBvbGRMZXZlbCl7XHJcbiAgICBpZihuZXdMZXZlbCA9PSBJbmZpbml0eSl7XHJcbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudCh0aGlzLm5vZGUsICdsb2FkJywgZmFsc2UsIHRydWUsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZihuZXdMZXZlbCA+IG9sZExldmVsKXtcclxuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50KHRoaXMubm9kZSwgJ3Byb2dyZXNzJywgZmFsc2UsIHRydWUsIG51bGwpO1xyXG4gICAgfVxyXG59O1xyXG5EYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF0YUNvbXBsZXRlID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLnhmbG93RGF0YU5vZGUuZ2V0UHJvZ3Jlc3NMZXZlbCgpID09IEluZmluaXR5O1xyXG59O1xyXG5EYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF0YVByb2dyZXNzTGV2ZWwgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMueGZsb3dEYXRhTm9kZS5nZXRQcm9ncmVzc0xldmVsKCk7XHJcbn07XHJcblxyXG4gICAgLyoqIFJlY3Vyc2l2ZWx5IHBhc3NpbmcgcGxhdGZvcm0gaW5mb3JtYXRpb24gdG8gY2hpbGRyZW4gb2YgYSBkYXRhIG5vZGVcclxuICAgICAqICBSZXF1aXJlcyB0aGF0IHRoZSBjaGlsZHJlbiBhbmQgdGhlIHBhcmVudHMgb2YgZGF0YSBub2RlcyBhcmUgZGVmaW5lZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RGF0YU5vZGV9IHBhcmVudE5vZGVcclxuICAgICAqL1xyXG5mdW5jdGlvbiByZWN1cnNpdmVEYXRhTm9kZUF0dHJJbml0KHBhcmVudE5vZGUpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudE5vZGUuX2NoaWxkcmVuLCBOQ2hpbGRyZW4sIGk7XHJcblxyXG4gICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBOQ2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IE5DaGlsZHJlbjsgaS0tOykge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0gaW5zdGFuY2VvZiBEYXRhTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uc2V0UGxhdGZvcm0ocGFyZW50Tm9kZS5fcGxhdGZvcm0pO1xyXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlRGF0YU5vZGVBdHRySW5pdChjaGlsZHJlbltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlY3Vyc2l2ZURhdGFBZGFwdGVyQ29uc3RydWN0aW9uKGFkYXB0ZXIpIHtcclxuICAgIGZvciAodmFyIGNoaWxkID0gYWRhcHRlci5ub2RlLmZpcnN0RWxlbWVudENoaWxkOyBjaGlsZCAhPT0gbnVsbDsgY2hpbGQgPSBjaGlsZC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcclxuICAgICAgICB2YXIgc3ViYWRhcHRlciA9IGFkYXB0ZXIuZmFjdG9yeS5nZXRBZGFwdGVyKGNoaWxkKTtcclxuICAgICAgICBpZiAoc3ViYWRhcHRlcikge1xyXG4gICAgICAgICAgICBpZiAoc3ViYWRhcHRlci5nZXRYZmxvd05vZGUpIHtcclxuICAgICAgICAgICAgICAgIGFkYXB0ZXIueGZsb3dEYXRhTm9kZS5hcHBlbmRDaGlsZChzdWJhZGFwdGVyLmdldFhmbG93Tm9kZSgpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdWJhZGFwdGVyLmdldFNjcmlwdFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzY3JpcHRJZCA9IHN1YmFkYXB0ZXIubm9kZS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzY3JpcHRJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiUGFyc2luZyBlcnJvcjogRXh0ZXJuYWxseSByZWZlcmVuY2VkIG9wZXJhdG9ycyBtdXN0IGhhdmUgYSAnbmFtZScgYXR0cmlidXRlIG1hdGNoaW5nIHRoZSBuYW1lIHRoZXkgd2VyZSByZWdpc3RlcmVkIHdpdGguIFwiLCBzdWJhZGFwdGVyLm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdElkID0gXCJ1bmtub3duX29wZXJhdG9yXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhZGFwdGVyLmV4dGVybmFsU2NyaXB0c1tzY3JpcHRJZF0gPSBzdWJhZGFwdGVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1YmFkYXB0ZXIuY29ubmVjdGVkQWRhcHRlckhhbmRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkYXB0ZXIuY29ubmVjdEFkYXB0ZXJIYW5kbGUoc2NyaXB0SWQsIHN1YmFkYXB0ZXIuY29ubmVjdGVkQWRhcHRlckhhbmRsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhZGFwdGVyLnhmbG93RGF0YU5vZGUuc2V0TG9hZGluZyh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQYXNzZXMgX3BsYXRmb3JtIHZhbHVlcyB0byBjaGlsZHJlbiBub2RlcyBzdGFydGluZyBmcm9tIHRoZSBub2RlXHJcbiAgICAgICAgICAgIC8vIHdoZXJlIHRoZXNlIGF0dHJpYnV0ZXMgYXJlIGZpcnN0IGRlZmluZWRcclxuICAgICAgICAgICAgaWYgKGFkYXB0ZXIueGZsb3dEYXRhTm9kZS5fcGxhdGZvcm0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZURhdGFOb2RlQXR0ckluaXQoYWRhcHRlci54Zmxvd0RhdGFOb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBub3RpZnlDaGFuZ2VkKCkgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgWE1MM0QgZGF0YSBzdHJ1Y3R1cmUgdG9cclxuICogbm90aWZ5IHRoZSBEYXRhQWRhcHRlciBhYm91dCBkYXRhIGNoYW5nZXMgKERPTSBtdXN0YXRpb24gZXZlbnRzKSBpbiBpdHNcclxuICogYXNzb2NpYXRpbmcgbm9kZS4gV2hlbiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIGFsbCBvYnNlcnZlcnMgb2YgdGhlXHJcbiAqIERhdGFBZGFwdGVyIGFyZSBub3RpZmllZCBhYm91dCBkYXRhIGNoYW5nZXMgdmlhIHRoZWlyIG5vdGlmeURhdGFDaGFuZ2VkKClcclxuICogbWV0aG9kLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXZ0IG5vdGlmaWNhdGlvbiBvZiB0eXBlIFhNTDNELk5vdGlmaWNhdGlvblxyXG4gKi9cclxuRGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICBpZiAoZXZ0LnR5cGUgPT09IEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRBZGFwdGVyQ2hhbmdlZChldnQua2V5LCBldnQuYWRhcHRlciwgZXZ0LmhhbmRsZVN0YXR1cyk7XHJcbiAgICAgICAgaWYgKGV2dC5oYW5kbGVTdGF0dXMgPT09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORCkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBmaW5kIDxkYXRhPiBlbGVtZW50IG9mIHVybCAnXCIgKyBldnQudXJsICsgXCInIGZvciBcIiArIGV2dC5rZXksIHRoaXMubm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSBpZiAoZXZ0LnR5cGUgPT09IEV2ZW50cy5OT0RFX0lOU0VSVEVEKSB7XHJcbiAgICAgICAgdmFyIGluc2VydGVkTm9kZSA9IGV2dC5hZmZlY3RlZE5vZGU7XHJcbiAgICAgICAgdmFyIGFkYXB0ZXIgPSB0aGlzLmZhY3RvcnkuZ2V0QWRhcHRlcihpbnNlcnRlZE5vZGUpO1xyXG4gICAgICAgIGlmICghYWRhcHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW5zZXJ0ZWRYZmxvd05vZGUgPSBhZGFwdGVyLmdldFhmbG93Tm9kZSgpO1xyXG4gICAgICAgIHZhciBzaWJsaW5nID0gaW5zZXJ0ZWROb2RlLCBmb2xsb3dVcEFkYXB0ZXIgPSBudWxsO1xyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLm5leHRTaWJsaW5nO1xyXG4gICAgICAgIH0gd2hpbGUgKHNpYmxpbmcgJiYgIShmb2xsb3dVcEFkYXB0ZXIgPSB0aGlzLmZhY3RvcnkuZ2V0QWRhcHRlcihzaWJsaW5nKSkpO1xyXG5cclxuICAgICAgICBpZiAoZm9sbG93VXBBZGFwdGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMueGZsb3dEYXRhTm9kZS5pbnNlcnRCZWZvcmUoaW5zZXJ0ZWRYZmxvd05vZGUsIGZvbGxvd1VwQWRhcHRlci5nZXRYZmxvd05vZGUoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy54Zmxvd0RhdGFOb2RlLmFwcGVuZENoaWxkKGluc2VydGVkWGZsb3dOb2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBlbHNlIGlmIChldnQudHlwZSA9PT0gRXZlbnRzLk5PREVfUkVNT1ZFRCkge1xyXG4gICAgICAgIHZhciBhZGFwdGVyID0gdGhpcy5mYWN0b3J5LmdldEFkYXB0ZXIoZXZ0LmFmZmVjdGVkTm9kZSk7XHJcbiAgICAgICAgaWYgKCFhZGFwdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZW1vdmVkWGZsb3dOb2RlID0gYWRhcHRlci5nZXRYZmxvd05vZGUoKTtcclxuICAgICAgICB0aGlzLnhmbG93RGF0YU5vZGUucmVtb3ZlQ2hpbGQocmVtb3ZlZFhmbG93Tm9kZSk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChldnQudHlwZSA9PT0gRXZlbnRzLlZBTFVFX01PRElGSUVEKSB7XHJcbiAgICAgICAgdmFyIGF0dHIgPSBldnQubXV0YXRpb24uYXR0cmlidXRlTmFtZTtcclxuXHJcbiAgICAgICAgaWYgKGF0dHIgPT09IFwiZmlsdGVyXCIgJiYgIXRoaXMuYXNzZXREYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueGZsb3dEYXRhTm9kZS5zZXRGaWx0ZXIodGhpcy5ub2RlLmdldEF0dHJpYnV0ZShhdHRyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGF0dHIgPT09IFwiY29tcHV0ZVwiICYmICF0aGlzLmFzc2V0RGF0YSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDb21wdXRlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhdHRyID09PSBcInNyY1wiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQWRhcHRlckhhbmRsZShhdHRyLCB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKGF0dHIpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGF0dHIgPT09IFwicGxhdGZvcm1cIikge1xyXG4gICAgICAgICAgICB1cGRhdGVQbGF0Zm9ybSh0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBlbHNlIGlmIChldnQudHlwZSA9PT0gRXZlbnRzLlRISVNfUkVNT1ZFRCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJBZGFwdGVySGFuZGxlcygpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRGF0YUFkYXB0ZXIucHJvdG90eXBlLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkID0gZnVuY3Rpb24gKGtleSwgYWRhcHRlciAvKiwgc3RhdHVzICovKSB7XHJcbiAgICBpZiAoa2V5ID09PSBcInNyY1wiKSB7XHJcbiAgICAgICAgdGhpcy54Zmxvd0RhdGFOb2RlLnNvdXJjZU5vZGUgPSBhZGFwdGVyID8gYWRhcHRlci5nZXRYZmxvd05vZGUoKSA6IG51bGw7XHJcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJkYXRhZmxvd1wiKSB7XHJcbiAgICAgICAgdGhpcy54Zmxvd0RhdGFOb2RlLmRhdGFmbG93Tm9kZSA9IGFkYXB0ZXIgPyBhZGFwdGVyLmdldFhmbG93Tm9kZSgpIDogbnVsbDtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5leHRlcm5hbFNjcmlwdHNba2V5XSkge1xyXG4gICAgICAgIHdpbmRvdy5ldmFsKGFkYXB0ZXIuc2NyaXB0KTtcclxuICAgICAgICB0aGlzLnhmbG93RGF0YU5vZGUubm90aWZ5KFhDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICB9XHJcbiAgICAvLyBDeWNsZSB0aGUgbG9hZCBzdGF0ZSB0byBmb3JjZSBhIGxvYWQgZXZlbnQgZXZlbiBpZiB0aGUgbmV3IHNvdXJjZU5vZGUgaXMgY2FjaGVkXHJcbiAgICB0aGlzLnhmbG93RGF0YU5vZGUuc2V0TG9hZGluZyh0cnVlKTtcclxuICAgIHVwZGF0ZUxvYWRTdGF0ZSh0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGFBZGFwdGVyXHJcbiAqL1xyXG5EYXRhQWRhcHRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gXCJEYXRhQWRhcHRlclwiO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdXBkYXRlQ29tcHV0ZShkYXRhQWRhcHRlcikge1xyXG4gICAgdmFyIHhmbG93Tm9kZSA9IGRhdGFBZGFwdGVyLnhmbG93RGF0YU5vZGU7XHJcbiAgICB4Zmxvd05vZGUuc2V0Q29tcHV0ZShkYXRhQWRhcHRlci5ub2RlLmdldEF0dHJpYnV0ZShcImNvbXB1dGVcIikpO1xyXG4gICAgaWYgKHhmbG93Tm9kZS5jb21wdXRlRGF0YWZsb3dVcmwpIHtcclxuICAgICAgICBkYXRhQWRhcHRlci51cGRhdGVBZGFwdGVySGFuZGxlKFwiZGF0YWZsb3dcIiwgeGZsb3dOb2RlLmNvbXB1dGVEYXRhZmxvd1VybCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBkYXRhQWRhcHRlci5kaXNjb25uZWN0QWRhcHRlckhhbmRsZShcImRhdGFmbG93XCIpO1xyXG4gICAgICAgIHVwZGF0ZUxvYWRTdGF0ZShkYXRhQWRhcHRlcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVBsYXRmb3JtKGRhdGFBZGFwdGVyKSB7XHJcbiAgICB2YXIgeGZsb3dOb2RlID0gZGF0YUFkYXB0ZXIueGZsb3dEYXRhTm9kZTtcclxuXHJcbiAgICB4Zmxvd05vZGUuc2V0UGxhdGZvcm0oZGF0YUFkYXB0ZXIubm9kZS5nZXRBdHRyaWJ1dGUoXCJwbGF0Zm9ybVwiKSk7XHJcbiAgICByZWN1cnNpdmVEYXRhTm9kZUF0dHJJbml0KHhmbG93Tm9kZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxvYWRTdGF0ZShkYXRhQWRwYXRlcikge1xyXG4gICAgdmFyIGxvYWRpbmcgPSBmYWxzZSwgaGFuZGxlO1xyXG5cclxuICAgIGhhbmRsZSA9IGRhdGFBZHBhdGVyLmdldENvbm5lY3RlZEFkYXB0ZXJIYW5kbGUoXCJzcmNcIik7XHJcbiAgICBpZiAoaGFuZGxlICYmIGhhbmRsZS5zdGF0dXMgPT09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLkxPQURJTkcpIHtcclxuICAgICAgICBsb2FkaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGUgPSBkYXRhQWRwYXRlci5nZXRDb25uZWN0ZWRBZGFwdGVySGFuZGxlKFwiZGF0YWZsb3dcIik7XHJcbiAgICBpZiAoaGFuZGxlICYmIGhhbmRsZS5zdGF0dXMgPT09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLkxPQURJTkcpIHtcclxuICAgICAgICBsb2FkaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBuYW1lIGluIGRhdGFBZHBhdGVyLmV4dGVybmFsU2NyaXB0cykge1xyXG4gICAgICAgIGhhbmRsZSA9IGRhdGFBZHBhdGVyLmdldENvbm5lY3RlZEFkYXB0ZXJIYW5kbGUobmFtZSk7XHJcbiAgICAgICAgaWYgKGhhbmRsZSAmJiBoYW5kbGUuc3RhdHVzID09PSBBZGFwdGVySGFuZGxlLlNUQVRVUy5MT0FESU5HKSB7XHJcbiAgICAgICAgICAgIGxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkYXRhQWRwYXRlci54Zmxvd0RhdGFOb2RlLnNldExvYWRpbmcobG9hZGluZyk7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFBZGFwdGVyO1xyXG5cclxuXHJcbiIsInZhciBCYXNlRGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xyXG52YXIgRGF0YU5vZGUgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLkRhdGFOb2RlO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgQWRhcHRlckhhbmRsZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXJoYW5kbGUuanNcIik7XHJcblxyXG4vKipcclxuICogRGF0YUFkYXB0ZXIgaGFuZGxpbmcgYSA8ZGF0YWZsb3c+IGVsZW1lbnRcclxuICogQHBhcmFtIGZhY3RvcnlcclxuICogQHBhcmFtIG5vZGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgRGF0YWZsb3dEYXRhQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XHJcbiAgICBCYXNlRGF0YUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcclxuICAgIHRoaXMueGZsb3dEYXRhTm9kZSA9IG51bGw7XHJcbiAgICB0aGlzLmV4dGVybmFsU2NyaXB0cyA9IHt9O1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhEYXRhZmxvd0RhdGFBZGFwdGVyLCBCYXNlRGF0YUFkYXB0ZXIpO1xyXG5cclxuRGF0YWZsb3dEYXRhQWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMueGZsb3dEYXRhTm9kZSA9IG5ldyBEYXRhTm9kZShmYWxzZSk7XHJcbiAgICB0aGlzLmRhdGFmbG93UmVmcyA9IFtdO1xyXG4gICAgdXBkYXRlRGF0YWZsb3dYZmxvd05vZGUodGhpcywgdGhpcy5ub2RlKTtcclxufTtcclxuXHJcbkRhdGFmbG93RGF0YUFkYXB0ZXIucHJvdG90eXBlLnVwZGF0ZUFkYXB0ZXJIYW5kbGUgPSBmdW5jdGlvbihrZXksIHVybCkge1xyXG4gICAgdmFyIG9sZEFkYXB0ZXJIYW5kbGUgPSB0aGlzLmdldENvbm5lY3RlZEFkYXB0ZXJIYW5kbGUoa2V5KTtcclxuXHJcbiAgICB2YXIgYWRhcHRlckhhbmRsZSA9IHRoaXMuZ2V0QWRhcHRlckhhbmRsZSh1cmwpLFxyXG4gICAgICAgIHN0YXR1cyA9IChhZGFwdGVySGFuZGxlICYmIGFkYXB0ZXJIYW5kbGUuc3RhdHVzKTtcclxuXHJcbiAgICBpZihvbGRBZGFwdGVySGFuZGxlID09IGFkYXB0ZXJIYW5kbGUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgaWYgKHN0YXR1cyA9PT0gQWRhcHRlckhhbmRsZS5TVEFUVVMuTk9UX0ZPVU5EKSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IG9mIHVybCAnXCIgKyBhZGFwdGVySGFuZGxlLnVybCArIFwiJyBmb3IgXCIgKyBrZXksIHRoaXMubm9kZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNvbm5lY3RBZGFwdGVySGFuZGxlKGtleSwgYWRhcHRlckhhbmRsZSk7XHJcbiAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkKGtleSwgYWRhcHRlckhhbmRsZSA/IGFkYXB0ZXJIYW5kbGUuZ2V0QWRhcHRlcigpIDogbnVsbCwgc3RhdHVzKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQHBhcmFtIGV2dCBub3RpZmljYXRpb24gb2YgdHlwZSBYTUwzRC5Ob3RpZmljYXRpb25cclxuICovXHJcbkRhdGFmbG93RGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICBpZiAoZXZ0LnR5cGUgPT09IEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEKSB7XHJcbiAgICAgICAgLy9UT0RPOiBIYW5kbGUgQURBUFRFUl9IQU5ETEVfQ0hBTkdFRFxyXG4gICAgICAgIGlmICh0aGlzLmV4dGVybmFsU2NyaXB0c1tldnQua2V5XSkge1xyXG4gICAgICAgICAgICB3aW5kb3cuZXZhbChldnQuYWRhcHRlci5zY3JpcHQpO1xyXG4gICAgICAgICAgICBzZXRMb2FkaW5nU3RhdGVGb3JNYXRjaGluZ1hmbG93Tm9kZXModGhpcy54Zmxvd0RhdGFOb2RlLCBldnQua2V5LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMueGZsb3dEYXRhTm9kZS5ub3RpZnkoWEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoIChldnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgRXZlbnRzLkFEQVBURVJfSEFORExFX0NIQU5HRUQ6XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkQWRhcHRlckNoYW5nZWQoZXZ0LmtleSwgZXZ0LmFkYXB0ZXIsIGV2dC5oYW5kbGVTdGF0dXMpO1xyXG4gICAgICAgICAgICBpZiAoZXZ0LmhhbmRsZVN0YXR1cyA9PT0gQWRhcHRlckhhbmRsZS5TVEFUVVMuTk9UX0ZPVU5EKSB7XHJcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGRhdGFmbG93IG9mIHVybCAnXCIgKyBldnQudXJsLCB0aGlzLm5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIEV2ZW50cy5OT0RFX0lOU0VSVEVEOlxyXG4gICAgICAgIGNhc2UgRXZlbnRzLk5PREVfUkVNT1ZFRDpcclxuICAgICAgICAgICAgdXBkYXRlRGF0YWZsb3dYZmxvd05vZGUodGhpcyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIEV2ZW50cy5WQUxVRV9NT0RJRklFRDpcclxuICAgICAgICAgICAgdmFyIGF0dHIgPSBldnQubXV0YXRpb24uYXR0cmlidXRlTmFtZTtcclxuICAgICAgICAgICAgaWYgKGF0dHIgPT09IFwib3V0XCIpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZURhdGFmbG93T3V0KHRoaXMpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIgPT09IFwicGxhdGZvcm1cIikge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRGF0YWZsb3dYZmxvd05vZGUodGhpcywgdGhpcy5ub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUcmF2ZXJzZSBhbGwgc3Vibm9kZXMgb2YgYSBkYXRhZmxvdyBhbmQgc2V0IHRoZSBsb2FkaW5nIHN0YXRlIG9mXHJcbiAqIGFsbCBub2RlcyB3aXRoIGEgY29tcHV0ZSBvcGVyYXRvciB0aGF0IHJlbGllcyBvbiB0aGUgbWF0Y2hpbmcgZXh0ZXJuYWwgc2NyaXB0IG5hbWUuXHJcbiAqIEEgY29tcHV0ZSBub2RlIHdpbGwgb25seSBiZSBleGVjdXRlZCBpZiBpdHMgbG9hZGluZyBzdGF0ZSBpcyAnZmFsc2UnIGFuZCBub25lIG9mIGl0cyBjaGlsZHJlbiBhcmUgJ2xvYWRpbmcnLCBzb1xyXG4gKiB0aGlzIGVuc3VyZXMgd2UgZG9uJ3QgZG8gdGhlIGNvbXB1dGUgb3BlcmF0aW9ucyB1bnRpbCB0aGUgZXh0ZXJuYWwgb3BlcmF0b3JzIGhhdmUgYmVlbiBsb2FkZWQuXHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IG5vZGUgdGhlIGN1cnJlbnQgbm9kZSB0byBjaGVjayBmb3IgaW5zdGFuY2VzIG9mIHRoZSBnaXZlbiBvcGVyYXRvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXh0ZXJuYWwgb3BlcmF0b3IgdG8gY2hlY2sgZm9yXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9hZGluZyB3aGV0aGVyIHRoZSBvcGVyYXRvciBoYXMgZmluaXNoZWQgbG9hZGluZyBvciBub3RcclxuICovXHJcbmZ1bmN0aW9uIHNldExvYWRpbmdTdGF0ZUZvck1hdGNoaW5nWGZsb3dOb2Rlcyhub2RlLCBuYW1lLCBsb2FkaW5nKSB7XHJcbiAgICBpZiAobm9kZS5fY29tcHV0ZU9wZXJhdG9yID09PSBuYW1lKSB7XHJcbiAgICAgICAgbm9kZS5zZXRMb2FkaW5nKGxvYWRpbmcpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUuX2NoaWxkcmVuKSB7XHJcbiAgICAgICAgdmFyIGkgPSBub2RlLl9jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICBzZXRMb2FkaW5nU3RhdGVGb3JNYXRjaGluZ1hmbG93Tm9kZXMobm9kZS5fY2hpbGRyZW5baV0sIG5hbWUsIGxvYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuRGF0YWZsb3dEYXRhQWRhcHRlci5wcm90b3R5cGUudXBkYXRlWGZsb3dOb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdXBkYXRlRGF0YWZsb3dYZmxvd05vZGUodGhpcywgdGhpcy5ub2RlKTtcclxufTtcclxuXHJcbkRhdGFmbG93RGF0YUFkYXB0ZXIucHJvdG90eXBlLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkID0gZnVuY3Rpb24gKGtleSwgYWRhcHRlciwgc3RhdHVzKSB7XHJcbiAgICB2YXIgeGZsb3dOb2RlID0gdGhpcy5kYXRhZmxvd1JlZnNba2V5XTtcclxuICAgIGlmICh4Zmxvd05vZGUpIHtcclxuICAgICAgICB4Zmxvd05vZGUuZGF0YWZsb3dOb2RlID0gYWRhcHRlciA/IGFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCkgOiBudWxsO1xyXG4gICAgICAgIHhmbG93Tm9kZS5zZXRMb2FkaW5nKHN0YXR1cyA9PT0gQWRhcHRlckhhbmRsZS5TVEFUVVMuTE9BRElORyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVEYXRhZmxvd091dChhZGFwdGVyKSB7XHJcbiAgICB2YXIgb3V0ID0gYWRhcHRlci5ub2RlLmdldEF0dHJpYnV0ZShcIm91dFwiKTtcclxuICAgIGlmIChvdXQpIHtcclxuICAgICAgICBhZGFwdGVyLnhmbG93RGF0YU5vZGUuc2V0RmlsdGVyKFwia2VlcChcIiArIG91dCArIFwiKVwiKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWRhcHRlci54Zmxvd0RhdGFOb2RlLnNldEZpbHRlcihcIlwiKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlRGF0YWZsb3dYZmxvd05vZGUoYWRhcHRlciwgbm9kZSkge1xyXG4gICAgLy8gR2V0dGluZyBwbGF0Zm9ybSBhbmQgbm9kZSB0eXBlIGluZm9ybWF0aW9uIGZvciBhIERhdGFmbG93IG5vZGVcclxuICAgIHZhciBwbGF0Zm9ybSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwicGxhdGZvcm1cIik7XHJcblxyXG4gICAgYWRhcHRlci54Zmxvd0RhdGFOb2RlLmNsZWFyQ2hpbGRyZW4oKTtcclxuICAgIGFkYXB0ZXIueGZsb3dEYXRhTm9kZS5zZXRDb21wdXRlKFwiXCIpO1xyXG4gICAgYWRhcHRlci5jbGVhckFkYXB0ZXJIYW5kbGVzKCk7XHJcbiAgICBhZGFwdGVyLmRhdGFmbG93UmVmcyA9IFtdO1xyXG4gICAgYWRhcHRlci5leHRlcm5hbFNjcmlwdHMgPSB7fTtcclxuICAgIHVwZGF0ZURhdGFmbG93T3V0KGFkYXB0ZXIpO1xyXG5cclxuICAgIHZhciBjaGlsZCA9IG5vZGUubGFzdEVsZW1lbnRDaGlsZCwgZmlyc3ROb2RlID0gdHJ1ZSwgcHJldk5vZGUgPSBudWxsLCBjdXJyZW50Tm9kZSA9IGFkYXB0ZXIueGZsb3dEYXRhTm9kZSwgc3ViQWRhcHRlciwgeGZsb3dOb2RlO1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgICBzdWJBZGFwdGVyID0gYWRhcHRlci5mYWN0b3J5LmdldEFkYXB0ZXIoY2hpbGQpO1xyXG4gICAgICAgIGlmICghc3ViQWRhcHRlcikge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdWJBZGFwdGVyLmdldFhmbG93Tm9kZSkge1xyXG4gICAgICAgICAgICB4Zmxvd05vZGUgPSBzdWJBZGFwdGVyLmdldFhmbG93Tm9kZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHByZXZOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5pbnNlcnRCZWZvcmUoeGZsb3dOb2RlLCBwcmV2Tm9kZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5hcHBlbmRDaGlsZCh4Zmxvd05vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByZXZOb2RlID0geGZsb3dOb2RlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3ViQWRhcHRlci5nZXRDb21wdXRlQ29kZSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGVtZW50cyA9IHN1YkFkYXB0ZXIuZ2V0Q29tcHV0ZUNvZGUoKS5zcGxpdChcIjtcIik7XHJcbiAgICAgICAgICAgIHZhciBqID0gc3RhdGVtZW50cy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoai0tKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcHV0ZSA9IHN0YXRlbWVudHNbal0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wdXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4Zmxvd05vZGUgPSBuZXcgRGF0YU5vZGUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5pbnNlcnRCZWZvcmUoeGZsb3dOb2RlLCBwcmV2Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuYXBwZW5kQ2hpbGQoeGZsb3dOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSB4Zmxvd05vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldk5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUudXNlckRhdGEgPSBjaGlsZDtcclxuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRQbGF0Zm9ybShwbGF0Zm9ybSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUuc2V0Q29tcHV0ZShzdGF0ZW1lbnRzW2pdLnRyaW0oKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmNvbXB1dGVEYXRhZmxvd1VybCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBhZGFwdGVyLmRhdGFmbG93UmVmcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRhcHRlci5kYXRhZmxvd1JlZnMucHVzaChjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRhcHRlci51cGRhdGVBZGFwdGVySGFuZGxlKGlkeCwgY3VycmVudE5vZGUuY29tcHV0ZURhdGFmbG93VXJsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoc3ViQWRhcHRlci5nZXRTY3JpcHRUeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY3JpcHRJZCA9IHN1YkFkYXB0ZXIubm9kZS5uYW1lO1xyXG4gICAgICAgICAgICBpZiAoIXNjcmlwdElkKSB7XHJcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlBhcnNpbmcgZXJyb3I6IEV4dGVybmFsbHkgcmVmZXJlbmNlZCBvcGVyYXRvcnMgbXVzdCBoYXZlIGEgJ25hbWUnIGF0dHJpYnV0ZSBtYXRjaGluZyB0aGUgbmFtZSB0aGV5IHdlcmUgcmVnaXN0ZXJlZCB3aXRoLiBcIiwgc3ViQWRhcHRlci5ub2RlKTtcclxuICAgICAgICAgICAgICAgIHNjcmlwdElkID0gXCJ1bmtub3duX29wZXJhdG9yXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRhcHRlci5leHRlcm5hbFNjcmlwdHNbc2NyaXB0SWRdID0gc3ViQWRhcHRlcjtcclxuICAgICAgICAgICAgaWYgKHN1YkFkYXB0ZXIuY29ubmVjdGVkQWRhcHRlckhhbmRsZSkge1xyXG4gICAgICAgICAgICAgICAgYWRhcHRlci5jb25uZWN0QWRhcHRlckhhbmRsZShzY3JpcHRJZCwgc3ViQWRhcHRlci5jb25uZWN0ZWRBZGFwdGVySGFuZGxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IHdoaWxlIChjaGlsZCA9IGNoaWxkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpO1xyXG5cclxuICAgIGZvciAodmFyIG5hbWUgaW4gYWRhcHRlci5leHRlcm5hbFNjcmlwdHMpIHtcclxuICAgICAgICAvLyBFbnN1cmUgWEZsb3cgZG9lc24ndCBleGVjdXRlIGFueSBjb21wdXRlIG5vZGVzIHRoYXQgZGVwZW5kIG9uIGV4dGVybmFsIHNjcmlwdHMgdW50aWwgdGhleSdyZSBsb2FkZWRcclxuICAgICAgICBzZXRMb2FkaW5nU3RhdGVGb3JNYXRjaGluZ1hmbG93Tm9kZXMoYWRhcHRlci54Zmxvd0RhdGFOb2RlLCBuYW1lLCB0cnVlKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGF0YWZsb3dEYXRhQWRhcHRlcjtcclxuIiwidmFyIE5vZGVBZGFwdGVyRmFjdG9yeSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXIuanNcIikuTm9kZUFkYXB0ZXJGYWN0b3J5O1xyXG52YXIgQXNzZXQgPSByZXF1aXJlKFwiLi9hc3NldC5qc1wiKTtcclxudmFyIE1pc2MgPSByZXF1aXJlKFwiLi9taXNjLmpzXCIpO1xyXG52YXIgU2NyaXB0RGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi9zY3JpcHQuanNcIik7XHJcbnZhciBUZXh0dXJlRGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi90ZXh0dXJlLmpzXCIpO1xyXG52YXIgVHJhbnNmb3JtRGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm0uanNcIik7XHJcbnZhciBWYWx1ZURhdGFBZGFwdGVyID0gcmVxdWlyZShcIi4vdmFsdWVzLmpzXCIpO1xyXG52YXIgRGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xyXG52YXIgQ29tcHV0ZURhdGFBZGFwdGVyID0gcmVxdWlyZShcIi4vY29tcHV0ZS5qc1wiKTtcclxudmFyIERhdGFmbG93RGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi9kYXRhZmxvdy5qc1wiKTtcclxuLy8gUmVnaXN0ZXIgSlNPTiBIYW5kbGVyXHJcbnJlcXVpcmUoXCIuL2pzb24vZmFjdG9yeS5qc1wiKTtcclxuLy8gUmVnaXN0ZXIgSmF2YVNjcmlwdCBIYW5kbGVyIChyZXF1aXJlZCBmb3IgZXh0ZXJuYWwgc2hhZGUuanMgSmF2YXNjcmlwdCByZXNvdXJjZXMpXHJcbnJlcXVpcmUoXCIuL2phdmFzY3JpcHQvZmFjdG9yeS5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RvciBvZiBYTUwzRERhdGFBZGFwdGVyRmFjdG9yeVxyXG4gKiBYTUwzRERhdGFBZGFwdGVyRmFjdG9yeSBjcmVhdGVzIERhdGFBZGFwdGVyIGluc3RhbmNlcyBmb3IgZWxlbWVudHMgdXNpbmcgZ2VuZXJpYyBkYXRhICg8bWVzaD4sIDxkYXRhPiwgPGZsb2F0PiwuLi4pLlxyXG4gKiBBZGRpdGlvbmFsbHksIGl0IG1hbmFnZXMgYWxsIERhdGFBZGFwdGVyIGluc3RhbmNlcyBzbyB0aGF0IGZvciBlYWNoIG5vZGUgdGhlcmUgaXMgYWx3YXlzIGp1c3Qgb25lIERhdGFBZGFwdGVyLiBXaGVuXHJcbiAqIGl0IGNyZWF0ZXMgYSBEYXRhQWRhcHRlciwgaXQgY2FsbHMgaXRzIGluaXQgbWV0aG9kLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQWRhcHRlckZhY3RvcnlcclxuICovXHJcblxyXG52YXIgWE1MM0REYXRhQWRhcHRlckZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBOb2RlQWRhcHRlckZhY3RvcnkuY2FsbCh0aGlzLCBcImRhdGFcIik7XHJcbn07XHJcblhNTDNELmNyZWF0ZUNsYXNzKFhNTDNERGF0YUFkYXB0ZXJGYWN0b3J5LCBOb2RlQWRhcHRlckZhY3RvcnkpO1xyXG5YTUwzRERhdGFBZGFwdGVyRmFjdG9yeS5wcm90b3R5cGUuYXNwZWN0ID0gXCJkYXRhXCI7XHJcblxyXG52YXIgcmVnID0ge1xyXG4gICAgJ21lc2gnOiBNaXNjLlNpbmtEYXRhQWRhcHRlcixcclxuICAgICdzaGFkZXInOiBNaXNjLlNpbmtEYXRhQWRhcHRlcixcclxuICAgICdsaWdodHNoYWRlcic6IE1pc2MuU2lua0RhdGFBZGFwdGVyLFxyXG4gICAgJ2Zsb2F0JzogVmFsdWVEYXRhQWRhcHRlcixcclxuICAgICdmbG9hdDInOiBWYWx1ZURhdGFBZGFwdGVyLFxyXG4gICAgJ2Zsb2F0Myc6IFZhbHVlRGF0YUFkYXB0ZXIsXHJcbiAgICAnZmxvYXQ0JzogVmFsdWVEYXRhQWRhcHRlcixcclxuICAgICdmbG9hdDR4NCc6IFZhbHVlRGF0YUFkYXB0ZXIsXHJcbiAgICAnaW50JzogVmFsdWVEYXRhQWRhcHRlcixcclxuICAgICdpbnQ0JzogVmFsdWVEYXRhQWRhcHRlcixcclxuICAgICdib29sJzogVmFsdWVEYXRhQWRhcHRlcixcclxuICAgICdieXRlJzogVmFsdWVEYXRhQWRhcHRlcixcclxuICAgICd1Ynl0ZSc6IFZhbHVlRGF0YUFkYXB0ZXIsXHJcbiAgICAnaW1nJzogTWlzYy5JbWdEYXRhQWRhcHRlcixcclxuICAgICd0ZXh0dXJlJzogVGV4dHVyZURhdGFBZGFwdGVyLFxyXG4gICAgJ2RhdGEnOiBEYXRhQWRhcHRlcixcclxuICAgICdwcm90byc6IERhdGFBZGFwdGVyLFxyXG4gICAgJ2RhdGFmbG93JzogRGF0YWZsb3dEYXRhQWRhcHRlcixcclxuICAgICdjb21wdXRlJzogQ29tcHV0ZURhdGFBZGFwdGVyLFxyXG4gICAgJ3ZpZGVvJzogTWlzYy5WaWRlb0RhdGFBZGFwdGVyLFxyXG4gICAgJ3NjcmlwdCc6IFNjcmlwdERhdGFBZGFwdGVyLFxyXG4gICAgJ3RyYW5zZm9ybSc6IFRyYW5zZm9ybURhdGFBZGFwdGVyLFxyXG4gICAgJ2Fzc2V0JzogQXNzZXQuQXNzZXRBZGFwdGVyLFxyXG4gICAgJ2Fzc2V0ZGF0YSc6IEFzc2V0LkFzc2V0RGF0YUFkYXB0ZXIsXHJcbiAgICAnYXNzZXRtZXNoJzogQXNzZXQuQXNzZXRNZXNoQWRhcHRlcixcclxuICAgICdtb2RlbCc6IEFzc2V0LkFzc2V0QWRhcHRlclxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBEYXRhQWRhcHRlciBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlXHJcbiAqICAgICAgICAgICAgZWxlbWVudCBub2RlIHdoaWNoIHVzZXMgZ2VuZXJpYyBkYXRhLiBUaGUgc3VwcG9ydGVkIGVsZW1lbnRzXHJcbiAqICAgICAgICAgICAgYXJlIGxpc3RlZCBpbiB0aGUgY2xhc3MgZGVzY3JpcHRpb24gYWJvdmUuXHJcbiAqIEByZXR1cm5zIERhdGFBZGFwdGVyIGluc3RhbmNlXHJcbiAqL1xyXG5YTUwzRERhdGFBZGFwdGVyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQWRhcHRlciA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAvL1hNTDNELmRlYnVnLmxvZ0RlYnVnKFwiQ3JlYXRpbmcgYWRhcHRlcjogXCIgKyBub2RlLmxvY2FsTmFtZSk7XHJcbiAgICB2YXIgYWRhcHRlckNvbnRydWN0b3IgPSByZWdbbm9kZS5sb2NhbE5hbWVdO1xyXG4gICAgaWYgKGFkYXB0ZXJDb250cnVjdG9yICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGFkYXB0ZXJDb250cnVjdG9yKHRoaXMsIG5vZGUpO1xyXG4gICAgfVxyXG4gICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIk5vdCBzdXBwb3J0ZWQgYXMgZGF0YSBlbGVtZW50OiBcIiArIG5vZGUubG9jYWxOYW1lKTtcclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAgWE1MM0REYXRhQWRhcHRlckZhY3Rvcnk7XHJcbiIsInZhciByZWdpc3RlckZvcm1hdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL3Jlc291cmNlbWFuYWdlci5qc1wiKS5yZWdpc3RlckZvcm1hdDtcclxudmFyIEZvcm1hdEhhbmRsZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9mb3JtYXRoYW5kbGVyLmpzXCIpLkZvcm1hdEhhbmRsZXI7XHJcbnZhciBBZGFwdGVyRmFjdG9yeSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2FkYXB0ZXIuanNcIikuQWRhcHRlckZhY3Rvcnk7XHJcblxyXG52YXIgSmF2YVNjcmlwdEZvcm1hdEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBGb3JtYXRIYW5kbGVyLmNhbGwodGhpcyk7XHJcbn07XHJcblhNTDNELmNyZWF0ZUNsYXNzKEphdmFTY3JpcHRGb3JtYXRIYW5kbGVyLCBGb3JtYXRIYW5kbGVyKTtcclxuXHJcbkphdmFTY3JpcHRGb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5pc0Zvcm1hdFN1cHBvcnRlZCA9IGZ1bmN0aW9uIChyZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBtaW1ldHlwZSkge1xyXG4gICAgcmV0dXJuIG1pbWV0eXBlID09PSBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiB8fCBtaW1ldHlwZSA9PT0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcclxufTtcclxuXHJcblxyXG5KYXZhU2NyaXB0Rm9ybWF0SGFuZGxlci5wcm90b3R5cGUuZ2V0Rm9ybWF0RGF0YSA9IGZ1bmN0aW9uIChyZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBtaW1ldHlwZSwgY2FsbGJhY2spIHtcclxuICAgIGNhbGxiYWNrKHRydWUsIHJlc3BvbnNlKTtcclxufTtcclxuXHJcbnZhciBqYXZhU2NyaXB0Rm9ybWF0SGFuZGxlciA9IG5ldyBKYXZhU2NyaXB0Rm9ybWF0SGFuZGxlcigpO1xyXG5yZWdpc3RlckZvcm1hdChqYXZhU2NyaXB0Rm9ybWF0SGFuZGxlcik7XHJcblxyXG5cclxudmFyIFNjcmlwdERhdGFBZGFwdGVyID0gZnVuY3Rpb24gKHNjcmlwdCkge1xyXG4gICAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XHJcbn07XHJcblxyXG5TY3JpcHREYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0U2NyaXB0VHlwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIjtcclxufTtcclxuXHJcblNjcmlwdERhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRTY3JpcHQ9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnNjcmlwdDtcclxufTtcclxuXHJcblxyXG52YXIgU2NyaXB0RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIEFkYXB0ZXJGYWN0b3J5LmNhbGwodGhpcywgXCJkYXRhXCIpO1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhTY3JpcHRGYWN0b3J5LCBBZGFwdGVyRmFjdG9yeSk7XHJcblxyXG5cclxuU2NyaXB0RmFjdG9yeS5wcm90b3R5cGUuYXNwZWN0ID0gXCJkYXRhXCI7XHJcblxyXG5TY3JpcHRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVBZGFwdGVyID0gZnVuY3Rpb24gKHhmbG93Tm9kZSkge1xyXG4gICAgcmV0dXJuIG5ldyBTY3JpcHREYXRhQWRhcHRlcih4Zmxvd05vZGUpO1xyXG59O1xyXG5cclxuamF2YVNjcmlwdEZvcm1hdEhhbmRsZXIucmVnaXN0ZXJGYWN0b3J5Q2xhc3MoU2NyaXB0RmFjdG9yeSk7XHJcbiIsInZhciBYQyA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgSW5wdXROb2RlID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9ncmFwaC5qc1wiKS5JbnB1dE5vZGU7XHJcbnZhciBEYXRhTm9kZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuRGF0YU5vZGU7XHJcbnZhciBCdWZmZXJFbnRyeSA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvZGF0YS5qc1wiKS5CdWZmZXJFbnRyeTtcclxudmFyIFJlc291cmNlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvcmVzb3VyY2VtYW5hZ2VyLmpzXCIpLlJlc291cmNlO1xyXG52YXIgcmVnaXN0ZXJGb3JtYXQgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9yZXNvdXJjZW1hbmFnZXIuanNcIikucmVnaXN0ZXJGb3JtYXQ7XHJcbnZhciBKU09ORm9ybWF0SGFuZGxlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2Zvcm1hdGhhbmRsZXIuanNcIikuSlNPTkZvcm1hdEhhbmRsZXI7XHJcbnZhciBBZGFwdGVyRmFjdG9yeSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2FkYXB0ZXIuanNcIikuQWRhcHRlckZhY3Rvcnk7XHJcblxyXG52YXIgWE1MM0RKU09ORm9ybWF0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgSlNPTkZvcm1hdEhhbmRsZXIuY2FsbCh0aGlzKTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoWE1MM0RKU09ORm9ybWF0SGFuZGxlciwgSlNPTkZvcm1hdEhhbmRsZXIpO1xyXG5cclxuWE1MM0RKU09ORm9ybWF0SGFuZGxlci5wcm90b3R5cGUuaXNGb3JtYXRTdXBwb3J0ZWQgPSBmdW5jdGlvbihyZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBtaW1ldHlwZSkge1xyXG4gICAgcmV0dXJuIG1pbWV0eXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIiAmJiByZXNwb25zZS5mb3JtYXQgPT0gXCJ4bWwzZC1qc29uXCIgJiYgcmVzcG9uc2UudmVyc2lvbiA9PSBcIjAuNC4wXCI7XHJcbn07XHJcblxyXG5cclxuWE1MM0RKU09ORm9ybWF0SGFuZGxlci5wcm90b3R5cGUuZ2V0Rm9ybWF0RGF0YSA9IGZ1bmN0aW9uKHJlc3BvbnNlLCByZXNwb25zZVR5cGUsIG1pbWV0eXBlLCBjYWxsYmFjaykge1xyXG4gICAgdHJ5e1xyXG4gICAgICAgIHZhciB4Zmxvd05vZGUgPSBjcmVhdGVYZmxvd05vZGUocmVzcG9uc2UpO1xyXG4gICAgICAgIGNhbGxiYWNrKHRydWUsIHhmbG93Tm9kZSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXhjZXB0aW9uKGUsIFwiRmFpbGVkIHRvIHByb2Nlc3MgWE1MM0QganNvbiBmaWxlXCIpO1xyXG4gICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG52YXIgeG1sM2RKU29uRm9ybWF0SGFuZGxlciA9IG5ldyBYTUwzREpTT05Gb3JtYXRIYW5kbGVyKCk7XHJcbnJlZ2lzdGVyRm9ybWF0KHhtbDNkSlNvbkZvcm1hdEhhbmRsZXIpO1xyXG5cclxuXHJcbnZhciBlbXB0eSA9IGZ1bmN0aW9uKCkge307XHJcblxyXG52YXIgVFlQRURfQVJSQVlfTUFQID0ge1xyXG4gICAgXCJpbnRcIiA6IEludDMyQXJyYXksXHJcbiAgICBcImludDRcIiA6IEludDMyQXJyYXksXHJcbiAgICBcImZsb2F0XCIgOiBGbG9hdDMyQXJyYXksXHJcbiAgICBcImZsb2F0MlwiIDogRmxvYXQzMkFycmF5LFxyXG4gICAgXCJmbG9hdDNcIiA6IEZsb2F0MzJBcnJheSxcclxuICAgIFwiZmxvYXQ0XCIgOiBGbG9hdDMyQXJyYXksXHJcbiAgICBcImZsb2F0NHg0XCIgOiBGbG9hdDMyQXJyYXksXHJcbiAgICBcImJvb2xcIiA6IFVpbnQ4QXJyYXksXHJcbiAgICBcImJ5dGVcIiA6IEludDhBcnJheSxcclxuICAgIFwidWJ5dGVcIiA6IFVpbnQ4QXJyYXlcclxufTtcclxuXHJcbnZhciBpc0xpdHRsZUVuZGlhbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDQpO1xyXG4gICAgdmFyIGR2ID0gbmV3IERhdGFWaWV3KGJ1Zik7XHJcbiAgICB2YXIgdmlldyA9IG5ldyBJbnQzMkFycmF5KGJ1Zik7XHJcbiAgICB2aWV3WzBdID0gMHgwMTAyMDMwNDtcclxuICAgIHZhciBsaXR0bGVFbmRpYW4gPSAoZHYuZ2V0SW50MzIoMCwgdHJ1ZSkgPT09IDB4MDEwMjAzMDQpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpdHRsZUVuZGlhbjsgfVxyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gcmVhbFR5cGVPZihvYmopIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKS5zbGljZSg4LCAtMSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVhmbG93VmFsdWUoZGF0YU5vZGUsIGRhdGFUeXBlLCBuYW1lLCBrZXksIHZhbHVlKSB7XHJcbiAgICB2YXIgdiA9IG5ldyAoVFlQRURfQVJSQVlfTUFQW2RhdGFUeXBlXSkodmFsdWUpO1xyXG4gICAgdmFyIHR5cGUgPSBYQy5EQVRBX1RZUEUuZnJvbVN0cmluZyhkYXRhVHlwZSk7XHJcbiAgICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlckVudHJ5KHR5cGUsIHYpO1xyXG5cclxuICAgIHZhciBpbnB1dE5vZGUgPSBuZXcgSW5wdXROb2RlKCk7XHJcbiAgICBpbnB1dE5vZGUuZGF0YSA9IGJ1ZmZlcjtcclxuICAgIGlucHV0Tm9kZS5uYW1lID0gbmFtZTtcclxuICAgIGlucHV0Tm9kZS5rZXkgPSBrZXk7XHJcbiAgICBkYXRhTm9kZS5hcHBlbmRDaGlsZChpbnB1dE5vZGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVYZmxvd1ZhbHVlRnJvbUJ1ZmZlcihkYXRhTm9kZSwgZGF0YVR5cGUsIG5hbWUsIGtleSwgYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcclxuICAgIHZhciBBcnJheVR5cGUgPSBUWVBFRF9BUlJBWV9NQVBbZGF0YVR5cGVdO1xyXG4gICAgdmFyIHYgPSBuZXcgKEFycmF5VHlwZSkoYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgvQXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UKTtcclxuICAgIHZhciB0eXBlID0gWEMuREFUQV9UWVBFLmZyb21TdHJpbmcoZGF0YVR5cGUpO1xyXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXJFbnRyeSh0eXBlLCB2KTtcclxuXHJcbiAgICB2YXIgaW5wdXROb2RlID0gbmV3IElucHV0Tm9kZSgpO1xyXG4gICAgaW5wdXROb2RlLmRhdGEgPSBidWZmZXI7XHJcbiAgICBpbnB1dE5vZGUubmFtZSA9IG5hbWU7XHJcbiAgICBpbnB1dE5vZGUua2V5ID0ga2V5O1xyXG4gICAgZGF0YU5vZGUuYXBwZW5kQ2hpbGQoaW5wdXROb2RlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlWGZsb3dJbnB1dHMoZGF0YU5vZGUsIG5hbWUsIGpzb25EYXRhKXtcclxuICAgIHZhciB2ID0gbnVsbDtcclxuXHJcbiAgICBpZiAoIVRZUEVEX0FSUkFZX01BUFtqc29uRGF0YS50eXBlXSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGpzb25EYXRhLnNlcS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IGpzb25EYXRhLnNlcVtpXTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBlbnRyeS52YWx1ZTtcclxuICAgICAgICB2YXIga2V5ID0gZW50cnkua2V5O1xyXG5cclxuICAgICAgICBpZiAocmVhbFR5cGVPZih2YWx1ZSkgPT09ICdPYmplY3QnICYmIHZhbHVlLnVybCkge1xyXG4gICAgICAgICAgICBpZiAoIWlzTGl0dGxlRW5kaWFuKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEZJWE1FIGFkZCBiaWctZW5kaWFuIC0+IGxpdHRsZS1lbmRpYW4gY29udmVyc2lvblxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmlnLWVuZGlhbiBiaW5hcnkgZGF0YSBhcmUgbm90IHN1cHBvcnRlZCB5ZXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUmVzb3VyY2UubG9hZERhdGEodmFsdWUudXJsLCBmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZVhmbG93VmFsdWVGcm9tQnVmZmVyKGRhdGFOb2RlLCBqc29uRGF0YS50eXBlLCBuYW1lLCBrZXksIGFycmF5QnVmZmVyLCB2YWx1ZS5ieXRlT2Zmc2V0LCB2YWx1ZS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgfSwgbnVsbCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY3JlYXRlWGZsb3dWYWx1ZShkYXRhTm9kZSwganNvbkRhdGEudHlwZSwgbmFtZSwga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVYZmxvd05vZGUoanNvbkRhdGEpe1xyXG4gICAgaWYgKGpzb25EYXRhLmZvcm1hdCAhPSBcInhtbDNkLWpzb25cIilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEpTT04gZm9ybWF0OiBcIiArIGpzb25EYXRhLmZvcm1hdCk7XHJcbiAgICBpZiAoanNvbkRhdGEudmVyc2lvbiAhPSBcIjAuNC4wXCIpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBKU09OIHZlcnNpb246IFwiICsganNvbkRhdGEudmVyc2lvbik7XHJcblxyXG4gICAgdmFyIG5vZGUgPSBuZXcgRGF0YU5vZGUoZmFsc2UpO1xyXG4gICAgbm9kZS51c2VyRGF0YSA9IFwiRXh0ZXJuYWwgSnNvblwiOyAvLyBUT0RPOiBUcnkgdG8gYWRkIGRvY3VtZW50IFVSTCBoZXJlIChob3cgdG8gZ2V0IGl0PylcclxuXHJcbiAgICB2YXIgZW50cmllcyA9IGpzb25EYXRhLmRhdGE7XHJcbiAgICBmb3IodmFyIG5hbWUgaW4gZW50cmllcykge1xyXG4gICAgICAgIGNyZWF0ZVhmbG93SW5wdXRzKG5vZGUsIG5hbWUsIGVudHJpZXNbbmFtZV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaW1wbGVtZW50cyBJRGF0YUFkYXB0ZXJcclxuICovXHJcbnZhciBKU09ORGF0YUFkYXB0ZXIgPSBmdW5jdGlvbih4Zmxvd05vZGUpIHtcclxuICAgIHRoaXMueGZsb3dEYXRhTm9kZSA9IHhmbG93Tm9kZTtcclxufTtcclxuXHJcbkpTT05EYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0WGZsb3dOb2RlID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLnhmbG93RGF0YU5vZGU7XHJcbn07XHJcblxyXG4vKipcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBpbXBsZW1lbnRzIHtYTUwzRC5iYXNlLklGYWN0b3J5fVxyXG4gKi9cclxudmFyIEpTT05GYWN0b3J5ID0gZnVuY3Rpb24oKVxyXG57XHJcbiAgICBBZGFwdGVyRmFjdG9yeS5jYWxsKHRoaXMsIFwiZGF0YVwiKTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoSlNPTkZhY3RvcnksIEFkYXB0ZXJGYWN0b3J5KTtcclxuXHJcblxyXG5KU09ORmFjdG9yeS5wcm90b3R5cGUuYXNwZWN0ID0gXCJkYXRhXCI7XHJcblxyXG5KU09ORmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQWRhcHRlciA9IGZ1bmN0aW9uKHhmbG93Tm9kZSkge1xyXG4gICAgcmV0dXJuIG5ldyBKU09ORGF0YUFkYXB0ZXIoeGZsb3dOb2RlKTtcclxufTtcclxuXHJcbnhtbDNkSlNvbkZvcm1hdEhhbmRsZXIucmVnaXN0ZXJGYWN0b3J5Q2xhc3MoSlNPTkZhY3RvcnkpO1xyXG4iLCJ2YXIgRGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xyXG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XHJcbnZhciBVUkkgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvdXJpLmpzXCIpLlVSSTtcclxudmFyIFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbWlzYy5qc1wiKTtcclxuXHJcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL3Jlc291cmNlbWFuYWdlci5qc1wiKS5SZXNvdXJjZTtcclxudmFyIE5vZGVBZGFwdGVyID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvYWRhcHRlci5qc1wiKS5Ob2RlQWRhcHRlcjtcclxudmFyIGNyZWF0ZUNsYXNzID0gWE1MM0QuY3JlYXRlQ2xhc3M7XHJcbiAgICAvKipcclxuICAgICAqIFNpbmtEYXRhQWRhcHRlciByZXByZXNlbnRzIHRoZSBzaW5rIGluIHRoZSBkYXRhIGhpZXJhcmNoeSAobm8gcGFyZW50cykuXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleHRlbmRzIHtEYXRhQWRhcHRlcn1cclxuICAgICAqIEBwYXJhbSBmYWN0b3J5XHJcbiAgICAgKiBAcGFyYW0gbm9kZVxyXG4gICAgICovXHJcbiAgICB2YXIgU2lua0RhdGFBZGFwdGVyID0gZnVuY3Rpb24oZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgICAgIERhdGFBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICB9O1xyXG4gICAgY3JlYXRlQ2xhc3MoU2lua0RhdGFBZGFwdGVyLCBEYXRhQWRhcHRlcik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIERhdGFBZGFwdGVyIGlzIGEgU2lua0FkYXB0ZXIgKGhhcyBubyBwYXJlbnRcclxuICAgICAqIERhdGFBZGFwdGVyKS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgRGF0YUFkYXB0ZXIgaXMgYSBTaW5rQWRhcHRlciwgb3RoZXJ3aXNlIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBTaW5rRGF0YUFkYXB0ZXIucHJvdG90eXBlLmlzU2lua0FkYXB0ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGFBZGFwdGVyXHJcbiAgICAgKi9cclxuICAgIFNpbmtEYXRhQWRhcHRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gXCJYTUwzRC5kYXRhLlNpbmtEYXRhQWRhcHRlclwiO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgdmFyIEltZ0RhdGFBZGFwdGVyID0gZnVuY3Rpb24oZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgICAgIE5vZGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlRW50cnkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBudWxsO1xyXG4gICAgICAgIGlmIChub2RlLnNyYylcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVJbWFnZUZyb21VUkwobm9kZS5zcmMpO1xyXG4gICAgfTtcclxuICAgIGNyZWF0ZUNsYXNzKEltZ0RhdGFBZGFwdGVyLCBOb2RlQWRhcHRlcik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGltYWdlIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcclxuICAgICAqL1xyXG4gICAgSW1nRGF0YUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUltYWdlRnJvbVVSTCA9IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgdXJpID0gbmV3IFVSSSh1cmwpLmdldEFic29sdXRlVVJJKHRoaXMubm9kZS5vd25lckRvY3VtZW50Ll9kb2N1bWVudFVSTCB8fCB0aGlzLm5vZGUub3duZXJEb2N1bWVudC5VUkwpO1xyXG4gICAgICAgIHZhciBvbmxvYWQgPSBmdW5jdGlvbiAoZSwgaW1hZ2UpIHtcclxuICAgICAgICAgICAgaWYgKHRoYXQudGV4dHVyZUVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnRleHR1cmVFbnRyeS5zZXRJbWFnZShpbWFnZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24gKGUsIGltYWdlKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQ291bGQgbm90IGxvYWQgaW1hZ2UgVVJJPVwiK2ltYWdlLnNyYyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmltYWdlID0gUmVzb3VyY2UuZ2V0SW1hZ2UodXJpLCBvbmxvYWQsIG9uZXJyb3IpO1xyXG4gICAgICAgIGlmICh0aGF0LnRleHR1cmVFbnRyeSkge1xyXG4gICAgICAgICAgICB0aGF0LnRleHR1cmVFbnRyeS5zZXRJbWFnZSh0aGlzLmltYWdlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtYZmxvdy5UZXh0dXJlRW50cnl9IGVudHJ5XHJcbiAgICAgKi9cclxuICAgIEltZ0RhdGFBZGFwdGVyLnByb3RvdHlwZS5zZXRUZXh0dXJlRW50cnkgPSBmdW5jdGlvbihlbnRyeSkge1xyXG4gICAgICAgIHRoaXMudGV4dHVyZUVudHJ5ID0gZW50cnk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlRW50cnkuc2V0SW1hZ2UodGhpcy5pbWFnZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBJbWdEYXRhQWRhcHRlci5wcm90b3R5cGUubm90aWZ5Q2hhbmdlZCA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIGlmIChldnQudHlwZSA9PSBFdmVudHMuVkFMVUVfTU9ESUZJRUQpIHtcclxuICAgICAgICAgICAgdmFyIGF0dHIgPSBldnQubXV0YXRpb24uYXR0cmlidXRlTmFtZTtcclxuICAgICAgICAgICAgaWYoYXR0ciA9PSBcInNyY1wiKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlSW1hZ2VGcm9tVVJMKHRoaXMubm9kZS5zcmMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgSW1nRGF0YUFkYXB0ZXIucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oY2IsIG9iaikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlO1xyXG4gICAgfTtcclxuXHJcbiAgICBJbWdEYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICByZXN1bHRbJ2ltYWdlJ10gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIEltZ0RhdGFBZGFwdGVyLnByb3RvdHlwZS5yZXNvbHZlU2NyaXB0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBWaWRlb0RhdGFBZGFwdGVyID0gZnVuY3Rpb24oZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgICAgIERhdGFBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlRW50cnkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlkZW8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RpY2tpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9ib3VuZFRpY2sgPSB0aGlzLl90aWNrLmJpbmQodGhpcyk7XHJcbiAgICAgICAgaWYgKG5vZGUuc3JjKVxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVZpZGVvRnJvbVVSTChub2RlLnNyYyk7XHJcbiAgICB9O1xyXG4gICAgY3JlYXRlQ2xhc3MoVmlkZW9EYXRhQWRhcHRlciwgTm9kZUFkYXB0ZXIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB2aWRlbyBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXHJcbiAgICAgKi9cclxuICAgIFZpZGVvRGF0YUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVZpZGVvRnJvbVVSTCA9IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgdXJpID0gbmV3IFVSSSh1cmwpLmdldEFic29sdXRlVVJJKHRoaXMubm9kZS5vd25lckRvY3VtZW50Ll9kb2N1bWVudFVSTCB8fCB0aGlzLm5vZGUub3duZXJEb2N1bWVudC5VUkwpO1xyXG4gICAgICAgIHRoaXMudmlkZW8gPSBSZXNvdXJjZS5nZXRWaWRlbyh1cmksIHRoaXMubm9kZS5hdXRvcGxheSwgdGhpcy5ub2RlLmxvb3AsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhbnBsYXkgOiBmdW5jdGlvbihldmVudCwgdmlkZW8pIHtcclxuICAgICAgICAgICAgICAgICAgICBVdGlsLmRpc3BhdGNoQ3VzdG9tRXZlbnQodGhhdC5ub2RlLCAnY2FucGxheScsIHRydWUsIHRydWUsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX3N0YXJ0VmlkZW9SZWZyZXNoKCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW5kZWQgOiBmdW5jdGlvbihldmVudCwgdmlkZW8pIHtcclxuICAgICAgICAgICAgICAgICAgICBVdGlsLmRpc3BhdGNoQ3VzdG9tRXZlbnQodGhhdC5ub2RlLCAnZW5kZWQnLCB0cnVlLCB0cnVlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsb2FkIDogZnVuY3Rpb24oZXZlbnQsIHZpZGVvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVXRpbC5kaXNwYXRjaEV2ZW50KHRoYXQubm9kZSwgJ2xvYWQnKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlcnJvciA6IGZ1bmN0aW9uKGV2ZW50LCB2aWRlbykge1xyXG4gICAgICAgICAgICAgICAgICAgIFV0aWwuZGlzcGF0Y2hDdXN0b21FdmVudCh0aGF0Lm5vZGUsICdlcnJvcicsIHRydWUsIHRydWUsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQ291bGQgbm90IGxvYWQgdmlkZW8gVVJJPVwiK3ZpZGVvLnNyYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIGlmICh0aGlzLnRleHR1cmVFbnRyeSlcclxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlRW50cnkuc2V0SW1hZ2UodGhpcy52aWRlbywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFZpZGVvRGF0YUFkYXB0ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy52aWRlbylcclxuICAgICAgICAgICAgdGhpcy52aWRlby5wbGF5KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFZpZGVvRGF0YUFkYXB0ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmlkZW8pXHJcbiAgICAgICAgICAgIHRoaXMudmlkZW8ucGF1c2UoKTtcclxuICAgIH07XHJcblxyXG4gICAgVmlkZW9EYXRhQWRhcHRlci5wcm90b3R5cGUuX3N0YXJ0VmlkZW9SZWZyZXNoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl90aWNraW5nKVxyXG4gICAgICAgICAgICB0aGlzLl90aWNrKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFZpZGVvRGF0YUFkYXB0ZXIucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fdGlja2luZyA9IHRydWU7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltRnJhbWUodGhpcy5fYm91bmRUaWNrLCAzMCk7XHJcbiAgICAgICAgLy8gRklYTUUgRG8gdGhpcyBvbmx5IHdoZW4gY3VycmVudFRpbWUgaXMgY2hhbmdlZCAod2hhdCBhYm91dCB3ZWJjYW0gPylcclxuICAgICAgICBpZiAodGhpcy50ZXh0dXJlRW50cnkpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlRW50cnkuc2V0SW1hZ2UodGhpcy52aWRlbyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7WGZsb3cuVGV4dHVyZUVudHJ5fSBlbnRyeVxyXG4gICAgICovXHJcbiAgICBWaWRlb0RhdGFBZGFwdGVyLnByb3RvdHlwZS5zZXRUZXh0dXJlRW50cnkgPSBmdW5jdGlvbihlbnRyeSkge1xyXG4gICAgICAgIHRoaXMudGV4dHVyZUVudHJ5ID0gZW50cnk7XHJcbiAgICAgICAgaWYgKHRoaXMudmlkZW8pIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlRW50cnkuc2V0SW1hZ2UodGhpcy52aWRlbywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBWaWRlb0RhdGFBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgaWYgKGV2dC50eXBlID09IEV2ZW50cy5WQUxVRV9NT0RJRklFRCkge1xyXG4gICAgICAgICAgICB2YXIgYXR0ciA9IGV2dC5tdXRhdGlvbi5hdHRyaWJ1dGVOYW1lO1xyXG4gICAgICAgICAgICBpZihhdHRyID09IFwic3JjXCIpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVWaWRlb0Zyb21VUkwodGhpcy5ub2RlLnNyYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBWaWRlb0RhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKGNiLCBvYmopIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWRlbztcclxuICAgIH07XHJcblxyXG4gICAgVmlkZW9EYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICByZXN1bHRbJ3ZpZGVvJ10gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEV4cG9ydFxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgSW1nRGF0YUFkYXB0ZXI6IEltZ0RhdGFBZGFwdGVyLFxyXG4gICAgICAgIFZpZGVvRGF0YUFkYXB0ZXI6IFZpZGVvRGF0YUFkYXB0ZXIsXHJcbiAgICAgICAgU2lua0RhdGFBZGFwdGVyOiBTaW5rRGF0YUFkYXB0ZXJcclxuICAgIH07XHJcblxyXG4iLCJ2YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XHJcbnZhciBjcmVhdGVDbGFzcyA9IFhNTDNELmNyZWF0ZUNsYXNzO1xyXG52YXIgTm9kZUFkYXB0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9hZGFwdGVyLmpzXCIpLk5vZGVBZGFwdGVyO1xyXG5cclxudmFyIFNjcmlwdERhdGFBZGFwdGVyID0gZnVuY3Rpb24oZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgTm9kZUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcclxuICAgIHRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZSA9IG51bGw7XHJcbiAgICBpZiAobm9kZS5zcmMpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGUgPSB0aGlzLmdldEFkYXB0ZXJIYW5kbGUobm9kZS5zcmMpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdEFkYXB0ZXJIYW5kbGUobm9kZS5uYW1lLCB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGUpO1xyXG4gICAgfVxyXG59O1xyXG5jcmVhdGVDbGFzcyhTY3JpcHREYXRhQWRhcHRlciwgTm9kZUFkYXB0ZXIpO1xyXG5cclxuU2NyaXB0RGF0YUFkYXB0ZXIucHJvdG90eXBlLmdldFNjcmlwdFR5cGUgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMubm9kZS50eXBlO1xyXG59O1xyXG5cclxuU2NyaXB0RGF0YUFkYXB0ZXIucHJvdG90eXBlLmdldFNjcmlwdCA9IGZ1bmN0aW9uKCl7XHJcbiAgICBpZiAodGhpcy5ub2RlLnNyYykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2NyaXB0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnZhbHVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU2NyaXB0RGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIHN3aXRjaChldnQudHlwZSl7XHJcbiAgICAgICAgY2FzZSBFdmVudHMuVkFMVUVfTU9ESUZJRUQ6XHJcbiAgICAgICAgY2FzZSBFdmVudHMuTk9ERV9JTlNFUlRFRDpcclxuICAgICAgICBjYXNlIEV2ZW50cy5OT0RFX1JFTU9WRUQ6XHJcbiAgICAgICAgICAgIHRoaXMubm90aWZ5T3Bwb3NpdGVBZGFwdGVycygpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBFdmVudHMuQURBUFRFUl9IQU5ETEVfQ0hBTkdFRDpcclxuICAgICAgICAgICAgdGhpcy5leHRlcm5hbFNjcmlwdCA9IGV2dC5hZGFwdGVyLnNjcmlwdDtcclxuICAgICAgICAgICAgdGhpcy5ub3RpZnlPcHBvc2l0ZUFkYXB0ZXJzKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTY3JpcHREYXRhQWRhcHRlcjsiLCJ2YXIgVGV4dHVyZUVudHJ5ID0gcmVxdWlyZShcIi4uLy4uL3hmbG93L2ludGVyZmFjZS9kYXRhLmpzXCIpLlRleHR1cmVFbnRyeTtcclxudmFyIElucHV0Tm9kZSA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuSW5wdXROb2RlO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgTm9kZUFkYXB0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9hZGFwdGVyLmpzXCIpLk5vZGVBZGFwdGVyO1xyXG5cclxudmFyIGNsYW1wVG9HTCA9IGZ1bmN0aW9uIChtb2RlU3RyKSB7XHJcbiAgICBpZiAobW9kZVN0ciA9PSBcImNsYW1wXCIpXHJcbiAgICAgICAgcmV0dXJuIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFO1xyXG4gICAgaWYgKG1vZGVTdHIgPT0gXCJyZXBlYXRcIilcclxuICAgICAgICByZXR1cm4gV2ViR0xSZW5kZXJpbmdDb250ZXh0LlJFUEVBVDtcclxufTtcclxuXHJcbnZhciBmaWx0ZXJUb0dMID0gZnVuY3Rpb24gKG1vZGVTdHIpIHtcclxuICAgIGlmIChtb2RlU3RyID09IFwibmVhcmVzdFwiKVxyXG4gICAgICAgIHJldHVybiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVDtcclxuICAgIGlmIChtb2RlU3RyID09IFwibGluZWFyXCIpXHJcbiAgICAgICAgcmV0dXJuIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5MSU5FQVI7XHJcbiAgICBpZiAobW9kZVN0ciA9PSBcIm5lYXJlc3QtbWlwbWFwLW5lYXJlc3RcIilcclxuICAgICAgICByZXR1cm4gV2ViR0xSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q7XHJcbiAgICBpZiAobW9kZVN0ciA9PSBcImxpbmVhci1taXBtYXAtbmVhcmVzdFwiKVxyXG4gICAgICAgIHJldHVybiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuTElORUFSX01JUE1BUF9ORUFSRVNUO1xyXG4gICAgaWYgKG1vZGVTdHIgPT0gXCJuZWFyZXN0LW1pcG1hcC1saW5lYXJcIilcclxuICAgICAgICByZXR1cm4gV2ViR0xSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1RfTUlQTUFQX0xJTkVBUjtcclxuICAgIGlmIChtb2RlU3RyID09IFwibGluZWFyLW1pcG1hcC1saW5lYXJcIilcclxuICAgICAgICByZXR1cm4gV2ViR0xSZW5kZXJpbmdDb250ZXh0LkxJTkVBUl9NSVBNQVBfTElORUFSO1xyXG59O1xyXG5cclxudmFyIFRleHR1cmVEYXRhQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XHJcbiAgICBOb2RlQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpO1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhUZXh0dXJlRGF0YUFkYXB0ZXIsIE5vZGVBZGFwdGVyKTtcclxuXHJcblRleHR1cmVEYXRhQWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMueGZsb3dJbnB1dE5vZGUgPSB0aGlzLmNyZWF0ZVhmbG93Tm9kZSgpO1xyXG4gICAgdGhpcy54Zmxvd0lucHV0Tm9kZS5kYXRhID0gdGhpcy5jcmVhdGVUZXh0dXJlRW50cnkoKTtcclxufTtcclxuXHJcblRleHR1cmVEYXRhQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlVGV4dHVyZUVudHJ5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XHJcbiAgICB2YXIgZW50cnkgPSBuZXcgVGV4dHVyZUVudHJ5KG51bGwpO1xyXG4gICAgdmFyIGNvbmZpZyA9IGVudHJ5LmdldFNhbXBsZXJDb25maWcoKTtcclxuICAgIGNvbmZpZy53cmFwUyA9IGNsYW1wVG9HTChub2RlLndyYXBTKTtcclxuICAgIGNvbmZpZy53cmFwVCA9IGNsYW1wVG9HTChub2RlLndyYXBUKTtcclxuICAgIGNvbmZpZy5taW5GaWx0ZXIgPSBmaWx0ZXJUb0dMKG5vZGUuZmlsdGVyTWluKTtcclxuICAgIGNvbmZpZy5tYWdGaWx0ZXIgPSBmaWx0ZXJUb0dMKG5vZGUuZmlsdGVyTWFnKTtcclxuICAgIGNvbmZpZy50ZXh0dXJlVHlwZSA9IFhDLlRFWF9UWVBFLlRFWFRVUkVfMkQ7XHJcbiAgICBjb25maWcuZ2VuZXJhdGVNaXBNYXAgPSB0aGlzLnNob3VsZEdlbmVyYXRlTWlwTWFwcyhjb25maWcubWluRmlsdGVyLCBjb25maWcubWFnRmlsdGVyKTtcclxuXHJcbiAgICB2YXIgaW1hZ2VBZGFwdGVyID0gdGhpcy5mYWN0b3J5LmdldEFkYXB0ZXIodGhpcy5ub2RlLmZpcnN0RWxlbWVudENoaWxkKTtcclxuICAgIGlmIChpbWFnZUFkYXB0ZXIpIHtcclxuICAgICAgICBpbWFnZUFkYXB0ZXIuc2V0VGV4dHVyZUVudHJ5KGVudHJ5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbnRyeTtcclxufTtcclxuXHJcblRleHR1cmVEYXRhQWRhcHRlci5wcm90b3R5cGUuc2hvdWxkR2VuZXJhdGVNaXBNYXBzID0gZnVuY3Rpb24gKG1pbkZpbHRlciwgbWFnRmlsdGVyKSB7XHJcbiAgICByZXR1cm4gKG1pbkZpbHRlciAhPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCAmJiBtaW5GaWx0ZXIgIT0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LkxJTkVBUikgfHwgKG1hZ0ZpbHRlciAhPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCAmJiBtYWdGaWx0ZXIgIT0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LkxJTkVBUik7XHJcbn07XHJcblxyXG5UZXh0dXJlRGF0YUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVhmbG93Tm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4bm9kZSA9IG5ldyBJbnB1dE5vZGUoKTtcclxuICAgIHhub2RlLm5hbWUgPSB0aGlzLm5vZGUubmFtZTtcclxuICAgIHhub2RlLnBhcmFtTmFtZSA9IHRoaXMubm9kZS5wYXJhbSA/IHRoaXMubm9kZS5uYW1lIDogbnVsbDtcclxuICAgIHhub2RlLmtleSA9IHRoaXMubm9kZS5rZXk7XHJcbiAgICByZXR1cm4geG5vZGU7XHJcbn07XHJcblxyXG5UZXh0dXJlRGF0YUFkYXB0ZXIucHJvdG90eXBlLnNldFNjcmlwdFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlRleHR1cmUgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgc2V0U2NyaXB0VmFsdWUoKVwiKTtcclxufVxyXG5cclxuVGV4dHVyZURhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRPdXRwdXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgcmVzdWx0W3RoaXMubm9kZS5uYW1lXSA9IHRoaXM7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuVGV4dHVyZURhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG59O1xyXG5cclxuVGV4dHVyZURhdGFBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgaWYgKGV2dC50eXBlID09IEV2ZW50cy5WQUxVRV9NT0RJRklFRCkge1xyXG4gICAgICAgIHZhciBhdHRyID0gZXZ0Lm11dGF0aW9uLmF0dHJpYnV0ZU5hbWU7XHJcbiAgICAgICAgaWYgKGF0dHIgPT0gXCJuYW1lXCIpIHtcclxuICAgICAgICAgICAgdGhpcy54Zmxvd0lucHV0Tm9kZS5uYW1lID0gdGhpcy5ub2RlLm5hbWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChhdHRyID09IFwia2V5XCIpIHtcclxuICAgICAgICAgICAgdGhpcy54Zmxvd0lucHV0Tm9kZS5rZXkgPSB0aGlzLm5vZGUua2V5O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXR0ciA9PSBcInBhcmFtXCIpIHtcclxuICAgICAgICAgICAgdGhpcy54Zmxvd0lucHV0Tm9kZS5wYXJhbU5hbWUgPSB0aGlzLm5vZGUucGFyYW0gPyB0aGlzLm5vZGUubmFtZSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAqL1xyXG5UZXh0dXJlRGF0YUFkYXB0ZXIucHJvdG90eXBlLmdldFhmbG93Tm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnhmbG93SW5wdXROb2RlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgVGV4dHVyZURhdGFBZGFwdGVyXHJcbiAqL1xyXG5UZXh0dXJlRGF0YUFkYXB0ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIFwiWE1MM0QuZGF0YS5UZXh0dXJlRGF0YUFkYXB0ZXJcIjtcclxufTtcclxuXHJcbi8vIEV4cG9ydFxyXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmVEYXRhQWRhcHRlcjtcclxuIiwidmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgTm9kZUFkYXB0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9hZGFwdGVyLmpzXCIpLk5vZGVBZGFwdGVyO1xyXG5cclxudmFyIFRyYW5zZm9ybURhdGFBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIE5vZGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICB0aGlzLmlzVmFsaWQgPSB0cnVlO1xyXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhUcmFuc2Zvcm1EYXRhQWRhcHRlciwgTm9kZUFkYXB0ZXIpO1xyXG5cclxudmFyIElERU5UX01BVCA9IFhNTDNELm1hdGgubWF0NC5pZGVudGl0eShYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCkpO1xyXG5cclxuVHJhbnNmb3JtRGF0YUFkYXB0ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBDcmVhdGUgYWxsIG1hdHJpY2VzLCBubyB2YWxpZCB2YWx1ZXMgeWV0XHJcbiAgICB0aGlzLm1hdHJpeCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuICAgIHRoaXMudHJhbnNmb3JtID0ge1xyXG4gICAgICAgIHRyYW5zbGF0ZTogWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpLFxyXG4gICAgICAgIHNjYWxlOiBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCksXHJcbiAgICAgICAgc2NhbGVPcmllbnRhdGlvbjogWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpLFxyXG4gICAgICAgIHNjYWxlT3JpZW50YXRpb25JbnY6IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKSxcclxuICAgICAgICBjZW50ZXI6IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKSxcclxuICAgICAgICBjZW50ZXJJbnZlcnNlOiBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCksXHJcbiAgICAgICAgcm90YXRpb246IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKVxyXG4gICAgfTtcclxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgdGhpcy5jaGVja0ZvckltcHJvcGVyTmVzdGluZygpO1xyXG59O1xyXG5cclxuVHJhbnNmb3JtRGF0YUFkYXB0ZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBuID0gdGhpcy5ub2RlO1xyXG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xyXG4gICAgdmFyIGNlbnRlclZlYyA9IG4uY2VudGVyLl9kYXRhO1xyXG5cclxuICAgIFhNTDNELm1hdGgubWF0NC5mcm9tUXVhdCh0cmFuc2Zvcm0uc2NhbGVPcmllbnRhdGlvbiwgbi5zY2FsZU9yaWVudGF0aW9uLl9kYXRhKTtcclxuICAgIFhNTDNELm1hdGgubWF0NC5mcm9tUXVhdCh0cmFuc2Zvcm0ucm90YXRpb24sIG4ucm90YXRpb24uX2RhdGEpO1xyXG5cclxuICAgIFhNTDNELm1hdGgubWF0NC50cmFuc2xhdGUodHJhbnNmb3JtLnRyYW5zbGF0ZSwgSURFTlRfTUFULCBuLnRyYW5zbGF0aW9uLl9kYXRhKTtcclxuICAgIFhNTDNELm1hdGgubWF0NC50cmFuc2xhdGUodHJhbnNmb3JtLmNlbnRlciwgSURFTlRfTUFULCBjZW50ZXJWZWMpO1xyXG4gICAgWE1MM0QubWF0aC5tYXQ0LnRyYW5zbGF0ZSh0cmFuc2Zvcm0uY2VudGVySW52ZXJzZSwgSURFTlRfTUFULCBYTUwzRC5tYXRoLnZlYzMubmVnYXRlKGNlbnRlclZlYywgY2VudGVyVmVjKSk7XHJcbiAgICBYTUwzRC5tYXRoLm1hdDQuc2NhbGUodHJhbnNmb3JtLnNjYWxlLCBJREVOVF9NQVQsIG4uc2NhbGUuX2RhdGEpO1xyXG4gICAgWE1MM0QubWF0aC5tYXQ0LmludmVydCh0cmFuc2Zvcm0uc2NhbGVPcmllbnRhdGlvbkludiwgdHJhbnNmb3JtLnNjYWxlT3JpZW50YXRpb24pO1xyXG5cclxuICAgIG11bHRpcGx5Q29tcG9uZW50cyh0cmFuc2Zvcm0sIHRoaXMubWF0cml4KTtcclxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIG11bHRpcGx5Q29tcG9uZW50cyh0cmFuc2Zvcm0sIG1hdHJpeCkge1xyXG4gICAgLy8gTSA9IFQgKiBDXHJcbiAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHkobWF0cml4LCB0cmFuc2Zvcm0udHJhbnNsYXRlLCB0cmFuc2Zvcm0uY2VudGVyKTtcclxuICAgIC8vIE0gPSBUICogQyAqIFJcclxuICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseShtYXRyaXgsIG1hdHJpeCwgdHJhbnNmb3JtLnJvdGF0aW9uKTtcclxuICAgIC8vIE0gPSBUICogQyAqIFIgKiBTT1xyXG4gICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5KG1hdHJpeCwgbWF0cml4LCB0cmFuc2Zvcm0uc2NhbGVPcmllbnRhdGlvbik7XHJcbiAgICAvLyBNID0gVCAqIEMgKiBSICogU08gKiBTXHJcbiAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHkobWF0cml4LCBtYXRyaXgsIHRyYW5zZm9ybS5zY2FsZSk7XHJcbiAgICAvLyBNID0gVCAqIEMgKiBSICogU08gKiBTICogLVNPXHJcbiAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHkobWF0cml4LCBtYXRyaXgsIHRyYW5zZm9ybS5zY2FsZU9yaWVudGF0aW9uSW52KTtcclxuICAgIC8vIE0gPSBUICogQyAqIFIgKiBTTyAqIFMgKiAtU08gKiAtQ1xyXG4gICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5KG1hdHJpeCwgbWF0cml4LCB0cmFuc2Zvcm0uY2VudGVySW52ZXJzZSk7XHJcbn1cclxuXHJcblRyYW5zZm9ybURhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRNYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLm5lZWRzVXBkYXRlICYmIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcbiAgICByZXR1cm4gdGhpcy5tYXRyaXg7XHJcbn07XHJcblxyXG5cclxuVHJhbnNmb3JtRGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgaWYgKGUudHlwZSA9PSBFdmVudHMuVkFMVUVfTU9ESUZJRUQpIHtcclxuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm5vdGlmeU9wcG9zaXRlQWRhcHRlcnMoRXZlbnRzLkFEQVBURVJfVkFMVUVfQ0hBTkdFRCk7XHJcbiAgICB9IGVsc2UgaWYgKGUudHlwZSA9PSBFdmVudHMuTk9ERV9SRU1PVkVEKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5ub3RpZnlPcHBvc2l0ZUFkYXB0ZXJzKEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEKTtcclxuICAgIH1cclxufTtcclxuVHJhbnNmb3JtRGF0YUFkYXB0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmlzVmFsaWQgPSBmYWxzZTtcclxufTtcclxuXHJcblRyYW5zZm9ybURhdGFBZGFwdGVyLnByb3RvdHlwZS5jaGVja0ZvckltcHJvcGVyTmVzdGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0ubG9jYWxOYW1lID09PSBcInRyYW5zZm9ybVwiKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiUGFyc2luZyBlcnJvcjogVHJhbnNmb3JtIGVsZW1lbnRzIGNhbm5vdCBiZSBuZXN0ZWQhXCIsIHRoaXMubm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gRXhwb3J0IHRvIFhNTDNELmRhdGEgbmFtZXNwYWNlXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtRGF0YUFkYXB0ZXI7XHJcblxyXG5cclxuXHJcbiIsInZhciBCdWZmZXJFbnRyeSA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9pbnRlcmZhY2UvZGF0YS5qc1wiKS5CdWZmZXJFbnRyeTtcclxudmFyIElucHV0Tm9kZSA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuSW5wdXROb2RlO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgTm9kZUFkYXB0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9hZGFwdGVyLmpzXCIpLk5vZGVBZGFwdGVyO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdG9yIG9mIFhNTDNELmRhdGEuVmFsdWVEYXRhQWRhcHRlclxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBYTUwzRC5kYXRhLkRhdGFBZGFwdGVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKlxyXG4gKiBAcGFyYW0gZmFjdG9yeVxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcclxuICovXHJcbnZhciBWYWx1ZURhdGFBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIE5vZGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICB0aGlzLnhmbG93SW5wdXROb2RlID0gbnVsbDtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoVmFsdWVEYXRhQWRhcHRlciwgTm9kZUFkYXB0ZXIpO1xyXG5cclxuVmFsdWVEYXRhQWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKClcclxue1xyXG4gICAgdmFyIGNvbmZpZyA9IHRoaXMubm9kZS5fY29uZmlndXJlZCwgdmFsdWU7XHJcbiAgICBpZih0aGlzLm5vZGUudGV4dENvbnRlbnQgPT0gXCJbdmFsdWUgc2V0IGJ5IHNjcmlwdF1cIil7XHJcbiAgICAgICAgdmFsdWUgPSBjb25maWcuc2NyaXB0VmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIGRlbGV0ZSBjb25maWcuc2NyaXB0VmFsdWU7XHJcbiAgICAgICAgdmFsdWUgPSB0aGlzLm5vZGUudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHR5cGUgPSBYQy5EQVRBX1RZUEUuZnJvbVN0cmluZyh0aGlzLm5vZGUubG9jYWxOYW1lKTtcclxuICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyRW50cnkodHlwZSwgdmFsdWUpO1xyXG5cclxuICAgIHRoaXMueGZsb3dJbnB1dE5vZGUgPSBuZXcgSW5wdXROb2RlKG51bGwpO1xyXG4gICAgdGhpcy54Zmxvd0lucHV0Tm9kZS5uYW1lID0gdGhpcy5ub2RlLm5hbWU7XHJcbiAgICB0aGlzLnhmbG93SW5wdXROb2RlLmRhdGEgPSBidWZmZXI7XHJcbiAgICB0aGlzLnhmbG93SW5wdXROb2RlLmtleSA9IHRoaXMubm9kZS5rZXk7XHJcbiAgICB0aGlzLnhmbG93SW5wdXROb2RlLnBhcmFtTmFtZSA9IHRoaXMubm9kZS5wYXJhbSA/IHRoaXMubm9kZS5uYW1lIDogbnVsbDtcclxuICAgIHRoaXMuY2hlY2tGb3JJbXByb3Blck5lc3RpbmcoKTtcclxufTtcclxuXHJcblZhbHVlRGF0YUFkYXB0ZXIucHJvdG90eXBlLmdldFhmbG93Tm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnhmbG93SW5wdXROb2RlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5WYWx1ZURhdGFBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgaWYgKGV2dC50eXBlID09IEV2ZW50cy5WQUxVRV9NT0RJRklFRCkge1xyXG4gICAgICAgIHZhciBhdHRyID0gZXZ0Lm11dGF0aW9uLmF0dHJpYnV0ZU5hbWU7XHJcbiAgICAgICAgaWYgKCFhdHRyKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGUuX2NvbmZpZ3VyZWQuc2NyaXB0VmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMueGZsb3dJbnB1dE5vZGUuZGF0YS5zZXRWYWx1ZSh0aGlzLm5vZGUudmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXR0ciA9PSBcIm5hbWVcIikge1xyXG4gICAgICAgICAgICB0aGlzLnhmbG93SW5wdXROb2RlLm5hbWUgPSB0aGlzLm5vZGUubmFtZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGF0dHIgPT0gXCJrZXlcIikge1xyXG4gICAgICAgICAgICB0aGlzLnhmbG93SW5wdXROb2RlLmtleSA9IHRoaXMubm9kZS5rZXk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChhdHRyID09IFwicGFyYW1cIikge1xyXG4gICAgICAgICAgICB0aGlzLnhmbG93SW5wdXROb2RlLnBhcmFtTmFtZSA9IHRoaXMubm9kZS5wYXJhbSA/IHRoaXMubm9kZS5uYW1lIDogbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5WYWx1ZURhdGFBZGFwdGVyLnByb3RvdHlwZS5zZXRTY3JpcHRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgLy8gVE9ETzogQWRkIFR5cGUgY2hlY2tcclxuICAgIHRoaXMueGZsb3dJbnB1dE5vZGUuZGF0YS5zZXRWYWx1ZSh2YWx1ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRhQWRhcHRlclxyXG4gKi9cclxuVmFsdWVEYXRhQWRhcHRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gXCJYTUwzRC5kYXRhLlZhbHVlRGF0YUFkYXB0ZXJcIjtcclxufTtcclxuXHJcblZhbHVlRGF0YUFkYXB0ZXIucHJvdG90eXBlLmNoZWNrRm9ySW1wcm9wZXJOZXN0aW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICBmb3IgKHZhciBpPTA7IGkgPCB0aGlzLm5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChYQy5EQVRBX1RZUEUuZnJvbVN0cmluZyh0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXS5sb2NhbE5hbWUpKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiUGFyc2luZyBlcnJvcjogVmFsdWUgZWxlbWVudHMgY2Fubm90IGJlIG5lc3RlZCFcIiwgdGhpcy5ub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBFeHBvcnRcclxubW9kdWxlLmV4cG9ydHMgPSBWYWx1ZURhdGFBZGFwdGVyO1xyXG4iLCJ2YXIgQ29tcHV0ZVJlcXVlc3QgPSByZXF1aXJlKFwiLi4veGZsb3cvaW50ZXJmYWNlL3JlcXVlc3QuanNcIikuQ29tcHV0ZVJlcXVlc3Q7XHJcbnZhciBFdmVudHMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL25vdGlmaWNhdGlvbi5qc1wiKTtcclxudmFyIENTUyA9IHJlcXVpcmUoXCIuLi91dGlscy9jc3MuanNcIik7XHJcblxyXG52YXIgRE9NVHJhbnNmb3JtRmV0Y2hlciA9IGZ1bmN0aW9uIChvd25lciwgYXR0ck5hbWUsIGRhdGFOYW1lLCBvbmx5RGF0YVRyYW5zZm9ybSkge1xyXG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xyXG4gICAgdGhpcy5ub2RlID0gb3duZXIubm9kZTtcclxuICAgIHRoaXMuYXR0ck5hbWUgPSBhdHRyTmFtZTtcclxuICAgIHRoaXMuZGF0YU5hbWUgPSBkYXRhTmFtZTtcclxuICAgIHRoaXMuYWRhcHRlckhhbmRsZSA9IG51bGw7XHJcbiAgICB0aGlzLnhmbG93UmVxdWVzdCA9IG51bGw7XHJcbiAgICB0aGlzLm9ubHlEYXRhVHJhbnNmb3JtID0gb25seURhdGFUcmFuc2Zvcm0gfHwgZmFsc2U7XHJcbiAgICB0aGlzLl9iaW5kZWRDYWxsYmFjayA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XHJcbn07XHJcbkRPTVRyYW5zZm9ybUZldGNoZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy54Zmxvd1JlcXVlc3QgJiYgdGhpcy54Zmxvd1JlcXVlc3QuY2xlYXIoKTtcclxuICAgIHRoaXMueGZsb3dSZXF1ZXN0ID0gbnVsbDtcclxuICAgIHRoaXMuYWRhcHRlckhhbmRsZSAmJiB0aGlzLmFkYXB0ZXJIYW5kbGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fYmluZGVkQ2FsbGJhY2spXHJcbn07XHJcblxyXG5ET01UcmFuc2Zvcm1GZXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbmV3SGFuZGxlID0gdGhpcy5vd25lci5nZXRBZGFwdGVySGFuZGxlKHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUodGhpcy5hdHRyTmFtZSksIFwiZGF0YVwiLCAwKTtcclxuICAgIGlmIChuZXdIYW5kbGUgIT0gdGhpcy5hZGFwdGVySGFuZGxlKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuYWRhcHRlckhhbmRsZSA9IG5ld0hhbmRsZTtcclxuICAgICAgICBpZiAobmV3SGFuZGxlKVxyXG4gICAgICAgICAgICBuZXdIYW5kbGUuYWRkTGlzdGVuZXIodGhpcy5fYmluZGVkQ2FsbGJhY2spXHJcbiAgICB9XHJcbiAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG59O1xyXG5cclxuRE9NVHJhbnNmb3JtRmV0Y2hlci5wcm90b3R5cGUudXBkYXRlTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5vd25lci5vblRyYW5zZm9ybUNoYW5nZSh0aGlzLmF0dHJOYW1lLCB0aGlzLmdldE1hdHJpeCgpKTtcclxufTtcclxuXHJcbkRPTVRyYW5zZm9ybUZldGNoZXIucHJvdG90eXBlLmdldE1hdHJpeCA9ICggZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIElERU5USVRZID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMub25seURhdGFUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgdmFyIGNzc01hdHJpeCA9IENTUy5nZXRDU1NNYXRyaXgodGhpcy5ub2RlKTtcclxuICAgICAgICAgICAgaWYgKGNzc01hdHJpeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENTUy5jb252ZXJ0Q3NzVG9NYXQ0KGNzc01hdHJpeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFkYXB0ZXI7XHJcbiAgICAgICAgaWYgKHRoaXMuYWRhcHRlckhhbmRsZSAmJiAoYWRhcHRlciA9IHRoaXMuYWRhcHRlckhhbmRsZS5nZXRBZGFwdGVyKCkpKSB7XHJcbiAgICAgICAgICAgIGlmIChhZGFwdGVyLmdldFhmbG93Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnhmbG93UmVxdWVzdClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnhmbG93UmVxdWVzdCA9IG5ldyBDb21wdXRlUmVxdWVzdChhZGFwdGVyLmdldFhmbG93Tm9kZSgpLCBbdGhpcy5kYXRhTmFtZV0sIHRoaXMuX2JpbmRlZENhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhUmVzdWx0ID0gdGhpcy54Zmxvd1JlcXVlc3QuZ2V0UmVzdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtRGF0YSA9IChkYXRhUmVzdWx0LmdldE91dHB1dERhdGEodGhpcy5kYXRhTmFtZSkgJiYgZGF0YVJlc3VsdC5nZXRPdXRwdXREYXRhKHRoaXMuZGF0YU5hbWUpLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybURhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybURhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFkYXB0ZXIuZ2V0TWF0cml4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRhcHRlci5nZXRNYXRyaXgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5vbmx5RGF0YVRyYW5zZm9ybSA/IG51bGwgOiBJREVOVElUWTtcclxuICAgIH07XHJcbn0oKSk7XHJcblxyXG5ET01UcmFuc2Zvcm1GZXRjaGVyLnByb3RvdHlwZS5fb25DaGFuZ2UgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICBpZiAoZXZ0LnR5cGUgPT0gRXZlbnRzLkFEQVBURVJfVkFMVUVfQ0hBTkdFRCkge1xyXG4gICAgICAgIHRoaXMub3duZXIub25UcmFuc2Zvcm1DaGFuZ2UodGhpcy5hdHRyTmFtZSwgZXZ0LmFkYXB0ZXJIYW5kbGUuZ2V0QWRhcHRlcigpLmdldE1hdHJpeCgpKTtcclxuICAgIH0gZWxzZSB7IC8vIElmIHRoZSBhZGFwdGVyIGNoYW5nZWQsIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgdGhlIG1hdHJpeFxyXG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERPTVRyYW5zZm9ybUZldGNoZXI7XHJcbiIsImlmICh3aW5kb3cuWE1MM0QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gZGVmaW5lIHRoZSBYTUwzRCBuYW1lc3BhY2UgYSBzZWNvbmQgdGltZS4gUGxlYXNlIGVuc3VyZSB4bWwzZC5qcyBpcyBvbmx5IGxvYWRlZCBvbmNlIVwiKTtcclxufVxyXG4vKiogQG5hbWVzcGFjZSAqICovXHJcbnZhciBYTUwzRCA9IFhNTDNEIHx8IHt9O1xyXG52YXIgWGZsb3cgPSBYZmxvdyB8fCB7fTtcclxud2luZG93LlhNTDNEID0gWE1MM0Q7XHJcbndpbmRvdy5YZmxvdyA9IFhmbG93O1xyXG5cclxuWE1MM0QudmVyc2lvbiA9ICclVkVSU0lPTiUnO1xyXG4vKiogQGNvbnN0ICovXHJcblhNTDNELnhtbDNkTlMgPSAnaHR0cDovL3d3dy54bWwzZC5vcmcvMjAwOS94bWwzZCc7XHJcbi8qKiBAY29uc3QgKi9cclxuWE1MM0QueGh0bWxOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcclxuLyoqIEBjb25zdCAqL1xyXG5YTUwzRC53ZWJnbE5TID0gJ2h0dHA6Ly93d3cueG1sM2Qub3JnLzIwMDkveG1sM2Qvd2ViZ2wnO1xyXG5YTUwzRC5feG1sM2QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoWE1MM0QueG1sM2ROUywgXCJ4bWwzZFwiKTtcclxuWE1MM0QuX3BhcmFsbGVsID0gWE1MM0QuX3BhcmFsbGVsICE9IHVuZGVmaW5lZCA/IFhNTDNELl9wYXJhbGxlbCA6IGZhbHNlO1xyXG5YTUwzRC54aHRtbCA9ICEhKGRvY3VtZW50LmRvY3R5cGUgJiYgbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhkb2N1bWVudC5kb2N0eXBlKS5tYXRjaCgveGh0bWwvaSkpO1xyXG5cclxuWE1MM0QuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHRhZ05hbWUpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoWE1MM0QueG1sM2ROUywgdGFnTmFtZSk7XHJcbn07XHJcblxyXG5YTUwzRC5leHRlbmQgPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICBmb3IgKCB2YXIgcHJvcCBpbiBiKSB7XHJcbiAgICAgICAgdmFyIGcgPSBiLl9fbG9va3VwR2V0dGVyX18ocHJvcCksIHMgPSBiLl9fbG9va3VwU2V0dGVyX18ocHJvcCk7XHJcbiAgICAgICAgaWYgKGd8fHMpIHtcclxuICAgICAgICAgICAgaWYgKGcpIHtcclxuICAgICAgICAgICAgICAgIGEuX19kZWZpbmVHZXR0ZXJfXyhwcm9wLCBnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgICAgICAgYS5fX2RlZmluZVNldHRlcl9fKHByb3AsIHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGJbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCAhPT0gXCJjb25zdHJ1Y3RvclwiIHx8IGEgIT09IHdpbmRvdykge1xyXG4gICAgICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgY3RvciBpcyBhIHN1cGVyY2xhc3Mgb2Ygc3ViY2xhc3NDdG9yLlxyXG4gKiBAcGFyYW0gY3RvclxyXG4gKiBAcGFyYW0gc3ViY2xhc3NDdG9yXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5YTUwzRC5pc1N1cGVyY2xhc3NPZiA9IGZ1bmN0aW9uKGN0b3IsIHN1YmNsYXNzQ3Rvcikge1xyXG4gICAgd2hpbGUgKHN1YmNsYXNzQ3RvciAmJiBzdWJjbGFzc0N0b3Iuc3VwZXJjbGFzcykge1xyXG4gICAgICAgIGlmIChzdWJjbGFzc0N0b3Iuc3VwZXJjbGFzcyA9PT0gY3Rvci5wcm90b3R5cGUpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIHN1YmNsYXNzQ3RvciA9IHN1YmNsYXNzQ3Rvci5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdG9yIENvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgUGFyZW50IGNsYXNzXHJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gbWV0aG9kcyBNZXRob2RzIHRvIGFkZCB0byB0aGUgY2xhc3NcclxuICogQHJldHVybiB7T2JqZWN0IX1cclxuICovXHJcblhNTDNELmNyZWF0ZUNsYXNzID0gZnVuY3Rpb24oY3RvciwgcGFyZW50LCBtZXRob2RzKSB7XHJcbiAgICBtZXRob2RzID0gbWV0aG9kcyB8fCB7fTtcclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAvKiogQGNvbnN0cnVjdG9yICovXHJcbiAgICAgICAgdmFyIEYgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEYucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcclxuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBGKCk7XHJcbiAgICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xyXG4gICAgICAgIGN0b3Iuc3VwZXJjbGFzcyA9IHBhcmVudC5wcm90b3R5cGU7XHJcbiAgICB9XHJcbiAgICBjdG9yLmlzU3VwZXJjbGFzc09mID0gWE1MM0QuaXNTdXBlcmNsYXNzT2YuYmluZChjdG9yLCBjdG9yKTtcclxuICAgIGZvciAoIHZhciBtIGluIG1ldGhvZHMpIHtcclxuICAgICAgICBjdG9yLnByb3RvdHlwZVttXSA9IG1ldGhvZHNbbV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3RvcjtcclxufTtcclxuXHJcblhNTDNELmRlYnVnID0gcmVxdWlyZShcIi4vdXRpbHMvZGVidWcuanNcIik7XHJcblhNTDNELnV0aWwgPSByZXF1aXJlKFwiLi91dGlscy9taXNjLmpzXCIpO1xyXG5YTUwzRC5vcHRpb25zID0gcmVxdWlyZShcIi4vdXRpbHMvb3B0aW9ucy5qc1wiKTtcclxuWE1MM0Quc2hhZGVycyA9IHJlcXVpcmUoXCIuL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy91cm4vc2hhZGVycy5qc1wiKTtcclxuWE1MM0QucmVzb3VyY2UgPSByZXF1aXJlKFwiLi9iYXNlL3Jlc291cmNlbWFuYWdlci5qc1wiKS5SZXNvdXJjZTsgLy9SZXF1aXJlZCBmb3IgdGhlIHRlc3QgbGlicmFyeSBiZWNhdXNlIHRoZSBSTSBuZWVkcyB0byBcImJlbG9uZ1wiIHRvIHRoZSBzYW1lIGRvY3VtZW50IGFzIHRoZSBYTUwzRCBlbGVtZW50IGluIG9yZGVyIHRvIHJlc29sdmUgcmVmZXJlbmNlcyBjb3JyZWN0bHlcclxuWE1MM0QucmVzb3VyY2UucmVnaXN0ZXJGb3JtYXQgPSByZXF1aXJlKFwiLi9iYXNlL3Jlc291cmNlbWFuYWdlci5qc1wiKS5yZWdpc3RlckZvcm1hdDtcclxuLy9YTUwzRC5yZXNvdXJjZS5Gb3JtYXRIYW5kbGVyXHJcbi8vWE1MM0QucmVzb3VyY2UuSlNPTkZvcm1hdEhhbmRsZXJcclxuLy9YTUwzRC5yZXNvdXJjZS5BZGFwdGVyRmFjdG9yeVxyXG5YTUwzRC53ZWJjbCA9IHJlcXVpcmUoXCIuL3V0aWxzL3dlYmNsLmpzXCIpLndlYmNsO1xyXG5YTUwzRC5tYXRoID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKTtcclxuWE1MM0QubWF0aC5iYm94ID0gcmVxdWlyZShcIi4vbWF0aC9iYm94LmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9tYXRoL21hdGguanNcIikoWE1MM0QubWF0aCk7XHJcblxyXG53aW5kb3cuWE1MM0RCb3ggPSByZXF1aXJlKFwiLi90eXBlcy9ib3guanNcIik7XHJcblhNTDNELmV4dGVuZCh3aW5kb3csIHJlcXVpcmUoXCIuL3R5cGVzL2RhdGEtb2JzZXJ2ZXIuanNcIikpO1xyXG53aW5kb3cuWE1MM0RNYXRyaXggPSByZXF1aXJlKFwiLi90eXBlcy9tYXRyaXguanNcIik7XHJcbndpbmRvdy5YTUwzRFJheSA9IHJlcXVpcmUoXCIuL3R5cGVzL3JheS5qc1wiKTtcclxud2luZG93LlhNTDNEUm90YXRpb24gPSByZXF1aXJlKFwiLi90eXBlcy9yb3RhdGlvbi5qc1wiKTtcclxud2luZG93LlhNTDNEVmVjMyA9IHJlcXVpcmUoXCIuL3R5cGVzL3ZlYzMuanNcIik7XHJcblxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yID0gcmVxdWlyZShcIi4veGZsb3cvb3BlcmF0b3Ivb3BlcmF0b3IuanNcIikucmVnaXN0ZXJPcGVyYXRvcjtcclxuWGZsb3cuY29uc3RhbnRzID0gcmVxdWlyZShcIi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxuWE1MM0QuZXh0ZW5kKFhmbG93LCByZXF1aXJlKFwiLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikpO1xyXG5YTUwzRC5leHRlbmQoWGZsb3csIHJlcXVpcmUoXCIuL3hmbG93L2ludGVyZmFjZS9kYXRhLmpzXCIpKTtcclxuWGZsb3cuQ29tcHV0ZVJlcXVlc3QgPSByZXF1aXJlKFwiLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5Db21wdXRlUmVxdWVzdDtcclxuXHJcblhNTDNELndlYmdsID0gWE1MM0Qud2ViZ2wgfHwge307XHJcblhNTDNELndlYmdsLkZ1bGxzY3JlZW5RdWFkID0gcmVxdWlyZShcIi4vcmVuZGVyZXIvd2ViZ2wvYmFzZS9mdWxsc2NyZWVucXVhZC5qc1wiKTtcclxuWE1MM0Qud2ViZ2wuQmFzZVJlbmRlclBhc3MgPSByZXF1aXJlKFwiLi9yZW5kZXJlci93ZWJnbC9yZW5kZXItcGFzc2VzL2Jhc2UuanNcIik7XHJcblhNTDNELndlYmdsLkZvcndhcmRSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy9mb3J3YXJkLmpzXCIpO1xyXG5YTUwzRC53ZWJnbC5CYXNlUmVuZGVyVHJlZSA9IHJlcXVpcmUoXCIuL3JlbmRlcmVyL3dlYmdsL3JlbmRlci10cmVlcy9iYXNlLmpzXCIpO1xyXG5YTUwzRC5leHRlbmQoWE1MM0Qud2ViZ2wsIHJlcXVpcmUoXCIuL3JlbmRlcmVyL3dlYmdsL2Jhc2UvcmVuZGVydGFyZ2V0LmpzXCIpKTtcclxuXHJcblxyXG5yZXF1aXJlKFwiLi94Zmxvdy9vcGVyYXRvci9kZWZhdWx0XCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBYTUwzRCA6IFhNTDNELFxyXG4gICAgWGZsb3cgOiBYZmxvd1xyXG59O1xyXG4iLCJ2YXIgWE1MM0QgPSByZXF1aXJlKFwiLi9nbG9iYWwuanNcIikuWE1MM0Q7XHJcbnZhciBDb25maWcgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2UvZWxlbWVudHMuanNcIikuY29uZmlnO1xyXG52YXIgc2VuZEFkYXB0ZXJFdmVudCA9IHJlcXVpcmUoXCIuL3V0aWxzL21pc2MuanNcIikuc2VuZEFkYXB0ZXJFdmVudDtcclxudmFyIE9wdGlvbnMgPSByZXF1aXJlKFwiLi91dGlscy9vcHRpb25zLmpzXCIpO1xyXG52YXIgQ1NTID0gcmVxdWlyZShcIi4vdXRpbHMvY3NzLmpzXCIpO1xyXG52YXIgQ29uZmlndXJlUmVuZGVyZXIgPSByZXF1aXJlKFwiLi9yZW5kZXJlci9yZW5kZXJlci9jb25maWd1cmUuanNcIik7XHJcbnZhciBXZWJnbFN1cHBvcnRlZCA9IHJlcXVpcmUoXCIuL3JlbmRlcmVyL3dlYmdsL2Jhc2UvdXRpbHMuanNcIikuc3VwcG9ydGVkO1xyXG5yZXF1aXJlKFwiLi9pbnRlcmZhY2UvZG9tLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi91dGlscy9kZWJ1Zy5qc1wiKTtcclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvKGlQYWR8aVBob25lfGlQb2QgdG91Y2gpL2kpKSB7XHJcbiAgICAgICAgdmFyIG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibWV0YVwiKTtcclxuICAgICAgICBtLm5hbWUgPSBcImZvcm1hdC1kZXRlY3Rpb25cIjtcclxuICAgICAgICBtLmNvbnRlbnQgPSBcInRlbGVwaG9uZT1ub1wiO1xyXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobSlcclxuICAgIH1cclxufSgpKTtcclxuXHJcbmZ1bmN0aW9uIGRpc3BsYXlXZWJHTE5vdFN1cHBvcnRlZEluZm8oeG1sM2RFbGVtZW50KXtcclxuXHJcbiAgICBpZih4bWwzZEVsZW1lbnQuaGFzQXR0cmlidXRlKFwib251bnN1cHBvcnRlZFwiKSl7XHJcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiZXZlbnRcIiwgeG1sM2RFbGVtZW50LmdldEF0dHJpYnV0ZShcIm9udW5zdXBwb3J0ZWRcIikpO1xyXG4gICAgICAgIHhtbDNkRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd1bnN1cHBvcnRlZCcsIGNhbGxiYWNrLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgZG9EZWZhdWx0ID0gWE1MM0QudXRpbC5kaXNwYXRjaEN1c3RvbUV2ZW50KHhtbDNkRWxlbWVudCwgJ3Vuc3VwcG9ydGVkJywgZmFsc2UsIHRydWUsIG51bGwpO1xyXG4gICAgaWYoZG9EZWZhdWx0KXtcclxuICAgICAgICAvLyBQbGFjZSB4bWwzZEVsZW1lbnQgaW5zaWRlIGFuIGludmlzaWJsZSBkaXZcclxuICAgICAgICB2YXIgaGlkZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhYTUwzRC54aHRtbE5TLCAnZGl2Jyk7XHJcblxyXG4gICAgICAgIHhtbDNkRWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShoaWRlRGl2LCB4bWwzZEVsZW1lbnQpO1xyXG4gICAgICAgIGhpZGVEaXYuYXBwZW5kQ2hpbGQoeG1sM2RFbGVtZW50KTtcclxuICAgICAgICBoaWRlRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuXHJcbiAgICAgICAgdmFyIGluZm9EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoWE1MM0QueGh0bWxOUywgJ2RpdicpO1xyXG4gICAgICAgIGlmKHhtbDNkRWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJjbGFzc1wiKSl7XHJcbiAgICAgICAgICAgIGluZm9EaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgeG1sM2RFbGVtZW50LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluZm9EaXYuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgeG1sM2RFbGVtZW50LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpKTtcclxuICAgICAgICBpbmZvRGl2LnN0eWxlLmJvcmRlciA9IFwiMnB4IHNvbGlkIHJlZFwiO1xyXG4gICAgICAgIGluZm9EaXYuc3R5bGUuZm9udEZhbWlseSA9IFwidmVyZGFuYSxzYW5zLXNlcmlmXCI7XHJcbiAgICAgICAgaW5mb0Rpdi5zdHlsZS5jb2xvciA9IFwicmVkXCI7XHJcbiAgICAgICAgaW5mb0Rpdi5zdHlsZS5wYWRkaW5nID0gXCIxMHB4XCI7XHJcbiAgICAgICAgaW5mb0Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoMjU1LCAwLCAwLCAwLjMpXCI7XHJcblxyXG4gICAgICAgIHZhciB3aWR0aCA9IHhtbDNkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKTtcclxuICAgICAgICBpZiAod2lkdGggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaW5mb0Rpdi5zdHlsZS53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHhtbDNkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIik7XHJcbiAgICAgICAgaWYgKGhlaWdodCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpbmZvRGl2LnN0eWxlLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBoRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoM1wiKTtcclxuICAgICAgICB2YXIgaFR4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU29ycnksIHlvdXIgYnJvd3NlciBkb2Vzbid0IGFwcGVhciB0byBzdXBwb3J0IFhNTDNELlwiKTtcclxuICAgICAgICBoRWxlbWVudC5hcHBlbmRDaGlsZChoVHh0KTtcclxuXHJcbiAgICAgICAgdmFyIHBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XHJcbiAgICAgICAgcEVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJQbGVhc2UgdmlzaXQgXCIpKTtcclxuICAgICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG4gICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBcImh0dHA6Ly93d3cueG1sM2Qub3JnL2hlbHBcIik7XHJcbiAgICAgICAgbGluay5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcImh0dHA6Ly93d3cueG1sM2Qub3JnL2hlbHBcIikpO1xyXG4gICAgICAgIHBFbGVtZW50LmFwcGVuZENoaWxkKGxpbmspO1xyXG4gICAgICAgIHBFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiKSk7XHJcbiAgICAgICAgaW5mb0Rpdi5hcHBlbmRDaGlsZChoRWxlbWVudCk7XHJcbiAgICAgICAgaW5mb0Rpdi5hcHBlbmRDaGlsZChwRWxlbWVudCk7XHJcblxyXG4gICAgICAgIGhpZGVEaXYucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5mb0RpdiwgaGlkZURpdik7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4vKiAgYSBsaXN0IG9mIGVsZW1lbnRzIHRoYXQgYXJlIGN1cnJlbnRseSBpbml0aWFsaXplZC4gTW9yZSBzcGVjaWZpY2FsbHksXHJcbiAqICB0aGV5J3JlIGN1cnJlbnRseSBpbiBhIGNhbGwgdG8gdGhlIG1ldGhvZCBiZWxvdy5cclxuICpcclxuICogIFdoeT9cclxuICogIEluIHdlYmdsIHdlIGFjdHVhbGx5IHJlYXR0YWNoIHRoZSB4bWwzZCBlbGVtZW50IGluIHRoZSBET00uIFRodXMsIHdoZW5cclxuICogIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2Ygd29ya2luZyBvbiBhIG9uTm9kZUluc2VydGVkIGV2ZW50LCB0aGVyZSB3aWxsIHByb2JhYmx5XHJcbiAqICBjb21lIHJpZ2h0IGFub3RoZXIgZXZlbnQgd2hpY2ggd2UgYWN0dWFsbHkgZG9uJ3QgY2FyZSBmb3IuXHJcbiAqICBTbyB3ZSB1c2UgdGhpcyBsaXN0IHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZWxlbWVudHMgYXJlIGN1cnJlbnRseSBpbml0aWFsaXppbmcuXHJcbiAqL1xyXG52YXIgY3VyWE1MM0RJbml0RWxlbWVudHMgPSBbXTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHhtbDNkRWxlbWVudFxyXG4gKi9cclxuZnVuY3Rpb24gaW5pdFhNTDNERWxlbWVudCh4bWwzZEVsZW1lbnQpIHtcclxuICAgIGlmKC0xIDwgY3VyWE1MM0RJbml0RWxlbWVudHMuaW5kZXhPZih4bWwzZEVsZW1lbnQpKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICBjdXJYTUwzREluaXRFbGVtZW50cy5wdXNoKHhtbDNkRWxlbWVudCk7XHJcblxyXG4gICAgdmFyIGRlYnVnID0gWE1MM0QuZGVidWcuc2V0dXAoKTtcclxuXHJcbiAgICBpZiAoIVdlYmdsU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICBkZWJ1ZyAmJiBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiQ291bGQgbm90IGluaXRpYWxpc2UgV2ViR0wsIHNvcnJ5IDotKFwiKTtcclxuICAgICAgICBkaXNwbGF5V2ViR0xOb3RTdXBwb3J0ZWRJbmZvKHhtbDNkRWxlbWVudCk7XHJcbiAgICAgICAgY3VyWE1MM0RJbml0RWxlbWVudHMuc3BsaWNlKGN1clhNTDNESW5pdEVsZW1lbnRzLmluZGV4T2YoeG1sM2RFbGVtZW50KSwgMSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIFhNTDNELmRlYnVnLmxvZ0luZm8oXCJDb25maWd1cmluZ1wiLCB4bWwzZEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIipcIikubGVuZ3RoLCBcImVsZW1lbnRzXCIpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgICAgQ29uZmlnLmNvbmZpZ3VyZSh4bWwzZEVsZW1lbnQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGRlYnVnICYmIFhNTDNELmRlYnVnLmxvZ0V4Y2VwdGlvbihlKTtcclxuICAgICAgICBjdXJYTUwzREluaXRFbGVtZW50cy5zcGxpY2UoY3VyWE1MM0RJbml0RWxlbWVudHMuaW5kZXhPZih4bWwzZEVsZW1lbnQpLCAxKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIENvbmZpZ3VyZVJlbmRlcmVyKHhtbDNkRWxlbWVudCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgZGVidWcgJiYgWE1MM0QuZGVidWcubG9nRXhjZXB0aW9uKGUpO1xyXG4gICAgICAgIGN1clhNTDNESW5pdEVsZW1lbnRzLnNwbGljZShjdXJYTUwzREluaXRFbGVtZW50cy5pbmRleE9mKHhtbDNkRWxlbWVudCksIDEpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpbml0aWFsaXplIGFsbCBhdHRhY2hlZCBhZGFwdGVyc1xyXG4gICAgc2VuZEFkYXB0ZXJFdmVudCh4bWwzZEVsZW1lbnQsIHtvbkNvbmZpZ3VyZWQgOiBbXX0pO1xyXG5cclxuICAgIGN1clhNTDNESW5pdEVsZW1lbnRzLnNwbGljZShjdXJYTUwzREluaXRFbGVtZW50cy5pbmRleE9mKHhtbDNkRWxlbWVudCksIDEpO1xyXG4gICAgY2xlYXJPYnNlcnZlcigpO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtFbGVtZW50fSB4bWwzZEVsZW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGRlc3Ryb3lYTUwzREVsZW1lbnQoeG1sM2RFbGVtZW50KVxyXG57XHJcbiAgICBpZigtMSA8IGN1clhNTDNESW5pdEVsZW1lbnRzLmluZGV4T2YoeG1sM2RFbGVtZW50KSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgeG1sM2RFbGVtZW50Ll9jb25maWd1cmVkID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGlmKCF4bWwzZEVsZW1lbnQucGFyZW50Tm9kZSlcclxuICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgcmVtb3ZlZFxyXG5cclxuICAgIHZhciBjYW52YXMgPSB4bWwzZEVsZW1lbnQucGFyZW50Tm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xyXG5cclxuICAgIHZhciBncmFuZFBhcmVudE5vZGUgPSB4bWwzZEVsZW1lbnQucGFyZW50Tm9kZS5wYXJlbnROb2RlO1xyXG4gICAgaWYoIWdyYW5kUGFyZW50Tm9kZSlcclxuICAgICAgICByZXR1cm47IC8vIHN1YnRyZWUgY29udGFpbmluZyBjYW52YXMgaXMgbm90IGF0dGFjaGVkLCBjYW4ndCByZW1vdmUgaXRcclxuXHJcbiAgICBpZighY2FudmFzIHx8IGNhbnZhcy50YWdOYW1lICE9PSBcImNhbnZhc1wiKVxyXG4gICAgICAgIHJldHVybjsgLy8gYW4gZWxlbWVudCB3ZSBkaWRuJ3QgY3JlYXRlLCBza2lwIGRlbGV0aW9uXHJcblxyXG4gICAgZ3JhbmRQYXJlbnROb2RlLnJlbW92ZUNoaWxkKHhtbDNkRWxlbWVudC5wYXJlbnROb2RlKTtcclxuICAgIGdyYW5kUGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjYW52YXMpO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtFdmVudH0gZXZ0XHJcbiAqL1xyXG5mdW5jdGlvbiBvbk5vZGVJbnNlcnRlZChldnQpIHtcclxuXHJcbiAgICBpZihldnQudGFyZ2V0LnRhZ05hbWUgPT09IFwieG1sM2RcIikge1xyXG4gICAgICAgIGluaXRYTUwzREVsZW1lbnQoZXZ0LnRhcmdldCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0V2ZW50fSBldnRcclxuICovXHJcbmZ1bmN0aW9uIG9uTm9kZVJlbW92ZWQoZXZ0KSB7XHJcblxyXG4gICAgaWYoZXZ0LnRhcmdldC50YWdOYW1lID09PSBcInhtbDNkXCIpIHtcclxuICAgICAgICBkZXN0cm95WE1MM0RFbGVtZW50KGV2dC50YXJnZXQpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBvbkxvYWQoKSB7XHJcblxyXG4gICAgT3B0aW9ucy5zZXRPcHRpb25zRnJvbVF1ZXJ5KCk7XHJcblxyXG4gICAgQ1NTLmluaXQoKTtcclxuXHJcbiAgICB2YXIgZGVidWcgPSBYTUwzRC5kZWJ1Zy5zZXR1cCgpO1xyXG4gICAgZGVidWcgJiYgWE1MM0QuZGVidWcubG9nSW5mbyhcInhtbDNkLmpzIHZlcnNpb246IFwiICsgWE1MM0QudmVyc2lvbik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIGFsbCB0aGUgWE1MM0QgdGFncyBpbiB0aGUgZG9jdW1lbnRcclxuICAgICAqIEB0eXBlIHtOb2RlTGlzdH1cclxuICAgICAqL1xyXG4gICAgdmFyIHhtbDNkcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJ4bWwzZFwiKTtcclxuXHJcbiAgICBkZWJ1ZyAmJiBYTUwzRC5kZWJ1Zy5sb2dJbmZvKFwiRm91bmQgXCIgKyB4bWwzZHMubGVuZ3RoICsgXCIgeG1sM2Qgbm9kZShzKVwiKTtcclxuXHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgeG1sM2RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaW5pdFhNTDNERWxlbWVudCh4bWwzZHNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKCFNdXRhdGlvbk9ic2VydmVyKXtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlSW5zZXJ0ZWQnLCBvbk5vZGVJbnNlcnRlZCwgZmFsc2UpO1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVSZW1vdmVkJywgb25Ob2RlUmVtb3ZlZCwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHJlc29sdmVNdXRhdGlvbnMpO1xyXG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7IGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0gKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gb25VbmxvYWQoKSB7XHJcbiAgICBpZiAoWE1MM0QuZG9jdW1lbnQpXHJcbiAgICAgICAgWE1MM0QuZG9jdW1lbnQub251bmxvYWQoKTtcclxufVxyXG5cclxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSAod2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93Lk1vek11dGF0aW9uT2JzZXJ2ZXIpLFxyXG4gICAgb2JzZXJ2ZXIgPSBudWxsO1xyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZU11dGF0aW9ucyhtdXRhdGlvbnMpe1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIG11dGF0aW9uID0gbXV0YXRpb25zW2ldO1xyXG4gICAgICAgIGlmKG11dGF0aW9uLnR5cGUgPT0gJ2NoaWxkTGlzdCcpe1xyXG4gICAgICAgICAgICB2YXIgYWRkZWROb2RlcyA9IG11dGF0aW9uLmFkZGVkTm9kZXM7XHJcbiAgICAgICAgICAgIHZhciBqID0gYWRkZWROb2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlKGotLSl7XHJcbiAgICAgICAgICAgICAgICBpZihhZGRlZE5vZGVzW2pdLnRhZ05hbWUgPT0gXCJ4bWwzZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIGluaXRYTUwzREVsZW1lbnQoYWRkZWROb2Rlc1tqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlbW92ZWROb2RlcyA9IG11dGF0aW9uLnJlbW92ZWROb2RlcztcclxuICAgICAgICAgICAgdmFyIGogPSByZW1vdmVkTm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZShqLS0pIHtcclxuICAgICAgICAgICAgICAgIGlmKHJlbW92ZWROb2Rlc1tqXS50YWdOYW1lID09IFwieG1sM2RcIilcclxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95WE1MM0RFbGVtZW50KHJlbW92ZWROb2Rlc1tqXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBmbHVzaE9ic2VydmVyKCl7XHJcbiAgICBpZihvYnNlcnZlcil7XHJcbiAgICAgICAgcmVzb2x2ZU11dGF0aW9ucyhvYnNlcnZlci50YWtlUmVjb3JkcygpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjbGVhck9ic2VydmVyKCl7XHJcbiAgICBpZihvYnNlcnZlcil7XHJcbiAgICAgICAgb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBvbkxvYWQsIGZhbHNlKTtcclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VubG9hZCcsIG9uVW5sb2FkLCBmYWxzZSk7XHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZWxvYWQnLCBvblVubG9hZCwgZmFsc2UpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYTUwzRDtcclxuXHJcbiIsInJlcXVpcmUoXCIuLi91dGlscy9hcnJheS5qc1wiKTtcclxudmFyIFJlc291cmNlID0gcmVxdWlyZShcIi4uL2Jhc2UvcmVzb3VyY2VtYW5hZ2VyLmpzXCIpLlJlc291cmNlO1xyXG5cclxudmFyIHN0cmluZzJib29sID0gZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICBpZiAoIXN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAoc3RyaW5nLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgIGNhc2UgXCJ0cnVlXCI6XHJcbiAgICBjYXNlIFwiMVwiOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgY2FzZSBcImZhbHNlXCI6XHJcbiAgICBjYXNlIFwiMFwiOlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oc3RyaW5nKTtcclxuICAgIH1cclxufTtcclxudmFyIGhhbmRsZXJzID0ge307XHJcblxyXG5mdW5jdGlvbiBnZXRTdG9yYWdlKGVsZW0pe1xyXG4gICAgcmV0dXJuIGVsZW0uX2NvbmZpZ3VyZWQuc3RvcmFnZTtcclxufVxyXG5cclxudmFyIEF0dHJpYnV0ZUhhbmRsZXIgPSBmdW5jdGlvbihlbGVtKSB7XHJcbn07XHJcblxyXG5oYW5kbGVycy5JREhhbmRsZXIgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlID0gZnVuY3Rpb24odmFsdWUsIHByZXZWYWx1ZSwgZWxlbSkge1xyXG4gICAgICAgIFJlc291cmNlLm5vdGlmeU5vZGVJZENoYW5nZShlbGVtLCBwcmV2VmFsdWUsIHZhbHVlKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmRlc2MgPSB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShpZCkgfHwgXCJcIjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGlkLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbmhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgdGhpcy5kZXNjID0ge1xyXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoaWQpIHx8IFwiXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShpZCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcblxyXG5oYW5kbGVycy5FbnVtQXR0cmlidXRlSGFuZGxlciA9IGZ1bmN0aW9uKGlkLCBwKSB7XHJcbiAgICBBdHRyaWJ1dGVIYW5kbGVyLmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24oZWxlbSwgc3RvcmFnZSl7XHJcbiAgICAgICAgc3RvcmFnZVtpZF0gPSBwLmQ7XHJcbiAgICAgICAgaWYgKGVsZW0uaGFzQXR0cmlidXRlKGlkKSlcclxuICAgICAgICAgICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlKGVsZW0uZ2V0QXR0cmlidXRlKGlkKSwgbnVsbCwgZWxlbSwgc3RvcmFnZSk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlID0gZnVuY3Rpb24odiwgcHJldlZhbHVlLCBlbGVtLCBzdG9yYWdlKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdi50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHN0b3JhZ2VbaWRdID0gKHZhbHVlICYmIHAuZVt2YWx1ZV0gIT09IHVuZGVmaW5lZCkgPyBwLmVbdmFsdWVdIDogcC5kO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICB0aGlzLmRlc2MgPSB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBwLmVbc3RvcmFnZVtpZF1dO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0IDogZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgICAgICAgLy8gQXR0cmlidXRlIGlzIHNldCB0byB3aGF0ZXZlciBjb21lcyBpblxyXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShpZCwgdik7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdHlwZW9mIHYgPT0gJ3N0cmluZycgPyB2LnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBwLmVbdmFsdWVdICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBzdG9yYWdlW2lkXSA9IHAuZVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2VbaWRdID0gcC5kO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbmhhbmRsZXJzLkVudW1BdHRyaWJ1dGVIYW5kbGVyLnByb3RvdHlwZSA9IG5ldyBBdHRyaWJ1dGVIYW5kbGVyKCk7XHJcbmhhbmRsZXJzLkVudW1BdHRyaWJ1dGVIYW5kbGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGhhbmRsZXJzLkVudW1BdHRyaWJ1dGVIYW5kbGVyO1xyXG5cclxuaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIEF0dHJpYnV0ZUhhbmRsZXIuY2FsbCh0aGlzKTtcclxuICAgIHZhciBldmVudFR5cGUgPSBpZC5zdWJzdHJpbmcoMik7XHJcblxyXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24oZWxlbSwgc3RvcmFnZSl7XHJcbiAgICAgICAgc3RvcmFnZVtpZF0gPSBudWxsO1xyXG4gICAgICAgIGlmIChlbGVtLmhhc0F0dHJpYnV0ZShpZCkpXHJcbiAgICAgICAgICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZShlbGVtLmdldEF0dHJpYnV0ZShpZCksIG51bGwsIGVsZW0sIHN0b3JhZ2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUgPSBmdW5jdGlvbih2YWx1ZSwgcHJldlZhbHVlLCBlbGVtLCBzdG9yYWdlKSB7XHJcbiAgICAgICAgaWYoc3RvcmFnZVtpZF0gIT0gbnVsbClcclxuICAgICAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgc3RvcmFnZVtpZF0pO1xyXG4gICAgICAgIGlmKCF2YWx1ZSl7XHJcbiAgICAgICAgICAgIHN0b3JhZ2VbaWRdID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBldmFsKFwiY3J4ID0gZnVuY3Rpb24gXCIgKyBpZCArIFwiKGV2ZW50KXtcXG4gIFwiICsgdmFsdWUgKyBcIlxcbn1cIik7XHJcbiAgICAgICAgICAgIGlmIChYTUwzRC54aHRtbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSBYSFRNTCBkb2N1bWVudHMgcmVxdWlyZSB0aGlzIHBvbHlmaWxsIGZvciBtb3VzZSBldmVudCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBzdG9yYWdlW2lkXSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICB0aGlzLmRlc2MgPSB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlW2lkXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcclxuICAgICAgICAgICAgaWYoWE1MM0QueGh0bWwgJiYgc3RvcmFnZVtpZF0pIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHN0b3JhZ2VbaWRdKTtcclxuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpID8gdmFsdWUgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlmKFhNTDNELnhodG1sICYmIHN0b3JhZ2VbaWRdKSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBzdG9yYWdlW2lkXSwgZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbmhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlci5wcm90b3R5cGUgPSBuZXcgQXR0cmlidXRlSGFuZGxlcigpO1xyXG5oYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyO1xyXG5cclxuaGFuZGxlcnMuSW50QXR0cmlidXRlSGFuZGxlciA9IGZ1bmN0aW9uKGlkLCBkZWZhdWx0VmFsdWUpIHtcclxuXHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlKXtcclxuICAgICAgICBzdG9yYWdlW2lkXSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICBpZiAoZWxlbS5oYXNBdHRyaWJ1dGUoaWQpKVxyXG4gICAgICAgICAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUoZWxlbS5nZXRBdHRyaWJ1dGUoaWQpLCBudWxsLCBlbGVtLCBzdG9yYWdlKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlID0gZnVuY3Rpb24odmFsdWUsIHByZXZWYWx1ZSwgZWxlbSwgc3RvcmFnZSkge1xyXG4gICAgICAgIHZhciB2ID0gdmFsdWUubWF0Y2goL15cXGQrLyk7XHJcbiAgICAgICAgaWYgKCF2IHx8IGlzTmFOKCt2WzBdKSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiSW52YWxpZCBhdHRyaWJ1dGUgW1wiK2lkK1wiXSB2YWx1ZTogXCIgKyB2YWx1ZSwgZWxlbSk7XHJcbiAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKGlkLCBwcmV2VmFsdWUpO1xyXG4gICAgICAgICAgICBzdG9yYWdlW2lkXSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdG9yYWdlW2lkXSA9ICArdlswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZWxlbS5fY29uZmlndXJlZC5jYW52YXMpXHJcbiAgICAgICAgICAgIGVsZW0uX2NvbmZpZ3VyZWQuY2FudmFzW2lkXSA9IHN0b3JhZ2VbaWRdO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kZXNjID0ge1xyXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlW2lkXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIHYgPSArdmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChpc05hTih2KSkge1xyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkludmFsaWQgYXR0cmlidXRlIFtcIitpZCtcIl0gdmFsdWU6IFwiICsgdmFsdWUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdG9yYWdlW2lkXSA9ICBNYXRoLmZsb29yKHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGlkLCBzdG9yYWdlW2lkXSArICcnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5oYW5kbGVycy5JbnRBdHRyaWJ1dGVIYW5kbGVyLnByb3RvdHlwZSA9IG5ldyBBdHRyaWJ1dGVIYW5kbGVyKCk7XHJcbmhhbmRsZXJzLkludEF0dHJpYnV0ZUhhbmRsZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gaGFuZGxlcnMuSW50QXR0cmlidXRlSGFuZGxlcjtcclxuXHJcbmhhbmRsZXJzLkZsb2F0QXR0cmlidXRlSGFuZGxlciA9IGZ1bmN0aW9uKGlkLCBkZWZhdWx0VmFsdWUpIHtcclxuXHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlKXtcclxuICAgICAgICBzdG9yYWdlW2lkXSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICBpZiAoZWxlbS5oYXNBdHRyaWJ1dGUoaWQpKVxyXG4gICAgICAgICAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUoZWxlbS5nZXRBdHRyaWJ1dGUoaWQpLCBudWxsLCBlbGVtLCBzdG9yYWdlKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlID0gZnVuY3Rpb24odmFsdWUsIHByZXZWYWx1ZSwgZWxlbSwgc3RvcmFnZSkge1xyXG4gICAgICAgIHZhciB2ID0gK3ZhbHVlO1xyXG4gICAgICAgIGlmIChpc05hTih2KSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiSW52YWxpZCBhdHRyaWJ1dGUgdmFsdWU6IFwiICsgdmFsdWUsIGVsZW0pO1xyXG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShpZCwgcHJldlZhbHVlKTtcclxuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSAgdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRlc2MgPSB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlW2lkXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIHYgPSArdmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChpc05hTih2KSkge1xyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkludmFsaWQgYXR0cmlidXRlIFtcIitpZCtcIl0gdmFsdWU6IFwiICsgdmFsdWUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdG9yYWdlW2lkXSA9ICB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGlkLCBzdG9yYWdlW2lkXSArICcnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5cclxuaGFuZGxlcnMuQm9vbEF0dHJpYnV0ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlKXtcclxuICAgICAgICBzdG9yYWdlW2lkXSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICBpZiAoZWxlbS5oYXNBdHRyaWJ1dGUoaWQpKVxyXG4gICAgICAgICAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUoZWxlbS5nZXRBdHRyaWJ1dGUoaWQpLCBudWxsLCBlbGVtLCBzdG9yYWdlKTtcclxuICAgIH07XHJcbiAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUgPSBmdW5jdGlvbih2YWx1ZSwgcHJldlZhbHVlLCBlbGVtLCBzdG9yYWdlKSB7XHJcbiAgICAgICAgc3RvcmFnZVtpZF0gPSBzdHJpbmcyYm9vbCh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRlc2MgPSB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlW2lkXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcclxuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBCb29sZWFuKHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaWQsIHN0b3JhZ2VbaWRdICsgJycpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcblxyXG5oYW5kbGVycy5YTUwzRFZlYzNBdHRyaWJ1dGVIYW5kbGVyID0gZnVuY3Rpb24oaWQsIGQpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlKXtcclxuICAgICAgICBzdG9yYWdlW2lkXSA9IG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuaW5pdFZlYzMgPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlLCB4LCB5LCB6KXtcclxuICAgICAgICB2YXIgY2hhbmdlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKGlkLCB2YWx1ZS54ICsgXCIgXCIgKyB2YWx1ZS55ICsgXCIgXCIgKyB2YWx1ZS56KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHN0b3JhZ2VbaWRdID0gbmV3IHdpbmRvdy5YTUwzRFZlYzMoeCwgeSwgeiwgY2hhbmdlZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBwcmV2VmFsdWUsIGVsZW0sIHN0b3JhZ2UpIHtcclxuICAgICAgICBpZiAoIXN0b3JhZ2VbaWRdKSB7XHJcbiAgICAgICAgICAgIHZhciBpbml0aWFsaXppbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmluaXRWZWMzKGVsZW0sIHN0b3JhZ2UsIDAsIDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdiA9IHN0b3JhZ2VbaWRdO1xyXG4gICAgICAgIHZhciBtID0gL15cXHMqKFxcUyspXFxzKyhcXFMrKVxccysoXFxTKylcXHMqJC8uZXhlYyh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKCFtIHx8IGlzTmFOKCttWzFdKSB8fCBpc05hTigrbVsyXSkgfHwgaXNOYU4oK21bM10pKSB7XHJcbiAgICAgICAgICAgIHYuX2RhdGEuc2V0KGQpO1xyXG4gICAgICAgICAgICAhaW5pdGlhbGl6aW5nICYmIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJJbnZhbGlkIGF0dHJpYnV0ZSBbXCIraWQrXCJdIHZhbHVlOiBcIiArIHZhbHVlLCBlbGVtKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2Ll9kYXRhWzBdID0gK21bMV07XHJcbiAgICAgICAgICAgIHYuX2RhdGFbMV0gPSArbVsyXTtcclxuICAgICAgICAgICAgdi5fZGF0YVsyXSA9ICttWzNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGVzYyA9IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKCFzdG9yYWdlW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zZXRGcm9tQXR0cmlidXRlKHRoaXMuZ2V0QXR0cmlidXRlKGlkKSwgbnVsbCwgdGhpcywgc3RvcmFnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VbaWRdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0IDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyB0aGlzLm5vZGVOYW1lICsgXCI6OlwiICsgaWQgKyBcIjogaXQncyByZWFkb25seVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5cclxuaGFuZGxlcnMuWE1MM0RSb3RhdGlvbkF0dHJpYnV0ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCwgZCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKGVsZW0sIHN0b3JhZ2Upe1xyXG4gICAgICAgIHN0b3JhZ2VbaWRdID0gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5pbml0Um90YXRpb24gPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlKXtcclxuICAgICAgICB2YXIgY2hhbmdlZCA9IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoaWQsIHYuYXhpcy54ICsgXCIgXCIgKyB2LmF4aXMueSArIFwiIFwiICsgdi5heGlzLnogKyBcIiBcIiArIHYuYW5nbGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgc3RvcmFnZVtpZF0gPSBuZXcgd2luZG93LlhNTDNEUm90YXRpb24obnVsbCwgbnVsbCwgY2hhbmdlZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBwcmV2VmFsdWUsIGVsZW0sIHN0b3JhZ2UpIHtcclxuICAgICAgICBpZiAoIXN0b3JhZ2VbaWRdKSB7XHJcbiAgICAgICAgICAgIHZhciBpbml0aWFsaXppbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmluaXRSb3RhdGlvbihlbGVtLCBzdG9yYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHYgPSBzdG9yYWdlW2lkXTtcclxuICAgICAgICB2YXIgbSA9IC9eXFxzKihcXFMrKVxccysoXFxTKylcXHMrKFxcUyspXFxzKyhcXFMrKVxccyokLy5leGVjKHZhbHVlKTtcclxuICAgICAgICBpZiAoIW0gIHx8IGlzTmFOKCttWzFdKSB8fCBpc05hTigrbVsyXSkgfHwgaXNOYU4oK21bM10pIHx8IGlzTmFOKCttWzRdKSkge1xyXG4gICAgICAgICAgICB2Ll9heGlzLl9kYXRhWzBdID0gZFswXTtcclxuICAgICAgICAgICAgdi5fYXhpcy5fZGF0YVsxXSA9IGRbMV07XHJcbiAgICAgICAgICAgIHYuX2F4aXMuX2RhdGFbMl0gPSBkWzJdO1xyXG4gICAgICAgICAgICB2Ll9hbmdsZSA9IGRbM107XHJcbiAgICAgICAgICAgIHYuX3VwZGF0ZVF1YXRlcm5pb24oKTtcclxuICAgICAgICAgICAgIWluaXRpYWxpemluZyAmJiBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiSW52YWxpZCBhdHRyaWJ1dGUgW1wiK2lkK1wiXSB2YWx1ZTogXCIgKyB2YWx1ZSwgZWxlbSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdi5fYXhpcy5fZGF0YVswXSA9ICttWzFdO1xyXG4gICAgICAgICAgICB2Ll9heGlzLl9kYXRhWzFdID0gK21bMl07XHJcbiAgICAgICAgICAgIHYuX2F4aXMuX2RhdGFbMl0gPSArbVszXTtcclxuICAgICAgICAgICAgdi5fYW5nbGUgPSArbVs0XTtcclxuICAgICAgICAgICAgdi5fdXBkYXRlUXVhdGVybmlvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGVzYyA9IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKCFzdG9yYWdlW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zZXRGcm9tQXR0cmlidXRlKHRoaXMuZ2V0QXR0cmlidXRlKGlkKSwgbnVsbCwgdGhpcywgc3RvcmFnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VbaWRdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0IDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyB0aGlzLm5vZGVOYW1lICsgXCI6OlwiICsgaWQgKyBcIjogaXQncyByZWFkb25seVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5cclxudmFyIG1peGVkQ29udGVudCA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcclxuICAgIGhhbmRsZXIuaW5pdCA9IGZ1bmN0aW9uKGVsZW0sIHN0b3JhZ2Upe1xyXG4gICAgICAgIGVsZW0uX2NvbmZpZ3VyZWQucmVnaXN0ZXJNaXhlZCgpO1xyXG4gICAgfTtcclxuICAgIGhhbmRsZXIuZGVzYyA9IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKCFzdG9yYWdlLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnZhbHVlID0gaGFuZGxlci5wYXJzZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZS52YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIFRocm93IGVycm9yP1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkNhbid0IHNldCBcIiArIHRoaXMubm9kZU5hbWUgKyBcIjo6dmFsdWU6IGl0J3MgcmVhZG9ubHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGhhbmRsZXIucmVzZXRWYWx1ZSA9IGZ1bmN0aW9uKHN0b3JhZ2UpIHsgc3RvcmFnZS52YWx1ZSA9IG51bGw7IH07XHJcbn07XHJcblxyXG52YXIgZ2V0Q29udGVudCA9IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgIHZhciBzdHIgPSBcIlwiO1xyXG4gICAgdmFyIGsgPSBlbGVtLmZpcnN0Q2hpbGQ7XHJcbiAgICB3aGlsZSAoaykge1xyXG4gICAgICAgIHN0ciArPSBrLm5vZGVUeXBlID09IDMgPyBrLnRleHRDb250ZW50IDogXCIgXCI7XHJcbiAgICAgICAgayA9IGsubmV4dFNpYmxpbmc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuaGFuZGxlcnMuRmxvYXRBcnJheVZhbHVlSGFuZGxlciA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICBtaXhlZENvbnRlbnQodGhpcyk7XHJcbn07XHJcblxyXG5oYW5kbGVycy5GbG9hdEFycmF5VmFsdWVIYW5kbGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgIHZhciBleHAgPSAvKFsrXFwtMC05ZUVcXC5dKykvZztcclxuICAgIHZhciBzdHIgPSBnZXRDb250ZW50KGVsZW0pO1xyXG4gICAgdmFyIG0gPSBzdHIubWF0Y2goZXhwKTtcclxuICAgIHJldHVybiBtID8gbmV3IEZsb2F0MzJBcnJheShtKSA6IG5ldyBGbG9hdDMyQXJyYXkoKTtcclxufTtcclxuXHJcbmhhbmRsZXJzLkZsb2F0MkFycmF5VmFsdWVIYW5kbGVyID0gaGFuZGxlcnMuRmxvYXRBcnJheVZhbHVlSGFuZGxlcjtcclxuaGFuZGxlcnMuRmxvYXQzQXJyYXlWYWx1ZUhhbmRsZXIgPSBoYW5kbGVycy5GbG9hdEFycmF5VmFsdWVIYW5kbGVyO1xyXG5oYW5kbGVycy5GbG9hdDRBcnJheVZhbHVlSGFuZGxlciA9IGhhbmRsZXJzLkZsb2F0QXJyYXlWYWx1ZUhhbmRsZXI7XHJcbmhhbmRsZXJzLkZsb2F0NHg0QXJyYXlWYWx1ZUhhbmRsZXIgPSBoYW5kbGVycy5GbG9hdEFycmF5VmFsdWVIYW5kbGVyO1xyXG5cclxuaGFuZGxlcnMuSW50QXJyYXlWYWx1ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgbWl4ZWRDb250ZW50KHRoaXMpO1xyXG59O1xyXG5oYW5kbGVycy5JbnRBcnJheVZhbHVlSGFuZGxlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICB2YXIgZXhwID0gLyhbK1xcLTAtOV0rKS9nO1xyXG4gICAgdmFyIHN0ciA9IGdldENvbnRlbnQoZWxlbSk7XHJcbiAgICB2YXIgbSA9IHN0ci5tYXRjaChleHApO1xyXG4gICAgcmV0dXJuIG0gPyBuZXcgSW50MzJBcnJheShtKSA6IG5ldyBJbnQzMkFycmF5KCk7XHJcbn07XHJcblxyXG5oYW5kbGVycy5Cb29sQXJyYXlWYWx1ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgbWl4ZWRDb250ZW50KHRoaXMpO1xyXG59O1xyXG5oYW5kbGVycy5Cb29sQXJyYXlWYWx1ZUhhbmRsZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgdmFyIGV4cCA9IC8odHJ1ZXxmYWxzZXwwfDEpL2lnO1xyXG4gICAgdmFyIHN0ciA9IGdldENvbnRlbnQoZWxlbSk7XHJcbiAgICB2YXIgbSA9IHN0ci5tYXRjaChleHApO1xyXG4gICAgaWYgKCFtKVxyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xyXG4gICAgbSA9IEFycmF5Lm1hcChtLCBzdHJpbmcyYm9vbCk7XHJcbiAgICByZXR1cm4gbSA/IG5ldyBVaW50OEFycmF5KG0pIDogbmV3IFVpbnQ4QXJyYXkoKTtcclxufTtcclxuXHJcbmhhbmRsZXJzLlN0cmluZ1ZhbHVlSGFuZGxlciA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICBtaXhlZENvbnRlbnQodGhpcyk7XHJcbn07XHJcbmhhbmRsZXJzLlN0cmluZ1ZhbHVlSGFuZGxlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICByZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcclxufTtcclxuXHJcbmhhbmRsZXJzLkNhbnZhc1N0eWxlSGFuZGxlciA9IGZ1bmN0aW9uKGlkLCBkKSB7XHJcblxyXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24oZWxlbSwgc3RvcmFnZSl7XHJcbiAgICAgICAgaWYgKGVsZW0uaGFzQXR0cmlidXRlKGlkKSlcclxuICAgICAgICAgICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlKGVsZW0uZ2V0QXR0cmlidXRlKGlkKSwgbnVsbCwgZWxlbSwgc3RvcmFnZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBwcmV2VmFsdWUsIGVsZW0sIHN0b3JhZ2UpIHtcclxuICAgICAgICBlbGVtLl9jb25maWd1cmVkLmNhbnZhcy5zZXRBdHRyaWJ1dGUoaWQsIHZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kZXNjID0ge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9jb25maWd1cmVkLmNhbnZhcy5zdHlsZTsgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7fVxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG5oYW5kbGVycy5DYW52YXNDbGFzc0hhbmRsZXIgPSBmdW5jdGlvbihpZCkge1xyXG5cclxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKGVsZW0sIHN0b3JhZ2Upe1xyXG4gICAgICAgIHZhciBjYW52YXMgPSBlbGVtLl9jb25maWd1cmVkLmNhbnZhcztcclxuICAgICAgICBjYW52YXMuY2xhc3NOYW1lID0gXCJfeG1sM2RcIjsgLy8gQ2xhc3MgbmFtZSBhbHdheXMgZGVmaW5lZCBmb3IgeG1sM2QgY2FudmFzXHJcbiAgICAgICAgaWYgKGVsZW0uaGFzQXR0cmlidXRlKGlkKSlcclxuICAgICAgICAgICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlKGVsZW0uZ2V0QXR0cmlidXRlKGlkKSwgbnVsbCwgZWxlbSwgc3RvcmFnZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBwcmV2VmFsdWUsIGVsZW0sIHN0b3JhZ2UpIHtcclxuICAgICAgICB2YXIgY2FudmFzID0gZWxlbS5fY29uZmlndXJlZC5jYW52YXM7XHJcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShpZCwgdmFsdWUgKyBcIiBfeG1sM2RcIik7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGVzYyA9IHtcclxuICAgICAgICAvLyBUT0RPOiBTaG91bGQgd2Ugbm90IHN0cmlwIHRoZSBfeG1sM2QgY2xhc3MgaGVyZT9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fY29uZmlndXJlZC5jYW52YXMuY2xhc3NOYW1lOyB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5fY29uZmlndXJlZC5jYW52YXMuY2xhc3NOYW1lID0gdmFsdWU7IH1cclxuICAgIH07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGhhbmRsZXJzO1xyXG4iLCJ2YXIgbWV0aG9kcyA9IHJlcXVpcmUoXCIuL21ldGhvZHMuanNcIik7XHJcbnZhciBoYW5kbGVycyA9IHJlcXVpcmUoXCIuL2F0dHJpYnV0ZXMuanNcIik7XHJcbnZhciBwcm9wZXJ0aWVzID0gcmVxdWlyZShcIi4vcHJvcGVydGllcy5qc1wiKTtcclxuXHJcbi8vIE1lc2hUeXBlc1xyXG52YXIgTWVzaFR5cGVzID0ge307XHJcbk1lc2hUeXBlc1tcInRyaWFuZ2xlc1wiXSA9IDA7XHJcbk1lc2hUeXBlc1swXSA9IFwidHJpYW5nbGVzXCI7XHJcbk1lc2hUeXBlc1tcInRyaWFuZ2xlc3RyaXBzXCJdID0gMTtcclxuTWVzaFR5cGVzWzFdID0gXCJ0cmlhbmdsZXN0cmlwc1wiO1xyXG5NZXNoVHlwZXNbXCJsaW5lc1wiXSA9IDI7XHJcbk1lc2hUeXBlc1syXSA9IFwibGluZXNcIjtcclxuTWVzaFR5cGVzW1wibGluZXN0cmlwc1wiXSA9IDM7XHJcbk1lc2hUeXBlc1szXSA9IFwibGluZXN0cmlwc1wiO1xyXG5NZXNoVHlwZXNbXCJwb2ludHNcIl0gPSA0O1xyXG5NZXNoVHlwZXNbNF0gPSBcInBvaW50c1wiO1xyXG4vLyBUZXh0dXJlVHlwZXNcclxudmFyIFRleHR1cmVUeXBlcyA9IHt9O1xyXG5UZXh0dXJlVHlwZXNbXCIyZFwiXSA9IDA7XHJcblRleHR1cmVUeXBlc1swXSA9IFwiMmRcIjtcclxuVGV4dHVyZVR5cGVzW1wiMWRcIl0gPSAxO1xyXG5UZXh0dXJlVHlwZXNbMV0gPSBcIjFkXCI7XHJcblRleHR1cmVUeXBlc1tcIjNkXCJdID0gMjtcclxuVGV4dHVyZVR5cGVzWzJdID0gXCIzZFwiO1xyXG4vLyBGaWx0ZXJUeXBlc1xyXG52YXIgRmlsdGVyVHlwZXMgPSB7fTtcclxuRmlsdGVyVHlwZXNbXCJuZWFyZXN0XCJdID0gMTtcclxuRmlsdGVyVHlwZXNbMV0gPSBcIm5lYXJlc3RcIjtcclxuRmlsdGVyVHlwZXNbXCJsaW5lYXJcIl0gPSAyO1xyXG5GaWx0ZXJUeXBlc1syXSA9IFwibGluZWFyXCI7XHJcbkZpbHRlclR5cGVzW1wibmVhcmVzdC1taXBtYXAtbmVhcmVzdFwiXSA9IDM7XHJcbkZpbHRlclR5cGVzWzNdID0gXCJuZWFyZXN0LW1pcG1hcC1uZWFyZXN0XCI7XHJcbkZpbHRlclR5cGVzW1wibGluZWFyLW1pcG1hcC1uZWFyZXN0XCJdID0gNDtcclxuRmlsdGVyVHlwZXNbNF0gPSBcImxpbmVhci1taXBtYXAtbmVhcmVzdFwiO1xyXG5GaWx0ZXJUeXBlc1tcIm5lYXJlc3QtbWlwbWFwLWxpbmVhclwiXSA9IDU7XHJcbkZpbHRlclR5cGVzWzVdID0gXCJuZWFyZXN0LW1pcG1hcC1saW5lYXJcIjtcclxuRmlsdGVyVHlwZXNbXCJsaW5lYXItbWlwbWFwLWxpbmVhclwiXSA9IDY7XHJcbkZpbHRlclR5cGVzWzZdID0gXCJsaW5lYXItbWlwbWFwLWxpbmVhclwiO1xyXG4vLyBXcmFwVHlwZXNcclxudmFyIFdyYXBUeXBlcyA9IHt9O1xyXG5XcmFwVHlwZXNbXCJjbGFtcFwiXSA9IDA7XHJcbldyYXBUeXBlc1swXSA9IFwiY2xhbXBcIjtcclxuV3JhcFR5cGVzW1wicmVwZWF0XCJdID0gMTtcclxuV3JhcFR5cGVzWzFdID0gXCJyZXBlYXRcIjtcclxuV3JhcFR5cGVzW1wiYm9yZGVyXCJdID0gMjtcclxuV3JhcFR5cGVzWzJdID0gXCJib3JkZXJcIjtcclxuLy8gUGxhdGZvcm1UeXBlc1xyXG52YXIgUGxhdGZvcm1UeXBlcyA9IHt9O1xyXG5QbGF0Zm9ybVR5cGVzW1wiYXV0b1wiXSA9IDE7XHJcblBsYXRmb3JtVHlwZXNbMV0gPSBcImF1dG9cIjtcclxuUGxhdGZvcm1UeXBlc1tcImpzXCJdID0gMjtcclxuUGxhdGZvcm1UeXBlc1syXSA9IFwianNcIjtcclxuUGxhdGZvcm1UeXBlc1tcImdsXCJdID0gMztcclxuUGxhdGZvcm1UeXBlc1szXSA9IFwiZ2xcIjtcclxuUGxhdGZvcm1UeXBlc1tcImNsXCJdID0gNDtcclxuUGxhdGZvcm1UeXBlc1s0XSA9IFwiY2xcIjtcclxuLy8gRGF0YUZpZWxkVHlwZVxyXG52YXIgRGF0YUZpZWxkVHlwZSA9IHt9O1xyXG5EYXRhRmllbGRUeXBlW1wiZmxvYXQgXCJdID0gMDtcclxuRGF0YUZpZWxkVHlwZVswXSA9IFwiZmxvYXQgXCI7XHJcbkRhdGFGaWVsZFR5cGVbXCJmbG9hdDIgXCJdID0gMTtcclxuRGF0YUZpZWxkVHlwZVsxXSA9IFwiZmxvYXQyIFwiO1xyXG5EYXRhRmllbGRUeXBlW1wiZmxvYXQzXCJdID0gMjtcclxuRGF0YUZpZWxkVHlwZVsyXSA9IFwiZmxvYXQzXCI7XHJcbkRhdGFGaWVsZFR5cGVbXCJmbG9hdDRcIl0gPSAzO1xyXG5EYXRhRmllbGRUeXBlWzNdID0gXCJmbG9hdDRcIjtcclxuRGF0YUZpZWxkVHlwZVtcImZsb2F0NHg0XCJdID0gNDtcclxuRGF0YUZpZWxkVHlwZVs0XSA9IFwiZmxvYXQ0eDRcIjtcclxuRGF0YUZpZWxkVHlwZVtcImludFwiXSA9IDEwO1xyXG5EYXRhRmllbGRUeXBlWzEwXSA9IFwiaW50XCI7XHJcbkRhdGFGaWVsZFR5cGVbXCJpbnQ0XCJdID0gMTE7XHJcbkRhdGFGaWVsZFR5cGVbMTFdID0gXCJpbnQ0XCI7XHJcbkRhdGFGaWVsZFR5cGVbXCJib29sXCJdID0gMjA7XHJcbkRhdGFGaWVsZFR5cGVbMjBdID0gXCJib29sXCI7XHJcbkRhdGFGaWVsZFR5cGVbXCJ0ZXh0dXJlXCJdID0gMzA7XHJcbkRhdGFGaWVsZFR5cGVbMzBdID0gXCJ0ZXh0dXJlXCI7XHJcbi8vIERhdGFDaGFubmVsT3JpZ2luXHJcbnZhciBEYXRhQ2hhbm5lbE9yaWdpbiA9IHt9O1xyXG5EYXRhQ2hhbm5lbE9yaWdpbltcIm9yaWdpbl92YWx1ZSBcIl0gPSAwO1xyXG5EYXRhQ2hhbm5lbE9yaWdpblswXSA9IFwib3JpZ2luX3ZhbHVlIFwiO1xyXG5EYXRhQ2hhbm5lbE9yaWdpbltcIm9yaWdpbl9jaGlsZFwiXSA9IDE7XHJcbkRhdGFDaGFubmVsT3JpZ2luWzFdID0gXCJvcmlnaW5fY2hpbGRcIjtcclxuRGF0YUNoYW5uZWxPcmlnaW5bXCJvcmlnaW5fc291cmNlXCJdID0gMjtcclxuRGF0YUNoYW5uZWxPcmlnaW5bMl0gPSBcIm9yaWdpbl9zb3VyY2VcIjtcclxuRGF0YUNoYW5uZWxPcmlnaW5bXCJvcmlnaW5fY29tcHV0ZVwiXSA9IDM7XHJcbkRhdGFDaGFubmVsT3JpZ2luWzNdID0gXCJvcmlnaW5fY29tcHV0ZVwiO1xyXG5EYXRhQ2hhbm5lbE9yaWdpbltcIm9yaWdpbl9wcm90b1wiXSA9IDQ7XHJcbkRhdGFDaGFubmVsT3JpZ2luWzRdID0gXCJvcmlnaW5fcHJvdG9cIjtcclxuXHJcbnZhciBjbGFzc0luZm8gPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8eG1sM2Q+XHJcbiAqKi9cclxuY2xhc3NJbmZvWyd4bWwzZCddID0ge1xyXG4gICAgaWQgOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZSA6IHthOiBoYW5kbGVycy5DYW52YXNDbGFzc0hhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIHN0eWxlIDoge2E6IGhhbmRsZXJzLkNhbnZhc1N0eWxlSGFuZGxlcn0sXHJcbiAgICBvbmNsaWNrIDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmRibGNsaWNrIDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlZG93biA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZXVwIDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlb3ZlciA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW1vdmUgOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2VvdXQgOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5cHJlc3MgOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5ZG93biA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXl1cCA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25sb2FkOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGNvbXBsZXRlOiB7cDogcHJvcGVydGllcy54bWwzZENvbXBsZXRlfSxcclxuICAgIGhlaWdodCA6IHthOiBoYW5kbGVycy5JbnRBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IDYwMH0sXHJcbiAgICB3aWR0aCA6IHthOiBoYW5kbGVycy5JbnRBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IDgwMH0sXHJcbiAgICBnZXRFbGVtZW50QnlQb2ludCA6IHttOiBtZXRob2RzLnhtbDNkR2V0RWxlbWVudEJ5UG9pbnR9LFxyXG4gICAgZ2VuZXJhdGVSYXkgOiB7bTogbWV0aG9kcy54bWwzZEdlbmVyYXRlUmF5fSxcclxuICAgIGdldEVsZW1lbnRCeVJheSA6IHttOiBtZXRob2RzLnhtbDNkR2V0RWxlbWVudEJ5UmF5fSxcclxuICAgIGdldEJvdW5kaW5nQm94IDoge206IG1ldGhvZHMuZGVwcmVjYXRlZEdldEJvdW5kaW5nQm94V29ybGR9LFxyXG4gICAgZ2V0V29ybGRCb3VuZGluZ0JveCA6IHttOiBtZXRob2RzLmdldFdvcmxkQm91bmRpbmdCb3h9LFxyXG4gICAgZ2V0TG9jYWxCb3VuZGluZ0JveCA6IHttOiBtZXRob2RzLmdldExvY2FsQm91bmRpbmdCb3h9LFxyXG4gICAgZ2V0UmVuZGVySW50ZXJmYWNlIDoge206IG1ldGhvZHMueG1sM2RHZXRSZW5kZXJJbnRlcmZhY2V9LFxyXG4gICAgYWN0aXZlVmlldyA6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIF90ZXJtOiB1bmRlZmluZWRcclxufTtcclxuXHJcbmNsYXNzSW5mb1snY29tcHV0ZSddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgdmFsdWU6IHthOiBoYW5kbGVycy5TdHJpbmdWYWx1ZUhhbmRsZXJ9LFxyXG4gICAgX3Rlcm06IHVuZGVmaW5lZFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxkYXRhPlxyXG4gKiovXHJcbmNsYXNzSW5mb1snZGF0YSddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgY29tcHV0ZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGxhdGZvcm06IHthOiBoYW5kbGVycy5FbnVtQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiB7ZTogUGxhdGZvcm1UeXBlcywgZDogMX19LFxyXG4gICAgZmlsdGVyOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmxvYWQ6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25wcm9ncmVzczoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBjb21wbGV0ZToge3A6IHByb3BlcnRpZXMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUNvbXBsZXRlfSxcclxuICAgIHByb2dyZXNzTGV2ZWw6IHtwOiBwcm9wZXJ0aWVzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVQcm9ncmVzc0xldmVsfSxcclxuICAgIGdldE91dHB1dE5hbWVzOiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0T3V0cHV0TmFtZXN9LFxyXG4gICAgZ2V0T3V0cHV0Q2hhbm5lbEluZm86IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRPdXRwdXRDaGFubmVsSW5mb30sXHJcbiAgICBnZXRDb21wdXRlSW5mbzoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldENvbXB1dGVJbmZvfSxcclxuICAgIGdldFByb3RvSW5mbzoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldFByb3RvSW5mb30sXHJcbiAgICBpc091dHB1dENvbm5lY3RlZDoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUlzT3V0cHV0Q29ubmVjdGVkfSxcclxuICAgIGdldFJlc3VsdDoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldFJlc3VsdH0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIF90ZXJtOiB1bmRlZmluZWRcclxufTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxkYXRhZmxvdz5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2RhdGFmbG93J10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBwbGF0Zm9ybToge2E6IGhhbmRsZXJzLkVudW1BdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IHtlOiBQbGF0Zm9ybVR5cGVzLCBkOiAxfX0sXHJcbiAgICBvdXQ6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubG9hZDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbnByb2dyZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGNvbXBsZXRlOiB7cDogcHJvcGVydGllcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlQ29tcGxldGV9LFxyXG4gICAgcHJvZ3Jlc3NMZXZlbDoge3A6IHByb3BlcnRpZXMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZVByb2dyZXNzTGV2ZWx9LFxyXG4gICAgZ2V0T3V0cHV0TmFtZXM6IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRPdXRwdXROYW1lc30sXHJcbiAgICBnZXRPdXRwdXRDaGFubmVsSW5mbzoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldE91dHB1dENoYW5uZWxJbmZvfSxcclxuICAgIGdldENvbXB1dGVJbmZvOiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0Q29tcHV0ZUluZm99LFxyXG4gICAgZ2V0UHJvdG9JbmZvOiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0UHJvdG9JbmZvfSxcclxuICAgIGlzT3V0cHV0Q29ubmVjdGVkOiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlSXNPdXRwdXRDb25uZWN0ZWR9LFxyXG4gICAgZ2V0UmVzdWx0OiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0UmVzdWx0fSxcclxuICAgIF90ZXJtOiB1bmRlZmluZWRcclxufTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxkYXRhPlxyXG4gKiovXHJcbmNsYXNzSW5mb1snYXNzZXQnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG9ubG9hZDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbnByb2dyZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGNvbXBsZXRlOiB7cDogcHJvcGVydGllcy5Bc3NldENvbXBsZXRlfSxcclxuICAgIHByb2dyZXNzTGV2ZWw6IHtwOiBwcm9wZXJ0aWVzLkFzc2V0UHJvZ3Jlc3NMZXZlbH0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBpY2s6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHRyYW5zZm9ybToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgc2hhZGVyOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBfdGVybTogdW5kZWZpbmVkXHJcbn07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8ZGVmcz5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2RlZnMnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIF90ZXJtOiB1bmRlZmluZWRcclxufTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxncm91cD5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2dyb3VwJ10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBvbmNsaWNrOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9uZGJsY2xpY2s6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZWRvd246IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZXVwOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2VvdmVyOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2Vtb3ZlOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2VvdXQ6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXlwcmVzczoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleWRvd246IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXl1cDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICB2aXNpYmxlOiB7YTogaGFuZGxlcnMuQm9vbEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogdHJ1ZX0sXHJcbiAgICBnZXRXb3JsZE1hdHJpeDoge206IG1ldGhvZHMuWE1MM0RHcmFwaFR5cGVHZXRXb3JsZE1hdHJpeH0sXHJcbiAgICBnZXRMb2NhbE1hdHJpeDoge206IG1ldGhvZHMuZ3JvdXBHZXRMb2NhbE1hdHJpeH0sXHJcbiAgICBnZXRCb3VuZGluZ0JveCA6IHttOiBtZXRob2RzLmRlcHJlY2F0ZWRHZXRCb3VuZGluZ0JveFdvcmxkfSxcclxuICAgIGdldFdvcmxkQm91bmRpbmdCb3ggOiB7bTogbWV0aG9kcy5nZXRXb3JsZEJvdW5kaW5nQm94fSxcclxuICAgIGdldExvY2FsQm91bmRpbmdCb3ggOiB7bTogbWV0aG9kcy5nZXRMb2NhbEJvdW5kaW5nQm94fSxcclxuICAgIHRyYW5zZm9ybToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgc2hhZGVyOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBfdGVybTogdW5kZWZpbmVkXHJcbn07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8bWVzaD5cclxuICoqL1xyXG5jbGFzc0luZm9bJ21lc2gnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG9uY2xpY2s6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25kYmxjbGljazoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlZG93bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNldXA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW92ZXI6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW1vdmU6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW91dDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXByZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5ZG93bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXVwOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubG9hZDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbnByb2dyZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGNvbXBsZXRlOiB7cDogcHJvcGVydGllcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlQ29tcGxldGV9LFxyXG4gICAgcHJvZ3Jlc3NMZXZlbDoge3A6IHByb3BlcnRpZXMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZVByb2dyZXNzTGV2ZWx9LFxyXG4gICAgdmlzaWJsZToge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IHRydWV9LFxyXG4gICAgdHlwZToge2E6IGhhbmRsZXJzLkVudW1BdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IHtlOiBNZXNoVHlwZXMsIGQ6IDB9fSxcclxuICAgIGNvbXB1dGU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHRyYW5zZm9ybToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgc2hhZGVyOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBnZXRXb3JsZE1hdHJpeDoge206IG1ldGhvZHMuWE1MM0RHcmFwaFR5cGVHZXRXb3JsZE1hdHJpeH0sXHJcbiAgICBnZXRCb3VuZGluZ0JveCA6IHttOiBtZXRob2RzLmRlcHJlY2F0ZWRHZXRCb3VuZGluZ0JveExvY2FsfSxcclxuICAgIGdldFdvcmxkQm91bmRpbmdCb3ggOiB7bTogbWV0aG9kcy5nZXRXb3JsZEJvdW5kaW5nQm94fSxcclxuICAgIGdldExvY2FsQm91bmRpbmdCb3ggOiB7bTogbWV0aG9kcy5nZXRMb2NhbEJvdW5kaW5nQm94fSxcclxuICAgIGdldE91dHB1dE5hbWVzOiB7bTogbWV0aG9kcy5tZXNoR2V0T3V0cHV0TmFtZXN9LFxyXG4gICAgZ2V0T3V0cHV0Q2hhbm5lbEluZm86IHttOiBtZXRob2RzLm1lc2hHZXRPdXRwdXRDaGFubmVsSW5mb30sXHJcbiAgICBnZXRDb21wdXRlSW5mbzoge206IG1ldGhvZHMubWVzaEdldENvbXB1dGVJbmZvfSxcclxuICAgIGdldFByb3RvSW5mbzoge206IG1ldGhvZHMubWVzaEdldFByb3RvSW5mb30sXHJcbiAgICBpc091dHB1dENvbm5lY3RlZDoge206IG1ldGhvZHMubWVzaElzT3V0cHV0Q29ubmVjdGVkfSxcclxuICAgIGdldFJlc3VsdDoge206IG1ldGhvZHMubWVzaEdldFJlc3VsdH0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIF90ZXJtOiB1bmRlZmluZWRcclxufTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxtb2RlbD5cclxuICoqL1xyXG5jbGFzc0luZm9bJ21vZGVsJ10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBvbmNsaWNrOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9uZGJsY2xpY2s6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZWRvd246IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZXVwOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2VvdmVyOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2Vtb3ZlOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2VvdXQ6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXlwcmVzczoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleWRvd246IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXl1cDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmxvYWQ6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25wcm9ncmVzczoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBjb21wbGV0ZToge3A6IHByb3BlcnRpZXMuQXNzZXRDb21wbGV0ZX0sXHJcbiAgICBwcm9ncmVzc0xldmVsOiB7cDogcHJvcGVydGllcy5Bc3NldFByb2dyZXNzTGV2ZWx9LFxyXG4gICAgdmlzaWJsZToge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IHRydWV9LFxyXG4gICAgZ2V0V29ybGRNYXRyaXg6IHttOiBtZXRob2RzLlhNTDNER3JhcGhUeXBlR2V0V29ybGRNYXRyaXh9LFxyXG4gICAgZ2V0Qm91bmRpbmdCb3ggOiB7bTogbWV0aG9kcy5kZXByZWNhdGVkR2V0Qm91bmRpbmdCb3hMb2NhbH0sXHJcbiAgICBnZXRXb3JsZEJvdW5kaW5nQm94IDoge206IG1ldGhvZHMuZ2V0V29ybGRCb3VuZGluZ0JveH0sXHJcbiAgICBnZXRMb2NhbEJvdW5kaW5nQm94IDoge206IG1ldGhvZHMuZ2V0TG9jYWxCb3VuZGluZ0JveH0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBpY2s6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHRyYW5zZm9ybToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgc2hhZGVyOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBfdGVybTogdW5kZWZpbmVkXHJcbn07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8dHJhbnNmb3JtPlxyXG4gKiovXHJcbmNsYXNzSW5mb1sndHJhbnNmb3JtJ10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICB0cmFuc2xhdGlvbjoge2E6IGhhbmRsZXJzLlhNTDNEVmVjM0F0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogWzAsIDAsIDBdfSxcclxuICAgIHNjYWxlOiB7YTogaGFuZGxlcnMuWE1MM0RWZWMzQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBbMSwgMSwgMV19LFxyXG4gICAgcm90YXRpb246IHthOiBoYW5kbGVycy5YTUwzRFJvdGF0aW9uQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBbMCwgMCwgMSwgMF19LFxyXG4gICAgY2VudGVyOiB7YTogaGFuZGxlcnMuWE1MM0RWZWMzQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBbMCwgMCwgMF19LFxyXG4gICAgc2NhbGVPcmllbnRhdGlvbjoge2E6IGhhbmRsZXJzLlhNTDNEUm90YXRpb25BdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IFswLCAwLCAxLCAwXX0sXHJcbiAgICBfdGVybTogdW5kZWZpbmVkXHJcbn07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8c2hhZGVyPlxyXG4gKiovXHJcbmNsYXNzSW5mb1snc2hhZGVyJ10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBvbmxvYWQ6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25wcm9ncmVzczoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBjb21wbGV0ZToge3A6IHByb3BlcnRpZXMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUNvbXBsZXRlfSxcclxuICAgIHByb2dyZXNzTGV2ZWw6IHtwOiBwcm9wZXJ0aWVzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVQcm9ncmVzc0xldmVsfSxcclxuICAgIGNvbXB1dGU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGdldE91dHB1dE5hbWVzOiB7bTogbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldE91dHB1dE5hbWVzfSxcclxuICAgIGdldE91dHB1dENoYW5uZWxJbmZvOiB7bTogbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldE91dHB1dENoYW5uZWxJbmZvfSxcclxuICAgIGdldENvbXB1dGVJbmZvOiB7bTogbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldENvbXB1dGVJbmZvfSxcclxuICAgIGdldFByb3RvSW5mbzoge206IG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRQcm90b0luZm99LFxyXG4gICAgaXNPdXRwdXRDb25uZWN0ZWQ6IHttOiBtZXRob2RzLlhNTDNEU2hhZGVyUHJvdmlkZXJUeXBlSXNPdXRwdXRDb25uZWN0ZWR9LFxyXG4gICAgZ2V0UmVzdWx0OiB7bTogbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldFJlc3VsdH0sXHJcbiAgICBzY3JpcHQ6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHNyYzoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgX3Rlcm06IHVuZGVmaW5lZFxyXG59O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGxpZ2h0PlxyXG4gKiovXHJcbmNsYXNzSW5mb1snbGlnaHQnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG9uY2xpY2s6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25kYmxjbGljazoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlZG93bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNldXA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW92ZXI6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW1vdmU6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW91dDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXByZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5ZG93bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXVwOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHZpc2libGU6IHthOiBoYW5kbGVycy5Cb29sQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiB0cnVlfSxcclxuICAgIGdsb2JhbDoge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IGZhbHNlfSxcclxuICAgIGludGVuc2l0eToge2E6IGhhbmRsZXJzLkZsb2F0QXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiAxfSxcclxuICAgIGdldFdvcmxkTWF0cml4OiB7bTogbWV0aG9kcy5YTUwzREdyYXBoVHlwZUdldFdvcmxkTWF0cml4fSxcclxuICAgIHNoYWRlcjoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgX3Rlcm06IHVuZGVmaW5lZFxyXG59O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGxpZ2h0c2hhZGVyPlxyXG4gKiovXHJcbmNsYXNzSW5mb1snbGlnaHRzaGFkZXInXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG9ubG9hZDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbnByb2dyZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGNvbXBsZXRlOiB7cDogcHJvcGVydGllcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlQ29tcGxldGV9LFxyXG4gICAgcHJvZ3Jlc3NMZXZlbDoge3A6IHByb3BlcnRpZXMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZVByb2dyZXNzTGV2ZWx9LFxyXG4gICAgY29tcHV0ZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgZ2V0T3V0cHV0TmFtZXM6IHttOiBtZXRob2RzLlhNTDNEU2hhZGVyUHJvdmlkZXJUeXBlR2V0T3V0cHV0TmFtZXN9LFxyXG4gICAgZ2V0T3V0cHV0Q2hhbm5lbEluZm86IHttOiBtZXRob2RzLlhNTDNEU2hhZGVyUHJvdmlkZXJUeXBlR2V0T3V0cHV0Q2hhbm5lbEluZm99LFxyXG4gICAgZ2V0Q29tcHV0ZUluZm86IHttOiBtZXRob2RzLlhNTDNEU2hhZGVyUHJvdmlkZXJUeXBlR2V0Q29tcHV0ZUluZm99LFxyXG4gICAgZ2V0UHJvdG9JbmZvOiB7bTogbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldFByb3RvSW5mb30sXHJcbiAgICBpc091dHB1dENvbm5lY3RlZDoge206IG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVJc091dHB1dENvbm5lY3RlZH0sXHJcbiAgICBnZXRSZXN1bHQ6IHttOiBtZXRob2RzLlhNTDNEU2hhZGVyUHJvdmlkZXJUeXBlR2V0UmVzdWx0fSxcclxuICAgIHNjcmlwdDoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgc3JjOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBfdGVybTogdW5kZWZpbmVkXHJcbn07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8c2NyaXB0PlxyXG4gKiovXHJcbmNsYXNzSW5mb1snc2NyaXB0J10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICB2YWx1ZToge2E6IGhhbmRsZXJzLlN0cmluZ1ZhbHVlSGFuZGxlcn0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHR5cGU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIF90ZXJtOiB1bmRlZmluZWRcclxufTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxhc3NldG1lc2g+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydhc3NldG1lc2gnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG1hdGNoOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICB0eXBlOiB7YTogaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczoge2U6IE1lc2hUeXBlcywgZDogMH19LFxyXG4gICAgY29tcHV0ZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgZmlsdGVyOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBpbmNsdWRlczoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgc2hhZGVyOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICB0cmFuc2Zvcm06IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBsYXRmb3JtOiB7YTogaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczoge2U6IFBsYXRmb3JtVHlwZXMsIGQ6IDF9fSxcclxuICAgIGdldE91dHB1dE5hbWVzOiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0T3V0cHV0TmFtZXN9LFxyXG4gICAgZ2V0T3V0cHV0Q2hhbm5lbEluZm86IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRPdXRwdXRDaGFubmVsSW5mb30sXHJcbiAgICBnZXRDb21wdXRlSW5mbzoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldENvbXB1dGVJbmZvfSxcclxuICAgIGdldFByb3RvSW5mbzoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldFByb3RvSW5mb30sXHJcbiAgICBpc091dHB1dENvbm5lY3RlZDoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUlzT3V0cHV0Q29ubmVjdGVkfSxcclxuICAgIGdldFJlc3VsdDoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldFJlc3VsdH0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIF90ZXJtOiB1bmRlZmluZWRcclxufTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxhc3NldGRhdGE+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydhc3NldGRhdGEnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGNvbXB1dGU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGZpbHRlcjoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgaW5jbHVkZXM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBsYXRmb3JtOiB7YTogaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczoge2U6IFBsYXRmb3JtVHlwZXMsIGQ6IDF9fSxcclxuICAgIGdldE91dHB1dE5hbWVzOiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0T3V0cHV0TmFtZXN9LFxyXG4gICAgZ2V0T3V0cHV0Q2hhbm5lbEluZm86IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRPdXRwdXRDaGFubmVsSW5mb30sXHJcbiAgICBnZXRDb21wdXRlSW5mbzoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldENvbXB1dGVJbmZvfSxcclxuICAgIGdldFByb3RvSW5mbzoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldFByb3RvSW5mb30sXHJcbiAgICBpc091dHB1dENvbm5lY3RlZDoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUlzT3V0cHV0Q29ubmVjdGVkfSxcclxuICAgIGdldFJlc3VsdDoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldFJlc3VsdH0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIF90ZXJtOiB1bmRlZmluZWRcclxufTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxmbG9hdD5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2Zsb2F0J10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBuYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBwYXJhbToge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IGZhbHNlfSxcclxuICAgIGtleToge2E6IGhhbmRsZXJzLkZsb2F0QXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiAwLjB9LFxyXG4gICAgdmFsdWU6IHthOiBoYW5kbGVycy5GbG9hdEFycmF5VmFsdWVIYW5kbGVyfSxcclxuICAgIHNldFNjcmlwdFZhbHVlOiB7bTogbWV0aG9kcy5YTUwzRERhdGFTb3VyY2VUeXBlU2V0U2NyaXB0VmFsdWV9LFxyXG4gICAgX3Rlcm06IHVuZGVmaW5lZFxyXG59O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGZsb2F0Mj5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2Zsb2F0MiddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgbmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGFyYW06IHthOiBoYW5kbGVycy5Cb29sQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBmYWxzZX0sXHJcbiAgICBrZXk6IHthOiBoYW5kbGVycy5GbG9hdEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogMC4wfSxcclxuICAgIHZhbHVlOiB7YTogaGFuZGxlcnMuRmxvYXQyQXJyYXlWYWx1ZUhhbmRsZXJ9LFxyXG4gICAgc2V0U2NyaXB0VmFsdWU6IHttOiBtZXRob2RzLlhNTDNERGF0YVNvdXJjZVR5cGVTZXRTY3JpcHRWYWx1ZX0sXHJcbiAgICBfdGVybTogdW5kZWZpbmVkXHJcbn07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8ZmxvYXQzPlxyXG4gKiovXHJcbmNsYXNzSW5mb1snZmxvYXQzJ10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBuYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBwYXJhbToge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IGZhbHNlfSxcclxuICAgIGtleToge2E6IGhhbmRsZXJzLkZsb2F0QXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiAwLjB9LFxyXG4gICAgdmFsdWU6IHthOiBoYW5kbGVycy5GbG9hdDNBcnJheVZhbHVlSGFuZGxlcn0sXHJcbiAgICBzZXRTY3JpcHRWYWx1ZToge206IG1ldGhvZHMuWE1MM0REYXRhU291cmNlVHlwZVNldFNjcmlwdFZhbHVlfSxcclxuICAgIF90ZXJtOiB1bmRlZmluZWRcclxufTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxmbG9hdDQ+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydmbG9hdDQnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBhcmFtOiB7YTogaGFuZGxlcnMuQm9vbEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogZmFsc2V9LFxyXG4gICAga2V5OiB7YTogaGFuZGxlcnMuRmxvYXRBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IDAuMH0sXHJcbiAgICB2YWx1ZToge2E6IGhhbmRsZXJzLkZsb2F0NEFycmF5VmFsdWVIYW5kbGVyfSxcclxuICAgIHNldFNjcmlwdFZhbHVlOiB7bTogbWV0aG9kcy5YTUwzRERhdGFTb3VyY2VUeXBlU2V0U2NyaXB0VmFsdWV9LFxyXG4gICAgX3Rlcm06IHVuZGVmaW5lZFxyXG59O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGZsb2F0NHg0PlxyXG4gKiovXHJcbmNsYXNzSW5mb1snZmxvYXQ0eDQnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBhcmFtOiB7YTogaGFuZGxlcnMuQm9vbEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogZmFsc2V9LFxyXG4gICAga2V5OiB7YTogaGFuZGxlcnMuRmxvYXRBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IDAuMH0sXHJcbiAgICB2YWx1ZToge2E6IGhhbmRsZXJzLkZsb2F0NHg0QXJyYXlWYWx1ZUhhbmRsZXJ9LFxyXG4gICAgc2V0U2NyaXB0VmFsdWU6IHttOiBtZXRob2RzLlhNTDNERGF0YVNvdXJjZVR5cGVTZXRTY3JpcHRWYWx1ZX0sXHJcbiAgICBfdGVybTogdW5kZWZpbmVkXHJcbn07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8aW50PlxyXG4gKiovXHJcbmNsYXNzSW5mb1snaW50J10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBuYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBwYXJhbToge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IGZhbHNlfSxcclxuICAgIGtleToge2E6IGhhbmRsZXJzLkZsb2F0QXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiAwLjB9LFxyXG4gICAgdmFsdWU6IHthOiBoYW5kbGVycy5JbnRBcnJheVZhbHVlSGFuZGxlcn0sXHJcbiAgICBzZXRTY3JpcHRWYWx1ZToge206IG1ldGhvZHMuWE1MM0REYXRhU291cmNlVHlwZVNldFNjcmlwdFZhbHVlfSxcclxuICAgIF90ZXJtOiB1bmRlZmluZWRcclxufTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxpbnQ0PlxyXG4gKiovXHJcbmNsYXNzSW5mb1snaW50NCddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgbmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGFyYW06IHthOiBoYW5kbGVycy5Cb29sQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBmYWxzZX0sXHJcbiAgICBrZXk6IHthOiBoYW5kbGVycy5GbG9hdEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogMC4wfSxcclxuICAgIHZhbHVlOiB7YTogaGFuZGxlcnMuSW50QXJyYXlWYWx1ZUhhbmRsZXJ9LFxyXG4gICAgc2V0U2NyaXB0VmFsdWU6IHttOiBtZXRob2RzLlhNTDNERGF0YVNvdXJjZVR5cGVTZXRTY3JpcHRWYWx1ZX0sXHJcbiAgICBfdGVybTogdW5kZWZpbmVkXHJcbn07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8Ym9vbD5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2Jvb2wnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBhcmFtOiB7YTogaGFuZGxlcnMuQm9vbEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogZmFsc2V9LFxyXG4gICAga2V5OiB7YTogaGFuZGxlcnMuRmxvYXRBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IDAuMH0sXHJcbiAgICB2YWx1ZToge2E6IGhhbmRsZXJzLkJvb2xBcnJheVZhbHVlSGFuZGxlcn0sXHJcbiAgICBzZXRTY3JpcHRWYWx1ZToge206IG1ldGhvZHMuWE1MM0REYXRhU291cmNlVHlwZVNldFNjcmlwdFZhbHVlfSxcclxuICAgIF90ZXJtOiB1bmRlZmluZWRcclxufTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDx0ZXh0dXJlPlxyXG4gKiovXHJcbmNsYXNzSW5mb1sndGV4dHVyZSddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgbmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGFyYW06IHthOiBoYW5kbGVycy5Cb29sQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBmYWxzZX0sXHJcbiAgICBrZXk6IHthOiBoYW5kbGVycy5GbG9hdEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogMC4wfSxcclxuICAgIHR5cGU6IHthOiBoYW5kbGVycy5FbnVtQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiB7ZTogVGV4dHVyZVR5cGVzLCBkOiAwfX0sXHJcbiAgICBmaWx0ZXJNaW46IHthOiBoYW5kbGVycy5FbnVtQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiB7ZTogRmlsdGVyVHlwZXMsIGQ6IDZ9fSxcclxuICAgIGZpbHRlck1hZzoge2E6IGhhbmRsZXJzLkVudW1BdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IHtlOiBGaWx0ZXJUeXBlcywgZDogMn19LFxyXG4gICAgZmlsdGVyTWlwOiB7YTogaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczoge2U6IEZpbHRlclR5cGVzLCBkOiAxfX0sXHJcbiAgICB3cmFwUzoge2E6IGhhbmRsZXJzLkVudW1BdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IHtlOiBXcmFwVHlwZXMsIGQ6IDB9fSxcclxuICAgIHdyYXBUOiB7YTogaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczoge2U6IFdyYXBUeXBlcywgZDogMH19LFxyXG4gICAgd3JhcFU6IHthOiBoYW5kbGVycy5FbnVtQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiB7ZTogV3JhcFR5cGVzLCBkOiAwfX0sXHJcbiAgICBib3JkZXJDb2xvcjoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgc2V0U2NyaXB0VmFsdWU6IHttOiBtZXRob2RzLlhNTDNERGF0YVNvdXJjZVR5cGVTZXRTY3JpcHRWYWx1ZX0sXHJcbiAgICBfdGVybTogdW5kZWZpbmVkXHJcbn07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8aW1nPlxyXG4gKiovXHJcbmNsYXNzSW5mb1snaW1nJ10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIF90ZXJtOiB1bmRlZmluZWRcclxufTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDx2aWRlbz5cclxuICoqL1xyXG5jbGFzc0luZm9bJ3ZpZGVvJ10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGF1dG9wbGF5OiB7YTogaGFuZGxlcnMuQm9vbEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogZmFsc2V9LFxyXG4gICAgcGxheToge206IG1ldGhvZHMudmlkZW9QbGF5fSxcclxuICAgIHBhdXNlOiB7bTogbWV0aG9kcy52aWRlb1BhdXNlfSxcclxuICAgIF90ZXJtOiB1bmRlZmluZWRcclxufTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDx2aWV3PlxyXG4gKiovXHJcbmNsYXNzSW5mb1sndmlldyddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgb25jbGljazoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmRibGNsaWNrOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2Vkb3duOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2V1cDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlb3Zlcjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlbW92ZToge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlb3V0OiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5cHJlc3M6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXlkb3duOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5dXA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgdmlzaWJsZToge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IHRydWV9LFxyXG4gICAgcG9zaXRpb246IHthOiBoYW5kbGVycy5YTUwzRFZlYzNBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IFswLCAwLCAwXX0sXHJcbiAgICBvcmllbnRhdGlvbjoge2E6IGhhbmRsZXJzLlhNTDNEUm90YXRpb25BdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IFswLCAwLCAxLCAwXX0sXHJcbiAgICBmaWVsZE9mVmlldzoge2E6IGhhbmRsZXJzLkZsb2F0QXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiAwLjc4NTM5OH0sXHJcbiAgICBnZXRXb3JsZE1hdHJpeDoge206IG1ldGhvZHMuWE1MM0RHcmFwaFR5cGVHZXRXb3JsZE1hdHJpeH0sXHJcbiAgICBzZXREaXJlY3Rpb246IHttOiBtZXRob2RzLnZpZXdTZXREaXJlY3Rpb259LFxyXG4gICAgc2V0VXBWZWN0b3I6IHttOiBtZXRob2RzLnZpZXdTZXRVcFZlY3Rvcn0sXHJcbiAgICBsb29rQXQ6IHttOiBtZXRob2RzLnZpZXdMb29rQXR9LFxyXG4gICAgZ2V0RGlyZWN0aW9uOiB7bTogbWV0aG9kcy52aWV3R2V0RGlyZWN0aW9ufSxcclxuICAgIGdldFVwVmVjdG9yOiB7bTogbWV0aG9kcy52aWV3R2V0VXBWZWN0b3J9LFxyXG4gICAgZ2V0Vmlld01hdHJpeDoge206IG1ldGhvZHMudmlld0dldFZpZXdNYXRyaXh9LFxyXG4gICAgcGVyc3BlY3RpdmU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIF90ZXJtOiB1bmRlZmluZWRcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY2xhc3NJbmZvIDogY2xhc3NJbmZvLFxyXG4gICAgTWVzaFR5cGVzIDogTWVzaFR5cGVzLFxyXG4gICAgRmlsdGVyVHlwZXMgOiBGaWx0ZXJUeXBlcyxcclxuICAgIFRleHR1cmVUeXBlcyA6IFRleHR1cmVUeXBlcyxcclxuICAgIFdyYXBUeXBlcyA6IFdyYXBUeXBlcyxcclxuICAgIFBsYXRmb3JtVHlwZXMgOiBQbGF0Zm9ybVR5cGVzLFxyXG4gICAgRGF0YUZpZWxkVHlwZXMgOiBEYXRhRmllbGRUeXBlLFxyXG4gICAgRGF0YUNoYW5uZWxPcmlnaW4gOiBEYXRhQ2hhbm5lbE9yaWdpblxyXG59O1xyXG4iLCJ2YXIgY29uZmlnID0gcmVxdWlyZShcIi4vZWxlbWVudHMuanNcIikuY29uZmlnO1xyXG52YXIgY2xhc3NJbmZvID0gcmVxdWlyZShcIi4vY29uZmlndXJhdGlvbi5qc1wiKS5jbGFzc0luZm87XHJcblxyXG52YXIgZG9jID0ge307XHJcbnZhciBuYXRpdmVHZXRFbGVtZW50QnlJZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkO1xyXG5kb2MuZ2V0RWxlbWVudEJ5SWQgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgdmFyIGVsZW0gPSBuYXRpdmVHZXRFbGVtZW50QnlJZC5jYWxsKHRoaXMsIGlkKTtcclxuICAgIGlmIChlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBlbGVtcyA9IHRoaXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpO1xyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gZWxlbXNbaV07XHJcbiAgICAgICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxudmFyIG5hdGl2ZUNyZWF0ZUVsZW1lbnROUyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUztcclxuZG9jLmNyZWF0ZUVsZW1lbnROUyA9IGZ1bmN0aW9uKG5zLCBuYW1lKSB7XHJcbiAgICB2YXIgciA9IG5hdGl2ZUNyZWF0ZUVsZW1lbnROUy5jYWxsKHRoaXMsIG5zLCBuYW1lKTtcclxuICAgIGlmIChucyA9PSBYTUwzRC54bWwzZE5TIHx8IGNsYXNzSW5mb1tuYW1lLnRvTG93ZXJDYXNlKCldKSB7XHJcbiAgICAgICAgY29uZmlnLmVsZW1lbnQocik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxudmFyIG5hdGl2ZUNyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50O1xyXG5kb2MuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIHZhciByID0gbmF0aXZlQ3JlYXRlRWxlbWVudC5jYWxsKHRoaXMsIG5hbWUpO1xyXG4gICAgaWYgKGNsYXNzSW5mb1tuYW1lLnRvTG93ZXJDYXNlKCldICkge1xyXG4gICAgICAgIGNvbmZpZy5lbGVtZW50KHIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5YTUwzRC5leHRlbmQod2luZG93LmRvY3VtZW50LCBkb2MpO1xyXG4iLCJ2YXIgZXZlbnRzID0gcmVxdWlyZShcIi4vbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgQ2xhc3NJbmZvID0gcmVxdWlyZShcIi4vY29uZmlndXJhdGlvbi5qc1wiKS5jbGFzc0luZm87XHJcbnJlcXVpcmUoXCIuLi91dGlscy9hcnJheS5qc1wiKTtcclxudmFyIFJlc291cmNlID0gcmVxdWlyZShcIi4uL2Jhc2UvcmVzb3VyY2VtYW5hZ2VyLmpzXCIpLlJlc291cmNlO1xyXG5cclxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSAod2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93Lk1vek11dGF0aW9uT2JzZXJ2ZXIpLFxyXG4gICAgbXV0T2JzZXJ2ZXI7XHJcblxyXG5pZihNdXRhdGlvbk9ic2VydmVyKXtcclxuICAgIG11dE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoaGFuZGxlTXV0YXRpb25zKTtcclxufSBlbHNlIHtcclxuICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiWE1MM0QgcmVxdWlyZXMgTXV0YXRpb25PYnNlcnZlcnMsIHdoaWNoIHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0LiBQbGVhc2UgY29uc2lkZXIgdXBncmFkaW5nIHRvIGEgbmV3ZXIgdmVyc2lvbi5cIik7XHJcbiAgICBtdXRPYnNlcnZlciA9IHtcclxuICAgICAgICB0YWtlUmVjb3JkczpmdW5jdGlvbigpe3JldHVybiBbXX0sXHJcbiAgICAgICAgb2JzZXJ2ZTogZnVuY3Rpb24oYSxiKSB7fVxyXG4gICAgfVxyXG59XHJcblxyXG5YTUwzRC5mbHVzaERPTUNoYW5nZXMgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIHJlY29yZHMgPSBtdXRPYnNlcnZlci50YWtlUmVjb3JkcygpO1xyXG4gICAgcmVjb3Jkcy5sZW5ndGggJiYgaGFuZGxlTXV0YXRpb25zKHJlY29yZHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gaGFuZGxlTXV0YXRpb25zKG11dGF0aW9ucykge1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIG11dGF0aW9uUmVjb3JkID0gbXV0YXRpb25zW2ldO1xyXG4gICAgICAgIGlmIChtdXRhdGlvblJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcclxuICAgICAgICAgICAgaGFuZGxlQXR0cmlidXRlQ2hhbmdlZChtdXRhdGlvblJlY29yZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtdXRhdGlvblJlY29yZC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xyXG4gICAgICAgICAgICBoYW5kbGVDaGlsZExpc3RDaGFuZ2VkKG11dGF0aW9uUmVjb3JkKTtcclxuICAgICAgICB9IGVsc2UgaWYobXV0YXRpb25SZWNvcmQudHlwZSA9PSAnY2hhcmFjdGVyRGF0YScpe1xyXG4gICAgICAgICAgICBoYW5kbGVDaGFyYWN0ZXJEYXRhQ2hhbmdlZChtdXRhdGlvblJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVDaGFyYWN0ZXJEYXRhQ2hhbmdlZChtdXRhdGlvbikge1xyXG4gICAgdmFyIHRhcmdldCA9IG11dGF0aW9uLnRhcmdldDtcclxuICAgIHdoaWxlKCF0YXJnZXQuX2NvbmZpZ3VyZWQgJiYgdGFyZ2V0LnBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcclxuICAgIH1cclxuICAgIHZhciBlbGVtZW50SGFuZGxlciA9IHRhcmdldC5fY29uZmlndXJlZDtcclxuICAgIGlmICghZWxlbWVudEhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgbiA9IG5ldyBldmVudHMuTm90aWZpY2F0aW9uV3JhcHBlcihtdXRhdGlvbiwgZXZlbnRzLlZBTFVFX01PRElGSUVELCB0YXJnZXQpO1xyXG4gICAgaWYgKGVsZW1lbnRIYW5kbGVyLmhhbmRsZXJzLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBlbGVtZW50SGFuZGxlci5oYW5kbGVycy52YWx1ZS5yZXNldFZhbHVlKGVsZW1lbnRIYW5kbGVyLnN0b3JhZ2UpO1xyXG4gICAgfVxyXG4gICAgZWxlbWVudEhhbmRsZXIubm90aWZ5KG4pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVDaGlsZExpc3RDaGFuZ2VkKG11dGF0aW9uKSB7XHJcbiAgICB2YXIgYWRkZWROb2RlcyA9IG11dGF0aW9uLmFkZGVkTm9kZXM7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYWRkZWROb2Rlc1tpXS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpe1xyXG4gICAgICAgICAgICAvLyBUaGlzIG1heSBoYXZlIGJlZW4gdGhlIHZhbHVlIG9mIGVnLiBhIGZsb2F0MyBlbGVtZW50LCB3ZSBzaG91bGQgdHJlYXQgaXQgYXMgYSBjaGFyYWN0ZXJEYXRhQ2hhbmdlZCBldmVudFxyXG4gICAgICAgICAgICBoYW5kbGVDaGFyYWN0ZXJEYXRhQ2hhbmdlZChtdXRhdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVOb2RlSW5zZXJ0ZWQoYWRkZWROb2Rlc1tpXSwgbXV0YXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZW1vdmVkTm9kZXMgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXM7XHJcbiAgICBmb3IgKHZhciBpPTA7IGkgPCByZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocmVtb3ZlZE5vZGVzW2ldLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSl7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBjaGFyYWN0ZXJEYXRhQ2hhbmdlZCBldmVudHMgd2VyZSBhbHJlYWR5IGhhbmRsZWQgaW4gYWRkZWROb2Rlc1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVOb2RlUmVtb3ZlZChyZW1vdmVkTm9kZXNbaV0sIG11dGF0aW9uKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlTm9kZUluc2VydGVkKG5vZGUsIG11dGF0aW9uKSB7XHJcbiAgICB2YXIgdGFyZ2V0SGFuZGxlciA9IG11dGF0aW9uLnRhcmdldC5fY29uZmlndXJlZDtcclxuICAgIGlmICghdGFyZ2V0SGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbmZpZy5lbGVtZW50KG5vZGUpO1xyXG4gICAgYWRkUmVjdXJzaXZlKG5vZGUpO1xyXG4gICAgdmFyIG4gPSBuZXcgZXZlbnRzLk5vdGlmaWNhdGlvbldyYXBwZXIobXV0YXRpb24sIGV2ZW50cy5OT0RFX0lOU0VSVEVELCBub2RlKTtcclxuICAgIHRhcmdldEhhbmRsZXIubm90aWZ5KG4pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVOb2RlUmVtb3ZlZChub2RlLCBtdXRhdGlvbikge1xyXG4gICAgdmFyIHRhcmdldEhhbmRsZXIgPSBtdXRhdGlvbi50YXJnZXQuX2NvbmZpZ3VyZWQ7XHJcbiAgICBpZiAoIXRhcmdldEhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgbiA9IG5ldyBldmVudHMuTm90aWZpY2F0aW9uV3JhcHBlcihtdXRhdGlvbiwgZXZlbnRzLk5PREVfUkVNT1ZFRCwgbm9kZSk7XHJcbiAgICB0YXJnZXRIYW5kbGVyLm5vdGlmeShuKTtcclxuICAgIGlmKG5vZGUuX2NvbmZpZ3VyZWQpIHtcclxuICAgICAgICBuLnR5cGUgPSBldmVudHMuVEhJU19SRU1PVkVEO1xyXG4gICAgICAgIHJlbW92ZVJlY3Vyc2l2ZShub2RlLCBuKTtcclxuICAgICAgICBub3RpZnlOb2RlSWRDaGFuZ2VSZWN1cnNpdmUobm9kZSk7XHJcbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKXtcclxuICAgICAgICAvLyBUaGlzIG1heSBoYXZlIGJlZW4gdGhlIHZhbHVlIG9mIGVnLiBhIGZsb2F0MyBlbGVtZW50LCB3ZSBzaG91bGQgYWxzbyB0cmVhdCBpdCBhcyBhIGNoYXJhY3RlckRhdGFDaGFuZ2VkIGV2ZW50XHJcbiAgICAgICAgaGFuZGxlQ2hhcmFjdGVyRGF0YUNoYW5nZWQobXV0YXRpb24pO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBub3RpZnlOb2RlSWRDaGFuZ2VSZWN1cnNpdmUoZWxlbWVudCl7XHJcbiAgICBSZXNvdXJjZS5ub3RpZnlOb2RlSWRDaGFuZ2UoZWxlbWVudCwgZWxlbWVudC5pZCwgbnVsbCk7XHJcbiAgICB2YXIgbiA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICB3aGlsZShuKSB7XHJcbiAgICAgICAgbm90aWZ5Tm9kZUlkQ2hhbmdlUmVjdXJzaXZlKG4pO1xyXG4gICAgICAgIG4gPSBuLm5leHRFbGVtZW50U2libGluZztcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlUmVjdXJzaXZlKGVsZW1lbnQsIGV2dCkge1xyXG4gICAgaWYoZWxlbWVudC5fY29uZmlndXJlZCkge1xyXG4gICAgICAgIGVsZW1lbnQuX2NvbmZpZ3VyZWQubm90aWZ5KGV2dCk7XHJcbiAgICAgICAgZWxlbWVudC5fY29uZmlndXJlZC5yZW1vdmUoZXZ0KTtcclxuICAgIH1cclxuICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICB3aGlsZShjaGlsZCkge1xyXG4gICAgICAgIHJlbW92ZVJlY3Vyc2l2ZShjaGlsZCwgZXZ0KTtcclxuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRFbGVtZW50U2libGluZztcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYWRkUmVjdXJzaXZlKGVsZW1lbnQpe1xyXG4gICAgdmFyIG4gPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xyXG4gICAgd2hpbGUobikge1xyXG4gICAgICAgIGFkZFJlY3Vyc2l2ZShuKTtcclxuICAgICAgICBuID0gbi5uZXh0RWxlbWVudFNpYmxpbmc7XHJcbiAgICB9XHJcbiAgICAvLyBXZSBjYWxsIHRoaXMgaGVyZSBpbiBhZGRpdGlvbiB0byBub2RlSW5zZXJ0ZWRJbnRvRG9jdW1lbnQsIHNpbmNlIHRoZSBsYXRlciBpcyBub3Qgc3VwcG9ydGVkIGJ5IEZpcmVmb3hcclxuICAgIFJlc291cmNlLm5vdGlmeU5vZGVJZENoYW5nZShlbGVtZW50LCBudWxsLCBlbGVtZW50LmlkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlQXR0cmlidXRlQ2hhbmdlZChtdXRhdGlvbikge1xyXG4gICAgdmFyIHRhcmdldCA9IG11dGF0aW9uLnRhcmdldDtcclxuICAgIHZhciBlbGVtZW50SGFuZGxlciA9IHRhcmdldC5fY29uZmlndXJlZDtcclxuICAgIGlmICghZWxlbWVudEhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgbm90aWZpZWQgPSBmYWxzZTtcclxuICAgIHZhciBhdHRyaWJ1dGVIYW5kbGVyID0gZWxlbWVudEhhbmRsZXIuaGFuZGxlcnNbbXV0YXRpb24uYXR0cmlidXRlTmFtZV0gfHwgZWxlbWVudEhhbmRsZXIuaGFuZGxlcnNbbXV0YXRpb24uYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpXTtcclxuICAgIGlmIChhdHRyaWJ1dGVIYW5kbGVyICYmIGF0dHJpYnV0ZUhhbmRsZXIuc2V0RnJvbUF0dHJpYnV0ZSkge1xyXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUobXV0YXRpb24uYXR0cmlidXRlTmFtZSk7XHJcbiAgICAgICAgbm90aWZpZWQgPSBhdHRyaWJ1dGVIYW5kbGVyLnNldEZyb21BdHRyaWJ1dGUobmV3VmFsdWUsIG11dGF0aW9uLm9sZFZhbHVlLCB0YXJnZXQsIGVsZW1lbnRIYW5kbGVyLnN0b3JhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghbm90aWZpZWQpIHtcclxuICAgICAgICB2YXIgbiA9IG5ldyBldmVudHMuTm90aWZpY2F0aW9uV3JhcHBlcihtdXRhdGlvbiwgZXZlbnRzLlZBTFVFX01PRElGSUVELCBtdXRhdGlvbi50YXJnZXQpO1xyXG4gICAgICAgIGVsZW1lbnRIYW5kbGVyLm5vdGlmeShuKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbnZhciBFbGVtZW50SGFuZGxlciA9IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgIGlmICghZWxlbSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW07XHJcbiAgICB0aGlzLmhhbmRsZXJzID0gbnVsbDtcclxuICAgIHRoaXMuc3RvcmFnZSA9IHt9O1xyXG4gICAgdGhpcy5hZGFwdGVycyA9IHt9O1xyXG4gICAgbXV0T2JzZXJ2ZXIub2JzZXJ2ZShlbGVtLCB7IGNoaWxkTGlzdDogdHJ1ZSwgIGF0dHJpYnV0ZXM6IHRydWUsIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlfSApO1xyXG5cclxufTtcclxuXHJcbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5yZWdpc3RlckF0dHJpYnV0ZXMgPSBmdW5jdGlvbihjb25maWcpIHtcclxuICAgIHZhciBlbGVtID0gdGhpcy5lbGVtZW50O1xyXG5cclxuICAgIHZhciBpc0hUTUwgPSAoZWxlbSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KTtcclxuICAgIHZhciBrZXlQcmVmaXggPSAoaXNIVE1MID8gXCJfaHRtbFwiIDogXCJfeG1sXCIpO1xyXG4gICAgdmFyIGhhbmRsZXJLZXkgPSBrZXlQcmVmaXggKyBcImhhbmRsZXJzXCIsXHJcbiAgICAgICAgcHJvdG9LZXkgPSBrZXlQcmVmaXggKyBcInByb3RvXCI7XHJcblxyXG4gICAgdmFyIGNhblByb3RvID0gISFlbGVtLl9fcHJvdG9fXztcclxuXHJcbiAgICBpZighY29uZmlnLl9jYWNoZSkgY29uZmlnLl9jYWNoZSA9IHt9O1xyXG5cclxuICAgIGlmKCFjb25maWcuX2NhY2hlW2hhbmRsZXJLZXldKXtcclxuICAgICAgICAvLyBDcmVhdGUgaGFuZGxlcnMgYW5kIHByb3RvdHlwZSBvbmx5IG9uY2UgcGVyIGNvbmZpZ3VyYXRpb25cclxuICAgICAgICB2YXIgcHJvdG87XHJcbiAgICAgICAgaWYoY2FuUHJvdG8pe1xyXG4gICAgICAgICAgICB2YXIgRiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBlbGVtLl9fcHJvdG9fXztcclxuICAgICAgICAgICAgcHJvdG8gPSBuZXcgRigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGhhbmRsZXJzID0ge307XHJcbiAgICAgICAgZm9yICggdmFyIHByb3AgaW4gY29uZmlnKSB7XHJcbiAgICAgICAgICAgIGlmKHByb3AgPT1cIl9jYWNoZVwiKSBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZ1twcm9wXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZihwcm90bykgZGVsZXRlIHByb3RvW3Byb3BdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ1twcm9wXS5hICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSBjb25maWdbcHJvcF0uaWQgfHwgcHJvcDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IG5ldyBjb25maWdbcHJvcF0uYShhdHRyTmFtZSwgY29uZmlnW3Byb3BdLnBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbaXNIVE1MID8gYXR0ck5hbWUudG9Mb3dlckNhc2UoKSA6IGF0dHJOYW1lXSA9IGhhbmRsZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocHJvdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgcHJvcCwgaGFuZGxlci5kZXNjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkNhbid0IGNvbmZpZ3VyZSBcIiArIGVsZW0ubm9kZU5hbWUgKyBcIjo6XCIgKyBwcm9wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZ1twcm9wXS5tICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihwcm90bykgcHJvdG9bcHJvcF0gPSBjb25maWdbcHJvcF0ubTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnW3Byb3BdLnAgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHByb3RvKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgcHJvcCwgY29uZmlnW3Byb3BdLnApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiQ2FuJ3QgY29uZmlndXJlIFwiICsgZWxlbS5ub2RlTmFtZSArIFwiOjpcIiArIHByb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfWVsc2VcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNhbid0IGNvbmZpZ3VyZSBcIiArIGVsZW0ubm9kZU5hbWUgKyBcIjo6XCIgKyBwcm9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25maWcuX2NhY2hlW2hhbmRsZXJLZXldID0gaGFuZGxlcnM7XHJcbiAgICAgICAgY29uZmlnLl9jYWNoZVtwcm90b0tleV0gPSBwcm90bztcclxuICAgIH1cclxuICAgIC8vIFNldCBhbmQgaW5pdGlhbGl6ZSBoYW5kbGVycyBmb3IgZWxlbWVudFxyXG4gICAgdGhpcy5oYW5kbGVycyA9IGNvbmZpZy5fY2FjaGVbaGFuZGxlcktleV07XHJcbiAgICBpZihjYW5Qcm90byl7XHJcbiAgICAgICAgZWxlbS5fX3Byb3RvX18gPSBjb25maWcuX2NhY2hlW3Byb3RvS2V5XTtcclxuICAgICAgICBmb3IgKCB2YXIgcHJvcCBpbiBjb25maWcpIHtcclxuICAgICAgICAgICAgaWYocHJvcCA9PVwiX2NhY2hlXCIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZihjb25maWdbcHJvcF0gJiYgY29uZmlnW3Byb3BdLmEgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSBjb25maWdbcHJvcF0uaWQgfHwgcHJvcDtcclxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyc1tpc0hUTUwgPyBhdHRyTmFtZS50b0xvd2VyQ2FzZSgpIDogYXR0ck5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci5pbml0ICYmIGhhbmRsZXIuaW5pdChlbGVtLCB0aGlzLnN0b3JhZ2UpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1bcHJvcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIGZvciAoIHZhciBwcm9wIGluIGNvbmZpZykge1xyXG4gICAgICAgICAgICBpZihwcm9wID09XCJfY2FjaGVcIikgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1bcHJvcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnW3Byb3BdLmEgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSBjb25maWdbcHJvcF0uaWQgfHwgcHJvcDtcclxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyc1tpc0hUTUwgPyBhdHRyTmFtZS50b0xvd2VyQ2FzZSgpIDogYXR0ck5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci5pbml0ICYmIGhhbmRsZXIuaW5pdChlbGVtLCB0aGlzLnN0b3JhZ2UpO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbSwgcHJvcCwgaGFuZGxlci5kZXNjKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiQ2FuJ3QgY29uZmlndXJlIFwiICsgZWxlbS5ub2RlTmFtZSArIFwiOjpcIiArIHByb3ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZSBpZiAoY29uZmlnW3Byb3BdLm0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbVtwcm9wXSA9IGNvbmZpZ1twcm9wXS5tO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZ1twcm9wXS5wICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW0sIHByb3AsIGNvbmZpZ1twcm9wXS5wKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiQ2FuJ3QgY29uZmlndXJlIFwiICsgZWxlbS5ub2RlTmFtZSArIFwiOjpcIiArIHByb3ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbGVtO1xyXG59O1xyXG5cclxuXHJcbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5yZWdpc3Rlck1peGVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICBtdXRPYnNlcnZlci5vYnNlcnZlKHRoaXMuZWxlbWVudCwgeyBjaGlsZExpc3Q6IHRydWUsICBhdHRyaWJ1dGVzOiB0cnVlLCBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0gKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gZXZ0XHJcbiAqL1xyXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUubm90aWZ5ID0gIGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5hZGFwdGVycztcclxuICAgIGZvcih2YXIgYSBpbiBhZGFwdGVycykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGFkYXB0ZXJzW2FdLm5vdGlmeUNoYW5nZWQoZXZ0KTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0V4Y2VwdGlvbihlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKlxyXG4gKiBHZXQgY2FsbGVkLCBpZiB0aGUgcmVsYXRlZCBub2RlIGdldHMgcmVtb3ZlZCBmcm9tIHRoZSBET01cclxuICovXHJcbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGZvcih2YXIgaCBpbiB0aGlzLmFkYXB0ZXJzKSB7XHJcbiAgICAgICAgdmFyIGFkYXB0ZXIgPSB0aGlzLmFkYXB0ZXJzW2hdO1xyXG4gICAgICAgIGlmKGFkYXB0ZXIub25EaXNwb3NlKVxyXG4gICAgICAgICAgICBhZGFwdGVyLm9uRGlzcG9zZSgpO1xyXG4gICAgICAgIGlmKGFkYXB0ZXIuY2xlYXJBZGFwdGVySGFuZGxlcylcclxuICAgICAgICAgICAgYWRhcHRlci5jbGVhckFkYXB0ZXJIYW5kbGVzKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFkYXB0ZXJzID0ge307XHJcbiAgICBmb3IodmFyIGggaW4gdGhpcy5oYW5kbGVycykge1xyXG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyc1toXTtcclxuICAgICAgICBpZihoYW5kbGVyLnJlbW92ZSlcclxuICAgICAgICAgICAgaGFuZGxlci5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBcIkVsZW1lbnRIYW5kbGVyIChcIit0aGlzLmVsZW1lbnQubm9kZU5hbWUgKyBcIiwgaWQ6IFwiK3RoaXMuZWxlbWVudC5pZCtcIilcIjtcclxufTtcclxuXHJcbnZhciBkZWxlZ2F0ZVByb3BlcnRpZXMgPSBbXCJjbGllbnRIZWlnaHRcIiwgXCJjbGllbnRMZWZ0XCIsIFwiY2xpZW50VG9wXCIsIFwiY2xpZW50V2lkdGhcIixcclxuICAgIFwib2Zmc2V0SGVpZ2h0XCIsIFwib2Zmc2V0TGVmdFwiLCBcIm9mZnNldFRvcFwiLCBcIm9mZnNldFdpZHRoXCJdO1xyXG5mdW5jdGlvbiBkZWxlZ2F0ZVByb3AobmFtZSwgZWxlbSwgY2FudmFzKSB7XHJcbiAgICB2YXIgZGVzYyA9IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhc1tuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbSwgbmFtZSwgZGVzYyk7XHJcbiAgICB9IGNhdGNoIChlKXtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiQ2FuJ3QgY29uZmlndXJlIFwiICsgZWxlbS5ub2RlTmFtZSArIFwiOjpcIiArIG5hbWUpO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgWE1MM0RIYW5kbGVyID0gZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgRWxlbWVudEhhbmRsZXIuY2FsbCh0aGlzLCBlbGVtKTtcclxuICAgIHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgIGMud2lkdGggPSA4MDA7XHJcbiAgICBjLmhlaWdodCA9IDYwMDtcclxuICAgIHRoaXMuY2FudmFzID0gYztcclxuXHJcbiAgICBmb3IodmFyIGkgaW4gZGVsZWdhdGVQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgZGVsZWdhdGVQcm9wKGRlbGVnYXRlUHJvcGVydGllc1tpXSwgZWxlbSwgYyk7XHJcbiAgICB9XHJcblxyXG4gICAgZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIH07XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhYTUwzREhhbmRsZXIsIEVsZW1lbnRIYW5kbGVyKTtcclxuXHJcblxyXG52YXIgY29uZmlnID0ge307XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cclxuICovXHJcbmNvbmZpZy5lbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgaWYgKGVsZW1lbnQuX2NvbmZpZ3VyZWQgPT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICB2YXIgY2xhc3NJbmZvID0gQ2xhc3NJbmZvW2VsZW1lbnQubG9jYWxOYW1lXTtcclxuICAgICAgICBpZiAoY2xhc3NJbmZvID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nSW5mbyhcIlVucmVjb2duaXNlZCBlbGVtZW50IFwiICsgZWxlbWVudC5sb2NhbE5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuX2NvbmZpZ3VyZWQgPSBlbGVtZW50LmxvY2FsTmFtZSA9PSBcInhtbDNkXCIgP1xyXG4gICAgICAgICAgICAgICAgbmV3IFhNTDNESGFuZGxlcihlbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgOiBuZXcgRWxlbWVudEhhbmRsZXIoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuX2NvbmZpZ3VyZWQucmVnaXN0ZXJBdHRyaWJ1dGVzKGNsYXNzSW5mbyk7XHJcbiAgICAgICAgICAgIC8vIEZpeCBkaWZmZXJlbmNlIGluIEZpcmVmb3ggKHVuZGVmaW5lZCkgYW5kIENocm9tZSAobnVsbClcclxuICAgICAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3R5bGUgPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoKGUpe1xyXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCB0aHJvd3MgZXhjZXB0aW9uIGhlcmUuLi5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG4gPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xyXG5cclxuICAgICAgICAgICAgUmVzb3VyY2Uubm90aWZ5Tm9kZUlkQ2hhbmdlKGVsZW1lbnQsIG51bGwsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaWRcIikpO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUobikge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLmVsZW1lbnQobik7XHJcbiAgICAgICAgICAgICAgICBuID0gbi5uZXh0RWxlbWVudFNpYmxpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cclxuICovXHJcbmNvbmZpZy5jb25maWd1cmUgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xyXG4gICAgICAgIEFycmF5LmZvckVhY2goZWxlbWVudCwgZnVuY3Rpb24oZWwpIHtcclxuICAgICAgICAgICAgY29uZmlnLmVsZW1lbnQoZWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25maWcuZWxlbWVudChlbGVtZW50KTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEVsZW1lbnRIYW5kbGVyIDogRWxlbWVudEhhbmRsZXIsXHJcbiAgICBYTUwzREhhbmRsZXIgOiBYTUwzREhhbmRsZXIsXHJcbiAgICBjb25maWcgOiBjb25maWdcclxufTtcclxuIiwidmFyIFJlc291cmNlID0gcmVxdWlyZShcIi4uL2Jhc2UvcmVzb3VyY2VtYW5hZ2VyLmpzXCIpLlJlc291cmNlO1xyXG52YXIgc2VuZEFkYXB0ZXJFdmVudCA9IHJlcXVpcmUoXCIuLi91dGlscy9taXNjLmpzXCIpLnNlbmRBZGFwdGVyRXZlbnQ7XHJcbnZhciBjYWxsQWRhcHRlckZ1bmMgPSByZXF1aXJlKFwiLi4vdXRpbHMvbWlzYy5qc1wiKS5jYWxsQWRhcHRlckZ1bmM7XHJcblxyXG52YXIgbWV0aG9kcyA9IHt9O1xyXG5cclxubWV0aG9kcy54bWwzZEdldEVsZW1lbnRCeVJheSA9IGZ1bmN0aW9uKHJheSwgaGl0UG9pbnQsIGhpdE5vcm1hbCkge1xyXG4gICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRFbGVtZW50QnlSYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJzW2FkYXB0ZXJdLmdldEVsZW1lbnRCeVJheShyYXksIGhpdFBvaW50LCBoaXROb3JtYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxubWV0aG9kcy52aWV3R2V0RGlyZWN0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbi5yb3RhdGVWZWMzKG5ldyB3aW5kb3cuWE1MM0RWZWMzKDAsIDAsIC0xKSk7XHJcbn07XHJcblxyXG5tZXRob2RzLnZpZXdTZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvcztcclxufTtcclxuXHJcbnZhciB0bXBYID0gWE1MM0QubWF0aC52ZWMzLmNyZWF0ZSgpO1xyXG52YXIgdG1wWSA9IFhNTDNELm1hdGgudmVjMy5jcmVhdGUoKTtcclxudmFyIHRtcFogPSBYTUwzRC5tYXRoLnZlYzMuY3JlYXRlKCk7XHJcblxyXG5tZXRob2RzLnZpZXdTZXREaXJlY3Rpb24gPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcclxuICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCBuZXcgd2luZG93LlhNTDNEVmVjMygwLDAsLTEpO1xyXG4gICAgZGlyZWN0aW9uID0gZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgIHZhciB1cCA9IHRoaXMub3JpZW50YXRpb24ucm90YXRlVmVjMyhuZXcgd2luZG93LlhNTDNEVmVjMygwLDEsMCkpO1xyXG4gICAgdXAgPSB1cC5ub3JtYWxpemUoKTtcclxuXHJcbiAgICBYTUwzRC5tYXRoLnZlYzMuY3Jvc3ModG1wWCxkaXJlY3Rpb24uX2RhdGEsdXAuX2RhdGEpO1xyXG4gICAgaWYoIVhNTDNELm1hdGgudmVjMy5sZW5ndGgodG1wWCkpIHtcclxuICAgICAgICAgICAgdG1wWCA9IHRoaXMub3JpZW50YXRpb24ucm90YXRlVmVjMyhuZXcgd2luZG93LlhNTDNEVmVjMygxLDAsMCkpLl9kYXRhO1xyXG4gICAgfVxyXG4gICAgWE1MM0QubWF0aC52ZWMzLmNyb3NzKHRtcFksdG1wWCxkaXJlY3Rpb24uX2RhdGEpO1xyXG4gICAgWE1MM0QubWF0aC52ZWMzLm5lZ2F0ZSh0bXBaLGRpcmVjdGlvbi5fZGF0YSk7XHJcblxyXG4gICAgdmFyIHEgPSBYTUwzRC5tYXRoLnF1YXQuY3JlYXRlKCk7XHJcbiAgICBYTUwzRC5tYXRoLnF1YXQuc2V0RnJvbUJhc2lzKHRtcFgsIHRtcFksIHRtcFosIHEpO1xyXG4gICAgdGhpcy5vcmllbnRhdGlvbi5fc2V0UXVhdGVybmlvbihxKTtcclxufTtcclxuXHJcbm1ldGhvZHMudmlld1NldFVwVmVjdG9yID0gZnVuY3Rpb24odXApIHtcclxuICAgIHVwID0gdXAgfHwgbmV3IHdpbmRvdy5YTUwzRFZlYzMoMCwxLDApO1xyXG4gICAgdXAgPSB1cC5ub3JtYWxpemUoKTtcclxuXHJcbiAgICB2YXIgciA9IG5ldyB3aW5kb3cuWE1MM0RSb3RhdGlvbigpO1xyXG4gICAgci5zZXRSb3RhdGlvbihuZXcgd2luZG93LlhNTDNEVmVjMygwLDEsMCksdXApO1xyXG4gICAgciA9IHRoaXMub3JpZW50YXRpb24ubXVsdGlwbHkocik7XHJcbiAgICByID0gci5ub3JtYWxpemUoKTtcclxuICAgIHRoaXMub3JpZW50YXRpb24uc2V0KHIpO1xyXG59O1xyXG5cclxubWV0aG9kcy52aWV3R2V0VXBWZWN0b3IgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uLnJvdGF0ZVZlYzMobmV3IHdpbmRvdy5YTUwzRFZlYzMoMCwgMSwgMCkpO1xyXG59O1xyXG5cclxubWV0aG9kcy52aWV3TG9va0F0ID0gZnVuY3Rpb24ocG9pbnQpIHtcclxuICAgIHRoaXMuc2V0RGlyZWN0aW9uKHBvaW50LnN1YnRyYWN0KHRoaXMucG9zaXRpb24pKTtcclxufTtcclxuXHJcbm1ldGhvZHMudmlld0dldFZpZXdNYXRyaXggPSBmdW5jdGlvbigpIHtcclxuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5fY29uZmlndXJlZC5hZGFwdGVycyB8fCB7fTtcclxuICAgIGZvciAoIHZhciBhZGFwdGVyIGluIGFkYXB0ZXJzKSB7XHJcbiAgICAgICAgaWYgKGFkYXB0ZXJzW2FkYXB0ZXJdLmdldFZpZXdNYXRyaXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJzW2FkYXB0ZXJdLmdldFZpZXdNYXRyaXgoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBGYWxsYmFjayBpbXBsZW1lbnRhdGlvblxyXG4gICAgdmFyIHAgPSB0aGlzLnBvc2l0aW9uO1xyXG4gICAgdmFyIHIgPSB0aGlzLm9yaWVudGF0aW9uO1xyXG4gICAgdmFyIGEgPSByLmF4aXM7XHJcbiAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUwzRE1hdHJpeCgpLnRyYW5zbGF0ZShwLngsIHAueSwgcC56KS5yb3RhdGVBeGlzQW5nbGUoYS54LCBhLnksIGEueiwgci5hbmdsZSkuaW52ZXJzZSgpO1xyXG59O1xyXG5cclxubWV0aG9kcy54bWwzZEdldEVsZW1lbnRCeVBvaW50ID0gZnVuY3Rpb24oeCwgeSwgaGl0UG9pbnQsIGhpdE5vcm1hbCkge1xyXG4gICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRFbGVtZW50QnlQb2ludCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0RWxlbWVudEJ5UG9pbnQoeCwgeSwgaGl0UG9pbnQsIGhpdE5vcm1hbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5tZXRob2RzLnhtbDNkR2VuZXJhdGVSYXkgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZW5lcmF0ZVJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2VuZXJhdGVSYXkoeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MM0RSYXkoKTtcclxufTtcclxuXHJcbm1ldGhvZHMuZGVwcmVjYXRlZEdldEJvdW5kaW5nQm94V29ybGQgPSBmdW5jdGlvbigpIHtcclxuICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJnZXRCb3VuZGluZ0JveCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiEgUGxlYXNlIHVzZSBnZXRMb2NhbEJvdW5kaW5nQm94IG9yIGdldFdvcmxkQm91bmRpbmdCb3ggaW5zdGVhZC5cIik7XHJcbiAgICByZXR1cm4gbWV0aG9kcy5nZXRXb3JsZEJvdW5kaW5nQm94LmNhbGwodGhpcyk7XHJcbn07XHJcblxyXG5tZXRob2RzLmRlcHJlY2F0ZWRHZXRCb3VuZGluZ0JveExvY2FsID0gZnVuY3Rpb24oKSB7XHJcbiAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiZ2V0Qm91bmRpbmdCb3ggaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24hIFBsZWFzZSB1c2UgZ2V0TG9jYWxCb3VuZGluZ0JveCBvciBnZXRXb3JsZEJvdW5kaW5nQm94IGluc3RlYWQuXCIpO1xyXG4gICAgcmV0dXJuIG1ldGhvZHMuZ2V0TG9jYWxCb3VuZGluZ0JveC5jYWxsKHRoaXMpO1xyXG59O1xyXG5cclxubWV0aG9kcy5ncm91cEdldExvY2FsTWF0cml4ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcclxuICAgIHZhciBhZGFwdGVycyA9IHRoaXMuX2NvbmZpZ3VyZWQuYWRhcHRlcnMgfHwge307XHJcbiAgICBmb3IgKCB2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRMb2NhbE1hdHJpeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0TG9jYWxNYXRyaXgoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUwzRE1hdHJpeCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIHJldHVybiB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBvd25pbmcgc3BhY2UgaW4gd29ybGQgc3BhY2VcclxuICovXHJcbm1ldGhvZHMuZ2V0V29ybGRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRXb3JsZEJvdW5kaW5nQm94KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhZGFwdGVyc1thZGFwdGVyXS5nZXRXb3JsZEJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MM0RCb3goKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgb3duaW5nIHNwYWNlIGluIGxvY2FsIHNwYWNlIChvYmplY3QgQkIpXHJcbiAqL1xyXG5tZXRob2RzLmdldExvY2FsQm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcclxuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5fY29uZmlndXJlZC5hZGFwdGVycyB8fCB7fTtcclxuICAgIGZvciAodmFyIGFkYXB0ZXIgaW4gYWRhcHRlcnMpIHtcclxuICAgICAgICBpZiAoYWRhcHRlcnNbYWRhcHRlcl0uZ2V0TG9jYWxCb3VuZGluZ0JveCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0TG9jYWxCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgd2luZG93LlhNTDNEQm94KCk7XHJcbn07XHJcblxyXG5tZXRob2RzLnhtbDNkR2V0UmVuZGVySW50ZXJmYWNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcclxuICAgIHZhciBhZGFwdGVycyA9IHRoaXMuX2NvbmZpZ3VyZWQuYWRhcHRlcnMgfHwge307XHJcbiAgICBmb3IgKCB2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRSZW5kZXJJbnRlcmZhY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJzW2FkYXB0ZXJdLmdldFJlbmRlckludGVyZmFjZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7fTtcclxufTtcclxuXHJcblxyXG5tZXRob2RzLlhNTDNER3JhcGhUeXBlR2V0V29ybGRNYXRyaXggPSBmdW5jdGlvbigpIHtcclxuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5fY29uZmlndXJlZC5hZGFwdGVycyB8fCB7fTtcclxuICAgIGZvciAodmFyIGFkYXB0ZXIgaW4gYWRhcHRlcnMpIHtcclxuICAgICAgICBpZiAoYWRhcHRlcnNbYWRhcHRlcl0uZ2V0V29ybGRNYXRyaXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJzW2FkYXB0ZXJdLmdldFdvcmxkTWF0cml4KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MM0RNYXRyaXgoKTtcclxufTtcclxuXHJcbm1ldGhvZHMudmlkZW9QbGF5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBzZW5kQWRhcHRlckV2ZW50KHRoaXMsIHtwbGF5OiBbXX0pO1xyXG59O1xyXG5cclxubWV0aG9kcy52aWRlb1BhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICBzZW5kQWRhcHRlckV2ZW50KHRoaXMsIHtwYXVzZTogW119KTtcclxufTtcclxuXHJcbm1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldE91dHB1dE5hbWVzID1cclxubWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldE91dHB1dE5hbWVzID1cclxubWV0aG9kcy5tZXNoR2V0T3V0cHV0TmFtZXMgPSBmdW5jdGlvbigpIHtcclxuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgdmFyIGRhdGFBZGFwdGVyID0gUmVzb3VyY2UuZ2V0QWRhcHRlcih0aGlzLCBcImRhdGFcIik7XHJcbiAgICBpZihkYXRhQWRhcHRlcil7XHJcbiAgICAgICAgcmV0dXJuIGRhdGFBZGFwdGVyLmdldE91dHB1dE5hbWVzKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbm1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldFJlc3VsdCA9XHJcbm1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRSZXN1bHQgPVxyXG5tZXRob2RzLm1lc2hHZXRSZXN1bHQgPSBmdW5jdGlvbihmaWx0ZXIpIHtcclxuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgdmFyIGRhdGFBZGFwdGVyID0gUmVzb3VyY2UuZ2V0QWRhcHRlcih0aGlzLCBcImRhdGFcIik7XHJcbiAgICBpZihkYXRhQWRhcHRlcil7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGFBZGFwdGVyLmdldENvbXB1dGVSZXN1bHQoZmlsdGVyKTtcclxuICAgICAgICBpZighcmVzdWx0KSByZXR1cm4gbnVsbDtcclxuICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUwzRERhdGFSZXN1bHQocmVzdWx0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxubWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0T3V0cHV0Q2hhbm5lbEluZm8gPVxyXG4gICAgbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldE91dHB1dENoYW5uZWxJbmZvID1cclxuICAgICAgICBtZXRob2RzLm1lc2hHZXRPdXRwdXRDaGFubmVsSW5mbyA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgICAgICB2YXIgZGF0YUFkYXB0ZXIgPSBSZXNvdXJjZS5nZXRBZGFwdGVyKHRoaXMsIFwiZGF0YVwiKTtcclxuICAgICAgICAgICAgaWYgKGRhdGFBZGFwdGVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZGF0YUFkYXB0ZXIuZ2V0T3V0cHV0Q2hhbm5lbEluZm8obmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUwzRERhdGFDaGFubmVsSW5mbyhyZXN1bHQudHlwZSwgcmVzdWx0Lm9yaWdpbiwgcmVzdWx0Lm9yaWdpbmFsTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2VxTGVuZ3RoLCByZXN1bHQuc2VxTWluS2V5LCByZXN1bHQuc2VxTWF4S2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxubWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0Q29tcHV0ZUluZm8gPVxyXG4gICAgbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldENvbXB1dGVJbmZvID1cclxuICAgICAgICBtZXRob2RzLm1lc2hHZXRDb21wdXRlSW5mbyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKHRoaXMubm9kZU5hbWUgKyBcIjo6Z2V0Q29tcHV0ZUluZm8gaXMgbm90IGltcGxlbWV0ZWQgeWV0LlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbm1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldFByb3RvSW5mbyA9XHJcbiAgICBtZXRob2RzLlhNTDNEU2hhZGVyUHJvdmlkZXJUeXBlR2V0UHJvdG9JbmZvID1cclxuICAgICAgICBtZXRob2RzLm1lc2hHZXRQcm90b0luZm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcih0aGlzLm5vZGVOYW1lICsgXCI6OmdldFByb3RvSW5mbyBpcyBub3QgaW1wbGVtZXRlZCB5ZXQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxubWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlSXNPdXRwdXRDb25uZWN0ZWQgPVxyXG4gICAgbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUlzT3V0cHV0Q29ubmVjdGVkID1cclxuICAgICAgICBtZXRob2RzLm1lc2hJc091dHB1dENvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKHRoaXMubm9kZU5hbWUgKyBcIjo6aXNPdXRwdXRDb25uZWN0ZWQgaXMgbm90IGltcGxlbWV0ZWQgeWV0LlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuZnVuY3Rpb24gY3JlYXRlVmFsdWVzKHJlc3VsdCwgbmFtZXMpIHtcclxuICAgIHZhciB2YWx1ZXMgPSB7fTtcclxuICAgIGZvciAodmFyIGkgaW4gbmFtZXMpIHtcclxuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xyXG4gICAgICAgIHZhciBkYXRhID0gcmVzdWx0LmdldE91dHB1dERhdGEobmFtZSkgJiYgcmVzdWx0LmdldE91dHB1dERhdGEobmFtZSkuZ2V0VmFsdWUoKTtcclxuICAgICAgICBpZiAoZGF0YSlcclxuICAgICAgICAgICAgdmFsdWVzW25hbWVdID0gZGF0YTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbn1cclxuXHJcbi8qKiBSZWdpc3RlciBkYXRhIGxpc3RlbmVyIGZvciBkYXRhIGZpZWxkcyBzcGVjaWZpZWQgYnkgbmFtZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBuYW1lcyAgIHNpbmdsZSBuYW1lIG9yIGFycmF5IG9mIG5hbWVzIHRoYXQgYXJlIG1vbml0b3JlZC5cclxuICogQHBhcmFtIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gc2VsZWN0ZWQgZGF0YSBhcmUgY2hhbmdlZC5cclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbm1ldGhvZHMuZGF0YUFkZE91dHB1dEZpZWxkTGlzdGVuZXIgPSBmdW5jdGlvbihuYW1lcywgY2FsbGJhY2spIHtcclxuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgaWYgKCFuYW1lcylcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgLy8gY2hlY2sgaWYgbmFtZXMgaXMgYSBzaW5nbGUgc3RyaW5nLCBhbmQgY29udmVydCBpdCB0byBhcnJheSB0aGVuXHJcbiAgICB2YXIgdHlwZU9mTmFtZXMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmFtZXMpLnNsaWNlKDgsIC0xKTtcclxuICAgIGlmICh0eXBlT2ZOYW1lcyA9PT0gXCJTdHJpbmdcIikge1xyXG4gICAgICAgIG5hbWVzID0gW25hbWVzXTtcclxuICAgIH1cclxuICAgIGlmIChuYW1lcy5sZW5ndGggPT0gMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgdmFyIHJlcXVlc3QgPSBjYWxsQWRhcHRlckZ1bmModGhpcywge1xyXG4gICAgICAgIGdldENvbXB1dGVSZXF1ZXN0IDogW25hbWVzLCBmdW5jdGlvbihyZXF1ZXN0LCBjaGFuZ2VUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGNyZWF0ZVZhbHVlcyhyZXF1ZXN0LmdldFJlc3VsdCgpLCBuYW1lcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBdfSk7XHJcbiAgICBpZiAocmVxdWVzdC5sZW5ndGggPT0gMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVxdWVzdFswXS5nZXRSZXN1bHQoKTtcclxuICAgIHZhciB2YWx1ZXMgPSBjcmVhdGVWYWx1ZXMocmVzdWx0LCBuYW1lcyk7XHJcbiAgICBpZiAoT2JqZWN0LmtleXModmFsdWVzKS5sZW5ndGgpXHJcbiAgICAgICAgY2FsbGJhY2sodmFsdWVzKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxubWV0aG9kcy5YTUwzRERhdGFTb3VyY2VUeXBlU2V0U2NyaXB0VmFsdWUgPSBmdW5jdGlvbihkYXRhKXtcclxuICAgIHZhciBjb25maWdEYXRhID0gdGhpcy5fY29uZmlndXJlZDtcclxuXHJcbiAgICBpZighY29uZmlnRGF0YSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgaWYodGhpcy50ZXh0Q29udGVudCAhPSBcIlt2YWx1ZSBzZXQgYnkgc2NyaXB0XVwiKVxyXG4gICAgICAgIHRoaXMudGV4dENvbnRlbnQgPSBcIlt2YWx1ZSBzZXQgYnkgc2NyaXB0XVwiO1xyXG4gICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICBjb25maWdEYXRhLnNjcmlwdFZhbHVlID0gZGF0YTtcclxuXHJcbiAgICB2YXIgZGF0YUFkYXB0ZXIgPSBSZXNvdXJjZS5nZXRBZGFwdGVyKHRoaXMsIFwiZGF0YVwiKTtcclxuICAgIGlmKGRhdGFBZGFwdGVyKVxyXG4gICAgICAgIGRhdGFBZGFwdGVyLnNldFNjcmlwdFZhbHVlKGRhdGEpO1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbWV0aG9kczsiLCJcclxuLyoqXHJcbiAqIFR5cGVzIG9mIGNoYW5nZSBldmVudHNcclxuICogQGVudW0ge251bWJlcn1cclxuICovXHJcbnZhciBldmVudHMgPSB7XHJcbiAgICAgIE5PREVfSU5TRVJURUQ6IDAsXHJcbiAgICAgIFZBTFVFX01PRElGSUVEOiAgMSxcclxuICAgICAgTk9ERV9SRU1PVkVEOiAyLFxyXG4gICAgICBUSElTX1JFTU9WRUQ6IDMsXHJcbiAgICAgIEFEQVBURVJfSEFORExFX0NIQU5HRUQ6IDQsXHJcbiAgICAgIEFEQVBURVJfVkFMVUVfQ0hBTkdFRDogNVxyXG59O1xyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vL0NsYXNzIE5vdGlmaWNhdGlvblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmV2ZW50cy5Ob3RpZmljYXRpb24gPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG59O1xyXG5ldmVudHMuTm90aWZpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFwiTm90aWZpY2F0aW9uICh0eXBlOlwiICsgdGhpcy50eXBlICsgXCIpXCI7XHJcbn07XHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuZXZlbnRzLk5vdGlmaWNhdGlvbldyYXBwZXIgPSBmdW5jdGlvbihtdXRhdGlvbiwgdHlwZSwgYWZmZWN0ZWROb2RlKSB7XHJcbiAgICB0aGlzLm11dGF0aW9uID0gbXV0YXRpb247XHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgdGhpcy5hZmZlY3RlZE5vZGUgPSBhZmZlY3RlZE5vZGU7XHJcbn07XHJcblhNTDNELmNyZWF0ZUNsYXNzKGV2ZW50cy5Ob3RpZmljYXRpb25XcmFwcGVyLCBldmVudHMuTm90aWZpY2F0aW9uKTtcclxuZXZlbnRzLk5vdGlmaWNhdGlvbldyYXBwZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gXCJOb3RpZmljYXRpb25XcmFwcGVyICh0eXBlOlwiICsgdGhpcy50eXBlICsgXCIsIHdyYXBwZWQ6IFwiKyB0aGlzLm11dGF0aW9uICtcIilcIjtcclxufTtcclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0FkYXB0ZXJIYW5kbGV9IGhhbmRsZVxyXG4gKiBAcGFyYW0ge2ludH0gdHlwZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmV2ZW50cy5BZGFwdGVySGFuZGxlTm90aWZpY2F0aW9uID0gZnVuY3Rpb24gKGhhbmRsZSwgdHlwZSkge1xyXG4gICAgdGhpcy5hZGFwdGVySGFuZGxlID0gaGFuZGxlO1xyXG4gICAgdGhpcy50eXBlID0gdHlwZTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoZXZlbnRzLkFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24sIGV2ZW50cy5Ob3RpZmljYXRpb24pO1xyXG5ldmVudHMuQWRhcHRlckhhbmRsZU5vdGlmaWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gXCJBZGFwdGVySGFuZGxlTm90aWZpY2F0aW9uICh0eXBlOlwiICsgdGhpcy50eXBlICsgXCIpXCI7XHJcbn07XHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbmV2ZW50cy5Db25uZWN0ZWRBZGFwdGVyTm90aWZpY2F0aW9uID0gZnVuY3Rpb24oYWRhcHRlckhhbmRsZU5vdGlmaWNhdGlvbiwga2V5KSB7XHJcbiAgICB0aGlzLmFkYXB0ZXIgPSBhZGFwdGVySGFuZGxlTm90aWZpY2F0aW9uLmFkYXB0ZXJIYW5kbGUuZ2V0QWRhcHRlcigpO1xyXG4gICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICB0aGlzLnVybCA9IGFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24uYWRhcHRlckhhbmRsZS51cmw7XHJcbiAgICB0aGlzLnR5cGUgPSBhZGFwdGVySGFuZGxlTm90aWZpY2F0aW9uLnR5cGU7XHJcbiAgICB0aGlzLmhhbmRsZVN0YXR1cyA9IGFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24uYWRhcHRlckhhbmRsZS5zdGF0dXM7XHJcbn07XHJcblhNTDNELmNyZWF0ZUNsYXNzKGV2ZW50cy5Db25uZWN0ZWRBZGFwdGVyTm90aWZpY2F0aW9uLCBldmVudHMuTm90aWZpY2F0aW9uKTtcclxuZXZlbnRzLkNvbm5lY3RlZEFkYXB0ZXJOb3RpZmljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gXCJDb25uZWN0ZWRBZGFwdGVyTm90aWZpY2F0aW9uICh0eXBlOlwiICsgdGhpcy50eXBlICsgXCIsIGtleTogXCIgKyB0aGlzLmtleSArIFwiKVwiO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBldmVudHM7IiwidmFyIHByb3BlcnRpZXMgPSB7fTtcclxuXHJcbnByb3BlcnRpZXMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUNvbXBsZXRlID0ge1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgIHZhciBhZGFwdGVycyA9IHRoaXMuX2NvbmZpZ3VyZWQuYWRhcHRlcnMgfHwge307XHJcbiAgICAgICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgICAgICBpZiAoYWRhcHRlcnNbYWRhcHRlcl0uZ2V0RGF0YUNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0RGF0YUNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuICAgIHNldDogZnVuY3Rpb24oKXt9XHJcbn07XHJcblxyXG5wcm9wZXJ0aWVzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVQcm9ncmVzc0xldmVsID0ge1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgIHZhciBhZGFwdGVycyA9IHRoaXMuX2NvbmZpZ3VyZWQuYWRhcHRlcnMgfHwge307XHJcbiAgICAgICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgICAgICBpZiAoYWRhcHRlcnNbYWRhcHRlcl0uZ2V0RGF0YVByb2dyZXNzTGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdGVyc1thZGFwdGVyXS5nZXREYXRhUHJvZ3Jlc3NMZXZlbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKCl7fVxyXG59O1xyXG5cclxucHJvcGVydGllcy5Bc3NldENvbXBsZXRlID0ge1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgIHZhciBhZGFwdGVycyA9IHRoaXMuX2NvbmZpZ3VyZWQuYWRhcHRlcnMgfHwge307XHJcbiAgICAgICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgICAgICBpZiAoYWRhcHRlcnNbYWRhcHRlcl0uZ2V0QXNzZXRDb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJzW2FkYXB0ZXJdLmdldEFzc2V0Q29tcGxldGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbigpe31cclxufTtcclxuXHJcblxyXG5wcm9wZXJ0aWVzLkFzc2V0UHJvZ3Jlc3NMZXZlbCA9IHtcclxuICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcclxuICAgICAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGFkYXB0ZXIgaW4gYWRhcHRlcnMpIHtcclxuICAgICAgICAgICAgaWYgKGFkYXB0ZXJzW2FkYXB0ZXJdLmdldEFzc2V0UHJvZ3Jlc3NMZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJzW2FkYXB0ZXJdLmdldEFzc2V0UHJvZ3Jlc3NMZXZlbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKCl7fVxyXG59O1xyXG5cclxucHJvcGVydGllcy54bWwzZENvbXBsZXRlID0ge1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgIHZhciBhZGFwdGVycyA9IHRoaXMuX2NvbmZpZ3VyZWQuYWRhcHRlcnMgfHwge307XHJcbiAgICAgICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgICAgICBpZiAoYWRhcHRlcnNbYWRhcHRlcl0uZ2V0Q29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdGVyc1thZGFwdGVyXS5nZXRDb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKCl7fVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJ0aWVzO1xyXG4iLCIoZnVuY3Rpb24gKG1vZHVsZSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIEFuIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggaW4gdGhlIHN0eWxlIG9mIGdsTWF0cml4XHJcbiAgICAgKiBAbmFtZSBiYm94XHJcbiAgICAgKi9cclxuICAgIHZhciBiYm94ID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSBib3VuZGluZyBib3hcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7YmJveH0gYSBuZXcgZW1wdHkgYm91bmRpbmcgYm94XHJcbiAgICAgKi9cclxuICAgIGJib3guY3JlYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDYpO1xyXG4gICAgICAgIG91dFswXSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgb3V0WzFdID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBvdXRbMl0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIG91dFszXSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIG91dFs0XSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIG91dFs1XSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGJib3guY2xvbmUgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDYpO1xyXG4gICAgICAgIG91dFswXSA9IGFbMF07XHJcbiAgICAgICAgb3V0WzFdID0gYVsxXTtcclxuICAgICAgICBvdXRbMl0gPSBhWzJdO1xyXG4gICAgICAgIG91dFszXSA9IGFbM107XHJcbiAgICAgICAgb3V0WzRdID0gYVs0XTtcclxuICAgICAgICBvdXRbNV0gPSBhWzVdO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGJib3guY29weSA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcclxuICAgICAgICBvdXRbMF0gPSBhWzBdO1xyXG4gICAgICAgIG91dFsxXSA9IGFbMV07XHJcbiAgICAgICAgb3V0WzJdID0gYVsyXTtcclxuICAgICAgICBvdXRbM10gPSBhWzNdO1xyXG4gICAgICAgIG91dFs0XSA9IGFbNF07XHJcbiAgICAgICAgb3V0WzVdID0gYVs1XTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuXHJcbiAgICBiYm94LmNvcHlNaW4gPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcclxuICAgICAgICB0YXJnZXRbMF0gPSBzb3VyY2VbMF07XHJcbiAgICAgICAgdGFyZ2V0WzFdID0gc291cmNlWzFdO1xyXG4gICAgICAgIHRhcmdldFsyXSA9IHNvdXJjZVsyXTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfTtcclxuXHJcbiAgICBiYm94LmNvcHlNYXggPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcclxuICAgICAgICB0YXJnZXRbMF0gPSBzb3VyY2VbM107XHJcbiAgICAgICAgdGFyZ2V0WzFdID0gc291cmNlWzRdO1xyXG4gICAgICAgIHRhcmdldFsyXSA9IHNvdXJjZVs1XTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfTtcclxuXHJcbiAgICBiYm94LmV4dGVuZFdpdGhCb3ggPSBmdW5jdGlvbiAodGFyZ2V0LCBvdGhlcikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFtpXSA9IE1hdGgubWluKG90aGVyW2ldLCB0YXJnZXRbaV0pO1xyXG4gICAgICAgICAgICB0YXJnZXRbaSArIDNdID0gTWF0aC5tYXgob3RoZXJbaSArIDNdLCB0YXJnZXRbaSArIDNdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH07XHJcblxyXG4gICAgYmJveC5lbXB0eSA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgYlswXSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgYlsxXSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgYlsyXSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgYlszXSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGJbNF0gPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBiWzVdID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgcmV0dXJuIGI7XHJcbiAgICB9O1xyXG5cclxuICAgIGJib3guaXNFbXB0eSA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgcmV0dXJuIChiWzBdID4gYlszXSB8fCBiWzFdID4gYls0XSB8fCBiWzJdID4gYls1XSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGJib3guY2VudGVyID0gZnVuY3Rpb24gKHRhcmdldCwgYikge1xyXG4gICAgICAgIHRhcmdldFswXSA9IChiWzBdICsgYlszXSkgKiAwLjU7XHJcbiAgICAgICAgdGFyZ2V0WzFdID0gKGJbMV0gKyBiWzRdKSAqIDAuNTtcclxuICAgICAgICB0YXJnZXRbMl0gPSAoYlsyXSArIGJbNV0pICogMC41O1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGJib3guc2l6ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGIpIHtcclxuICAgICAgICB0YXJnZXRbMF0gPSBiWzNdIC0gYlswXTtcclxuICAgICAgICB0YXJnZXRbMV0gPSBiWzRdIC0gYlsxXTtcclxuICAgICAgICB0YXJnZXRbMl0gPSBiWzVdIC0gYlsyXTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfTtcclxuXHJcbiAgICBiYm94LmhhbGZTaXplID0gZnVuY3Rpb24gKHRhcmdldCwgYikge1xyXG4gICAgICAgIHRhcmdldFswXSA9IChiWzNdIC0gYlswXSkgKiAwLjU7XHJcbiAgICAgICAgdGFyZ2V0WzFdID0gKGJbNF0gLSBiWzFdKSAqIDAuNTtcclxuICAgICAgICB0YXJnZXRbMl0gPSAoYls1XSAtIGJbMl0pICogMC41O1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGJib3gudHJhbnNmb3JtID0gZnVuY3Rpb24gKG91dCwgbWF0LCBib3gpIHtcclxuICAgICAgICBpZiAoYm94WzBdID4gYm94WzNdIHx8IGJveFsxXSA+IGJveFs0XSB8fCBib3hbMl0gPiBib3hbNV0pIHtcclxuICAgICAgICAgICAgYmJveC5jb3B5KG91dCwgYm94KTsgLy8gYW4gZW1wdHkgYm94IHJlbWFpbnMgZW1wdHlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBib3ggPSBiYm94LmNsb25lKGJveCk7XHJcblxyXG4gICAgICAgIGlmIChtYXRbM10gPT0gMCAmJiBtYXRbN10gPT0gMCAmJiBtYXRbMTFdID09IDAgJiYgbWF0WzE1XSA9PSAxKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgb3V0W2ldID0gb3V0W2kgKyAzXSA9IG1hdFsxMiArIGldO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEsIGI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBtYXRbaiAqIDQgKyBpXSAqIGJveFtqXTtcclxuICAgICAgICAgICAgICAgICAgICBiID0gbWF0W2ogKiA0ICsgaV0gKiBib3hbaiArIDNdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYSA8IGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2ldICs9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtpICsgM10gKz0gYjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtpXSArPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRbaSArIDNdICs9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hdHJpeCBpcyBub3QgYWZmaW5lXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBiYm94LnRyYW5zZm9ybTIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhYnNNYXQgPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNlbnRlciA9IFhNTDNELm1hdGgudmVjMy5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgZXh0ZW5kID0gWE1MM0QubWF0aC52ZWMzLmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG91dCwgbWF0LCBib3gpIHtcclxuXHJcbiAgICAgICAgICAgIGJib3guY2VudGVyKGNlbnRlciwgYm94KTtcclxuICAgICAgICAgICAgYmJveC5oYWxmU2l6ZShleHRlbmQsIGJveCk7XHJcblxyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQuY29weShhYnNNYXQsIG1hdCk7XHJcbiAgICAgICAgICAgIGFic01hdC5zZXQoWzAsIDAsIDAsIDFdLCAxMik7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYWJzTWF0W2ldID0gTWF0aC5hYnMoYWJzTWF0W2ldKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgWE1MM0QubWF0aC52ZWMzLnRyYW5zZm9ybU1hdDQoZXh0ZW5kLCBleHRlbmQsIGFic01hdCk7XHJcbiAgICAgICAgICAgIFhNTDNELm1hdGgudmVjMy50cmFuc2Zvcm1NYXQ0KGNlbnRlciwgY2VudGVyLCBtYXQpO1xyXG5cclxuICAgICAgICAgICAgb3V0WzBdID0gY2VudGVyWzBdIC0gZXh0ZW5kWzBdO1xyXG4gICAgICAgICAgICBvdXRbMV0gPSBjZW50ZXJbMV0gLSBleHRlbmRbMV07XHJcbiAgICAgICAgICAgIG91dFsyXSA9IGNlbnRlclsyXSAtIGV4dGVuZFsyXTtcclxuICAgICAgICAgICAgb3V0WzNdID0gY2VudGVyWzBdICsgZXh0ZW5kWzBdO1xyXG4gICAgICAgICAgICBvdXRbNF0gPSBjZW50ZXJbMV0gKyBleHRlbmRbMV07XHJcbiAgICAgICAgICAgIG91dFs1XSA9IGNlbnRlclsyXSArIGV4dGVuZFsyXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSgpKTtcclxuXHJcbiAgICBiYm94Lmxvbmdlc3RTaWRlID0gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICB2YXIgeCA9IE1hdGguYWJzKGJbM10gLSBiWzBdKTtcclxuICAgICAgICB2YXIgeSA9IE1hdGguYWJzKGJbNF0gLSBiWzFdKTtcclxuICAgICAgICB2YXIgeiA9IE1hdGguYWJzKGJbNV0gLSBiWzJdKTtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoeCwgTWF0aC5tYXgoeSwgeikpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGEgZ2l2ZW4gcmF5IGFnYWluc3QgYSBnaXZlbiBib3VuZGluZyBib3ggYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgcmF5IGludGVyc2VjdHMgaXQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqIEBwYXJhbSBiYiBUaGUgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCB0byB0ZXN0IGFnYWluc3RcclxuICAgICAqIEBwYXJhbSB4bWwzZFJheSBUaGUgcmF5IHRvIHRlc3QgZm9yIGludGVyc2VjdGlvbiB3aXRoXHJcbiAgICAgKiBAcGFyYW0gb3B0IHtvYmplY3R9IElmIG9wdC5kaXN0IGlzIHByb3ZpZGVkIHRoZSBmdW5jdGlvbiB3aWxsIGZpbGwgaXQgd2l0aCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcmF5IG9yaWdpbiB0b1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICB0aGUgaGl0IHBvaW50IG9uIHRoZSBib3VuZGluZyBib3gsIG9yIE1BWF9WQUxVRSBpZiB0aGUgcmF5IGRvZXMgbm90IGludGVyc2VjdC5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBiYm94LmludGVyc2VjdHMgPSBmdW5jdGlvbihiYiwgeG1sM2RSYXksIG9wdCkge1xyXG4gICAgICAgIHZhciBpbnZlcnNlRGlyWCA9IDEgLyB4bWwzZFJheS5fZGlyZWN0aW9uLng7XHJcbiAgICAgICAgdmFyIGludmVyc2VEaXJZID0gMSAvIHhtbDNkUmF5Ll9kaXJlY3Rpb24ueTtcclxuICAgICAgICB2YXIgaW52ZXJzZURpclogPSAxIC8geG1sM2RSYXkuX2RpcmVjdGlvbi56O1xyXG5cclxuICAgICAgICB2YXIgdDEgPSAoYmJbMF0gLSB4bWwzZFJheS5fb3JpZ2luLngpICogaW52ZXJzZURpclg7XHJcbiAgICAgICAgdmFyIHQyID0gKGJiWzNdIC0geG1sM2RSYXkuX29yaWdpbi54KSAqIGludmVyc2VEaXJYO1xyXG4gICAgICAgIHZhciB0MyA9IChiYlsxXSAtIHhtbDNkUmF5Ll9vcmlnaW4ueSkgKiBpbnZlcnNlRGlyWTtcclxuICAgICAgICB2YXIgdDQgPSAoYmJbNF0gLSB4bWwzZFJheS5fb3JpZ2luLnkpICogaW52ZXJzZURpclk7XHJcbiAgICAgICAgdmFyIHQ1ID0gKGJiWzJdIC0geG1sM2RSYXkuX29yaWdpbi56KSAqIGludmVyc2VEaXJaO1xyXG4gICAgICAgIHZhciB0NiA9IChiYls1XSAtIHhtbDNkUmF5Ll9vcmlnaW4ueikgKiBpbnZlcnNlRGlyWjtcclxuXHJcbiAgICAgICAgdmFyIHRtaW4gPSBNYXRoLm1heChNYXRoLm1heChNYXRoLm1pbih0MSwgdDIpLCBNYXRoLm1pbih0MywgdDQpKSwgTWF0aC5taW4odDUsIHQ2KSk7XHJcbiAgICAgICAgdmFyIHRtYXggPSBNYXRoLm1pbihNYXRoLm1pbihNYXRoLm1heCh0MSwgdDIpLCBNYXRoLm1heCh0MywgdDQpKSwgTWF0aC5tYXgodDUsIHQ2KSk7XHJcblxyXG4gICAgICAgIGlmIChvcHQgPT09IHVuZGVmaW5lZCB8fCBvcHQuZGlzdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0bWF4ID4gMCAmJiB0bWluIDw9IHRtYXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodG1heCA8IDApIHtcclxuICAgICAgICAgICAgb3B0LmRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodG1pbiA+IHRtYXgpIHtcclxuICAgICAgICAgICAgb3B0LmRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvcHQuZGlzdCA9IHRtaW47XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIGJib3guYXNYTUwzREJveCA9IGZ1bmN0aW9uIChiYikge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgd2luZG93LlhNTDNEQm94KCk7XHJcbiAgICAgICAgcmVzdWx0Lm1pbi5fZGF0YVswXSA9IGJiWzBdO1xyXG4gICAgICAgIHJlc3VsdC5taW4uX2RhdGFbMV0gPSBiYlsxXTtcclxuICAgICAgICByZXN1bHQubWluLl9kYXRhWzJdID0gYmJbMl07XHJcbiAgICAgICAgcmVzdWx0Lm1heC5fZGF0YVswXSA9IGJiWzNdO1xyXG4gICAgICAgIHJlc3VsdC5tYXguX2RhdGFbMV0gPSBiYls0XTtcclxuICAgICAgICByZXN1bHQubWF4Ll9kYXRhWzJdID0gYmJbNV07XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgYmJveC5mcm9tWE1MM0RCb3ggPSBmdW5jdGlvbihiYikge1xyXG4gICAgICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDYpO1xyXG4gICAgICAgIG91dFswXSA9IGJiLm1pbi5fZGF0YVswXTtcclxuICAgICAgICBvdXRbMV0gPSBiYi5taW4uX2RhdGFbMV07XHJcbiAgICAgICAgb3V0WzJdID0gYmIubWluLl9kYXRhWzJdO1xyXG4gICAgICAgIG91dFszXSA9IGJiLm1heC5fZGF0YVswXTtcclxuICAgICAgICBvdXRbNF0gPSBiYi5tYXguX2RhdGFbMV07XHJcbiAgICAgICAgb3V0WzVdID0gYmIubWF4Ll9kYXRhWzJdO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGJib3guc3RyID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICByZXR1cm4gJ2Jib3goJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICtcclxuICAgICAgICAgICAgYVs0XSArICcsICcgKyBhWzVdICsgJyknO1xyXG4gICAgfTtcclxuXHJcbiAgICBiYm94LkVNUFRZX0JPWCA9IGJib3guY3JlYXRlKCk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiYm94O1xyXG5cclxuXHJcbn0obW9kdWxlKSk7XHJcblxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XHJcblxyXG4vLyBBZGRpdGlvbmFsIG1ldGhvZHMgaW4gZ2xNYXRyaXggc3R5bGVcclxuICAgIG1hdGgudmVjMy5yZWNpcHJvY2FsID0gZnVuY3Rpb24gKHZlYywgZGVzdCkge1xyXG4gICAgICAgIGlmICghZGVzdCkge1xyXG4gICAgICAgICAgICBkZXN0ID0gdmVjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVzdFswXSA9IDEgLyB2ZWNbMF07XHJcbiAgICAgICAgZGVzdFsxXSA9IDEgLyB2ZWNbMV07XHJcbiAgICAgICAgZGVzdFsyXSA9IDEgLyB2ZWNbMl07XHJcbiAgICAgICAgcmV0dXJuIGRlc3Q7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBtYXRoLm1hdDQubXVsdGlwbHlPZmZzZXRWZWMzID0gZnVuY3Rpb24gKG1hdCwgbWF0T2Zmc2V0LCB2ZWMsIHZlY09mZnNldCwgZGVzdCkge1xyXG4gICAgICAgIGlmICghZGVzdCkge1xyXG4gICAgICAgICAgICBkZXN0ID0gdmVjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXZlY09mZnNldCkge1xyXG4gICAgICAgICAgICB2ZWNPZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHggPSB2ZWNbdmVjT2Zmc2V0ICsgMF0sIHkgPSB2ZWNbdmVjT2Zmc2V0ICsgMV0sIHogPSB2ZWNbdmVjT2Zmc2V0ICsgMl07XHJcblxyXG4gICAgICAgIGRlc3RbMF0gPSBtYXRbbWF0T2Zmc2V0ICsgMF0gKiB4ICsgbWF0W21hdE9mZnNldCArIDRdICogeSArIG1hdFttYXRPZmZzZXQgKyA4XSAqIHogKyBtYXRbbWF0T2Zmc2V0ICsgMTJdO1xyXG4gICAgICAgIGRlc3RbMV0gPSBtYXRbbWF0T2Zmc2V0ICsgMV0gKiB4ICsgbWF0W21hdE9mZnNldCArIDVdICogeSArIG1hdFttYXRPZmZzZXQgKyA5XSAqIHogKyBtYXRbbWF0T2Zmc2V0ICsgMTNdO1xyXG4gICAgICAgIGRlc3RbMl0gPSBtYXRbbWF0T2Zmc2V0ICsgMl0gKiB4ICsgbWF0W21hdE9mZnNldCArIDZdICogeSArIG1hdFttYXRPZmZzZXQgKyAxMF0gKiB6ICsgbWF0W21hdE9mZnNldCArIDE0XTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRlc3Q7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBtYXRoLm1hdDQubXVsdGlwbHlPZmZzZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAobWF0LCBtYXRPZmZzZXQsIHZlYywgdmVjT2Zmc2V0LCBkZXN0KSB7XHJcbiAgICAgICAgaWYgKCFkZXN0KSB7XHJcbiAgICAgICAgICAgIGRlc3QgPSB2ZWM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdmVjT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZlY09mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgeCA9IHZlY1t2ZWNPZmZzZXQgKyAwXSwgeSA9IHZlY1t2ZWNPZmZzZXQgKyAxXSwgeiA9IHZlY1t2ZWNPZmZzZXQgKyAyXSwgdztcclxuXHJcbiAgICAgICAgZGVzdFswXSA9IG1hdFttYXRPZmZzZXQgKyAwXSAqIHggKyBtYXRbbWF0T2Zmc2V0ICsgNF0gKiB5ICsgbWF0W21hdE9mZnNldCArIDhdICogejtcclxuICAgICAgICBkZXN0WzFdID0gbWF0W21hdE9mZnNldCArIDFdICogeCArIG1hdFttYXRPZmZzZXQgKyA1XSAqIHkgKyBtYXRbbWF0T2Zmc2V0ICsgOV0gKiB6O1xyXG4gICAgICAgIGRlc3RbMl0gPSBtYXRbbWF0T2Zmc2V0ICsgMl0gKiB4ICsgbWF0W21hdE9mZnNldCArIDZdICogeSArIG1hdFttYXRPZmZzZXQgKyAxMF0gKiB6O1xyXG5cclxuICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIElERU5UX01BVCA9IFhNTDNELm1hdGgubWF0NC5pZGVudGl0eShYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCkpO1xyXG4gICAgdmFyIFRNUF9NQVRSSVggPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICB2YXIgVE1QX1ZFQyA9IFhNTDNELm1hdGgudmVjMy5jcmVhdGUoKTtcclxuXHJcbiAgICBtYXRoLm1hdDQubWFrZVRyYW5zZm9ybVhmbG93ID0gZnVuY3Rpb24gKHRyYW5zbGF0aW9uLCByb3RhdGlvbiwgc2NhbGUsIGNlbnRlciwgc2NhbGVPcmllbnRhdGlvbiwgZGVzdCkge1xyXG4gICAgICAgIFhNTDNELm1hdGgubWF0NC5pZGVudGl0eShkZXN0KTtcclxuICAgICAgICBpZiAodHJhbnNsYXRpb24pIFhNTDNELm1hdGgubWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdHJhbnNsYXRpb24pO1xyXG4gICAgICAgIGlmIChjZW50ZXIpIFhNTDNELm1hdGgubWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgY2VudGVyKTtcclxuICAgICAgICBpZiAocm90YXRpb24pIHtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKFRNUF9NQVRSSVgsIFtyb3RhdGlvblswXSwgcm90YXRpb25bMV0sIHJvdGF0aW9uWzJdLCByb3RhdGlvblszXV0sIFswLCAwLCAwXSk7XHJcbiAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseShkZXN0LCBkZXN0LCBUTVBfTUFUUklYKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNjYWxlT3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKFRNUF9NQVRSSVgsIFtzY2FsZU9yaWVudGF0aW9uWzBdLCBzY2FsZU9yaWVudGF0aW9uWzFdLCBzY2FsZU9yaWVudGF0aW9uWzJdLCBzY2FsZU9yaWVudGF0aW9uWzNdXSwgWzAsIDAsIDBdKTtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5KGRlc3QsIGRlc3QsIFRNUF9NQVRSSVgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2NhbGUpIFhNTDNELm1hdGgubWF0NC5zY2FsZShkZXN0LCBkZXN0LCBzY2FsZSk7XHJcbiAgICAgICAgaWYgKHNjYWxlT3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKFRNUF9NQVRSSVgsIFtzY2FsZU9yaWVudGF0aW9uWzBdLCBzY2FsZU9yaWVudGF0aW9uWzFdLCBzY2FsZU9yaWVudGF0aW9uWzJdLCAtc2NhbGVPcmllbnRhdGlvblszXV0sIFswLCAwLCAwXSk7XHJcbiAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseShkZXN0LCBkZXN0LCBUTVBfTUFUUklYKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNlbnRlcikge1xyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIFhNTDNELm1hdGgudmVjMy5uZWdhdGUoVE1QX1ZFQywgY2VudGVyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBtYXRoLm1hdDQubWFrZVRyYW5zZm9ybUludlhmbG93ID0gZnVuY3Rpb24gKHRyYW5zbGF0aW9uLCByb3RhdGlvbiwgc2NhbGUsIGNlbnRlciwgc2NhbGVPcmllbnRhdGlvbiwgZGVzdCkge1xyXG4gICAgICAgIFhNTDNELm1hdGgubWF0NC5pZGVudGl0eShkZXN0KTtcclxuICAgICAgICBpZiAoY2VudGVyKSB7XHJcbiAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgY2VudGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNjYWxlT3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKFRNUF9NQVRSSVgsIFtzY2FsZU9yaWVudGF0aW9uWzBdLCBzY2FsZU9yaWVudGF0aW9uWzFdLCBzY2FsZU9yaWVudGF0aW9uWzJdLCBzY2FsZU9yaWVudGF0aW9uWzNdXSwgWzAsIDAsIDBdKVxyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHkoZGVzdCwgZGVzdCwgVE1QX01BVFJJWCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY2FsZSkgWE1MM0QubWF0aC5tYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIFhNTDNELm1hdGgudmVjMy5yZWNpcHJvY2FsKHNjYWxlLCBUTVBfVkVDKSk7XHJcbiAgICAgICAgaWYgKHNjYWxlT3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKFRNUF9NQVRSSVgsIFtzY2FsZU9yaWVudGF0aW9uWzBdLCBzY2FsZU9yaWVudGF0aW9uWzFdLCBzY2FsZU9yaWVudGF0aW9uWzJdLCAtc2NhbGVPcmllbnRhdGlvblszXV0sIFswLCAwLCAwXSlcclxuICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5KGRlc3QsIGRlc3QsIFRNUF9NQVRSSVgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm90YXRpb24pIHtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKFRNUF9NQVRSSVgsIFtyb3RhdGlvblswXSwgcm90YXRpb25bMV0sIHJvdGF0aW9uWzJdLCAtcm90YXRpb25bM11dLCBbMCwgMCwgMF0pXHJcbiAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseShkZXN0LCBkZXN0LCBUTVBfTUFUUklYKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNlbnRlcikgWE1MM0QubWF0aC5tYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCBYTUwzRC5tYXRoLnZlYzMubmVnYXRlKFRNUF9WRUMsIGNlbnRlcikpO1xyXG4gICAgICAgIGlmICh0cmFuc2xhdGlvbikgWE1MM0QubWF0aC5tYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCBYTUwzRC5tYXRoLnZlYzMubmVnYXRlKFRNUF9WRUMsIHRyYW5zbGF0aW9uKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1hdGgubWF0NC5tdWx0aXBseU9mZnNldCA9IGZ1bmN0aW9uIChkZXN0LCBkZXN0T2Zmc2V0LCBtYXQsIG9mZnNldDEsIG1hdDIsIG9mZnNldDIpIHtcclxuICAgICAgICB2YXIgYTAwID0gbWF0MltvZmZzZXQyICsgMF0sIGEwMSA9IG1hdDJbb2Zmc2V0MiArIDFdLCBhMDIgPSBtYXQyW29mZnNldDIgKyAyXSwgYTAzID0gbWF0MltvZmZzZXQyICsgM107XHJcbiAgICAgICAgdmFyIGExMCA9IG1hdDJbb2Zmc2V0MiArIDRdLCBhMTEgPSBtYXQyW29mZnNldDIgKyA1XSwgYTEyID0gbWF0MltvZmZzZXQyICsgNl0sIGExMyA9IG1hdDJbb2Zmc2V0MiArIDddO1xyXG4gICAgICAgIHZhciBhMjAgPSBtYXQyW29mZnNldDIgKyA4XSwgYTIxID0gbWF0MltvZmZzZXQyICsgOV0sIGEyMiA9IG1hdDJbb2Zmc2V0MiArIDEwXSwgYTIzID0gbWF0MltvZmZzZXQyICsgMTFdO1xyXG4gICAgICAgIHZhciBhMzAgPSBtYXQyW29mZnNldDIgKyAxMl0sIGEzMSA9IG1hdDJbb2Zmc2V0MiArIDEzXSwgYTMyID0gbWF0MltvZmZzZXQyICsgMTRdLCBhMzMgPSBtYXQyW29mZnNldDIgKyAxNV07XHJcblxyXG4gICAgICAgIHZhciBiMDAgPSBtYXRbb2Zmc2V0MSArIDBdLCBiMDEgPSBtYXRbb2Zmc2V0MSArIDFdLCBiMDIgPSBtYXRbb2Zmc2V0MSArIDJdLCBiMDMgPSBtYXRbb2Zmc2V0MSArIDNdO1xyXG4gICAgICAgIHZhciBiMTAgPSBtYXRbb2Zmc2V0MSArIDRdLCBiMTEgPSBtYXRbb2Zmc2V0MSArIDVdLCBiMTIgPSBtYXRbb2Zmc2V0MSArIDZdLCBiMTMgPSBtYXRbb2Zmc2V0MSArIDddO1xyXG4gICAgICAgIHZhciBiMjAgPSBtYXRbb2Zmc2V0MSArIDhdLCBiMjEgPSBtYXRbb2Zmc2V0MSArIDldLCBiMjIgPSBtYXRbb2Zmc2V0MSArIDEwXSwgYjIzID0gbWF0W29mZnNldDEgKyAxMV07XHJcbiAgICAgICAgdmFyIGIzMCA9IG1hdFtvZmZzZXQxICsgMTJdLCBiMzEgPSBtYXRbb2Zmc2V0MSArIDEzXSwgYjMyID0gbWF0W29mZnNldDEgKyAxNF0sIGIzMyA9IG1hdFtvZmZzZXQxICsgMTVdO1xyXG5cclxuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAwXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMCArIGIwMyAqIGEzMDtcclxuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMSArIGIwMyAqIGEzMTtcclxuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMiArIGIwMyAqIGEzMjtcclxuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAzXSA9IGIwMCAqIGEwMyArIGIwMSAqIGExMyArIGIwMiAqIGEyMyArIGIwMyAqIGEzMztcclxuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyA0XSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMCArIGIxMyAqIGEzMDtcclxuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyA1XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMSArIGIxMyAqIGEzMTtcclxuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyA2XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMiArIGIxMyAqIGEzMjtcclxuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyA3XSA9IGIxMCAqIGEwMyArIGIxMSAqIGExMyArIGIxMiAqIGEyMyArIGIxMyAqIGEzMztcclxuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyA4XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMCArIGIyMyAqIGEzMDtcclxuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyA5XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMSArIGIyMyAqIGEzMTtcclxuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAxMF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjIgKyBiMjMgKiBhMzI7XHJcbiAgICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMTFdID0gYjIwICogYTAzICsgYjIxICogYTEzICsgYjIyICogYTIzICsgYjIzICogYTMzO1xyXG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDEyXSA9IGIzMCAqIGEwMCArIGIzMSAqIGExMCArIGIzMiAqIGEyMCArIGIzMyAqIGEzMDtcclxuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAxM10gPSBiMzAgKiBhMDEgKyBiMzEgKiBhMTEgKyBiMzIgKiBhMjEgKyBiMzMgKiBhMzE7XHJcbiAgICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMTRdID0gYjMwICogYTAyICsgYjMxICogYTEyICsgYjMyICogYTIyICsgYjMzICogYTMyO1xyXG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDE1XSA9IGIzMCAqIGEwMyArIGIzMSAqIGExMyArIGIzMiAqIGEyMyArIGIzMyAqIGEzMztcclxuICAgIH07XHJcblxyXG4gICAgbWF0aC5xdWF0LnNsZXJwT2Zmc2V0ID0gZnVuY3Rpb24gKHF1YXQsIG9mZnNldDEsIHF1YXQyLCBvZmZzZXQyLCB0LCBkZXN0LCBkZXN0T2Zmc2V0LCBzaG9ydGVzdCkge1xyXG4gICAgICAgIGlmICghZGVzdCkge1xyXG4gICAgICAgICAgICBkZXN0ID0gcXVhdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpeDEgPSBvZmZzZXQxLCBpeTEgPSBvZmZzZXQxICsgMSwgaXoxID0gb2Zmc2V0MSArIDIsIGl3MSA9IG9mZnNldDEgKyAzO1xyXG4gICAgICAgIHZhciBpeDIgPSBvZmZzZXQyLCBpeTIgPSBvZmZzZXQyICsgMSwgaXoyID0gb2Zmc2V0MiArIDIsIGl3MiA9IG9mZnNldDIgKyAzO1xyXG4gICAgICAgIHZhciBpeGQgPSBkZXN0T2Zmc2V0LCBpeWQgPSBkZXN0T2Zmc2V0ICsgMSwgaXpkID0gZGVzdE9mZnNldCArIDIsIGl3ZCA9IGRlc3RPZmZzZXQgKyAzO1xyXG5cclxuICAgICAgICB2YXIgY29zQW5nbGUgPSBxdWF0W2l4MV0gKiBxdWF0MltpeDJdICsgcXVhdFtpeTFdICogcXVhdDJbaXkyXSArIHF1YXRbaXoxXSAqIHF1YXQyW2l6Ml0gKyBxdWF0W2l3MV0gKiBxdWF0MltpdzJdO1xyXG5cclxuICAgICAgICB2YXIgYzEsIGMyO1xyXG5cclxuICAgICAgICAvLyBMaW5lYXIgaW50ZXJwb2xhdGlvbiBmb3IgY2xvc2Ugb3JpZW50YXRpb25zXHJcbiAgICAgICAgaWYgKCgxLjAgLSBNYXRoLmFicyhjb3NBbmdsZSkpIDwgMC4wMSkge1xyXG4gICAgICAgICAgICBjMSA9IDEuMCAtIHQ7XHJcbiAgICAgICAgICAgIGMyID0gdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBTcGhlcmljYWwgaW50ZXJwb2xhdGlvblxyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmFjb3MoTWF0aC5hYnMoY29zQW5nbGUpKTtcclxuICAgICAgICAgICAgdmFyIHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgICAgICBjMSA9IE1hdGguc2luKGFuZ2xlICogKDEuMCAtIHQpKSAvIHNpbkFuZ2xlO1xyXG4gICAgICAgICAgICBjMiA9IE1hdGguc2luKGFuZ2xlICogdCkgLyBzaW5BbmdsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVzZSB0aGUgc2hvcnRlc3QgcGF0aFxyXG4gICAgICAgIGlmIChzaG9ydGVzdCAmJiAoY29zQW5nbGUgPCAwLjApKVxyXG4gICAgICAgICAgICBjMSA9IC1jMTtcclxuXHJcbiAgICAgICAgZGVzdFtpeGRdID0gYzEgKiBxdWF0W2l4MV0gKyBjMiAqIHF1YXQyW2l4Ml07XHJcbiAgICAgICAgZGVzdFtpeWRdID0gYzEgKiBxdWF0W2l5MV0gKyBjMiAqIHF1YXQyW2l5Ml07XHJcbiAgICAgICAgZGVzdFtpemRdID0gYzEgKiBxdWF0W2l6MV0gKyBjMiAqIHF1YXQyW2l6Ml07XHJcbiAgICAgICAgZGVzdFtpd2RdID0gYzEgKiBxdWF0W2l3MV0gKyBjMiAqIHF1YXQyW2l3Ml07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cclxuICAgICAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gICAgICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gICAgICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gICAgICovXHJcbiAgICBtYXRoLnZlYzMudHJhbnNmb3JtRGlyZWN0aW9uID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XHJcbiAgICAgICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XHJcbiAgICAgICAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeik7XHJcbiAgICAgICAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeik7XHJcbiAgICAgICAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHopO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIG1hdGgucXVhdC5zZXRGcm9tTWF0MyA9IGZ1bmN0aW9uKG0sIGRlc3QpIHtcclxuICAgICAgICB2YXIgdHIgPSBtWzBdICsgbVs0XSArIG1bOF07XHJcblxyXG4gICAgICAgIGlmICh0ciA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQodHIgKyAxLjApICogMjsgLy8gcz00KmRlc3RbM11cclxuICAgICAgICAgICAgZGVzdFswXSA9IChtWzddIC0gbVs1XSkgLyBzO1xyXG4gICAgICAgICAgICBkZXN0WzFdID0gKG1bMl0gLSBtWzZdKSAvIHM7XHJcbiAgICAgICAgICAgIGRlc3RbMl0gPSAobVszXSAtIG1bMV0pIC8gcztcclxuICAgICAgICAgICAgZGVzdFszXSA9IDAuMjUgKiBzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKG1bMF0gPiBtWzRdKSAmJiAobVswXSA+IG1bOF0pKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gTWF0aC5zcXJ0KDEuMCArIG1bMF0gLSBtWzRdIC0gbVs4XSkgKiAyOyAvLyBzPTQqcXhcclxuICAgICAgICAgICAgZGVzdFszXSA9IChtWzddIC0gbVs1XSkgLyBzO1xyXG4gICAgICAgICAgICBkZXN0WzBdID0gMC4yNSAqIHM7XHJcbiAgICAgICAgICAgIGRlc3RbMV0gPSAobVsxXSArIG1bM10pIC8gcztcclxuICAgICAgICAgICAgZGVzdFsyXSA9IChtWzJdICsgbVs2XSkgLyBzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobVs0XSA+IG1bOF0pIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoMS4wICsgbVs0XSAtIG1bMF0gLSBtWzhdKSAqIDI7IC8vIHM9NCpxeVxyXG4gICAgICAgICAgICBkZXN0WzNdID0gKG1bMl0gLSBtWzZdKSAvIHM7XHJcbiAgICAgICAgICAgIGRlc3RbMF0gPSAobVsxXSArIG1bM10pIC8gcztcclxuICAgICAgICAgICAgZGVzdFsxXSA9IDAuMjUgKiBzO1xyXG4gICAgICAgICAgICBkZXN0WzJdID0gKG1bNV0gKyBtWzddKSAvIHM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoMS4wICsgbVs4XSAtIG1bMF0gLSBtWzRdKSAqIDI7IC8vIHM9NCpxelxyXG4gICAgICAgICAgICBkZXN0WzNdID0gKG1bM10gLSBtWzFdKSAvIHM7XHJcbiAgICAgICAgICAgIGRlc3RbMF0gPSAobVsyXSArIG1bNl0pIC8gcztcclxuICAgICAgICAgICAgZGVzdFsxXSA9IChtWzVdICsgbVs3XSkgLyBzO1xyXG4gICAgICAgICAgICBkZXN0WzJdID0gMC4yNSAqIHM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBtYXRoLnF1YXQuc2V0RnJvbUJhc2lzID0gZnVuY3Rpb24oWCxZLFosZGVzdCkge1xyXG4gICAgICAgIHZhciBseCA9IDEuMCAvIFhNTDNELm1hdGgudmVjMy5sZW5ndGgoWCk7XHJcbiAgICAgICAgdmFyIGx5ID0gMS4wIC8gWE1MM0QubWF0aC52ZWMzLmxlbmd0aChZKTtcclxuICAgICAgICB2YXIgbHogPSAxLjAgLyBYTUwzRC5tYXRoLnZlYzMubGVuZ3RoKFopO1xyXG4gICAgICAgIHZhciBtID0gWE1MM0QubWF0aC5tYXQzLmNyZWF0ZSgpO1xyXG4gICAgICAgIG1bMF0gPSBYWzBdICogbHg7XHJcbiAgICAgICAgbVsxXSA9IFlbMF0gKiBseTtcclxuICAgICAgICBtWzJdID0gWlswXSAqIGx6O1xyXG4gICAgICAgIG1bM10gPSBYWzFdICogbHg7XHJcbiAgICAgICAgbVs0XSA9IFlbMV0gKiBseTtcclxuICAgICAgICBtWzVdID0gWlsxXSAqIGx6O1xyXG4gICAgICAgIG1bNl0gPSBYWzJdICogbHg7XHJcbiAgICAgICAgbVs3XSA9IFlbMl0gKiBseTtcclxuICAgICAgICBtWzhdID0gWlsyXSAqIGx6O1xyXG4gICAgICAgIFhNTDNELm1hdGgucXVhdC5zZXRGcm9tTWF0MyhtLGRlc3QpO1xyXG4gICAgfTtcclxuXHJcblxyXG59O1xyXG4iLCJ2YXIgTm9kZUFkYXB0ZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9hZGFwdGVyLmpzXCIpLk5vZGVBZGFwdGVyO1xyXG5cclxudmFyIFJlbmRlckFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgTm9kZUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoUmVuZGVyQWRhcHRlciwgTm9kZUFkYXB0ZXIpO1xyXG5cclxuUmVuZGVyQWRhcHRlci5wcm90b3R5cGUuZ2V0U2hhZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5SZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5nZXRQYXJlbnRSZW5kZXJBZGFwdGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZmFjdG9yeS5nZXRBZGFwdGVyKHRoaXMubm9kZS5wYXJlbnROb2RlLCBSZW5kZXJBZGFwdGVyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gZWxlbWVudFxyXG4gKi9cclxuUmVuZGVyQWRhcHRlci5wcm90b3R5cGUuaW5pdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgdGhpcy5mYWN0b3J5LmdldEFkYXB0ZXIoZWxlbWVudCk7XHJcbiAgICB0aGlzLmluaXRDaGlsZEVsZW1lbnRzKGVsZW1lbnQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gKi9cclxuUmVuZGVyQWRhcHRlci5wcm90b3R5cGUuaW5pdENoaWxkRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgdmFyIGNoaWxkID0gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgIHdoaWxlIChjaGlsZCkge1xyXG4gICAgICAgIHRoaXMuaW5pdEVsZW1lbnQoY2hpbGQpO1xyXG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblJlbmRlckFkYXB0ZXIucHJvdG90eXBlLmFwcGx5VHJhbnNmb3JtTWF0cml4ID0gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xyXG4gICAgcmV0dXJuIHRyYW5zZm9ybTtcclxufTtcclxuXHJcblJlbmRlckFkYXB0ZXIucHJvdG90eXBlLmdldFNjZW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZmFjdG9yeS5yZW5kZXJlci5zY2VuZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyQWRhcHRlcjtcclxuIiwidmFyIFJlbmRlckFkYXB0ZXIgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xyXG5cclxuLy9BZGFwdGVyIGZvciA8ZGVmcz5cclxudmFyIERlZnNSZW5kZXJBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIFJlbmRlckFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoRGVmc1JlbmRlckFkYXB0ZXIsIFJlbmRlckFkYXB0ZXIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEZWZzUmVuZGVyQWRhcHRlcjtcclxuIiwidmFyIE5vZGVBZGFwdGVyRmFjdG9yeSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2FkYXB0ZXIuanNcIikuTm9kZUFkYXB0ZXJGYWN0b3J5O1xyXG52YXIgRGF0YUFkYXB0ZXJGYWN0b3J5ID0gcmVxdWlyZShcIi4uLy4uLy4uL2RhdGEvYWRhcHRlci9mYWN0b3J5LmpzXCIpO1xyXG5yZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9mb3JtYXRoYW5kbGVyLmpzXCIpLnhtbDNkRm9ybWF0SGFuZGxlci5yZWdpc3RlckZhY3RvcnlDbGFzcyhEYXRhQWRhcHRlckZhY3RvcnkpO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAaW1wbGVtZW50cyB7WE1MM0QuYmFzZS5JRmFjdG9yeX1cclxuICogQGV4dGVuZHMgWE1MM0QuYmFzZS5Ob2RlQWRhcHRlckZhY3RvcnlcclxuICogQHBhcmFtIHtudW1iZXJ9IGNhbnZhc0lkXHJcbiAqL1xyXG52YXIgUmVuZGVyQWRhcHRlckZhY3RvcnkgPSBmdW5jdGlvbiAoY2FudmFzSWQpIHtcclxuICAgIE5vZGVBZGFwdGVyRmFjdG9yeS5jYWxsKHRoaXMsIFwid2ViZ2xcIiwgY2FudmFzSWQpO1xyXG4gICAgdGhpcy50eXBlID0gXCJSZW5kZXJBZGFwdGVyRmFjdG9yeVwiO1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhSZW5kZXJBZGFwdGVyRmFjdG9yeSwgTm9kZUFkYXB0ZXJGYWN0b3J5KTtcclxuUmVuZGVyQWRhcHRlckZhY3RvcnkucHJvdG90eXBlLmFzcGVjdCA9IFwid2ViZ2xcIjtcclxuXHJcblxyXG52YXIgcmVnaXN0cnkgPSB7XHJcbiAgICAgICAgeG1sM2Q6IHJlcXVpcmUoXCIuL3htbDNkLmpzXCIpLFxyXG4gICAgICAgIHZpZXc6IHJlcXVpcmUoXCIuL3ZpZXcuanNcIiksXHJcbiAgICAgICAgZGVmczogcmVxdWlyZShcIi4vZGVmcy5qc1wiKSxcclxuICAgICAgICBtZXNoOiByZXF1aXJlKFwiLi9tZXNoLmpzXCIpLFxyXG4gICAgICAgIG1vZGVsOiByZXF1aXJlKFwiLi9tb2RlbC5qc1wiKSxcclxuICAgICAgICBzaGFkZXI6IHJlcXVpcmUoXCIuL3NoYWRlci5qc1wiKSxcclxuICAgICAgICBncm91cDogcmVxdWlyZShcIi4vZ3JvdXAuanNcIiksXHJcbiAgICAgICAgbGlnaHQ6IHJlcXVpcmUoXCIuL2xpZ2h0LmpzXCIpLFxyXG4gICAgICAgIGxpZ2h0c2hhZGVyOiByZXF1aXJlKFwiLi9saWdodHNoYWRlci5qc1wiKVxyXG4gICAgfTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gbm9kZVxyXG4gKiBAcmV0dXJuIHtYTUwzRC5iYXNlLkFkYXB0ZXJ8bnVsbH1cclxuICovXHJcblJlbmRlckFkYXB0ZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVBZGFwdGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIHZhciBhZGFwdGVyQ29uc3RydWN0b3IgPSByZWdpc3RyeVtub2RlLmxvY2FsTmFtZV07XHJcbiAgICBpZiAoYWRhcHRlckNvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGFkYXB0ZXJDb25zdHJ1Y3Rvcih0aGlzLCBub2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuUmVuZGVyQWRhcHRlckZhY3RvcnkucHJvdG90eXBlLnNldFNjZW5lID0gZnVuY3Rpb24gKHNjZW5lKSB7XHJcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcbn07XHJcblxyXG5SZW5kZXJBZGFwdGVyRmFjdG9yeS5wcm90b3R5cGUuZ2V0U2NlbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zY2VuZTtcclxufTtcclxuXHJcblJlbmRlckFkYXB0ZXJGYWN0b3J5LnByb3RvdHlwZS5zZXRSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlcikge1xyXG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG59O1xyXG5cclxuUmVuZGVyQWRhcHRlckZhY3RvcnkucHJvdG90eXBlLmdldFJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXI7XHJcbn07XHJcblxyXG4vLyBFeHBvcnRcclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJBZGFwdGVyRmFjdG9yeTtcclxuIiwidmFyIFRyYW5zZm9ybWFibGVBZGFwdGVyID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtYWJsZS5qc1wiKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG5cclxudmFyIEdyb3VwUmVuZGVyQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XHJcbiAgICBUcmFuc2Zvcm1hYmxlQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUsIHRydWUsIHRydWUpO1xyXG4gICAgdGhpcy5jcmVhdGVSZW5kZXJOb2RlKCk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhHcm91cFJlbmRlckFkYXB0ZXIsIFRyYW5zZm9ybWFibGVBZGFwdGVyKTtcclxuXHJcbnZhciBwID0gR3JvdXBSZW5kZXJBZGFwdGVyLnByb3RvdHlwZTtcclxuXHJcbnAuY3JlYXRlUmVuZGVyTm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vVE9ETzogU2hvdWxkbid0IGhhdmUgdG8gZ28gdGhyb3VnaCB0aGUgcmVuZGVyZXIuLi5cclxuICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudFJlbmRlckFkYXB0ZXIoKTtcclxuICAgIHZhciBwYXJlbnROb2RlID0gcGFyZW50LmdldFJlbmRlck5vZGUgJiYgcGFyZW50LmdldFJlbmRlck5vZGUoKTtcclxuICAgIHRoaXMucmVuZGVyTm9kZSA9IHRoaXMuZ2V0U2NlbmUoKS5jcmVhdGVSZW5kZXJHcm91cCh7XHJcbiAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlLCB2aXNpYmxlOiB0aGlzLm5vZGUudmlzaWJsZSwgbmFtZTogdGhpcy5ub2RlLmlkXHJcbiAgICB9KTtcclxuICAgIHRoaXMudXBkYXRlTG9jYWxNYXRyaXgoKTtcclxuICAgIHRoaXMudXBkYXRlU2hhZGVySGFuZGxlcigpO1xyXG4gICAgdmFyIGJib3ggPSBYTUwzRC5tYXRoLmJib3guY3JlYXRlKCk7XHJcbiAgICB0aGlzLnJlbmRlck5vZGUuc2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGJib3gpO1xyXG59O1xyXG5cclxucC5ub3RpZnlDaGFuZ2VkID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgVHJhbnNmb3JtYWJsZUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQuY2FsbCh0aGlzLCBldnQpO1xyXG4gICAgaWYgKGV2dC50eXBlICE9PSBFdmVudHMuVkFMVUVfTU9ESUZJRUQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDb25uZWN0ZWRBZGFwdGVyRXZlbnQoZXZ0KTtcclxuICAgIH1cclxufTtcclxuXHJcbnAuaGFuZGxlQ29ubmVjdGVkQWRhcHRlckV2ZW50ID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgc3dpdGNoIChldnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgRXZlbnRzLk5PREVfSU5TRVJURUQ6XHJcbiAgICAgICAgICAgIC8vIFRoaXMgYWxzbyBpbml0aWFsaXplcyB0aGUgY2hpbGRyZW5cclxuICAgICAgICAgICAgdGhpcy5pbml0RWxlbWVudChldnQubXV0YXRpb24udGFyZ2V0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFdmVudHMuVEhJU19SRU1PVkVEOlxyXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFdmVudHMuQURBUFRFUl9IQU5ETEVfQ0hBTkdFRDpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFdmVudHMuTk9ERV9SRU1PVkVEOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiVW5oYW5kbGVkIGNvbm5lY3RlZCBhZGFwdGVyIGV2ZW50IGZvciBcIiArIGV2dC5rZXkgKyBcIiBpbiBzaGFkZXIgYWRhcHRlclwiKTtcclxuICAgIH1cclxufTtcclxuXHJcbnAuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIERpc3Bvc2UgYWxsIGNoaWxkcmVuIGFzIHdlbGxcclxuICAgIHRoaXMudHJhdmVyc2UoZnVuY3Rpb24gKGFkYXB0ZXIpIHtcclxuICAgICAgICBpZiAoYWRhcHRlciAmJiBhZGFwdGVyLmRlc3Ryb3kpXHJcbiAgICAgICAgICAgIGFkYXB0ZXIuZGlzcG9zZSgpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmdldFJlbmRlck5vZGUoKS5yZW1vdmUoKTtcclxuICAgIHRoaXMuY2xlYXJBZGFwdGVySGFuZGxlcygpO1xyXG59O1xyXG5cclxuLyogSW50ZXJmYWNlIG1ldGhvZHMgKi9cclxucC5nZXRXb3JsZEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGJib3ggPSBYTUwzRC5tYXRoLmJib3guY3JlYXRlKCk7XHJcbiAgICB0aGlzLnJlbmRlck5vZGUuZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGJib3gpO1xyXG4gICAgcmV0dXJuIFhNTDNELm1hdGguYmJveC5hc1hNTDNEQm94KGJib3gpO1xyXG59O1xyXG5cclxuLy9UT0RPOiBpbXByb3ZlIGVmZmljaWVuY3kgb2YgdGhpcyBmdW5jdGlvbiBvbmNlIFhNTDNEIHR5cGVzIGFyZSBvdmVyaGF1bGVkXHJcbnAuZ2V0TG9jYWxCb3VuZGluZ0JveCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbG9jYWxNYXQgPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBiYm94ID0gbmV3IHdpbmRvdy5YTUwzREJveCgpO1xyXG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJOb2RlLnZpc2libGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJib3g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodGhpcy5ub2RlLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgIGlmIChjLmdldExvY2FsQm91bmRpbmdCb3ggJiYgYy52aXNpYmxlKVxyXG4gICAgICAgICAgICAgICAgYmJveC5leHRlbmQoYy5nZXRMb2NhbEJvdW5kaW5nQm94KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucmVuZGVyTm9kZS5nZXRMb2NhbE1hdHJpeChsb2NhbE1hdCk7XHJcbiAgICAgICAgdmFyIGxvY2FsQkIgPSBYTUwzRC5tYXRoLmJib3guZnJvbVhNTDNEQm94KGJib3gpO1xyXG4gICAgICAgIFhNTDNELm1hdGguYmJveC50cmFuc2Zvcm0obG9jYWxCQiwgbG9jYWxNYXQsIGxvY2FsQkIpO1xyXG4gICAgICAgIHJldHVybiBYTUwzRC5tYXRoLmJib3guYXNYTUwzREJveChsb2NhbEJCKTtcclxuICAgIH1cclxufSkoKTtcclxuXHJcbnAuZ2V0TG9jYWxNYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbSA9IG5ldyB3aW5kb3cuWE1MM0RNYXRyaXgoKTtcclxuICAgIHRoaXMucmVuZGVyTm9kZS5nZXRMb2NhbE1hdHJpeChtLl9kYXRhKTtcclxuICAgIHJldHVybiBtO1xyXG59O1xyXG5cclxucC5nZXRXb3JsZE1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtID0gbmV3IHdpbmRvdy5YTUwzRE1hdHJpeCgpO1xyXG4gICAgdGhpcy5yZW5kZXJOb2RlLmdldFdvcmxkTWF0cml4KG0uX2RhdGEpO1xyXG4gICAgcmV0dXJuIG07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwUmVuZGVyQWRhcHRlcjtcclxuIiwidmFyIFRyYW5zZm9ybWFibGVBZGFwdGVyID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtYWJsZS5qc1wiKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG4vKipcclxuICogQWRhcHRlciBmb3IgPGxpZ2h0PlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtSZW5kZXJBZGFwdGVyRmFjdG9yeX0gZmFjdG9yeVxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcclxuICovXHJcbnZhciBMaWdodFJlbmRlckFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgVHJhbnNmb3JtYWJsZUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICB0aGlzLnVwZGF0ZUxpZ2h0U2hhZGVyKCk7XHJcbiAgICB0aGlzLmNyZWF0ZVJlbmRlck5vZGUoKTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoTGlnaHRSZW5kZXJBZGFwdGVyLCBUcmFuc2Zvcm1hYmxlQWRhcHRlcik7XHJcblxyXG5MaWdodFJlbmRlckFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVJlbmRlck5vZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcGFyZW50QWRhcHRlciA9IHRoaXMuZ2V0UGFyZW50UmVuZGVyQWRhcHRlcigpO1xyXG4gICAgdmFyIHBhcmVudE5vZGUgPSBwYXJlbnRBZGFwdGVyLmdldFJlbmRlck5vZGUgJiYgcGFyZW50QWRhcHRlci5nZXRSZW5kZXJOb2RlKCk7XHJcbiAgICB2YXIgbGlnaHRTaGFkZXIgPSB0aGlzLmdldExpZ2h0U2hhZGVyKCk7XHJcbiAgICB0aGlzLnJlbmRlck5vZGUgPSB0aGlzLmZhY3RvcnkuZ2V0U2NlbmUoKS5jcmVhdGVSZW5kZXJMaWdodCh7XHJcbiAgICAgICAgbGlnaHQ6IHtcclxuICAgICAgICAgICAgdHlwZTogbGlnaHRTaGFkZXIgPyBsaWdodFNoYWRlci5nZXRMaWdodFR5cGUoKSA6IG51bGwsIGRhdGE6IGxpZ2h0U2hhZGVyID8gbGlnaHRTaGFkZXIuZ2V0RGF0YU5vZGUoKSA6IG51bGxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmVudDogcGFyZW50Tm9kZSxcclxuICAgICAgICBzaGFkZXI6IGxpZ2h0U2hhZGVyLFxyXG4gICAgICAgIHZpc2libGU6ICF0aGlzLm5vZGUudmlzaWJsZSA/IGZhbHNlIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGxvY2FsSW50ZW5zaXR5OiB0aGlzLm5vZGUuaW50ZW5zaXR5XHJcbiAgICB9KTtcclxufTtcclxuXHJcbkxpZ2h0UmVuZGVyQWRhcHRlci5wcm90b3R5cGUubm90aWZ5Q2hhbmdlZCA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgIHN3aXRjaCAoZXZ0LnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBFdmVudHMuTk9ERV9SRU1PVkVEOlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY2FzZSBFdmVudHMuVEhJU19SRU1PVkVEOlxyXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNhc2UgRXZlbnRzLkFEQVBURVJfSEFORExFX0NIQU5HRUQ6XHJcbiAgICAgICAgICAgIGlmIChldnQua2V5ID09IFwic2hhZGVyXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vVGhlIGxpZ2h0c2hhZGVyIHdhcyBkZXN0cm95ZWQsIHNvIHRoaXMgbGlnaHQgaXMgbm93IGludmFsaWRcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEV2ZW50cy5WQUxVRV9NT0RJRklFRDpcclxuICAgICAgICAgICAgdGhpcy52YWx1ZU1vZGlmaWVkKGV2dC5tdXRhdGlvbik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRXZlbnRzLkFEQVBURVJfVkFMVUVfQ0hBTkdFRDpcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlLnNldExpZ2h0VHlwZShldnQuYWRhcHRlci5nZXRMaWdodFR5cGUoKSwgZXZ0LmFkYXB0ZXIuZ2V0RGF0YU5vZGUoKSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5MaWdodFJlbmRlckFkYXB0ZXIucHJvdG90eXBlLnZhbHVlTW9kaWZpZWQgPSBmdW5jdGlvbiAobXV0YXRpb24pIHtcclxuICAgIHZhciBuZXdWYWx1ZSA9IG11dGF0aW9uLnRhcmdldC5nZXRBdHRyaWJ1dGUobXV0YXRpb24uYXR0cmlidXRlTmFtZSk7XHJcbiAgICBzd2l0Y2ggKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUpIHtcclxuICAgICAgICBjYXNlIFwidmlzaWJsZVwiOlxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUuc2V0TG9jYWxWaXNpYmxlKG5ld1ZhbHVlICYmIChuZXdWYWx1ZS50b0xvd2VyQ2FzZSgpICE9PSBcImZhbHNlXCIpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImludGVuc2l0eVwiOlxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUuc2V0TG9jYWxJbnRlbnNpdHkobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwic2hhZGVyXCI6XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaWdodFNoYWRlcigpO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVJlbmRlck5vZGUoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn07XHJcblxyXG5MaWdodFJlbmRlckFkYXB0ZXIucHJvdG90eXBlLnVwZGF0ZUxpZ2h0U2hhZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNoYWRlckhyZWYgPSB0aGlzLm5vZGUuc2hhZGVyO1xyXG4gICAgaWYgKCFzaGFkZXJIcmVmKSB7XHJcbiAgICAgICAgdmFyIHN0eWxlVmFsdWUgPSB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgICAgIGlmIChzdHlsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gL3NoYWRlclxccyo6XFxzKnVybFxccypcXChcXHMqKFxcUyspXFxzKlxcKS9pO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGF0dGVybi5leGVjKHN0eWxlVmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgc2hhZGVySHJlZiA9IHJlc3VsdFsxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmNvbm5lY3RBZGFwdGVySGFuZGxlKFwic2hhZGVyXCIsIHRoaXMuZ2V0QWRhcHRlckhhbmRsZShzaGFkZXJIcmVmKSk7XHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICovXHJcbkxpZ2h0UmVuZGVyQWRhcHRlci5wcm90b3R5cGUuZ2V0TGlnaHRTaGFkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRDb25uZWN0ZWRBZGFwdGVyKFwic2hhZGVyXCIpO1xyXG59O1xyXG5cclxuTGlnaHRSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5nZXRSZW5kZXJOb2RlKCkucmVtb3ZlKCk7XHJcbiAgICB0aGlzLmNsZWFyQWRhcHRlckhhbmRsZXMoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJuIHtYTUwzRE1hdHJpeH1cclxuICovXHJcbkxpZ2h0UmVuZGVyQWRhcHRlci5wcm90b3R5cGUuZ2V0V29ybGRNYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbSA9IG5ldyB3aW5kb3cuWE1MM0RNYXRyaXgoKTtcclxuICAgIHRoaXMucmVuZGVyTm9kZS5nZXRXb3JsZE1hdHJpeChtLl9kYXRhKTtcclxuICAgIHJldHVybiBtO1xyXG59O1xyXG5cclxuLy8gRXhwb3J0XHJcbm1vZHVsZS5leHBvcnRzID0gTGlnaHRSZW5kZXJBZGFwdGVyO1xyXG5cclxuIiwidmFyIFJlbmRlckFkYXB0ZXIgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xyXG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XHJcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL3Jlc291cmNlbWFuYWdlci5qc1wiKS5SZXNvdXJjZTtcclxuXHJcbi8qKlxyXG4gKiBBZGFwdGVyIGZvciA8bGlnaHRzaGFkZXI+XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1JlbmRlckFkYXB0ZXJGYWN0b3J5fSBmYWN0b3J5XHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxyXG4gKiBAZXh0ZW5kcyBSZW5kZXJBZGFwdGVyXHJcbiAqL1xyXG52YXIgTGlnaHRTaGFkZXJSZW5kZXJBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIFJlbmRlckFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcclxuICAgIHRoaXMuZGF0YUFkYXB0ZXIgPSBSZXNvdXJjZS5nZXRBZGFwdGVyKHRoaXMubm9kZSwgXCJkYXRhXCIpO1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhMaWdodFNoYWRlclJlbmRlckFkYXB0ZXIsIFJlbmRlckFkYXB0ZXIsIHtcclxuICAgIGdldERhdGFOb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCk7XHJcbiAgICB9LCBnZXRMaWdodFR5cGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2NyaXB0ID0gdGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcInNjcmlwdFwiKTtcclxuICAgICAgICBpZiAoc2NyaXB0LmluZGV4T2YoXCJ1cm46eG1sM2Q6bGlnaHRzaGFkZXI6XCIpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHQuc3Vic3RyaW5nKDIyLCBzY3JpcHQubGVuZ3RoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlVuc3VwcG9ydGVkIGxpZ2h0IHR5cGUgXCIgKyBzY3JpcHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9LCBub3RpZnlDaGFuZ2VkOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgc3dpdGNoIChldnQudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIEV2ZW50cy5USElTX1JFTU9WRUQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeU9wcG9zaXRlQWRhcHRlcnMoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEV2ZW50cy5WQUxVRV9NT0RJRklFRDpcclxuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5T3Bwb3NpdGVBZGFwdGVycyhFdmVudHMuQURBUFRFUl9WQUxVRV9DSEFOR0VEKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG4vLyBFeHBvcnRcclxubW9kdWxlLmV4cG9ydHMgPSBMaWdodFNoYWRlclJlbmRlckFkYXB0ZXI7XHJcblxyXG4iLCJ2YXIgVHJhbnNmb3JtYWJsZUFkYXB0ZXIgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1hYmxlLmpzXCIpO1xyXG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XHJcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL3Jlc291cmNlbWFuYWdlci5qc1wiKS5SZXNvdXJjZTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBNZXNoUmVuZGVyQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XHJcbiAgICBUcmFuc2Zvcm1hYmxlQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUsIHRydWUsIHRydWUpO1xyXG4gICAgdGhpcy5jcmVhdGVSZW5kZXJOb2RlKCk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhNZXNoUmVuZGVyQWRhcHRlciwgVHJhbnNmb3JtYWJsZUFkYXB0ZXIsIHtcclxuXHJcbiAgICBjcmVhdGVSZW5kZXJOb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGFBZGFwdGVyID0gUmVzb3VyY2UuZ2V0QWRhcHRlcih0aGlzLm5vZGUsIFwiZGF0YVwiKTtcclxuXHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50UmVuZGVyQWRhcHRlcigpO1xyXG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gcGFyZW50LmdldFJlbmRlck5vZGUgJiYgcGFyZW50LmdldFJlbmRlck5vZGUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gdGhpcy5nZXRTY2VuZSgpLmNyZWF0ZVJlbmRlck9iamVjdCh7XHJcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50Tm9kZSwgbm9kZTogdGhpcy5ub2RlLCBvYmplY3Q6IHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFBZGFwdGVyLmdldFhmbG93Tm9kZSgpLCB0eXBlOiB0aGlzLmdldE1lc2hUeXBlKClcclxuICAgICAgICAgICAgfSwgbmFtZTogdGhpcy5ub2RlLmlkLCB2aXNpYmxlOiAhdGhpcy5ub2RlLnZpc2libGUgPyBmYWxzZSA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTG9jYWxNYXRyaXgoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNoYWRlckhhbmRsZXIoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TWVzaFR5cGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmhhc0F0dHJpYnV0ZShcInR5cGVcIikgPyB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA6IFwidHJpYW5nbGVzXCI7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtFdmVudHMuTm90aWZpY2F0aW9ufSBldnRcclxuICAgICAqL1xyXG4gICAgbm90aWZ5Q2hhbmdlZDogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIFRyYW5zZm9ybWFibGVBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkLmNhbGwodGhpcywgZXZ0KTtcclxuICAgICAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgIEV2ZW50cy5OT0RFX0lOU0VSVEVEOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjYXNlIEV2ZW50cy5USElTX1JFTU9WRUQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY2FzZSBFdmVudHMuTk9ERV9SRU1PVkVEOlxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5jcmVhdGVQZXJPYmplY3REYXRhKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRzLlZBTFVFX01PRElGSUVEOlxyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZWQoZXZ0Lm11dGF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9LCAvKipcclxuICAgICAqIEBwYXJhbSB7TXV0YXRpb25FdmVudH0gZXZ0XHJcbiAgICAgKi9cclxuICAgIHZhbHVlQ2hhbmdlZDogZnVuY3Rpb24gKG11dGF0aW9uKSB7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IG11dGF0aW9uLmF0dHJpYnV0ZU5hbWU7XHJcbiAgICAgICAgc3dpdGNoICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgY2FzZSBcInNyY1wiOlxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlZCBieSBkYXRhIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwidHlwZVwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlLnNldFR5cGUobXV0YXRpb24udGFyZ2V0LmdldEF0dHJpYnV0ZShcInR5cGVcIikpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmdldFJlbmRlck5vZGUoKS5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLmNsZWFyQWRhcHRlckhhbmRsZXMoKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5cclxuLy8gSW50ZXJmYWNlIG1ldGhvZHNcclxuXHJcblhNTDNELmV4dGVuZChNZXNoUmVuZGVyQWRhcHRlci5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7V2luZG93LlhNTDNEQm94fVxyXG4gICAgICovXHJcbiAgICBnZXRMb2NhbEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyTm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgYmJveCA9IG5ldyBYTUwzRC5tYXRoLmJib3guY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZS5nZXRPYmplY3RTcGFjZUJvdW5kaW5nQm94KGJib3gpO1xyXG4gICAgICAgICAgICByZXR1cm4gWE1MM0QubWF0aC5iYm94LmFzWE1MM0RCb3goYmJveCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUwzREJveCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge1dpbmRvdy5YTUwzREJveH1cclxuICAgICAqL1xyXG4gICAgZ2V0V29ybGRCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlck5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGJib3ggPSBuZXcgWE1MM0QubWF0aC5iYm94LmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUuZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGJib3gpO1xyXG4gICAgICAgICAgICByZXR1cm4gWE1MM0QubWF0aC5iYm94LmFzWE1MM0RCb3goYmJveCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUwzREJveCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge1dpbmRvdy5YTUwzRE1hdHJpeH1cclxuICAgICAqL1xyXG4gICAgZ2V0V29ybGRNYXRyaXg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbSA9IG5ldyB3aW5kb3cuWE1MM0RNYXRyaXgoKSwgb2JqID0gdGhpcy5yZW5kZXJOb2RlO1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgb2JqLmdldFdvcmxkTWF0cml4KG0uX2RhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vLyBFeHBvcnRcclxubW9kdWxlLmV4cG9ydHMgPSBNZXNoUmVuZGVyQWRhcHRlcjtcclxuXHJcbiIsInZhciBUcmFuc2Zvcm1hYmxlQWRhcHRlciA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybWFibGUuanNcIik7XHJcbnZhciBDb21wdXRlUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5Db21wdXRlUmVxdWVzdDtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgUmVzb3VyY2UgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9yZXNvdXJjZW1hbmFnZXIuanNcIikuUmVzb3VyY2U7XHJcbnZhciBBZGFwdGVySGFuZGxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvYWRhcHRlcmhhbmRsZS5qc1wiKTtcclxuXHJcbnZhciBNb2RlbFJlbmRlckFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgVHJhbnNmb3JtYWJsZUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICB0aGlzLmFzc2V0ID0gbnVsbDtcclxuICAgIHRoaXMucG9zdFRyYW5zZm9ybVhmbG93UmVxdWVzdHMgPSBbXTtcclxuICAgIHRoaXMucG9zdFRyYW5zZm9ybVJlbmRlckdyb3VwcyA9IFtdO1xyXG4gICAgdGhpcy5jcmVhdGVSZW5kZXJOb2RlKCk7XHJcbiAgICB0aGlzLl9iaW5kZWRSZXF1ZXN0Q2FsbGJhY2sgPSB0aGlzLm9uWGZsb3dSZXF1ZXN0Q2hhbmdlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLnRyYW5zZm9ybUZldGNoZXIudXBkYXRlKCk7XHJcbn07XHJcblxyXG52YXIgY19JREVOVElUWSA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKE1vZGVsUmVuZGVyQWRhcHRlciwgVHJhbnNmb3JtYWJsZUFkYXB0ZXIsIHtcclxuXHJcbiAgICBjcmVhdGVSZW5kZXJOb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGFBZGFwdGVyID0gUmVzb3VyY2UuZ2V0QWRhcHRlcih0aGlzLm5vZGUsIFwiZGF0YVwiKTtcclxuICAgICAgICB0aGlzLmFzc2V0ID0gZGF0YUFkYXB0ZXIuZ2V0QXNzZXQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5hc3NldC5hZGRDaGFuZ2VMaXN0ZW5lcih0aGlzKTtcclxuXHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50UmVuZGVyQWRhcHRlcigpO1xyXG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gcGFyZW50LmdldFJlbmRlck5vZGUgJiYgcGFyZW50LmdldFJlbmRlck5vZGUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gdGhpcy5nZXRTY2VuZSgpLmNyZWF0ZVJlbmRlckdyb3VwKHtcclxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlLCB2aXNpYmxlOiB0aGlzLm5vZGUudmlzaWJsZSwgbmFtZTogdGhpcy5ub2RlLmlkXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlLnNldExvY2FsTWF0cml4KGNfSURFTlRJVFkpO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlTW9kZWxSZW5kZXJOb2RlcygpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhck1vZGVsUmVuZGVyTm9kZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNsZWFyQWRhcHRlckhhbmRsZXMoKTtcclxuICAgICAgICB0aGlzLl9zdWJSZW5kZXJOb2RlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5wb3N0VHJhbnNmb3JtWGZsb3dSZXF1ZXN0cy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLnBvc3RUcmFuc2Zvcm1YZmxvd1JlcXVlc3RzW2ldLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlY19yZW1vdmVSZW5kZXJOb2Rlcyh0aGlzLnJlbmRlck5vZGUsIHRydWUpO1xyXG4gICAgICAgIHRoaXMucG9zdFRyYW5zZm9ybVhmbG93UmVxdWVzdHMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLnBvc3RUcmFuc2Zvcm1SZW5kZXJHcm91cHMubGVuZ3RoID0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlTW9kZWxSZW5kZXJOb2RlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJNb2RlbFJlbmRlck5vZGVzKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFzc2V0LmlzU3VidHJlZUxvYWRpbmcoKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hc3NldC5jaGVja1ZhbGlkaXR5KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXNzZXRSZXN1bHQgPSB0aGlzLmFzc2V0LmdldFJlc3VsdCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFUcmVlID0gYXNzZXRSZXN1bHQuZ2V0RGF0YVRyZWUoKTtcclxuICAgICAgICAgICAgICAgIHJlY19jcmVhdGVSZW5kZXJOb2Rlcyh0aGlzLCB0aGlzLnJlbmRlck5vZGUsIGRhdGFUcmVlKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJBc3NldCBFcnJvcjogXCIgKyBlLm1lc3NhZ2UsIGUubm9kZSB8fCB0aGlzLm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhck1vZGVsUmVuZGVyTm9kZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TWF0ZXJpYWxDb25maWd1cmF0aW9uOiBmdW5jdGlvbiAoc2hhZGVySHJlZiwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICBpZiAoc2hhZGVySHJlZikge1xyXG4gICAgICAgICAgICB2YXIgYWRhcHRlckhhbmRsZSA9IHRoaXMuZ2V0QWRhcHRlckhhbmRsZShzaGFkZXJIcmVmKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0QWRhcHRlckhhbmRsZShcInNoYWRlcl9cIiArIGluZGV4LCBhZGFwdGVySGFuZGxlKTtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoYWRhcHRlckhhbmRsZS5zdGF0dXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORDpcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBmaW5kIDxzaGFkZXI+IG9mIHVybCAnXCIgKyBhZGFwdGVySGFuZGxlLnVybCArIFwiJyBcIiwgdGhpcy5ub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWRhcHRlckhhbmRsZS5TVEFUVVMuUkVBRFk6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkYXB0ZXIgPSBhZGFwdGVySGFuZGxlLmdldEFkYXB0ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRhcHRlciAmJiBhZGFwdGVyLmdldE1hdGVyaWFsQ29uZmlndXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhZGFwdGVyLmdldE1hdGVyaWFsQ29uZmlndXJhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWRhcHRlckhhbmRsZS5TVEFUVVMuTE9BRElORzpcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXZ0XHJcbiAgICAgKi9cclxuICAgIG5vdGlmeUNoYW5nZWQ6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICBUcmFuc2Zvcm1hYmxlQWRhcHRlci5wcm90b3R5cGUubm90aWZ5Q2hhbmdlZC5jYWxsKHRoaXMsIGV2dCk7XHJcbiAgICAgICAgc3dpdGNoIChldnQudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICBFdmVudHMuTk9ERV9JTlNFUlRFRDpcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY2FzZSBFdmVudHMuVEhJU19SRU1PVkVEOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRzLkFEQVBURVJfSEFORExFX0NIQU5HRUQ6XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXRzID0gZXZ0LmtleS5zcGxpdChcIl9cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRzWzBdID09IFwic2hhZGVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVuZGVyTm9kZUlkID0gK3NwbGl0c1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBpZGVudGlmeSB0aGUgY29ycmVzcG9uZGluZyByZW5kZXJub2RlIGJ5IHRoZSBoYW5kbGVyIGtleVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQgaWYgdGhlcmUgYXJlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIGNhbGxiYWNrcyBmb3JcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVuZGVyTm9kZSA9IHRoaXMuX3N1YlJlbmRlck5vZGVzW3JlbmRlck5vZGVJZF07XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcuYXNzZXJ0KHJlbmRlck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldnQuaGFuZGxlU3RhdHVzID09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJOb2RlLnNldE1hdGVyaWFsKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGFwdGVyID0gZXZ0LmFkYXB0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGFwdGVyICYmIGFkYXB0ZXIuZ2V0TWF0ZXJpYWxDb25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJOb2RlLnNldE1hdGVyaWFsKGFkYXB0ZXIuZ2V0TWF0ZXJpYWxDb25maWd1cmF0aW9uKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFjdG9yeS5yZW5kZXJlci5yZXF1ZXN0UmVkcmF3KFwiTWF0ZXJpYWwgbW9kZWwgY2hhbmdlZC5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkFzc2V0Q2hhbmdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgIGlmICghdGhpcy5yZW5kZXJOb2RlKSB7XHJcbiAgICAgICAgICAgIC8vVGhpcyBtb2RlbCBoYXNuJ3QgZXZlbiBiZWVuIGluaXRpYWxpemVkIHlldCBzbyB3ZSBkZWZlciBidWlsZGluZyB0aGUgcmVuZGVyIG5vZGVzIHRvIHRoYXQgc3RlcFxyXG4gICAgICAgICAgICAvL1RoaXMgY2FuIGhhcHBlbiBmb3IgZXguIHdoZW4gY2hhbmdpbmcgdGhlIFwic3JjXCIgYXR0cmlidXRlIGJlZm9yZSB0aGUgbW9kZWwgaXMgYXBwZW5kZWQgaW50byB0aGUgRE9NXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3JlYXRlTW9kZWxSZW5kZXJOb2RlcygpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblhmbG93UmVxdWVzdENoYW5nZTogZnVuY3Rpb24gKHJlcXVlc3QpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnBvc3RUcmFuc2Zvcm1YZmxvd1JlcXVlc3RzLmluZGV4T2YocmVxdWVzdCk7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUG9zdFRyYW5zZm9ybSh0aGlzLnBvc3RUcmFuc2Zvcm1SZW5kZXJHcm91cHNbaW5kZXhdLCByZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICB9LCB1cGRhdGVQb3N0VHJhbnNmb3JtOiBmdW5jdGlvbiAocmVuZGVyTm9kZSwgeGZsb3dSZXF1ZXN0KSB7XHJcbiAgICAgICAgdmFyIGRhdGFSZXN1bHQgPSB4Zmxvd1JlcXVlc3QuZ2V0UmVzdWx0KCk7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybURhdGEgPSAoZGF0YVJlc3VsdC5nZXRPdXRwdXREYXRhKFwidHJhbnNmb3JtXCIpICYmIGRhdGFSZXN1bHQuZ2V0T3V0cHV0RGF0YShcInRyYW5zZm9ybVwiKS5nZXRWYWx1ZSgpKTtcclxuICAgICAgICBpZiAoIXRyYW5zZm9ybURhdGEpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIlBvc3QgVHJhbnNmb3JtIGVudHJ5IGRvZXMgbm90IGNvbnRhaW4gYW55ICd0cmFuc2Zvcm0nIHZhbHVlLlwiLCB0aGlzLm5vZGUpO1xyXG4gICAgICAgICAgICByZW5kZXJOb2RlLnNldExvY2FsTWF0cml4KGNfSURFTlRJVFkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlck5vZGUuc2V0TG9jYWxNYXRyaXgodHJhbnNmb3JtRGF0YSk7XHJcbiAgICB9LCBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hc3NldC5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzKTtcclxuICAgICAgICB0aGlzLmNsZWFyTW9kZWxSZW5kZXJOb2RlcygpO1xyXG4gICAgICAgIHRoaXMuZ2V0UmVuZGVyTm9kZSgpLnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBZGFwdGVySGFuZGxlcygpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHJlY19yZW1vdmVSZW5kZXJOb2Rlcyhub2RlLCBrZWVwQ3VycmVudE5vZGUpIHtcclxuICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICgha2VlcEN1cnJlbnROb2RlKVxyXG4gICAgICAgIG5vZGUucmVtb3ZlKCk7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XHJcbiAgICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICByZWNfcmVtb3ZlUmVuZGVyTm9kZXMoY2hpbGRyZW5baV0sIGZhbHNlKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVjX2NyZWF0ZVJlbmRlck5vZGVzKGFkYXB0ZXIsIHBhcmVudE5vZGUsIGRhdGFUcmVlTm9kZSkge1xyXG5cclxuICAgIGlmIChkYXRhVHJlZU5vZGUucG9zdFRyYW5zZm9ybVhmbG93Tm9kZSkge1xyXG4gICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IENvbXB1dGVSZXF1ZXN0KGRhdGFUcmVlTm9kZS5wb3N0VHJhbnNmb3JtWGZsb3dOb2RlLCBbXCJ0cmFuc2Zvcm1cIl0sIGFkYXB0ZXIuX2JpbmRlZFJlcXVlc3RDYWxsYmFjayk7XHJcbiAgICAgICAgcGFyZW50Tm9kZSA9IGFkYXB0ZXIuZ2V0U2NlbmUoKS5jcmVhdGVSZW5kZXJHcm91cCh7XHJcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50Tm9kZSwgdmlzaWJsZTogdHJ1ZSwgbmFtZTogdW5kZWZpbmVkXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRhcHRlci5wb3N0VHJhbnNmb3JtWGZsb3dSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xyXG4gICAgICAgIGFkYXB0ZXIucG9zdFRyYW5zZm9ybVJlbmRlckdyb3Vwcy5wdXNoKHBhcmVudE5vZGUpO1xyXG4gICAgICAgIGFkYXB0ZXIudXBkYXRlUG9zdFRyYW5zZm9ybShwYXJlbnROb2RlLCByZXF1ZXN0KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZ3JvdXBOb2RlID0gYWRhcHRlci5nZXRTY2VuZSgpLmNyZWF0ZVJlbmRlckdyb3VwKHtcclxuICAgICAgICBwYXJlbnQ6IHBhcmVudE5vZGUsXHJcbiAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICBuYW1lOiBhZGFwdGVyLm5vZGUuaWRcclxuICAgIH0pO1xyXG4gICAgZ3JvdXBOb2RlLnNldExvY2FsTWF0cml4KGRhdGFUcmVlTm9kZS50cmFuc2Zvcm0gfHwgY19JREVOVElUWSk7XHJcbiAgICBncm91cE5vZGUuc2V0TWF0ZXJpYWwoYWRhcHRlci5nZXRNYXRlcmlhbENvbmZpZ3VyYXRpb24oZGF0YVRyZWVOb2RlLnNoYWRlciwgYWRhcHRlci5fc3ViUmVuZGVyTm9kZXMubGVuZ3RoKSk7XHJcbiAgICBhZGFwdGVyLl9zdWJSZW5kZXJOb2Rlcy5wdXNoKGdyb3VwTm9kZSk7XHJcblxyXG4gICAgdmFyIG1lc2hTZXRzID0gZGF0YVRyZWVOb2RlLm1lc2hlcywgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBtZXNoU2V0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciByZW5kZXJOb2RlID0gYWRhcHRlci5nZXRTY2VuZSgpLmNyZWF0ZVJlbmRlck9iamVjdCh7XHJcbiAgICAgICAgICAgIHBhcmVudDogZ3JvdXBOb2RlLFxyXG4gICAgICAgICAgICBub2RlOiBtZXNoU2V0c1tpXS5yZWZOb2RlIHx8IGFkYXB0ZXIubm9kZSxcclxuICAgICAgICAgICAgb2JqZWN0OiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBtZXNoU2V0c1tpXS54Zmxvd05vZGUsIHR5cGU6IG1lc2hTZXRzW2ldLnR5cGVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbmFtZTogYWRhcHRlci5ub2RlLmlkLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVuZGVyTm9kZS5zZXRMb2NhbE1hdHJpeChtZXNoU2V0c1tpXS50cmFuc2Zvcm0gfHwgY19JREVOVElUWSk7XHJcbiAgICAgICAgcmVuZGVyTm9kZS5zZXRNYXRlcmlhbChhZGFwdGVyLmdldE1hdGVyaWFsQ29uZmlndXJhdGlvbihtZXNoU2V0c1tpXS5zaGFkZXIsIGFkYXB0ZXIuX3N1YlJlbmRlck5vZGVzLmxlbmd0aCkpO1xyXG4gICAgICAgIGFkYXB0ZXIuX3N1YlJlbmRlck5vZGVzLnB1c2gocmVuZGVyTm9kZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgZ3JvdXBzID0gZGF0YVRyZWVOb2RlLmdyb3VwcztcclxuICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICByZWNfY3JlYXRlUmVuZGVyTm9kZXMoYWRhcHRlciwgZ3JvdXBOb2RlLCBncm91cHNbaV0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLy8gSW50ZXJmYWNlIG1ldGhvZHNcclxuXHJcblhNTDNELmV4dGVuZChNb2RlbFJlbmRlckFkYXB0ZXIucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge1dpbmRvdy5YTUwzREJveH1cclxuICAgICAqL1xyXG4gICAgZ2V0TG9jYWxCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlck5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGJib3ggPSBuZXcgWE1MM0QubWF0aC5iYm94LmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUuZ2V0T2JqZWN0U3BhY2VCb3VuZGluZ0JveChiYm94KTtcclxuICAgICAgICAgICAgcmV0dXJuIFhNTDNELm1hdGguYmJveC5hc1hNTDNEQm94KGJib3gpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MM0RCb3goKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtXaW5kb3cuWE1MM0RCb3h9XHJcbiAgICAgKi9cclxuICAgIGdldFdvcmxkQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJOb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBiYm94ID0gbmV3IFhNTDNELm1hdGguYmJveC5jcmVhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlLmdldFdvcmxkU3BhY2VCb3VuZGluZ0JveChiYm94KTtcclxuICAgICAgICAgICAgcmV0dXJuIFhNTDNELm1hdGguYmJveC5hc1hNTDNEQm94KGJib3gpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MM0RCb3goKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtXaW5kb3cuWE1MM0RNYXRyaXh9XHJcbiAgICAgKi9cclxuICAgIGdldFdvcmxkTWF0cml4OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG0gPSBuZXcgd2luZG93LlhNTDNETWF0cml4KCksIG9iaiA9IHRoaXMucmVuZGVyTm9kZTtcclxuICAgICAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgICAgIG9iai5nZXRXb3JsZE1hdHJpeChtLl9kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLy8gRXhwb3J0XHJcbm1vZHVsZS5leHBvcnRzID0gTW9kZWxSZW5kZXJBZGFwdGVyO1xyXG5cclxuIiwidmFyIFJlbmRlckFkYXB0ZXIgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xyXG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XHJcbnZhciBVUkkgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvdXJpLmpzXCIpLlVSSTtcclxudmFyIFJlc291cmNlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvcmVzb3VyY2VtYW5hZ2VyLmpzXCIpLlJlc291cmNlO1xyXG52YXIgQWRhcHRlckhhbmRsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2FkYXB0ZXJoYW5kbGUuanNcIik7XHJcblxyXG4vKipcclxuICogQHBhcmFtIGZhY3RvcnlcclxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXHJcbiAqIEBleHRlbmRzIFJlbmRlckFkYXB0ZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgU2hhZGVyUmVuZGVyQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XHJcbiAgICBSZW5kZXJBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICB0aGlzLl9kYXRhQWRhcHRlciA9IFJlc291cmNlLmdldEFkYXB0ZXIodGhpcy5ub2RlLCBcImRhdGFcIik7XHJcbiAgICAvKiogQHR5cGUgTWF0ZXJpYWxDb25maWd1cmF0aW9uIHwgbnVsbCAqKi9cclxuICAgIHRoaXMuX21hdGVyaWFsQ29uZmlndXJhdGlvbiA9IG51bGw7XHJcbiAgICB0aGlzLl9tYXRlcmlhbE1vZGVsID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsQ29uZmlndXJhdGlvbigpO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoU2hhZGVyUmVuZGVyQWRhcHRlciwgUmVuZGVyQWRhcHRlcik7XHJcblhNTDNELmV4dGVuZChTaGFkZXJSZW5kZXJBZGFwdGVyLnByb3RvdHlwZSwge1xyXG5cclxuICAgIGdldE1hdGVyaWFsQ29uZmlndXJhdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdGVyaWFsQ29uZmlndXJhdGlvbjtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlTWF0ZXJpYWxDb25maWd1cmF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRmlyc3QgZmluZCB0aGUgbW9kZWxcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsTW9kZWwoKTtcclxuICAgICAgICBpZiAoIXRoaXMuX21hdGVyaWFsTW9kZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWF0ZXJpYWxDb25maWd1cmF0aW9uID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXRlcmlhbENvbmZpZ3VyYXRpb24gPSB0aGlzLmdldFNjZW5lKCkuY3JlYXRlTWF0ZXJpYWxDb25maWd1cmF0aW9uKHRoaXMuX21hdGVyaWFsTW9kZWwsIHRoaXMuX2RhdGFBZGFwdGVyLmdldFhmbG93Tm9kZSgpLCB7bmFtZTogdGhpcy5ub2RlLmlkfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubm90aWZ5T3Bwb3NpdGVBZGFwdGVycygpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVNYXRlcmlhbE1vZGVsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWxNb2RlbCA9IG51bGw7XHJcblxyXG4gICAgICAgIHZhciB1cmkgPSB0aGlzLmdldFNoYWRlclNjcmlwdFVSSSgpO1xyXG4gICAgICAgIGlmICh1cmkuc2NoZW1lID09IFwidXJuXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWRhcHRlckhhbmRsZShcInNjcmlwdFwiKTtcclxuICAgICAgICAgICAgdGhpcy5fbWF0ZXJpYWxNb2RlbCA9IHsgXCJ0eXBlXCI6IFwidXJuXCIsIFwidXJuXCI6IHVyaSB9O1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3RBZGFwdGVySGFuZGxlKFwic2NyaXB0XCIsIHRoaXMuZ2V0QWRhcHRlckhhbmRsZSh1cmksIFwiZGF0YVwiLCAwKSk7XHJcbiAgICAgICAgdmFyIGFkYXB0ZXIgPSB0aGlzLmdldENvbm5lY3RlZEFkYXB0ZXIoJ3NjcmlwdCcpO1xyXG4gICAgICAgIGlmIChhZGFwdGVyICYmIGFkYXB0ZXIuZ2V0U2NyaXB0VHlwZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXRlcmlhbE1vZGVsID0geyB0eXBlOiBhZGFwdGVyLmdldFNjcmlwdFR5cGUoKSwgc2NyaXB0OiBhZGFwdGVyLmdldFNjcmlwdCgpIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTaGFkZXJTY3JpcHRVUkk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFVSSSh0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwic2NyaXB0XCIpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbm90aWZ5Q2hhbmdlZDogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHN3aXRjaCAoZXZ0LnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBFdmVudHMuVkFMVUVfTU9ESUZJRUQ6XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZ0Lm11dGF0aW9uLmF0dHJpYnV0ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNYXRlcmlhbENvbmZpZ3VyYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIlVuaGFuZGxlZCBtdXRhdGlvbiBldmVudCBpbiBzaGFkZXIgYWRhcHRlciBmb3IgcGFyYW1ldGVyICdcIiArIHRhcmdldCArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRzLkFEQVBURVJfSEFORExFX0NIQU5HRUQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZ0LmhhbmRsZVN0YXR1cyA9PSBBZGFwdGVySGFuZGxlLlNUQVRVUy5OT1RfRk9VTkQpIHtcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBmaW5kIG1hdGVyaWFsIGZvciB1cmwgJ1wiICsgZXZ0LnVybCArIFwiJ1wiKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsQ29uZmlndXJhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLy8gRXhwb3J0XHJcbm1vZHVsZS5leHBvcnRzID0gU2hhZGVyUmVuZGVyQWRhcHRlcjtcclxuXHJcbiIsInZhciBSZW5kZXJBZGFwdGVyID0gcmVxdWlyZShcIi4vYmFzZS5qc1wiKTtcclxudmFyIERPTVRyYW5zZm9ybUZldGNoZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vZGF0YS90cmFuc2Zvcm0tZmV0Y2hlci5qc1wiKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgQWRhcHRlckhhbmRsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2FkYXB0ZXJoYW5kbGUuanNcIik7XHJcblxyXG52YXIgVHJhbnNmb3JtYWJsZUFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSwgaGFuZGxlU2hhZGVyLCBoYW5kbGVUcmFuc2Zvcm0pIHtcclxuICAgIFJlbmRlckFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcclxuICAgIHRoaXMucmVuZGVyTm9kZSA9IG51bGw7XHJcbiAgICB0aGlzLnNoYWRlckhhbmRsZXIgPSBudWxsO1xyXG4gICAgdGhpcy5oYW5kbGVTaGFkZXIgPSBoYW5kbGVTaGFkZXIgfHwgZmFsc2U7XHJcbiAgICBpZiAoaGFuZGxlVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1GZXRjaGVyID0gbmV3IERPTVRyYW5zZm9ybUZldGNoZXIodGhpcywgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2Zvcm1cIik7XHJcbiAgICB9XHJcblxyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhUcmFuc2Zvcm1hYmxlQWRhcHRlciwgUmVuZGVyQWRhcHRlcik7XHJcblxyXG5YTUwzRC5leHRlbmQoVHJhbnNmb3JtYWJsZUFkYXB0ZXIucHJvdG90eXBlLCB7XHJcbiAgICB1cGRhdGVTaGFkZXJIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNoYWRlclVSSSA9IGdldFNoYWRlclVSSSh0aGlzLm5vZGUpO1xyXG4gICAgICAgIGlmICghc2hhZGVyVVJJKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFkYXB0ZXJIYW5kbGUoXCJzaGFkZXJcIik7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVySGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXJIYW5kbGVyID0gdGhpcy5nZXRBZGFwdGVySGFuZGxlKHNoYWRlclVSSSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdEFkYXB0ZXJIYW5kbGUoXCJzaGFkZXJcIiwgdGhpcy5zaGFkZXJIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VkU2hhZGVyQ2hhbmdlZCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZWZlcmVuY2VkU2hhZGVyQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5zaGFkZXJIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0UmVuZGVyTm9kZSgpLnNldE1hdGVyaWFsKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGF0dXMgPSB0aGlzLnNoYWRlckhhbmRsZXIuc3RhdHVzO1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORCkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGVsZW1lbnQgb2YgdXJsICdcIiArIHRoaXMuc2hhZGVySGFuZGxlci51cmwgKyBcIicgZm9yIHNoYWRlclwiLCB0aGlzLm5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmdldFJlbmRlck5vZGUoKS5zZXRNYXRlcmlhbChudWxsKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWRhcHRlciA9IHRoaXMuc2hhZGVySGFuZGxlci5nZXRBZGFwdGVyKCk7XHJcbiAgICAgICAgaWYgKGFkYXB0ZXIgJiYgYWRhcHRlci5nZXRNYXRlcmlhbENvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRSZW5kZXJOb2RlKCkuc2V0TWF0ZXJpYWwoYWRhcHRlci5nZXRNYXRlcmlhbENvbmZpZ3VyYXRpb24oKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRSZW5kZXJOb2RlKCkuc2V0TWF0ZXJpYWwobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybUZldGNoZXIgJiYgdGhpcy50cmFuc2Zvcm1GZXRjaGVyLmNsZWFyKCk7XHJcbiAgICB9LCBvbkNvbmZpZ3VyZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIH0sIGdldFJlbmRlck5vZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMucmVuZGVyTm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUgPSB0aGlzLmNyZWF0ZVJlbmRlck5vZGUgPyB0aGlzLmNyZWF0ZVJlbmRlck5vZGUoKSA6IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTG9jYWxNYXRyaXgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyTm9kZTtcclxuICAgIH0sIHVwZGF0ZUxvY2FsTWF0cml4OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1GZXRjaGVyICYmIHRoaXMudHJhbnNmb3JtRmV0Y2hlci51cGRhdGUoKTtcclxuICAgIH0sIG9uVHJhbnNmb3JtQ2hhbmdlOiBmdW5jdGlvbiAoYXR0ck5hbWUsIG1hdHJpeCkge1xyXG4gICAgICAgIGlmIChhdHRyTmFtZSA9PSBcInRyYW5zZm9ybVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZS5zZXRMb2NhbE1hdHJpeChtYXRyaXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICBub3RpZnlDaGFuZ2VkOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgaWYgKGV2dC50eXBlID09IEV2ZW50cy5WQUxVRV9NT0RJRklFRCkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZ0Lm11dGF0aW9uLmF0dHJpYnV0ZU5hbWU7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gXCJ0cmFuc2Zvcm1cIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1GZXRjaGVyICYmIHRoaXMudHJhbnNmb3JtRmV0Y2hlci51cGRhdGUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgPT0gXCJzdHlsZVwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUZldGNoZXIgJiYgdGhpcy50cmFuc2Zvcm1GZXRjaGVyLnVwZGF0ZU1hdHJpeCgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCA9PSBcInZpc2libGVcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gZXZ0Lm11dGF0aW9uLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ2aXNpYmxlXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlLnNldExvY2FsVmlzaWJsZShuZXdWYWx1ZSAmJiAobmV3VmFsdWUudG9Mb3dlckNhc2UoKSAhPT0gXCJmYWxzZVwiKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhY3RvcnkucmVuZGVyZXIucmVxdWVzdFJlZHJhdyhcIlRyYW5zZm9ybWFibGUgdmlzaWJpbGl0eSBjaGFuZ2VkLlwiKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgPT0gXCJzaGFkZXJcIiAmJiB0aGlzLmhhbmRsZVNoYWRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTaGFkZXJIYW5kbGVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhY3RvcnkucmVuZGVyZXIucmVxdWVzdFJlZHJhdyhcIlRyYW5zZm9ybWFibGUgc2hhZGVyIGNoYW5nZWQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChldnQudHlwZSA9PSBFdmVudHMuQURBUFRFUl9IQU5ETEVfQ0hBTkdFRCkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gZXZ0LmtleTtcclxuICAgICAgICAgICAgaWYgKGtleSA9PSBcInNoYWRlclwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNoYWRlckhhbmRsZXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmFjdG9yeS5yZW5kZXJlci5yZXF1ZXN0UmVkcmF3KFwiU2hhZGVyIHJlZmVyZW5jZSBjaGFuZ2VkLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBnZXRTaGFkZXJVUkkobm9kZSkge1xyXG4gICAgdmFyIHNoYWRlckhyZWYgPSBub2RlLnNoYWRlcjtcclxuICAgIGlmIChzaGFkZXJIcmVmID09IFwiXCIpIHtcclxuICAgICAgICB2YXIgc3R5bGVWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgICAgIGlmIChzdHlsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gL3NoYWRlclxccyo6XFxzKnVybFxccypcXChcXHMqKFxcUyspXFxzKlxcKS9pO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGF0dGVybi5leGVjKHN0eWxlVmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgc2hhZGVySHJlZiA9IHJlc3VsdFsxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2hhZGVySHJlZjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm1hYmxlQWRhcHRlcjtcclxuIiwidmFyIFRyYW5zZm9ybWFibGVBZGFwdGVyID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtYWJsZS5qc1wiKTtcclxudmFyIERPTVRyYW5zZm9ybUZldGNoZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vZGF0YS90cmFuc2Zvcm0tZmV0Y2hlci5qc1wiKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG5cclxudmFyIFZpZXdSZW5kZXJBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIFRyYW5zZm9ybWFibGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSwgZmFsc2UsIGZhbHNlKTtcclxuICAgIHRoaXMucGVyc3BlY3RpdmVGZXRjaGVyID0gbmV3IERPTVRyYW5zZm9ybUZldGNoZXIodGhpcywgXCJwZXJzcGVjdGl2ZVwiLCBcInBlcnNwZWN0aXZlXCIsIHRydWUpO1xyXG4gICAgdGhpcy5jcmVhdGVSZW5kZXJOb2RlKCk7XHJcbn07XHJcblhNTDNELmNyZWF0ZUNsYXNzKFZpZXdSZW5kZXJBZGFwdGVyLCBUcmFuc2Zvcm1hYmxlQWRhcHRlcik7XHJcbnZhciBwID0gVmlld1JlbmRlckFkYXB0ZXIucHJvdG90eXBlO1xyXG5cclxucC5jcmVhdGVSZW5kZXJOb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50UmVuZGVyQWRhcHRlcigpO1xyXG4gICAgdmFyIHBhcmVudE5vZGUgPSBwYXJlbnQuZ2V0UmVuZGVyTm9kZSA/IHBhcmVudC5nZXRSZW5kZXJOb2RlKCkgOiB0aGlzLmZhY3RvcnkucmVuZGVyZXIuc2NlbmUuY3JlYXRlUm9vdE5vZGUoKTtcclxuXHJcbiAgICB0aGlzLnJlbmRlck5vZGUgPSB0aGlzLmZhY3RvcnkucmVuZGVyZXIuc2NlbmUuY3JlYXRlUmVuZGVyVmlldyh7XHJcbiAgICAgICAgcG9zaXRpb246IHRoaXMubm9kZS5wb3NpdGlvbi5fZGF0YSxcclxuICAgICAgICBvcmllbnRhdGlvbjogdGhpcy5ub2RlLm9yaWVudGF0aW9uLnRvTWF0cml4KCkuX2RhdGEsXHJcbiAgICAgICAgZmllbGRPZlZpZXc6IHRoaXMubm9kZS5maWVsZE9mVmlldyxcclxuICAgICAgICBwYXJlbnQ6IHBhcmVudE5vZGVcclxuICAgIH0pO1xyXG4gICAgdGhpcy5wZXJzcGVjdGl2ZUZldGNoZXIudXBkYXRlKCk7XHJcbn07XHJcblxyXG4vKiBJbnRlcmZhY2UgbWV0aG9kICovXHJcbnAuZ2V0Vmlld01hdHJpeCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtID0gbmV3IHdpbmRvdy5YTUwzRE1hdHJpeCgpO1xyXG4gICAgdGhpcy5yZW5kZXJOb2RlLmdldFdvcmxkVG9WaWV3TWF0cml4KG0uX2RhdGEpO1xyXG4gICAgcmV0dXJuIG07XHJcbn07XHJcblxyXG4vKipcclxuICogcmV0dXJucyB2aWV3MndvcmxkIG1hdHJpeFxyXG4gKiBAcmV0dXJuIHt3aW5kb3cuWE1MM0RNYXRyaXh9XHJcbiAqL1xyXG5wLmdldFdvcmxkTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG0gPSBuZXcgd2luZG93LlhNTDNETWF0cml4KCk7XHJcbiAgICB0aGlzLnJlbmRlck5vZGUuZ2V0Vmlld1RvV29ybGRNYXRyaXgobS5fZGF0YSk7XHJcbiAgICByZXR1cm4gbTtcclxufTtcclxuXHJcbnAubm90aWZ5Q2hhbmdlZCA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgIHN3aXRjaCAoZXZ0LnR5cGUpIHtcclxuICAgICAgICBjYXNlIEV2ZW50cy5USElTX1JFTU9WRUQ6XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEV2ZW50cy5WQUxVRV9NT0RJRklFRDpcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2dC5tdXRhdGlvbi5hdHRyaWJ1dGVOYW1lO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJvcmllbnRhdGlvblwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZS51cGRhdGVPcmllbnRhdGlvbih0aGlzLm5vZGUub3JpZW50YXRpb24udG9NYXRyaXgoKS5fZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicG9zaXRpb25cIjpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUudXBkYXRlUG9zaXRpb24odGhpcy5ub2RlLnBvc2l0aW9uLl9kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJwZXJzcGVjdGl2ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyc3BlY3RpdmVGZXRjaGVyLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImZpZWxkT2ZWaWV3XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlLnVwZGF0ZUZpZWxkT2ZWaWV3KHRoaXMubm9kZS5maWVsZE9mVmlldyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJVbmhhbmRsZWQgdmFsdWUgY2hhbmdlZCBldmVudCBpbiB2aWV3IGFkYXB0ZXIgZm9yIGF0dHJpYnV0ZTpcIiArIHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICB0aGlzLmZhY3RvcnkuZ2V0UmVuZGVyZXIoKS5yZXF1ZXN0UmVkcmF3KFwiVmlldyBjaGFuZ2VkXCIpO1xyXG59O1xyXG5cclxucC5vblRyYW5zZm9ybUNoYW5nZSA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgbWF0cml4KSB7XHJcbiAgICBUcmFuc2Zvcm1hYmxlQWRhcHRlci5wcm90b3R5cGUub25UcmFuc2Zvcm1DaGFuZ2UuY2FsbCh0aGlzLCBhdHRyTmFtZSwgbWF0cml4KTtcclxuICAgIGlmIChhdHRyTmFtZSA9PSBcInBlcnNwZWN0aXZlXCIpIHtcclxuICAgICAgICB0aGlzLnJlbmRlck5vZGUuc2V0UHJvamVjdGlvbk92ZXJyaWRlKG1hdHJpeCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnAuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucGVyc3BlY3RpdmVGZXRjaGVyLmNsZWFyKCk7XHJcbiAgICB0aGlzLmdldFJlbmRlck5vZGUoKS5yZW1vdmUoKTtcclxuICAgIHRoaXMuY2xlYXJBZGFwdGVySGFuZGxlcygpO1xyXG59XHJcblxyXG4vLyBFeHBvcnRcclxubW9kdWxlLmV4cG9ydHMgPSBWaWV3UmVuZGVyQWRhcHRlcjtcclxuXHJcbiIsInZhciBSZW5kZXJBZGFwdGVyID0gcmVxdWlyZShcIi4vYmFzZS5qc1wiKTtcclxudmFyIFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xyXG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XHJcbnZhciBkaXNwYXRjaEN1c3RvbUV2ZW50ID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL21pc2MuanNcIikuZGlzcGF0Y2hDdXN0b21FdmVudDtcclxudmFyIGdldE9yQ3JlYXRlQWN0aXZlVmlldyA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9taXNjLmpzXCIpLmdldE9yQ3JlYXRlQWN0aXZlVmlldztcclxudmFyIFJlc291cmNlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvcmVzb3VyY2VtYW5hZ2VyLmpzXCIpLlJlc291cmNlO1xyXG5cclxudmFyIFhNTDNEUmVuZGVyQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XHJcbiAgICBSZW5kZXJBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICB0aGlzLmZpcmVMb2FkRXZlbnRBZnRlckRyYXcgPSBmYWxzZTtcclxuICAgIHRoaXMuZmlyc3RMb2FkRmlyZWQgPSBmYWxzZTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoWE1MM0RSZW5kZXJBZGFwdGVyLCBSZW5kZXJBZGFwdGVyKTtcclxuXHJcblhNTDNELmV4dGVuZChYTUwzRFJlbmRlckFkYXB0ZXIucHJvdG90eXBlLCB7XHJcbiAgICB1cGRhdGVBY3RpdmVWaWV3QWRhcHRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBocmVmID0gdGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcImFjdGl2ZVZpZXdcIik7XHJcbiAgICAgICAgaWYgKGhyZWYpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0QWRhcHRlckhhbmRsZShcImFjdGl2ZVZpZXdcIiwgdGhpcy5nZXRBZGFwdGVySGFuZGxlKGhyZWYpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBZGFwdGVySGFuZGxlKFwiYWN0aXZlVmlld1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBzZXRWaWV3QWRhcHRlcjogZnVuY3Rpb24gKGFkYXB0ZXIpIHtcclxuICAgICAgICBhZGFwdGVyID0gYWRhcHRlciB8fCB0aGlzLmdldENvbm5lY3RlZEFkYXB0ZXIoXCJhY3RpdmVWaWV3XCIpO1xyXG4gICAgICAgIGlmICghKGFkYXB0ZXIgJiYgYWRhcHRlci5nZXRSZW5kZXJOb2RlKSkge1xyXG4gICAgICAgICAgICB2YXIgdmlld0VsZW1lbnQgPSBnZXRPckNyZWF0ZUFjdGl2ZVZpZXcodGhpcy5ub2RlKTtcclxuICAgICAgICAgICAgYWRhcHRlciA9IHRoaXMuZmFjdG9yeS5nZXRBZGFwdGVyKHZpZXdFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mYWN0b3J5LmdldFNjZW5lKCkuc2V0QWN0aXZlVmlldyhhZGFwdGVyLmdldFJlbmRlck5vZGUoKSk7XHJcbiAgICB9LCBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckFkYXB0ZXJIYW5kbGVzKCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkID0gZnVuY3Rpb24gKGV2dCkge1xyXG5cclxuICAgIHN3aXRjaCAoZXZ0LnR5cGUpIHtcclxuICAgICAgICBjYXNlIEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEOlxyXG4gICAgICAgICAgICB0aGlzLnNldFZpZXdBZGFwdGVyKGV2dC5hZGFwdGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNhc2UgRXZlbnRzLk5PREVfSU5TRVJURUQ6XHJcbiAgICAgICAgICAgIC8vIFRoaXMgYWxzbyBpbml0aWFsaXplcyB0aGUgY2hpbGRyZW5cclxuICAgICAgICAgICAgdGhpcy5pbml0RWxlbWVudChldnQubXV0YXRpb24udGFyZ2V0KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNhc2UgRXZlbnRzLk5PREVfUkVNT1ZFRDpcclxuICAgICAgICAgICAgLy8gSGFuZGxlZCBpbiByZW1vdmVkIG5vZGVcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0YXJnZXQgPSBldnQubXV0YXRpb24uYXR0cmlidXRlTmFtZTtcclxuICAgIGlmICh0YXJnZXQgJiYgKHRhcmdldC50b0xvd2VyQ2FzZSgpID09PSBcImFjdGl2ZXZpZXdcIikpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZVZpZXdBZGFwdGVyKCk7XHJcbiAgICAgICAgdGhpcy5zZXRWaWV3QWRhcHRlcigpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyogSW50ZXJmYWNlIG1ldGhvZHMgKi9cclxuXHJcbi8qXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gc2NlbmUgRE9NIGlzIGxvYWRlZCBhbmQgYWxsIGFkYXB0ZXJzIGFyZSBhdHRhY2hlZFxyXG4gKi9cclxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5vbkNvbmZpZ3VyZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnVwZGF0ZUFjdGl2ZVZpZXdBZGFwdGVyKCk7XHJcbiAgICB0aGlzLnNldFZpZXdBZGFwdGVyKCk7XHJcblxyXG4gICAgLy8gZW1pdCBsb2FkIGV2ZW50IHdoZW4gYWxsIHJlc291cmNlcyBjdXJyZW50bHkgbG9hZGluZyBhcmUgY29tcGxldGVkXHJcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLm9uTG9hZENvbXBsZXRlLmJpbmQodGhpcyk7XHJcbiAgICAvLyByZWdpc3RlciBjYWxsYmFjayBmb3IgY2FudmFzSWQgPT0gMCBpLmUuIGdsb2JhbCByZXNvdXJjZXNcclxuICAgIFJlc291cmNlLmFkZExvYWRDb21wbGV0ZUxpc3RlbmVyKDAsIGNhbGxiYWNrKTtcclxuICAgIC8vIHJlZ2lzdGVyIGNhbGxiYWNrIGZvciBjYW52YXNJZCBvZiB0aGlzIG5vZGVcclxuICAgIFJlc291cmNlLmFkZExvYWRDb21wbGV0ZUxpc3RlbmVyKHRoaXMuZmFjdG9yeS5jYW52YXNJZCwgY2FsbGJhY2spO1xyXG4gICAgdGhpcy5vbkxvYWRDb21wbGV0ZSgpO1xyXG59O1xyXG5cclxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5vbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIChjYW52YXNJZCkge1xyXG4gICAgaWYgKFJlc291cmNlLmlzTG9hZENvbXBsZXRlKDApICYmIFJlc291cmNlLmlzTG9hZENvbXBsZXRlKHRoaXMuZmFjdG9yeS5jYW52YXNJZCkpIHtcclxuICAgICAgICB0aGlzLmZpcmVMb2FkRXZlbnRBZnRlckRyYXcgPSB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5vbkZyYW1lRHJhd24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5maXJlTG9hZEV2ZW50QWZ0ZXJEcmF3KSB7XHJcbiAgICAgICAgdGhpcy5maXJlTG9hZEV2ZW50QWZ0ZXJEcmF3ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5maXJzdExvYWRGaXJlZCA9IHRydWU7XHJcbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudCh0aGlzLm5vZGUsICdsb2FkJywgZmFsc2UsIHRydWUsIG51bGwpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblhNTDNEUmVuZGVyQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5maXJlTG9hZEV2ZW50QWZ0ZXJEcmF3KSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAoIXRoaXMuZmlyc3RMb2FkRmlyZWQpIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiBSZXNvdXJjZS5pc0xvYWRDb21wbGV0ZSgwKSAmJiBSZXNvdXJjZS5pc0xvYWRDb21wbGV0ZSh0aGlzLmZhY3RvcnkuY2FudmFzSWQpO1xyXG59O1xyXG5cclxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5nZXRXb3JsZEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGJib3ggPSBuZXcgd2luZG93LlhNTDNEQm94KCk7XHJcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHRoaXMubm9kZS5jaGlsZE5vZGVzLCBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgIGlmIChjLmdldFdvcmxkQm91bmRpbmdCb3gpXHJcbiAgICAgICAgICAgIGJib3guZXh0ZW5kKGMuZ2V0V29ybGRCb3VuZGluZ0JveCgpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGJib3g7XHJcbn07XHJcbi8vWE1MM0QgZWxlbWVudCBpcyB0aGUgcm9vdCB3aXRoIG5vIHRyYW5zZm9ybSBvZiBpdHMgb3duIHNvIGJ5IGRlZmluaXRpb24gaXQncyBhbHdheXMgaW4gd29ybGQgc3BhY2VcclxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kaW5nQm94ID0gWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5nZXRXb3JsZEJvdW5kaW5nQm94O1xyXG5cclxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5nZXRFbGVtZW50QnlQb2ludCA9IGZ1bmN0aW9uICh4LCB5LCBoaXRQb2ludCwgaGl0Tm9ybWFsKSB7XHJcbiAgICB2YXIgcmVsYXRpdmVNb3VzZVBvcyA9IFV0aWxzLmNvbnZlcnRQYWdlQ29vcmRzKHRoaXMubm9kZSwgeCwgeSk7XHJcblxyXG4gICAgdmFyIHJlbFggPSByZWxhdGl2ZU1vdXNlUG9zLng7XHJcbiAgICB2YXIgcmVsWSA9IHJlbGF0aXZlTW91c2VQb3MueTtcclxuXHJcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmZhY3RvcnkuZ2V0UmVuZGVyZXIoKTtcclxuICAgIHZhciBvYmplY3QgPSByZW5kZXJlci5nZXRSZW5kZXJPYmplY3RGcm9tUGlja2luZ0J1ZmZlcihyZWxYLCByZWxZKTtcclxuICAgIGlmIChvYmplY3QpIHtcclxuICAgICAgICBpZiAoaGl0UG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIHZlYyA9IHJlbmRlcmVyLmdldFdvcmxkU3BhY2VQb3NpdGlvbkJ5UG9pbnQocmVsWCwgcmVsWSwgb2JqZWN0KTtcclxuICAgICAgICAgICAgaGl0UG9pbnQuc2V0KHZlY1swXSwgdmVjWzFdLCB2ZWNbMl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGl0Tm9ybWFsKSB7XHJcbiAgICAgICAgICAgIHZhciB2ZWMgPSByZW5kZXJlci5nZXRXb3JsZFNwYWNlTm9ybWFsQnlQb2ludChyZWxYLCByZWxZLCBvYmplY3QpO1xyXG4gICAgICAgICAgICBoaXROb3JtYWwuc2V0KHZlY1swXSwgdmVjWzFdLCB2ZWNbMl0pO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGhpdFBvaW50KSBoaXRQb2ludC5zZXQoTmFOLCBOYU4sIE5hTik7XHJcbiAgICAgICAgaWYgKGhpdE5vcm1hbCkgaGl0Tm9ybWFsLnNldChOYU4sIE5hTiwgTmFOKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvYmplY3QgPyBvYmplY3Qubm9kZSA6IG51bGw7XHJcbn07XHJcblxyXG5YTUwzRFJlbmRlckFkYXB0ZXIucHJvdG90eXBlLmdldFJlbmRlckludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmZhY3RvcnkuZ2V0UmVuZGVyZXIoKS5nZXRSZW5kZXJJbnRlcmZhY2UoKTtcclxufTtcclxuXHJcblhNTDNEUmVuZGVyQWRhcHRlci5wcm90b3R5cGUuZ2VuZXJhdGVSYXkgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgdmFyIHJlbGF0aXZlTW91c2VQb3MgPSBVdGlscy5jb252ZXJ0UGFnZUNvb3Jkcyh0aGlzLm5vZGUsIHgsIHkpO1xyXG4gICAgcmV0dXJuIHRoaXMuZmFjdG9yeS5nZXRSZW5kZXJlcigpLmdlbmVyYXRlUmF5KHJlbGF0aXZlTW91c2VQb3MueCwgcmVsYXRpdmVNb3VzZVBvcy55KTtcclxufTtcclxuXHJcblhNTDNEUmVuZGVyQWRhcHRlci5wcm90b3R5cGUuZ2V0RWxlbWVudEJ5UmF5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBjX3ZpZXdNYXQgPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICB2YXIgY19wcm9qTWF0ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoeG1sM2RSYXksIGhpdFBvaW50LCBoaXROb3JtYWwpIHtcclxuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmZhY3RvcnkuZ2V0UmVuZGVyZXIoKTtcclxuICAgICAgICByZW5kZXJlci5jYWxjdWxhdGVNYXRyaWNlc0ZvclJheSh4bWwzZFJheSwgY192aWV3TWF0LCBjX3Byb2pNYXQpO1xyXG4gICAgICAgIHZhciBoaXRPYmplY3QgPSByZW5kZXJlci5nZXRSZW5kZXJPYmplY3RCeVJheSh4bWwzZFJheSwgY192aWV3TWF0LCBjX3Byb2pNYXQpO1xyXG4gICAgICAgIGlmIChoaXRPYmplY3QgIT09IG51bGwgJiYgKGhpdFBvaW50IHx8IGhpdE5vcm1hbCkpIHtcclxuICAgICAgICAgICAgaWYgKGhpdFBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVjID0gcmVuZGVyZXIuZ2V0V29ybGRTcGFjZVBvc2l0aW9uQnlSYXkoeG1sM2RSYXksIGhpdE9iamVjdCwgY192aWV3TWF0LCBjX3Byb2pNYXQpO1xyXG4gICAgICAgICAgICAgICAgaGl0UG9pbnQuc2V0KHZlY1swXSwgdmVjWzFdLCB2ZWNbMl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoaXROb3JtYWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ZWMgPSByZW5kZXJlci5nZXRXb3JsZFNwYWNlTm9ybWFsQnlSYXkoeG1sM2RSYXksIGhpdE9iamVjdCwgY192aWV3TWF0LCBjX3Byb2pNYXQpO1xyXG4gICAgICAgICAgICAgICAgaGl0Tm9ybWFsLnNldCh2ZWNbMF0sIHZlY1sxXSwgdmVjWzJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChoaXRQb2ludCkgaGl0UG9pbnQuc2V0KE5hTiwgTmFOLCBOYU4pO1xyXG4gICAgICAgICAgICBpZiAoaGl0Tm9ybWFsKSBoaXROb3JtYWwuc2V0KE5hTiwgTmFOLCBOYU4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGl0T2JqZWN0ICE9PSBudWxsID8gaGl0T2JqZWN0Lm5vZGUgOiBudWxsO1xyXG4gICAgfVxyXG59KSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYTUwzRFJlbmRlckFkYXB0ZXI7XHJcblxyXG5cclxuIiwidmFyIE1vdXNlRXZlbnRzID0gcmVxdWlyZShcIi4vZXZlbnRzL21vdXNlLmpzXCIpO1xyXG52YXIgVG91Y2hFdmVudHMgPSByZXF1aXJlKFwiLi9ldmVudHMvdG91Y2guanNcIik7XHJcblxyXG52YXIgY19nbG9iYWxDYW52YXNJZCA9IDA7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtFbGVtZW50fSB4bWwzZEVsZW1lbnRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBBYnN0cmFjdENhbnZhc0hhbmRsZXIoeG1sM2RFbGVtZW50LCBjYW52YXMpIHtcclxuICAgIHRoaXMuX3htbDNkRWxlbWVudCA9IHhtbDNkRWxlbWVudDtcclxuICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcclxuICAgIHRoaXMuaWQgPSArK2NfZ2xvYmFsQ2FudmFzSWQ7IC8vIGdsb2JhbCBjYW52YXMgaWQgc3RhcnRzIGF0IDFcclxuXHJcbiAgICB0aGlzLl9tb3VzZUhhbmRsZXIgPSBuZXcgTW91c2VFdmVudHMuTW91c2VFdmVudEhhbmRsZXIoeG1sM2RFbGVtZW50LCB0aGlzKTtcclxuICAgIHRoaXMuX3JlZ2lzdGVyQ2FudmFzTGlzdGVuZXJzKHRoaXMuX21vdXNlSGFuZGxlciwgTW91c2VFdmVudHMuRVZFTlRTKTtcclxuICAgIGlmKHRoaXMuaGFzVG91Y2hFdmVudHMoKSkge1xyXG4gICAgICAgIHRoaXMuX3RvdWNoSGFuZGxlciA9IG5ldyBUb3VjaEV2ZW50cy5Ub3VjaEV2ZW50SGFuZGxlcih4bWwzZEVsZW1lbnQsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyQ2FudmFzTGlzdGVuZXJzKHRoaXMuX3RvdWNoSGFuZGxlciwgVG91Y2hFdmVudHMuRVZFTlRTKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuQWJzdHJhY3RDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5oYXNUb3VjaEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcclxufTtcclxuXHJcbkFic3RyYWN0Q2FudmFzSGFuZGxlci5wcm90b3R5cGUuZ2V0Q2FudmFzID0gZnVuY3Rpb24oKSB7XHJcbiAgIHJldHVybiB0aGlzLl9jYW52YXM7XHJcbn07XHJcblxyXG5BYnN0cmFjdENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgdGhpcy5feG1sM2RFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG59O1xyXG5cclxuQWJzdHJhY3RDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5fcmVnaXN0ZXJDYW52YXNMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoaGFuZGxlciwgZXZlbnRzKSB7XHJcbiAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xyXG4gICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBoYW5kbGVyW25hbWVdICYmIGhhbmRsZXJbbmFtZV0uY2FsbChoYW5kbGVyLCBlKTtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuQWJzdHJhY3RDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5kaXNwYXRjaEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24odHlwZSwgZGV0YWlsKSB7XHJcbiAgICBkZXRhaWwgPSBkZXRhaWwgfHwgbnVsbDtcclxuICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xyXG4gICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIHRydWUsIHRydWUsIGRldGFpbCk7XHJcbiAgICB0aGlzLl94bWwzZEVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSB1cGRhdGUgZXZlbnQgY2FuIGJlIHVzZWQgYnkgdXNlciB0byBzeW5jIGFjdGlvbnNcclxuICogd2l0aCByZW5kZXJpbmdcclxuICovXHJcbkFic3RyYWN0Q2FudmFzSGFuZGxlci5wcm90b3R5cGUuZGlzcGF0Y2hVcGRhdGVFdmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZGlzcGF0Y2hDdXN0b21FdmVudChcInVwZGF0ZVwiKTtcclxufTtcclxuXHJcblxyXG5BYnN0cmFjdENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmRpc3BhdGNoUmVzaXplRXZlbnQgPSBmdW5jdGlvbiAoZGltZW5zaW9ucykge1xyXG4gICAgdGhpcy5kaXNwYXRjaEN1c3RvbUV2ZW50KFwicmVzaXplXCIsIGRpbWVuc2lvbnMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERpc3BhdGNoZXMgYSBGcmFtZURyYXduRXZlbnQgdG8gbGlzdGVuZXJzXHJcbiAqXHJcbiAqIEBwYXJhbSBzdGFydFxyXG4gKiBAcGFyYW0gZW5kXHJcbiAqIEBwYXJhbSBzdGF0c1xyXG4gKiBAcmV0dXJuXHJcbiAqL1xyXG5BYnN0cmFjdENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmRpc3BhdGNoRnJhbWVEcmF3bkV2ZW50ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHN0YXRzKSB7XHJcbiAgICBzdGF0cyA9IHN0YXRzIHx8IHtcclxuICAgICAgICBjb3VudDoge1xyXG4gICAgICAgICAgICBwcmltaXRpdmVzOiAwLCBvYmplY3RzOiAwXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBkYXRhID0ge1xyXG4gICAgICAgIHRpbWVTdGFydDogc3RhcnQsIHRpbWVFbmQ6IGVuZCwgcmVuZGVyVGltZUluTWlsbGlzZWNvbmRzOiBlbmQgLSBzdGFydCwgY291bnQ6IHN0YXRzLmNvdW50XHJcbiAgICB9O1xyXG4gICAgdGhpcy5kaXNwYXRjaEN1c3RvbUV2ZW50KFwiZnJhbWVkcmF3blwiLCBkYXRhKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RDYW52YXNIYW5kbGVyO1xyXG4iLCJ2YXIgUmVuZGVyQWRhcHRlckZhY3RvcnkgPSByZXF1aXJlKFwiLi9hZGFwdGVyL2ZhY3RvcnkuanNcIik7XHJcbnZhciB4bWwzZEZvcm1hdEhhbmRsZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9mb3JtYXRoYW5kbGVyLmpzXCIpLnhtbDNkRm9ybWF0SGFuZGxlcjtcclxuXHJcbnhtbDNkRm9ybWF0SGFuZGxlci5yZWdpc3RlckZhY3RvcnlDbGFzcyhSZW5kZXJBZGFwdGVyRmFjdG9yeSk7XHJcblxyXG52YXIgZmFjdG9yeSA9IHJlcXVpcmUoXCIuL3JlbmRlcmVyLWZhY3RvcnkuanNcIik7XHJcblxyXG52YXIgY29uZmlndXJlID0gZnVuY3Rpb24oeG1sM2RzKSB7XHJcbiAgICBpZiAoISh4bWwzZHMgaW5zdGFuY2VvZiBBcnJheSkpXHJcbiAgICAgICAgeG1sM2RzID0gW3htbDNkc107XHJcblxyXG4gICAgeG1sM2RzLmZvckVhY2goZnVuY3Rpb24oeG1sM2RFbGVtZW50KSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJDb25maWd1cmluZyBSZW5kZXJlciBmb3JcIiwgeG1sM2RFbGVtZW50LmlkKTtcclxuICAgICAgICB2YXIgcmVuZGVyZXIgPSBmYWN0b3J5LmNyZWF0ZVJlbmRlcmVyKHhtbDNkRWxlbWVudClcclxuXHJcbiAgICB9KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY29uZmlndXJlOyIsInZhciBPcHRpb25zID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL29wdGlvbnMuanNcIik7XHJcblxyXG52YXIgT1BUSU9OX01PVVNFTU9WRV9QSUNLSU5HID0gXCJyZW5kZXJlci1tb3VzZW1vdmUtcGlja2luZ1wiO1xyXG52YXIgT1BUSU9OX01PVkVNRU5UX0FXQVJFX0NMSUNLX0hBTkRMRVIgPSBcInJlbmRlcmVyLW1vdmVtZW50LWF3YXJlLWNsaWNrLWhhbmRsZXJcIjtcclxuT3B0aW9ucy5yZWdpc3RlcihPUFRJT05fTU9VU0VNT1ZFX1BJQ0tJTkcsIHRydWUpO1xyXG5PcHRpb25zLnJlZ2lzdGVyKE9QVElPTl9NT1ZFTUVOVF9BV0FSRV9DTElDS19IQU5ETEVSLCBmYWxzZSk7XHJcblxyXG52YXIgRVZFTlRTID0gW1wiY2xpY2tcIiwgXCJkYmxjbGlja1wiLCBcIm1vdXNlZG93blwiLCBcIm1vdXNldXBcIiwgXCJtb3VzZW92ZXJcIiwgXCJtb3VzZW1vdmVcIiwgXCJtb3VzZW91dFwiLCBcIndoZWVsXCJdO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZGVmYXVsdFRhcmdldFxyXG4gKiBAcGFyYW0ge0Fic3RyYWN0Q2FudmFzSGFuZGxlcn0gY2FudmFzSGFuZGxlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBNb3VzZUV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uKGRlZmF1bHRUYXJnZXQsIGNhbnZhc0hhbmRsZXIpIHtcclxuICAgIHRoaXMuX2RlZmF1bHRUYXJnZXQgPSBkZWZhdWx0VGFyZ2V0O1xyXG4gICAgdGhpcy5fY2FudmFzSGFuZGxlciA9IGNhbnZhc0hhbmRsZXI7XHJcbiAgICB0aGlzLl9sYXN0TW91c2VQb3NpdGlvbiA9ICB7eDogMCwgeTogMH07XHJcbn07XHJcblxyXG52YXIgc3VwcG9ydHNFdmVudENvbnN0cnVjdG9ycyA9IChmdW5jdGlvbigpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiLCB7fSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn0pKCk7XHJcblxyXG5Nb3VzZUV2ZW50SGFuZGxlci5wcm90b3R5cGUgPSAge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAgVGhlIG9yaWdpbmFsIGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAgdGFyZ2V0IHRvIGRpc3BhdGNoIG9uXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdD99ICAgICBvcHQgICAgT3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBkaXNwYXRjaE1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0LCBvcHQpIHtcclxuICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHRoaXMuX2RlZmF1bHRUYXJnZXQ7XHJcbiAgICAgICAgdmFyIHggPSBvcHQueCAhPT0gdW5kZWZpbmVkID8gb3B0LnggOiBldmVudC5jbGllbnRYO1xyXG4gICAgICAgIHZhciB5ID0gb3B0LnkgIT09IHVuZGVmaW5lZCA/IG9wdC55IDogZXZlbnQuY2xpZW50WTtcclxuICAgICAgICB2YXIgbm9Db3B5ID0gb3B0Lm5vQ29weSB8fCBmYWxzZTtcclxuICAgICAgICAvLyBDb3B5IGV2ZW50IHRvIGF2b2lkIERPTSBkaXNwYXRjaCBlcnJvcnMgKGNhbm5vdCBkaXNwYXRjaCBldmVudCBtb3JlXHJcbiAgICAgICAgLy8gdGhhbiBvbmNlKVxyXG4gICAgICAgIGlmICghbm9Db3B5KSB7XHJcbiAgICAgICAgICAgIGV2ZW50ID0gdGhpcy5jb3B5TW91c2VFdmVudChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5pdEV4dGVuZGVkTW91c2VFdmVudChldmVudCwgeCwgeSk7XHJcblxyXG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR8V2hlZWxFdmVudH0gZXZlbnQgdGhlIGV2ZW50IHRvIGNvcHlcclxuICAgICAqIEByZXR1cm4ge01vdXNlRXZlbnR9IHRoZSBuZXcgZXZlbnRcclxuICAgICAqL1xyXG4gICAgY29weU1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciBldnQ7XHJcbiAgICAgICAgaWYgKHN1cHBvcnRzRXZlbnRDb25zdHJ1Y3RvcnMpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnRvU3RyaW5nKCkgPT09IFwiW29iamVjdCBXaGVlbEV2ZW50XVwiKSB7XHJcbiAgICAgICAgICAgICAgICBldnQgPSBuZXcgV2hlZWxFdmVudChldmVudC50eXBlLCBldmVudCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBldnQgPSBuZXcgTW91c2VFdmVudChldmVudC50eXBlLCBldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL1RoZXNlIGV2ZW50IEFQSXMgYXJlIGRlcHJlY2F0ZWQgYnV0IHN0aWxsIHJlcXVpcmVkIGJ5IElFLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgZXZlbnQgY29uc3RydWN0b3JzIHlldFxyXG4gICAgICAgICAgICBpZiAoZXZlbnQudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IFdoZWVsRXZlbnRdXCIpIHtcclxuICAgICAgICAgICAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiV2hlZWxFdmVudFwiKTtcclxuICAgICAgICAgICAgICAgIGV2dC5pbml0V2hlZWxFdmVudChldmVudC50eXBlLCBldmVudC5idWJibGVzLCBldmVudC5jYW5jZWxhYmxlLCBldmVudC52aWV3LCBldmVudC5kZXRhaWwsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc2NyZWVuWCwgZXZlbnQuc2NyZWVuWSwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSwgZXZlbnQuYnV0dG9uLCBldmVudC5yZWxhdGVkVGFyZ2V0LCBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRlbHRhWCwgZXZlbnQuZGVsdGFZLCBldmVudC5kZWx0YVosIGV2ZW50LmRlbHRhTW9kZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIik7XHJcbiAgICAgICAgICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQoZXZlbnQudHlwZSwgZXZlbnQuYnViYmxlcywgZXZlbnQuY2FuY2VsYWJsZSwgZXZlbnQudmlldywgZXZlbnQuZGV0YWlsLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnNjcmVlblgsIGV2ZW50LnNjcmVlblksIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFksIGV2ZW50LmN0cmxLZXksIGV2ZW50LmFsdEtleSxcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5zaGlmdEtleSwgZXZlbnQubWV0YUtleSwgZXZlbnQuYnV0dG9uLCBldmVudC5yZWxhdGVkVGFyZ2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnQuZGF0YVRyYW5zZmVyKVxyXG4gICAgICAgICAgICBldnQuZGF0YSA9IHt1cmw6IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwiVVJMXCIpLCB0ZXh0OiBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlRleHRcIil9O1xyXG4gICAgICAgIC8vIG92ZXJyaWRlIHByZXZlbnREZWZhdWx0IHRvIGFjdHVhbGx5IHByZXZlbnQgdGhlIGRlZmF1bHQgb2YgdGhlIG9yaWdpbmFsIGV2ZW50XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGV2dDtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlTW91c2VFdmVudDogZnVuY3Rpb24gKHR5cGUsIG9wdHMpIHtcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcclxuICAgICAgICB2YXIgZGljdCA9IHtcclxuICAgICAgICAgICAgYnViYmxlc1x0XHQ6IG9wdHMuYnViYmxlcyAhPT0gdW5kZWZpbmVkID8gb3B0cy5idWJibGVzIDogdHJ1ZSxcclxuICAgICAgICAgICAgY2FuY2VsYWJsZSBcdDogb3B0cy5jYW5jZWxhYmxlICE9PSB1bmRlZmluZWQgPyBvcHRzLmNhbmNlbGFibGUgOiB0cnVlLFxyXG4gICAgICAgICAgICB2aWV3IFx0XHQ6IG9wdHMudmlldyB8fCB3aW5kb3csXHJcbiAgICAgICAgICAgIGRldGFpbCBcdFx0OiBvcHRzLmRldGFpbCAhPT0gdW5kZWZpbmVkID8gb3B0cy5kZXRhaWwgOiAwLFxyXG4gICAgICAgICAgICBzY3JlZW5YXHRcdDogb3B0cy5zY3JlZW5YICE9PSB1bmRlZmluZWQgPyBvcHRzLnNjcmVlblggOiAwLFxyXG4gICAgICAgICAgICBzY3JlZW5ZXHRcdDogb3B0cy5zY3JlZW5ZICE9PSB1bmRlZmluZWQgPyBvcHRzLnNjcmVlblkgOiAwLFxyXG4gICAgICAgICAgICBjbGllbnRYXHRcdDogb3B0cy5jbGllbnRYICE9PSB1bmRlZmluZWQgPyBvcHRzLmNsaWVudFggOiAwLFxyXG4gICAgICAgICAgICBjbGllbnRZXHRcdDogb3B0cy5jbGllbnRZICE9PSB1bmRlZmluZWQgPyBvcHRzLmNsaWVudFkgOiAwLFxyXG4gICAgICAgICAgICBjdHJsIFx0XHQ6IG9wdHMuY3RybCAhPT0gdW5kZWZpbmVkID8gb3B0cy5jdHJsIDogZmFsc2UsXHJcbiAgICAgICAgICAgIGFsdCBcdFx0OiBvcHRzLmFsdCAhPT0gdW5kZWZpbmVkID8gb3B0cy5hbHQgOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hpZnQgXHRcdDogb3B0cy5zaGlmdCAhPT0gdW5kZWZpbmVkID8gb3B0cy5zaGlmdCA6IGZhbHNlLFxyXG4gICAgICAgICAgICBtZXRhIFx0XHQ6IG9wdHMubWV0YSAhPT0gdW5kZWZpbmVkID8gb3B0cy5tZXRhIDogZmFsc2UsXHJcbiAgICAgICAgICAgIGJ1dHRvbiBcdFx0OiBvcHRzLmJ1dHRvbiAhPT0gdW5kZWZpbmVkID8gb3B0cy5idXR0b24gOiAwLFxyXG4gICAgICAgICAgICByZWxhdGVkVGFyZ2V0IDogb3B0cy5yZWxhdGVkVGFyZ2V0XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoc3VwcG9ydHNFdmVudENvbnN0cnVjdG9ycykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vdXNlRXZlbnQodHlwZSwgZGljdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtcclxuICAgICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KHR5cGUsIGRpY3QuYnViYmxlcywgZGljdC5jYW5jZWxhYmxlLCBkaWN0LnZpZXcsIGRpY3QuZGV0YWlsLFxyXG4gICAgICAgICAgICAgICAgZGljdC5zY3JlZW5YLCBkaWN0LnNjcmVlblksIGRpY3QuY2xpZW50WCwgZGljdC5jbGllbnRZLCBkaWN0LmN0cmxLZXksIGRpY3QuYWx0S2V5LFxyXG4gICAgICAgICAgICAgICAgZGljdC5zaGlmdEtleSwgZGljdC5tZXRhS2V5LCBkaWN0LmJ1dHRvbiwgZGljdC5yZWxhdGVkVGFyZ2V0KTtcclxuICAgICAgICAgICAgcmV0dXJuIGV2dDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBwb3NpdGlvbiBhbmQgbm9ybWFsIGF0dHJpYnV0ZXMgdG8gdGhlIGdpdmVuIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgICAqIEByZXR1cm4ge1hNTDNEVmVjM31cclxuICAgICAqL1xyXG4gICAgaW5pdEV4dGVuZGVkTW91c2VFdmVudDogZnVuY3Rpb24gKGV2ZW50LCB4LCB5KSB7XHJcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9jYW52YXNIYW5kbGVyO1xyXG5cclxuICAgICAgICAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY2FjaGVkUG9zaXRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHZhciBjYWNoZWROb3JtYWwgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICBldmVudC5fX2RlZmluZUdldHRlcl9fKFwibm9ybWFsXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWROb3JtYWwgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGNhY2hlZE5vcm1hbDtcclxuICAgICAgICAgICAgICAgIHZhciBub3JtID0gKGhhbmRsZXIuZ2V0V29ybGRTcGFjZU5vcm1hbEJ5UG9pbnQoeCwgeSkpO1xyXG4gICAgICAgICAgICAgICAgY2FjaGVkTm9ybWFsID0gbm9ybSA/IG5ldyB3aW5kb3cuWE1MM0RWZWMzKG5vcm1bMF0sIG5vcm1bMV0sIG5vcm1bMl0pIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWROb3JtYWw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBldmVudC5fX2RlZmluZUdldHRlcl9fKFwicG9zaXRpb25cIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZWRQb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBoYW5kbGVyLmdldFdvcmxkU3BhY2VQb3NpdGlvbkJ5UG9pbnQoeCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkUG9zaXRpb24gPSBwb3MgPyBuZXcgd2luZG93LlhNTDNEVmVjMyhwb3NbMF0sIHBvc1sxXSwgcG9zWzJdKSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUG9zaXRpb247XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldnRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0P30gb3B0XHJcbiAgICAgKi9cclxuICAgIGRpc3BhdGNoTW91c2VFdmVudE9uUGlja2VkT2JqZWN0OiBmdW5jdGlvbiAoZXZ0LCBvcHQpIHtcclxuICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldnQpO1xyXG5cclxuICAgICAgICB2YXIgcGlja2VkID0gbnVsbDtcclxuICAgICAgICBpZiAoIW9wdC5vbWl0VXBkYXRlKVxyXG4gICAgICAgICAgICBwaWNrZWQgPSB0aGlzLl9jYW52YXNIYW5kbGVyLmdldFBpY2tPYmplY3RCeVBvaW50KHBvcy54LCBwb3MueSk7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hNb3VzZUV2ZW50KGV2dCwgcGlja2VkICYmIHBpY2tlZC5ub2RlLCBwb3MpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRNb3VzZVBvc2l0aW9uOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc0hhbmRsZXIuZ2V0TW91c2VQb3NpdGlvbihldnQpXHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZ0XHJcbiAgICAgKi9cclxuICAgIG1vdXNldXA6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoTW91c2VFdmVudE9uUGlja2VkT2JqZWN0KGV2dCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldnRcclxuICAgICAqL1xyXG4gICAgbW91c2Vkb3duOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgdGhpcy5fbGFzdE1vdXNlUG9zaXRpb24gPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZ0KTtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoTW91c2VFdmVudE9uUGlja2VkT2JqZWN0KGV2dCk7XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZ0XHJcbiAgICAgKi9cclxuICAgIGNsaWNrOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgaWYgKE9wdGlvbnMuZ2V0VmFsdWUoXCJyZW5kZXJlci1tb3ZlbWVudC1hd2FyZS1jbGljay1oYW5kbGVyXCIpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZ0KTtcclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHBvcy54IC0gdGhpcy5fbGFzdE1vdXNlUG9zaXRpb24ueCkgPiA0IHx8IE1hdGguYWJzKHBvcy55IC0gdGhpcy5fbGFzdE1vdXNlUG9zaXRpb24ueSkgPiA0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRpc3BhdGNoTW91c2VFdmVudE9uUGlja2VkT2JqZWN0KGV2dCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldnRcclxuICAgICAqL1xyXG4gICAgZGJsY2xpY2s6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoTW91c2VFdmVudE9uUGlja2VkT2JqZWN0KGV2dCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGVhY2ggdGltZSBhIG1vdXNlTW92ZSBldmVudCBpcyB0cmlnZ2VyZWQgb24gdGhlXHJcbiAgICAgKiBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgYWxzbyB0cmlnZ2VycyBtb3VzZW92ZXIgYW5kIG1vdXNlb3V0IGV2ZW50cyBvZiBvYmplY3RzIGluIHRoZVxyXG4gICAgICogc2NlbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldnRcclxuICAgICAqL1xyXG4gICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldnQpO1xyXG5cclxuICAgICAgICB2YXIgZG9Nb3VzZU1vdmVQaWNrID0gT3B0aW9ucy5nZXRWYWx1ZShPUFRJT05fTU9VU0VNT1ZFX1BJQ0tJTkcpO1xyXG5cclxuICAgICAgICB0aGlzLmRpc3BhdGNoTW91c2VFdmVudE9uUGlja2VkT2JqZWN0KGV2dCwge29taXRVcGRhdGU6ICFkb01vdXNlTW92ZVBpY2t9KTtcclxuICAgICAgICBpZiAoIWRvTW91c2VNb3ZlUGljaylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgY3VyT2JqID0gdGhpcy5fY2FudmFzSGFuZGxlci5nZXRQaWNrZWRPYmplY3QoKTtcclxuXHJcbiAgICAgICAgLy8gdHJpZ2dlciBtb3VzZW92ZXIgYW5kIG1vdXNlb3V0XHJcbiAgICAgICAgaWYgKGN1ck9iaiAhPT0gdGhpcy5sYXN0UGlja09iaikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0UGlja09iaikge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1vdXNlIGhhcyBsZWZ0IHRoZSBsYXN0IG9iamVjdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE1vdXNlRXZlbnQodGhpcy5jcmVhdGVNb3VzZUV2ZW50KFwibW91c2VvdXRcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IHBvcy54LCBjbGllbnRZOiBwb3MueSwgYnV0dG9uOiBldnQuYnV0dG9uXHJcbiAgICAgICAgICAgICAgICB9KSwgdGhpcy5sYXN0UGlja09iaik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1ck9iaikgeyAvLyBOb3RoaW5nIHBpY2tlZCwgdGhpcyBtZWFucyB3ZSBlbnRlciB0aGUgeG1sM2QgY2FudmFzXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE1vdXNlRXZlbnQodGhpcy5jcmVhdGVNb3VzZUV2ZW50KFwibW91c2VvdmVyXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogcG9zLngsIGNsaWVudFk6IHBvcy55LCBidXR0b246IGV2dC5idXR0b25cclxuICAgICAgICAgICAgICAgICAgICB9KSwgdGhpcy5fZGVmYXVsdFRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGN1ck9iaikge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1vdXNlIGlzIG5vdyBvdmVyIGEgZGlmZmVyZW50IG9iamVjdCwgc28gY2FsbCB0aGUgbmV3XHJcbiAgICAgICAgICAgICAgICAvLyBvYmplY3QncyBtb3VzZW92ZXIgbWV0aG9kXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoTW91c2VFdmVudCh0aGlzLmNyZWF0ZU1vdXNlRXZlbnQoXCJtb3VzZW92ZXJcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IHBvcy54LCBjbGllbnRZOiBwb3MueSwgYnV0dG9uOiBldnQuYnV0dG9uXHJcbiAgICAgICAgICAgICAgICB9KSwgY3VyT2JqKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5sYXN0UGlja09iaikgeyAvLyBOb3RoaW5nIHdhcyBwaWNrZWQgYmVmb3JlLCB0aGlzIG1lYW5zIHdlIGxlYXZlIHRoZSB4bWwzZCBjYW52YXNcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoTW91c2VFdmVudCh0aGlzLmNyZWF0ZU1vdXNlRXZlbnQoXCJtb3VzZW91dFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IHBvcy54LCBjbGllbnRZOiBwb3MueSwgYnV0dG9uOiBldnQuYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgfSksIHRoaXMuX2RlZmF1bHRUYXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxhc3RQaWNrT2JqID0gY3VyT2JqO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2dFxyXG4gICAgICovXHJcbiAgICBtb3VzZW91dDogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZ0KTtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoTW91c2VFdmVudChldnQsIHRoaXMubGFzdFBpY2tPYmosIHBvcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldnRcclxuICAgICAqL1xyXG4gICAgbW91c2VvdmVyOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgdmFyIGRvTW91c2VNb3ZlUGljayA9IE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX01PVVNFTU9WRV9QSUNLSU5HKTtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoTW91c2VFdmVudE9uUGlja2VkT2JqZWN0KGV2dCwge29taXRVcGRhdGU6ICFkb01vdXNlTW92ZVBpY2t9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge1doZWVsRXZlbnR9IGV2dFxyXG4gICAgICovXHJcbiAgICB3aGVlbDogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hNb3VzZUV2ZW50T25QaWNrZWRPYmplY3QoZXZ0LCB7IHR5cGU6IFwid2hlZWxcIiB9KTtcclxuICAgIH1cclxuXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBFVkVOVFM6IEVWRU5UUywgTW91c2VFdmVudEhhbmRsZXI6IE1vdXNlRXZlbnRIYW5kbGVyXHJcbn07XHJcbiIsIi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRlZmF1bHRUYXJnZXRcclxuICogQHBhcmFtIHtBYnN0cmFjdENhbnZhc0hhbmRsZXJ9IGNhbnZhc0hhbmRsZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgVG91Y2hFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoZGVmYXVsdFRhcmdldCwgY2FudmFzSGFuZGxlcikge1xyXG4gICAgdGhpcy5fZGVmYXVsdFRhcmdldCA9IGRlZmF1bHRUYXJnZXQ7XHJcbiAgICB0aGlzLl9jYW52YXNIYW5kbGVyID0gY2FudmFzSGFuZGxlcjtcclxufTtcclxuXHJcblxyXG52YXIgRVZFTlRTID0gW1widG91Y2hzdGFydFwiLCBcInRvdWNobW92ZVwiLCBcInRvdWNoZW5kXCIsIFwidG91Y2hjYW5jZWxcIl07XHJcblxyXG5Ub3VjaEV2ZW50SGFuZGxlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29weVRvdWNoRXZlbnQ6IGZ1bmN0aW9uIChldmVudCwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciB0b3VjaEV2ZW50RGF0YSA9IHRoaXMuY29weVRvdWNoRXZlbnREYXRhKGV2ZW50LCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb3VjaEV2ZW50KHRvdWNoRXZlbnREYXRhKTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIGNvcHlUb3VjaEV2ZW50RGF0YTogZnVuY3Rpb24gKGV2ZW50LCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogb3B0aW9ucy50eXBlIHx8IGV2ZW50LnR5cGUsXHJcbiAgICAgICAgICAgIHRpbWVTdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgYnViYmxlczogZXZlbnQuYnViYmxlcyxcclxuICAgICAgICAgICAgY2FuY2VsYWJsZTogZXZlbnQuY2FuY2VsYWJsZSxcclxuICAgICAgICAgICAgZGV0YWlsOiBldmVudC5kZXRhaWwsXHJcbiAgICAgICAgICAgIHNjcmVlblg6IGV2ZW50LnNjcmVlblgsXHJcbiAgICAgICAgICAgIHNjcmVlblk6IGV2ZW50LnNjcmVlblksXHJcbiAgICAgICAgICAgIHBhZ2VYOiBldmVudC5wYWdlWCxcclxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LnBhZ2VZLFxyXG4gICAgICAgICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICAgICAgICBjdHJsS2V5OiBldmVudC5jdHJsS2V5LFxyXG4gICAgICAgICAgICBhbHRLZXk6IGV2ZW50LmFsdEtleSxcclxuICAgICAgICAgICAgc2hpZnRLZXk6IGV2ZW50LnNoaWZ0S2V5LFxyXG4gICAgICAgICAgICBtZXRhS2V5OiBldmVudC5tZXRhS2V5LFxyXG4gICAgICAgICAgICBzY2FsZTogZXZlbnQuc2NhbGUsXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiBldmVudC5yb3RhdGlvbixcclxuICAgICAgICAgICAgdmlldzogZXZlbnQudmlldyxcclxuICAgICAgICAgICAgdG91Y2hlczogZXZlbnQudG91Y2hlcyxcclxuICAgICAgICAgICAgY2hhbmdlZFRvdWNoZXM6IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxyXG4gICAgICAgICAgICB0YXJnZXRUb3VjaGVzOiBldmVudC50YXJnZXRUb3VjaGVzXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlVG91Y2hFdmVudDogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB2YXIgdG91Y2hFdmVudDtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdG91Y2hFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdUb3VjaEV2ZW50Jyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiQ3JlYXRlIFRvdWNoIEV2ZW50IGZhaWxlZCwgY3JlYXRpbmcgVUkgaW5zdGVhZFwiKTtcclxuICAgICAgICAgICAgdG91Y2hFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdVSUV2ZW50Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodG91Y2hFdmVudCAmJiB0b3VjaEV2ZW50LmluaXRUb3VjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0b3VjaEV2ZW50LmluaXRUb3VjaEV2ZW50Lmxlbmd0aCA9PSAwKSB7IC8vY2hyb21lXHJcbiAgICAgICAgICAgICAgICB0b3VjaEV2ZW50LmluaXRUb3VjaEV2ZW50KGRhdGEudG91Y2hlcywgZGF0YS50YXJnZXRUb3VjaGVzLCBkYXRhLmNoYW5nZWRUb3VjaGVzLCBkYXRhLnR5cGUsIGRhdGEudmlldywgZGF0YS5zY3JlZW5YLCBkYXRhLnNjcmVlblksIGRhdGEuY2xpZW50WCwgZGF0YS5jbGllbnRZKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0b3VjaEV2ZW50LmluaXRUb3VjaEV2ZW50Lmxlbmd0aCA9PSAxMikgeyAvL2ZpcmVmb3hcclxuICAgICAgICAgICAgICAgIHRvdWNoRXZlbnQuaW5pdFRvdWNoRXZlbnQoZGF0YS50eXBlLCBkYXRhLmJ1YmJsZXMsIGRhdGEuY2FuY2VsYWJsZSwgZGF0YS52aWV3LCBkYXRhLmRldGFpbCwgZGF0YS5jdHJsS2V5LCBkYXRhLmFsdEtleSwgZGF0YS5zaGlmdEtleSwgZGF0YS5tZXRhS2V5LCBkYXRhLnRvdWNoZXMsIGRhdGEudGFyZ2V0VG91Y2hlcywgZGF0YS5jaGFuZ2VkVG91Y2hlcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vaU9TIGxlbmd0aCA9IDE4XHJcbiAgICAgICAgICAgICAgICB0b3VjaEV2ZW50LmluaXRUb3VjaEV2ZW50KGRhdGEudHlwZSwgZGF0YS5idWJibGVzLCBkYXRhLmNhbmNlbGFibGUsIGRhdGEudmlldywgZGF0YS5kZXRhaWwsIGRhdGEuc2NyZWVuWCwgZGF0YS5zY3JlZW5ZLCBkYXRhLnBhZ2VYLCBkYXRhLnBhZ2VZLCBkYXRhLmN0cmxLZXksIGRhdGEuYWx0S2V5LCBkYXRhLnNoaWZ0S2V5LCBkYXRhLm1ldGFLZXksIGRhdGEudG91Y2hlcywgZGF0YS50YXJnZXRUb3VjaGVzLCBkYXRhLmNoYW5nZWRUb3VjaGVzLCBkYXRhLnNjYWxlLCBkYXRhLnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG91Y2hFdmVudDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldnRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0P30gb3B0XHJcbiAgICAgKi9cclxuICAgIGRpc3BhdGNoVG91Y2hFdmVudE9uUGlja2VkT2JqZWN0OiBmdW5jdGlvbiAoZXZ0LCBvcHQpIHtcclxuICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICAgICAgdmFyIHRvdWNoRXZlbnQgPSB0aGlzLmNvcHlUb3VjaEV2ZW50KGV2dCwgb3B0KTtcclxuICAgICAgICB0b3VjaEV2ZW50LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2RlZmF1bHRUYXJnZXQuZGlzcGF0Y2hFdmVudCh0b3VjaEV2ZW50KTtcclxuICAgIH0sXHJcblxyXG4gICAgdG91Y2hzdGFydDogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUb3VjaEV2ZW50T25QaWNrZWRPYmplY3QoZXZ0KTtcclxuICAgIH0sXHJcblxyXG4gICAgdG91Y2hlbmQ6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoVG91Y2hFdmVudE9uUGlja2VkT2JqZWN0KGV2dCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUb3VjaEV2ZW50T25QaWNrZWRPYmplY3QoZXZ0KTtcclxuICAgIH0sXHJcblxyXG4gICAgdG91Y2hjYW5jZWw6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoVG91Y2hFdmVudE9uUGlja2VkT2JqZWN0KGV2dCk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgRVZFTlRTOiBFVkVOVFMsIFRvdWNoRXZlbnRIYW5kbGVyOiBUb3VjaEV2ZW50SGFuZGxlclxyXG59O1xyXG4iLCJmdW5jdGlvbiBMaWdodE1hbmFnZXIoKSB7XHJcbiAgICB0aGlzLl9saWdodHMgPSBbXTtcclxuICAgIHRoaXMuX21vZGVscyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRpbmcgbGlnaHQgcGFyYW1ldGVycyBjYW4gbGVhZCB0byB1cGRhdGluZyB0aGUgKGxhenkpIHNjZW5lIHN0cnVjdHVyZSwgd2hpY2hcclxuICAgICAqIGluIHR1cm4gdXBkYXRlcyB0aGUgbGlnaHRzLiBJZiB3ZSBhcmUgaW4gdXBkYXRpbmcgdGhlIGxpZ2h0cywgZmxhZyBpcyBzZXQgdG8gdHJ1ZS5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5faW5VcGRhdGUgPSBmYWxzZTtcclxufVxyXG5cclxuTGlnaHRNYW5hZ2VyLnByb3RvdHlwZSA9IHtcclxuICAgIGFkZDogZnVuY3Rpb24gKGxpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5fbGlnaHRzLnB1c2gobGlnaHQpO1xyXG4gICAgICAgIHRoaXMuX2FkZE1vZGVsKGxpZ2h0Lm1vZGVsKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAobGlnaHQpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9saWdodHMuaW5kZXhPZihsaWdodCk7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpZ2h0cy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZW1vdmVNb2RlbChsaWdodC5tb2RlbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbGxHbG9iYWxQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoZ2xvYmFscywgZm9yY2UpIHtcclxuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9tb2RlbHMpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fbW9kZWxzW2lkXTtcclxuICAgICAgICAgICAgLyogRmlsbCBnbG9iYWxzIG9ubHkgaWYgdGhpcyB3YXMgbm90IGFscmVhZHkgZG9uZSBiZWZvcmUgKi9cclxuICAgICAgICAgICAgaWYgKGVudHJ5LmNoYW5nZWQgfHwgZm9yY2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBpZCArIFwiTGlnaHRcIjtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHBhcmFtIGluIGVudHJ5LnBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHByZWZpeCArIHBhcmFtLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcGFyYW0uc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsc1tuYW1lXSA9IGVudHJ5LnBhcmFtZXRlcnNbcGFyYW1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZW50cnkuY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBsaWdodFZhbHVlQ2hhbmdlZDogZnVuY3Rpb24gKGxpZ2h0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2luVXBkYXRlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5faW5VcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB2YXIgbGlnaHRzID0gbGlnaHQgPyBbbGlnaHRdIDogdGhpcy5fbGlnaHRzO1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgICAgbGlnaHRzLmZvckVhY2goZnVuY3Rpb24obGlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIG1vZGVsID0gbGlnaHQubW9kZWw7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoYXQuZ2V0TW9kZWxFbnRyeShtb2RlbC5pZCk7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBlbnRyeS5saWdodE1vZGVscy5pbmRleE9mKG1vZGVsKTtcclxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgICAgIC8vVGhlc2UgY2hhbmdlcyBhcmUgZm9yIGEgbGlnaHQgdGhhdCBubyBsb25nZXIgZXhpc3RzIHNvIHdlIGNhbiBpZ25vcmUgdGhlbVxyXG4gICAgICAgICAgICAgICAgLy9UaGlzIGNhbiBoYXBwZW4gZm9yIGV4LiBkdXJpbmcgYSBkZWxheWVkIGNoYW5nZSBub3RpZmljYXRpb24gdGhhdCBpc24ndCBmaXJlZCB1bnRpbCBhZnRlciBhIHJlbW92ZSgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbW9kZWwuZmlsbExpZ2h0UGFyYW1ldGVycyhlbnRyeS5wYXJhbWV0ZXJzLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICBtb2RlbC5nZXRMaWdodERhdGEoZW50cnkucGFyYW1ldGVycywgb2Zmc2V0KTtcclxuICAgICAgICAgICAgZW50cnkuY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5faW5VcGRhdGUgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TW9kZWxFbnRyeTogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGVsc1tpZF07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldE1vZGVsczogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX21vZGVscyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldE1vZGVsQ291bnQ6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuZ2V0TW9kZWxFbnRyeShpZCk7XHJcbiAgICAgICAgcmV0dXJuIG1vZGVsID8gbW9kZWwubGlnaHRNb2RlbHMubGVuZ3RoIDogMDtcclxuICAgIH0sXHJcblxyXG4gICAgX2FkZE1vZGVsOiBmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9tb2RlbHNbbW9kZWwuaWRdO1xyXG4gICAgICAgIGlmICghZW50cnkpIHtcclxuICAgICAgICAgICAgZW50cnkgPSB0aGlzLl9tb2RlbHNbbW9kZWwuaWRdID0ge2xpZ2h0TW9kZWxzOiBbXSwgcGFyYW1ldGVyczoge319O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbnRyeS5saWdodE1vZGVscy5wdXNoKG1vZGVsKTtcclxuICAgICAgICB0aGlzLl9saWdodFN0cnVjdHVyZUNoYW5nZWQoZW50cnkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfcmVtb3ZlTW9kZWw6IGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZ2V0TW9kZWxFbnRyeShtb2RlbC5pZCk7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gZW50cnkubGlnaHRNb2RlbHMuaW5kZXhPZihtb2RlbCk7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgIGVudHJ5LmxpZ2h0TW9kZWxzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xpZ2h0U3RydWN0dXJlQ2hhbmdlZChlbnRyeSk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9saWdodFN0cnVjdHVyZUNoYW5nZWQ6IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIHRoaXMuX2luVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gZW50cnkubGlnaHRNb2RlbHMubGVuZ3RoO1xyXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGVudHJ5LnBhcmFtZXRlcnMgPSB7fTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW9kZWwgPSBlbnRyeS5saWdodE1vZGVsc1swXTtcclxuICAgICAgICBlbnRyeS5wYXJhbWV0ZXJzID0gbW9kZWwuYWxsb2NhdGVQYXJhbWV0ZXJBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIGVudHJ5LmxpZ2h0TW9kZWxzLmZvckVhY2goZnVuY3Rpb24gKGxpZ2h0TW9kZWwsIG9mZnNldCkge1xyXG4gICAgICAgICAgICBsaWdodE1vZGVsLmZpbGxMaWdodFBhcmFtZXRlcnMoZW50cnkucGFyYW1ldGVycywgb2Zmc2V0KVxyXG4gICAgICAgICAgICBsaWdodE1vZGVsLmdldExpZ2h0RGF0YShlbnRyeS5wYXJhbWV0ZXJzLCBvZmZzZXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVudHJ5LmNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2luVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaWdodE1hbmFnZXI7XHJcbiIsInZhciBGcnVzdHVtID0gcmVxdWlyZShcIi4uL3Rvb2xzL2ZydXN0dW0uanNcIikuRnJ1c3R1bTtcclxudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcbnZhciBEYXRhTm9kZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuRGF0YU5vZGU7XHJcbnZhciBJbnB1dE5vZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLklucHV0Tm9kZTtcclxudmFyIEJ1ZmZlckVudHJ5ID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9kYXRhLmpzXCIpLkJ1ZmZlckVudHJ5O1xyXG52YXIgQ29tcHV0ZVJlcXVlc3QgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL3JlcXVlc3QuanNcIikuQ29tcHV0ZVJlcXVlc3Q7XHJcblxyXG52YXIgUG9pbnRMaWdodERhdGEgPSB7XHJcbiAgICBcImludGVuc2l0eVwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUMywgJ2RlZmF1bHQnOiBbMSwgMSwgMV19LFxyXG4gICAgXCJhdHRlbnVhdGlvblwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUMywgJ2RlZmF1bHQnOiBbMCwgMCwgMV19LFxyXG4gICAgXCJwb3NpdGlvblwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUMywgJ2RlZmF1bHQnOiBbMCwgMCwgMF19LFxyXG4gICAgXCJzaGFkb3dCaWFzXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQsICdkZWZhdWx0JzogWzAuMDAwMV19LFxyXG4gICAgXCJkaXJlY3Rpb25cIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVDMsICdkZWZhdWx0JzogWzAsIDAsIC0xXX0sXHJcbiAgICBcImNhc3RTaGFkb3dcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5CT09MLCAnZGVmYXVsdCc6IFtmYWxzZV19LFxyXG4gICAgXCJvblwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkJPT0wsICdkZWZhdWx0JzogW3RydWVdfSxcclxuICAgIFwibWF0cml4XCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQ0WDQsICdkZWZhdWx0JzogWzEsIDAsIDAsIDAsICAgMCwgMSwgMCwgMCwgICAgMCwgMCwgMSwgMCwgIDAsIDAsIDAsIDFdfSxcclxuICAgIFwibmVhckZhclwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUMiwgJ2RlZmF1bHQnOiBbMS4wLCAxMDAuMF19XHJcbn07XHJcblxyXG52YXIgU3BvdExpZ2h0RGF0YSA9IHtcclxuICAgIFwiaW50ZW5zaXR5XCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IFsxLCAxLCAxXX0sXHJcbiAgICBcImF0dGVudWF0aW9uXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IFswLCAwLCAxXX0sXHJcbiAgICBcInBvc2l0aW9uXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IFswLCAwLCAwXX0sXHJcbiAgICBcImRpcmVjdGlvblwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUMywgJ2RlZmF1bHQnOiBbMCwgMCwgLTFdfSxcclxuICAgIFwiZmFsbG9mZkFuZ2xlXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQsICdkZWZhdWx0JzogW01hdGguUEkgLyA0XX0sXHJcbiAgICBcInNvZnRuZXNzXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQsICdkZWZhdWx0JzogWzAuMF19LFxyXG4gICAgXCJzaGFkb3dCaWFzXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQsICdkZWZhdWx0JzogWzAuMDAwMV19LFxyXG4gICAgXCJjYXN0U2hhZG93XCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuQk9PTCwgJ2RlZmF1bHQnOiBbZmFsc2VdfSxcclxuICAgIFwibWF0cml4XCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQ0WDQsICdkZWZhdWx0JzogWzEsIDAsIDAsIDAsICAgMCwgMSwgMCwgMCwgICAgMCwgMCwgMSwgMCwgIDAsIDAsIDAsIDFdfSxcclxuICAgIFwib25cIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5CT09MLCAnZGVmYXVsdCc6IFt0cnVlXX1cclxufTtcclxuXHJcbnZhciBEaXJlY3Rpb25hbExpZ2h0RGF0YSA9IHtcclxuICAgIFwiaW50ZW5zaXR5XCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IFsxLCAxLCAxXX0sXHJcbiAgICBcImRpcmVjdGlvblwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUMywgJ2RlZmF1bHQnOiBbMCwgMCwgLTFdfSxcclxuICAgIFwic2hhZG93Qmlhc1wiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FULCAnZGVmYXVsdCc6IFswLjAwMDFdfSxcclxuICAgIFwicG9zaXRpb25cIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVDMsICdkZWZhdWx0JzogWzAsIDAsIDBdfSxcclxuICAgIFwiY2FzdFNoYWRvd1wiOiB7dHlwZTogWEMuREFUQV9UWVBFLkJPT0wsICdkZWZhdWx0JzogW2ZhbHNlXX0sXHJcbiAgICBcIm9uXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuQk9PTCwgJ2RlZmF1bHQnOiBbdHJ1ZV19LFxyXG4gICAgXCJtYXRyaXhcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVDRYNCwgJ2RlZmF1bHQnOiBbMSwgMCwgMCwgMCwgICAwLCAxLCAwLCAwLCAgICAwLCAwLCAxLCAwLCAgMCwgMCwgMCwgMV19XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gY3JlYXRlWGZsb3dEYXRhKGNvbmZpZykge1xyXG4gICAgdmFyIGRhdGEgPSBuZXcgRGF0YU5vZGUoKTtcclxuICAgIGZvciAodmFyIG5hbWUgaW4gY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gY29uZmlnW25hbWVdO1xyXG4gICAgICAgIGNyZWF0ZVhmbG93VmFsdWUoZGF0YSwgbmFtZSwgZW50cnkudHlwZSwgZW50cnlbJ2RlZmF1bHQnXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlWGZsb3dWYWx1ZShkYXRhTm9kZSwgbmFtZSwgdHlwZSwgdmFsdWUpIHtcclxuICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyRW50cnkodHlwZSwgbmV3IFhDLlRZUEVEX0FSUkFZX01BUFt0eXBlXSh2YWx1ZSkpO1xyXG4gICAgdmFyIGlucHV0Tm9kZSA9IG5ldyBJbnB1dE5vZGUoKTtcclxuICAgIGlucHV0Tm9kZS5kYXRhID0gYnVmZmVyO1xyXG4gICAgaW5wdXROb2RlLm5hbWUgPSBuYW1lO1xyXG4gICAgZGF0YU5vZGUuYXBwZW5kQ2hpbGQoaW5wdXROb2RlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGxpZ2h0IG1vZGVsc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5pcXVlIGlkIHRoYXQgaWRlbnRpZmllcyB0aGUgbGlnaHQgbW9kZWxcclxuICogQHBhcmFtIHtSZW5kZXJMaWdodH0gbGlnaHRcclxuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YU5vZGVcclxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIHRoYXQgY29udGFpbnMgdGhlIGxpZ2h0IG1vZGVsJ3MgcGFyYW1ldGVycyBhbmQgZGVmYXVsdCB2YWx1ZXNcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgTGlnaHRNb2RlbCA9IGZ1bmN0aW9uIChpZCwgbGlnaHQsIGRhdGFOb2RlLCBjb25maWcpIHtcclxuICAgIHRoaXMuaWQgPSBpZDtcclxuICAgIHRoaXMubGlnaHQgPSBsaWdodDtcclxuICAgIHRoaXMuZGF0YU5vZGUgPSBkYXRhTm9kZTtcclxuICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZztcclxuICAgIHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5rZXlzKGNvbmZpZyk7XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBsaWdodCBoYXMgbm90IGRhdGEsIGp1c3QgdXNlIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgaWYgKGRhdGFOb2RlKSB7XHJcbiAgICAgICAgZGF0YU5vZGUuaW5zZXJ0QmVmb3JlKGNyZWF0ZVhmbG93RGF0YShjb25maWcpLCBudWxsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0YU5vZGUgPSBjcmVhdGVYZmxvd0RhdGEoY29uZmlnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIb3Jpem9udGFsIG9wZW5pbmcgYW5nbGUgb2YgdGhlIGxpZ2h0IGNhbWVyYS4gRGVyaXZlZCBmcm9tIGZhbGxvZmZBbmdsZSBpbiBjYXNlIG9mIHNwb3QgbGlnaHRcclxuICAgIHRoaXMuZm92eSA9ICBNYXRoLlBJLzIuMDtcclxuXHJcbiAgICB0aGlzLmxpZ2h0UGFyYW1ldGVyUmVxdWVzdCA9IG5ldyBDb21wdXRlUmVxdWVzdChkYXRhTm9kZSwgdGhpcy5wYXJhbWV0ZXJzLCB0aGlzLmxpZ2h0UGFyYW1ldGVyc0NoYW5nZWQuYmluZCh0aGlzKSk7XHJcbiAgICB0aGlzLmxpZ2h0UGFyYW1ldGVyc0NoYW5nZWQodGhpcy5saWdodFBhcmFtZXRlclJlcXVlc3QsIG51bGwpO1xyXG59O1xyXG5cclxuTGlnaHRNb2RlbC5wcm90b3R5cGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyB0aGUgbGlnaHQgcGFyYW1ldGVycyBpbiBhbiBhcnJheSBvZiB0aGUgc2FtZSBzaXplXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IE5hbWUgdG8gdHlwZWQgYXJyYXkgbWFwIGNvbnRhaW5pbmcgdGhlIGRhdGFcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgU2xvdCBpbiB0aGUgYXJyYXkgdG8gYmUgZmlsbGVkXHJcbiAgICAgKi9cclxuICAgIGZpbGxMaWdodFBhcmFtZXRlcnM6IGZ1bmN0aW9uICh0YXJnZXQsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmxpZ2h0UGFyYW1ldGVyUmVxdWVzdC5nZXRSZXN1bHQoKTtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSByZXN1bHQuZ2V0T3V0cHV0RGF0YShuYW1lKTtcclxuICAgICAgICAgICAgdmFyIHNpemUgPSBYQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtlbnRyeS50eXBlXTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZW50cnkuZ2V0VmFsdWUoKTtcclxuICAgICAgICAgICAgdGFyZ2V0W25hbWVdLnNldCh2YWx1ZS5zdWJhcnJheSgwLCBzaXplKSwgb2Zmc2V0ICogc2l6ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1QYXJhbWV0ZXJzKHRhcmdldCwgb2Zmc2V0KTtcclxuICAgIH0sXHJcblxyXG4gICAgYWxsb2NhdGVQYXJhbWV0ZXJBcnJheTogZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICB2YXIgcGFyYW1ldGVyQXJyYXlzID0ge307XHJcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlndXJhdGlvbjtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IGNvbmZpZ1tuYW1lXS50eXBlO1xyXG4gICAgICAgICAgICB2YXIgdHVwbGVTaXplID0gWEMuREFUQV9UWVBFX1RVUExFX1NJWkVbdHlwZV07XHJcbiAgICAgICAgICAgIHBhcmFtZXRlckFycmF5c1tuYW1lXSA9IG5ldyBYQy5UWVBFRF9BUlJBWV9NQVBbdHlwZV0odHVwbGVTaXplICogc2l6ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlckFycmF5cztcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgaWYobmFtZSBpbiB0aGlzLmNvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgLy8gTm8gb3RoZXIgY2hlY2tzIHJlcXVpcmVkIGJlY2F1c2UgcGFyYW1ldGVycyBhcmUgYWx3YXlzIGRlZmluZWRcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlnaHRQYXJhbWV0ZXJSZXF1ZXN0LmdldFJlc3VsdCgpLmdldE91dHB1dERhdGEobmFtZSkuZ2V0VmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIGxpZ2h0UGFyYW1ldGVyc0NoYW5nZWQ6IGZ1bmN0aW9uIChyZXF1ZXN0LCBjaGFuZ2VUeXBlKSB7XHJcbiAgICAgICAgaWYgKGNoYW5nZVR5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy5saWdodC5saWdodFZhbHVlQ2hhbmdlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX2V4cGFuZE5lYXJGYXI6ZnVuY3Rpb24obmZvYmplY3Qpe1xyXG4gICAgICAgIHZhciBleHBhbmQgPSBNYXRoLm1heCgobmZvYmplY3QuZmFyIC0gbmZvYmplY3QubmVhcikgKiAwLjMwLCAwLjA1KTtcclxuICAgICAgICBuZm9iamVjdC5uZWFyIC09IGV4cGFuZDtcclxuICAgICAgICBuZm9iamVjdC5mYXIgICs9IGV4cGFuZDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TGlnaHREYXRhOiBmdW5jdGlvbiAodGFyZ2V0LCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gdGFyZ2V0W1wibWF0cml4XCJdLnN1YmFycmF5KG9mZnNldCAqIDE2LCBvZmZzZXQgKiAxNiArIDE2KTtcclxuICAgICAgICB0aGlzLmdldExpZ2h0Vmlld1Byb2plY3Rpb25NYXRyaXgobWF0cml4KTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TGlnaHRWaWV3UHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIHZhciBMVk0gPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIExQTSA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB0aGlzLmdldExpZ2h0Vmlld01hdHJpeChMVk0pO1xyXG4gICAgICAgIHRoaXMuZ2V0TGlnaHRQcm9qZWN0aW9uTWF0cml4KExQTSk7XHJcbiAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5KHRhcmdldCwgTFBNLCBMVk0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRMaWdodFByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICB0aGlzLmxpZ2h0LmdldEZydXN0dW0oMSkuZ2V0UHJvamVjdGlvbk1hdHJpeCh0YXJnZXQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRMaWdodFZpZXdNYXRyaXg6IGZ1bmN0aW9uIChtYXQ0KSB7XHJcbiAgICAgICAgdmFyIHBfZGlyID0gdGhpcy5nZXRQYXJhbWV0ZXIoXCJkaXJlY3Rpb25cIik7XHJcbiAgICAgICAgdmFyIHBfcG9zID0gdGhpcy5nZXRQYXJhbWV0ZXIoXCJwb3NpdGlvblwiKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB3b3JsZCBtYXRyaXggZnJvbSB0aGUgbGlnaHQgaW4gdGhlIHRyYW5zZm9ybWF0aW9uIGhpZXJhcmNoeVxyXG4gICAgICAgIC8vIHdvcmxkID0+IGxpZ2h0XHJcbiAgICAgICAgdGhpcy5saWdodC5nZXRXb3JsZE1hdHJpeChtYXQ0KTtcclxuXHJcbiAgICAgICAgLy8gRGVyaXZlIHJvdGF0aW9uIGZyb20gdGhlIGRpcmVjdGlvbiBhbmQgc3RhbmRhcmQgZGlyZWN0aW9uICgteiA9PiBubyByb3RhdGlvbilcclxuICAgICAgICB2YXIgcV9yb3QgPSBYTUwzRC5tYXRoLnF1YXQucm90YXRpb25UbyhYTUwzRC5tYXRoLnF1YXQuY3JlYXRlKCksY19zdGFuZGFyZERpcmVjdGlvbiwgcF9kaXIpO1xyXG4gICAgICAgIC8vIENyZWF0ZSBtYXRyaXggZnJvbSByb3RhdGlvbiBhbmQgdHJhbnNsYXRpb25cclxuICAgICAgICB2YXIgdHJhbnMgPSBYTUwzRC5tYXRoLm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24oWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpLCBxX3JvdCwgcF9wb3MpO1xyXG4gICAgICAgIC8vIEFkZCB0byB3b3JsZCBtYXRyaXhcclxuICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsKG1hdDQsIG1hdDQsIHRyYW5zKTtcclxuXHJcbiAgICAgICAgLy8gSW52ZXJ0OiAgbGlnaHQgPT4gd29ybGRcclxuICAgICAgICBYTUwzRC5tYXRoLm1hdDQuaW52ZXJ0KG1hdDQsIG1hdDQpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbnZhciBjX3RtcFdvcmxkTWF0cml4ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG52YXIgY19zdGFuZGFyZERpcmVjdGlvbiA9IFhNTDNELm1hdGgudmVjMy5mcm9tVmFsdWVzKDAsMCwtMSk7XHJcblxyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtUG9zZShsaWdodCwgcG9zaXRpb24sIGRpcmVjdGlvbikge1xyXG4gICAgbGlnaHQuZ2V0V29ybGRNYXRyaXgoY190bXBXb3JsZE1hdHJpeCk7XHJcbiAgICBpZiAocG9zaXRpb24pIHtcclxuICAgICAgICBYTUwzRC5tYXRoLnZlYzMudHJhbnNmb3JtTWF0NChwb3NpdGlvbiwgcG9zaXRpb24sIGNfdG1wV29ybGRNYXRyaXgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpcmVjdGlvbikge1xyXG4gICAgICAgIFhNTDNELm1hdGgudmVjMy50cmFuc2Zvcm1EaXJlY3Rpb24oZGlyZWN0aW9uLCBkaXJlY3Rpb24sIGNfdG1wV29ybGRNYXRyaXgpO1xyXG4gICAgICAgIFhNTDNELm1hdGgudmVjMy5ub3JtYWxpemUoZGlyZWN0aW9uLCBkaXJlY3Rpb24pO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1EZWZhdWx0KHRhcmdldCwgb2Zmc2V0LCBsaWdodCkge1xyXG4gICAgdmFyIGNvbG9yID0gdGFyZ2V0W1wiaW50ZW5zaXR5XCJdLnN1YmFycmF5KG9mZnNldCAqIDMsIG9mZnNldCAqIDMgKyAzKTtcclxuICAgIFhNTDNELm1hdGgudmVjMy5zY2FsZShjb2xvciwgY29sb3IsIGxpZ2h0LmxvY2FsSW50ZW5zaXR5KTtcclxuICAgIHRhcmdldFtcIm9uXCJdW29mZnNldF0gPSBsaWdodC52aXNpYmxlO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudCBYTUwzRCdzIHByZWRlZmluZWQgcG9pbnQgbGlnaHQgbW9kZWwgdXJuOnhtbDNkOmxpZ2h0c2hhZGVyOnBvaW50XHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlXHJcbiAqIEBwYXJhbSB7UmVuZGVyTGlnaHR9IGxpZ2h0XHJcbiAqIEBleHRlbmRzIExpZ2h0TW9kZWxcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgUG9pbnRMaWdodE1vZGVsID0gZnVuY3Rpb24gKGRhdGFOb2RlLCBsaWdodCkge1xyXG4gICAgTGlnaHRNb2RlbC5jYWxsKHRoaXMsIFwicG9pbnRcIiwgbGlnaHQsIGRhdGFOb2RlLCBQb2ludExpZ2h0RGF0YSk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhQb2ludExpZ2h0TW9kZWwsIExpZ2h0TW9kZWwsIHtcclxuICAgIGdldEZydXN0dW06IGZ1bmN0aW9uIChhc3BlY3QsIHNjZW5lQm91bmRpbmdCb3gpIHtcclxuICAgICAgICB2YXIgb3J0aG9nb25hbCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMubGlnaHQuc2NlbmUubGlnaHRzLmdldE1vZGVsRW50cnkodGhpcy5pZCk7XHJcblxyXG4gICAgICAgIGlmIChYTUwzRC5tYXRoLmJib3guaXNFbXB0eShzY2VuZUJvdW5kaW5nQm94KSkge1xyXG4gICAgICAgICAgICBlbnRyeS5wYXJhbWV0ZXJzW1wibmVhckZhclwiXVswXSA9IDEuMDtcclxuICAgICAgICAgICAgZW50cnkucGFyYW1ldGVyc1tcIm5lYXJGYXJcIl1bMV0gPSAxMTAuMDtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGcnVzdHVtKDEuMCwgMTEwLjAsIDAsIHRoaXMuZm92eSwgYXNwZWN0LCBvcnRob2dvbmFsKVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHZhciB0X21hdCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB0aGlzLmdldExpZ2h0Vmlld01hdHJpeCh0X21hdCk7XHJcbiAgICAgICAgWE1MM0QubWF0aC5iYm94LnRyYW5zZm9ybShzY2VuZUJvdW5kaW5nQm94LCB0X21hdCwgc2NlbmVCb3VuZGluZ0JveCk7XHJcblxyXG4gICAgICAgIHZhciBuZiA9IHtcclxuICAgICAgICAgICAgbmVhcjogLXNjZW5lQm91bmRpbmdCb3hbNV0sIGZhcjogLXNjZW5lQm91bmRpbmdCb3hbMl1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEV4cGFuZCB0aGUgdmlldyBmcnVzdHVtIGEgYml0IHRvIGVuc3VyZSAyRCBvYmplY3RzIHBhcmFsbGVsIHRvIHRoZSBjYW1lcmEgYXJlIHJlbmRlcmVkXHJcbiAgICAgICAgdGhpcy5fZXhwYW5kTmVhckZhcihuZik7XHJcblxyXG4gICAgICAgIGVudHJ5LnBhcmFtZXRlcnNbXCJuZWFyRmFyXCJdWzBdID0gMS4wO1xyXG4gICAgICAgIGVudHJ5LnBhcmFtZXRlcnNbXCJuZWFyRmFyXCJdWzFdID0gbmYuZmFyO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEZydXN0dW0oMS4wLCBuZi5mYXIsIDAsIHRoaXMuZm92eSwgYXNwZWN0LCBvcnRob2dvbmFsKTtcclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNmb3JtUGFyYW1ldGVyczogZnVuY3Rpb24gKHRhcmdldCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGFyZ2V0W1wicG9zaXRpb25cIl0uc3ViYXJyYXkob2Zmc2V0ICogMywgb2Zmc2V0ICogMyArIDMpO1xyXG4gICAgICAgIHRyYW5zZm9ybVBvc2UodGhpcy5saWdodCwgcG9zaXRpb24sIG51bGwpO1xyXG4gICAgICAgIHRyYW5zZm9ybURlZmF1bHQodGFyZ2V0LCBvZmZzZXQsIHRoaXMubGlnaHQpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnQgWE1MM0QncyBwcmVkZWZpbmVkIHNwb3QgbGlnaHQgbW9kZWwgdXJuOnhtbDNkOmxpZ2h0c2hhZGVyOnNwb3RcclxuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YU5vZGVcclxuICogQHBhcmFtIHtSZW5kZXJMaWdodH0gbGlnaHRcclxuICogQGV4dGVuZHMgTGlnaHRNb2RlbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBTcG90TGlnaHRNb2RlbCA9IGZ1bmN0aW9uIChkYXRhTm9kZSwgbGlnaHQpIHtcclxuICAgIExpZ2h0TW9kZWwuY2FsbCh0aGlzLCBcInNwb3RcIiwgbGlnaHQsIGRhdGFOb2RlLCBTcG90TGlnaHREYXRhKTtcclxufTtcclxuXHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhTcG90TGlnaHRNb2RlbCwgTGlnaHRNb2RlbCwge1xyXG4gICAgZ2V0RnJ1c3R1bTogZnVuY3Rpb24gKGFzcGVjdCwgc2NlbmVCb3VuZGluZ0JveCkge1xyXG5cclxuICAgICAgICBpZiAoWE1MM0QubWF0aC5iYm94LmlzRW1wdHkoc2NlbmVCb3VuZGluZ0JveCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGcnVzdHVtKDEuMCwgMTEwLjAsIDAsIHRoaXMuZm92eSwgYXNwZWN0LCBmYWxzZSlcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB2YXIgdF9tYXQgPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdGhpcy5nZXRMaWdodFZpZXdNYXRyaXgodF9tYXQpO1xyXG4gICAgICAgIFhNTDNELm1hdGguYmJveC50cmFuc2Zvcm0oc2NlbmVCb3VuZGluZ0JveCwgdF9tYXQsIHNjZW5lQm91bmRpbmdCb3gpO1xyXG5cclxuICAgICAgICB2YXIgbmYgPSB7XHJcbiAgICAgICAgICAgIG5lYXI6IC1zY2VuZUJvdW5kaW5nQm94WzVdLCBmYXI6IC1zY2VuZUJvdW5kaW5nQm94WzJdXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBFeHBhbmQgdGhlIHZpZXcgZnJ1c3R1bSBhIGJpdCB0byBlbnN1cmUgMkQgb2JqZWN0cyBwYXJhbGxlbCB0byB0aGUgY2FtZXJhIGFyZSByZW5kZXJlZFxyXG4gICAgICAgIHRoaXMuX2V4cGFuZE5lYXJGYXIobmYpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEZydXN0dW0oMS4wLCBuZi5mYXIsIDAsIHRoaXMuZm92eSwgYXNwZWN0LCBmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zZm9ybVBhcmFtZXRlcnM6IGZ1bmN0aW9uICh0YXJnZXQsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRhcmdldFtcInBvc2l0aW9uXCJdLnN1YmFycmF5KG9mZnNldCAqIDMsIG9mZnNldCAqIDMgKyAzKTtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGFyZ2V0W1wiZGlyZWN0aW9uXCJdLnN1YmFycmF5KG9mZnNldCAqIDMsIG9mZnNldCAqIDMgKyAzKTtcclxuICAgICAgICAvLyBUcmFuc2Zvcm0gcG9zaXRpb24gYW5kIGRpcmVjdGlvbiBmcm9tIG9iamVjdCB0byB3b3JsZCBzcGFjZVxyXG4gICAgICAgIHRyYW5zZm9ybVBvc2UodGhpcy5saWdodCwgcG9zaXRpb24sIGRpcmVjdGlvbik7XHJcbiAgICAgICAgdHJhbnNmb3JtRGVmYXVsdCh0YXJnZXQsIG9mZnNldCwgdGhpcy5saWdodCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGxpZ2h0UGFyYW1ldGVyc0NoYW5nZWQ6IGZ1bmN0aW9uIChyZXF1ZXN0LCBjaGFuZ2VUeXBlKSB7XHJcbiAgICAgICAgdGhpcy5mb3Z5ID0gdGhpcy5nZXRQYXJhbWV0ZXIoXCJmYWxsb2ZmQW5nbGVcIilbMF0gKiAyO1xyXG4gICAgICAgIExpZ2h0TW9kZWwucHJvdG90eXBlLmxpZ2h0UGFyYW1ldGVyc0NoYW5nZWQuY2FsbCh0aGlzLCByZXF1ZXN0LCBjaGFuZ2VUeXBlKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogSW1wbGVtZW50IFhNTDNEJ3MgcHJlZGVmaW5lZCBzcG90IGxpZ2h0IG1vZGVsIHVybjp4bWwzZDpsaWdodHNoYWRlcjpkaXJlY3Rpb25hbFxyXG4gKiBAcGFyYW0ge0RhdGFOb2RlfSBkYXRhTm9kZVxyXG4gKiBAcGFyYW0ge1JlbmRlckxpZ2h0fSBsaWdodFxyXG4gKiBAZXh0ZW5kcyBMaWdodE1vZGVsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIERpcmVjdGlvbmFsTGlnaHRNb2RlbCA9IGZ1bmN0aW9uIChkYXRhTm9kZSwgbGlnaHQpIHtcclxuICAgIExpZ2h0TW9kZWwuY2FsbCh0aGlzLCBcImRpcmVjdGlvbmFsXCIsIGxpZ2h0LCBkYXRhTm9kZSwgRGlyZWN0aW9uYWxMaWdodERhdGEpO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoRGlyZWN0aW9uYWxMaWdodE1vZGVsLCBMaWdodE1vZGVsLCB7XHJcbiAgICBnZXRGcnVzdHVtOiBmdW5jdGlvbihhc3BlY3QsIHNjZW5lQm91bmRpbmdCb3gpIHtcclxuICAgICAgICB2YXIgb3J0aG9nb25hbCA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmIChYTUwzRC5tYXRoLmJib3guaXNFbXB0eShzY2VuZUJvdW5kaW5nQm94KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZydXN0dW0oMS4wLCAxMTAuMCwgMCwgdGhpcy5mb3Z5LCBhc3BlY3QsIG9ydGhvZ29uYWwpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdF9tYXQgPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdGhpcy5nZXRMaWdodFZpZXdNYXRyaXgodF9tYXQpO1xyXG4gICAgICAgIFhNTDNELm1hdGguYmJveC50cmFuc2Zvcm0oc2NlbmVCb3VuZGluZ0JveCwgdF9tYXQsIHNjZW5lQm91bmRpbmdCb3gpO1xyXG5cclxuICAgICAgICB2YXIgbmYgPSB7ICBuZWFyOiAtc2NlbmVCb3VuZGluZ0JveFs1XSxcclxuICAgICAgICAgICAgICAgICAgICBmYXI6ICAtc2NlbmVCb3VuZGluZ0JveFsyXX07XHJcbiAgICAgICAgLy8gRXhwYW5kIHRoZSB2aWV3IGZydXN0dW0gYSBiaXQgdG8gZW5zdXJlIDJEIG9iamVjdHMgcGFyYWxsZWwgdG8gdGhlIGNhbWVyYSBhcmUgcmVuZGVyZWRcclxuICAgICAgICB0aGlzLl9leHBhbmROZWFyRmFyKG5mKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBGcnVzdHVtKDEuMCwgbmYuZmFyLCAwLCB0aGlzLmZvdnksIGFzcGVjdCwgb3J0aG9nb25hbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zZm9ybVBhcmFtZXRlcnM6IGZ1bmN0aW9uICh0YXJnZXQsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0YXJnZXRbXCJkaXJlY3Rpb25cIl0uc3ViYXJyYXkob2Zmc2V0ICogMywgb2Zmc2V0ICogMyArIDMpO1xyXG4gICAgICAgIHRyYW5zZm9ybVBvc2UodGhpcy5saWdodCwgbnVsbCwgZGlyZWN0aW9uKTtcclxuICAgICAgICB0cmFuc2Zvcm1EZWZhdWx0KHRhcmdldCwgb2Zmc2V0LCB0aGlzLmxpZ2h0KTtcclxuICAgIH0sXHJcblxyXG5cclxuXHJcbiAgICBnZXRMaWdodFZpZXdNYXRyaXg6IGZ1bmN0aW9uIChtYXQ0KSB7XHJcbiAgICAgICAgdmFyIG1hbmFnZXIgPSB0aGlzLmxpZ2h0LnNjZW5lLmxpZ2h0cztcclxuICAgICAgICB2YXIgZW50cnkgPSBtYW5hZ2VyLmdldE1vZGVsRW50cnkodGhpcy5pZCk7XHJcbiAgICAgICAgdmFyIHBfZGlyID0gZW50cnkucGFyYW1ldGVyc1tcImRpcmVjdGlvblwiXTtcclxuICAgICAgICB2YXIgcF9wb3MgPSBlbnRyeS5wYXJhbWV0ZXJzW1wicG9zaXRpb25cIl07XHJcblxyXG4gICAgICAgIHZhciBiYiA9IG5ldyBYTUwzRC5tYXRoLmJib3guY3JlYXRlKCk7XHJcbiAgICAgICAgdGhpcy5saWdodC5zY2VuZS5nZXRCb3VuZGluZ0JveChiYik7XHJcbiAgICAgICAgdmFyIGJiU2l6ZSA9IFhNTDNELm1hdGgudmVjMy5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgYmJDZW50ZXIgPSBYTUwzRC5tYXRoLnZlYzMuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIG9mZiA9IFhNTDNELm1hdGgudmVjMy5jcmVhdGUoKTtcclxuICAgICAgICBYTUwzRC5tYXRoLmJib3guY2VudGVyKGJiQ2VudGVyLCBiYik7XHJcbiAgICAgICAgWE1MM0QubWF0aC5iYm94LnNpemUoYmJTaXplLCBiYik7XHJcbiAgICAgICAgdmFyIGQgPSBYTUwzRC5tYXRoLnZlYzMubGVuKGJiU2l6ZSk7IC8vZGlhbWV0ZXIgb2YgYm91bmRpbmcgc3BoZXJlIG9mIHRoZSBzY2VuZVxyXG4gICAgICAgIFhNTDNELm1hdGgudmVjMy5zY2FsZShvZmYsIHBfZGlyLCAtMC41NSAqIGQpOyAvL2VubGFyZ2UgYSBiaXQgb24gdGhlIHJhZGl1cyBvZiB0aGUgc2NlbmVcclxuICAgICAgICBwX3BvcyA9IFhNTDNELm1hdGgudmVjMy5hZGQocF9wb3MsIGJiQ2VudGVyLCBvZmYpO1xyXG4gICAgICAgIGVudHJ5LnBhcmFtZXRlcnNbXCJwb3NpdGlvblwiXSA9IHBfcG9zO1xyXG5cclxuXHJcbiAgICAgICAgLy9jcmVhdGUgbmV3IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBkZXBlbmRpbmcgb24gdGhlIHVwZGF0ZWQgcGFyYW1ldGVyc1xyXG4gICAgICAgIFhNTDNELm1hdGgubWF0NC5pZGVudGl0eShtYXQ0KTtcclxuICAgICAgICB2YXIgbG9va2F0X21hdCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgdG9wX3ZlYyA9IFhNTDNELm1hdGgudmVjMy5mcm9tVmFsdWVzKDAuMCwgMS4wLCAwLjApO1xyXG4gICAgICAgIGlmICgocF9kaXJbMF0gPT0gMC4wKSAmJiAocF9kaXJbMl0gPT0gMC4wKSkgLy9jaGVjayBpZiB0b3BfdmVjIGNvbGluZWFyIHdpdGggZGlyZWN0aW9uXHJcbiAgICAgICAgICAgIHRvcF92ZWMgPSBYTUwzRC5tYXRoLnZlYzMuZnJvbVZhbHVlcygwLjAsIDAuMCwgMS4wKTtcclxuICAgICAgICB2YXIgdXBfdmVjID0gWE1MM0QubWF0aC52ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBkaXJfbGVuID0gWE1MM0QubWF0aC52ZWMzLmxlbihwX2Rpcik7XHJcbiAgICAgICAgWE1MM0QubWF0aC52ZWMzLnNjYWxlKHVwX3ZlYywgcF9kaXIsIC1YTUwzRC5tYXRoLnZlYzMuZG90KHRvcF92ZWMsIHBfZGlyKSAvIChkaXJfbGVuICogZGlyX2xlbikpO1xyXG4gICAgICAgIFhNTDNELm1hdGgudmVjMy5hZGQodXBfdmVjLCB1cF92ZWMsIHRvcF92ZWMpO1xyXG4gICAgICAgIFhNTDNELm1hdGgudmVjMy5ub3JtYWxpemUodXBfdmVjLCB1cF92ZWMpO1xyXG4gICAgICAgIFhNTDNELm1hdGgubWF0NC5sb29rQXQobG9va2F0X21hdCwgWE1MM0QubWF0aC52ZWMzLmZyb21WYWx1ZXMoMC4wLCAwLjAsIDAuMCksIHBfZGlyLCB1cF92ZWMpO1xyXG4gICAgICAgIFhNTDNELm1hdGgubWF0NC5pbnZlcnQobG9va2F0X21hdCwgbG9va2F0X21hdCk7XHJcbiAgICAgICAgWE1MM0QubWF0aC5tYXQ0LnRyYW5zbGF0ZShtYXQ0LCBtYXQ0LCBwX3Bvcyk7XHJcbiAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5KG1hdDQsIG1hdDQsIGxvb2thdF9tYXQpO1xyXG5cclxuICAgICAgICB2YXIgYmIgPSBuZXcgWE1MM0QubWF0aC5iYm94LmNyZWF0ZSgpO1xyXG4gICAgICAgIHRoaXMubGlnaHQuc2NlbmUuZ2V0Qm91bmRpbmdCb3goYmIpO1xyXG4gICAgICAgIFhNTDNELm1hdGguYmJveC50cmFuc2Zvcm0oYmIsIG1hdDQsIGJiKTtcclxuICAgICAgICB2YXIgYmJTaXplID0gWE1MM0QubWF0aC52ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIFhNTDNELm1hdGguYmJveC5zaXplKGJiU2l6ZSwgYmIpO1xyXG4gICAgICAgIHZhciBtYXggPSAoYmJTaXplWzBdID4gYmJTaXplWzFdKSA/IGJiU2l6ZVswXSA6IGJiU2l6ZVsxXTtcclxuICAgICAgICBtYXggPSAwLjU1ICogKG1heCk7Ly9lbmxhcmdlIDEwcGVyY2VudCB0byBtYWtlIHN1cmUgbm90aGluZyBnZXRzIGN1dCBvZmZcclxuICAgICAgICB0aGlzLmZvdnkgPSBNYXRoLmF0YW4obWF4KSoyLjA7XHJcblxyXG4gICAgICAgIGVudHJ5LnBhcmFtZXRlcnNbXCJkaXJlY3Rpb25cIl0gPSBwX2RpcjtcclxuICAgICAgICBlbnRyeS5wYXJhbWV0ZXJzW1wicG9zaXRpb25cIl0gID0gcF9wb3M7XHJcblxyXG4gICAgICAgIFhNTDNELm1hdGgubWF0NC5pbnZlcnQobWF0NCwgbWF0NCk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgUG9pbnRMaWdodE1vZGVsOiBQb2ludExpZ2h0TW9kZWwsIFNwb3RMaWdodE1vZGVsOiBTcG90TGlnaHRNb2RlbCwgRGlyZWN0aW9uYWxMaWdodE1vZGVsOiBEaXJlY3Rpb25hbExpZ2h0TW9kZWxcclxuXHJcbn07XHJcbiIsInZhciBHTFJlbmRlcmVyID0gcmVxdWlyZShcIi4uL3dlYmdsL3JlbmRlcmVyLmpzXCIpO1xyXG52YXIgR0xDYW52YXNIYW5kbGVyID0gcmVxdWlyZShcIi4uL3dlYmdsL2NhbnZhcy1oYW5kbGVyLmpzXCIpO1xyXG5cclxudmFyIFJlbmRlcmVyRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY3JlYXRlUmVuZGVyZXIgPSBmdW5jdGlvbiAoeG1sM2RFbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IHhtbDNkRWxlbWVudC5fY29uZmlndXJlZC5jYW52YXM7XHJcbiAgICAgICAgdmFyIGNhbnZhc0hhbmRsZXIgPSBuZXcgR0xDYW52YXNIYW5kbGVyKHhtbDNkRWxlbWVudCwgY2FudmFzKTtcclxuICAgICAgICB2YXIgcmVuZGVyZXIgPSBuZXcgR0xSZW5kZXJlcih4bWwzZEVsZW1lbnQsIGNhbnZhc0hhbmRsZXIpO1xyXG4gICAgICAgIGNhbnZhc0hhbmRsZXIuc2V0UmVuZGVyZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FudmFzSGFuZGxlci50aWNrKTtcclxuICAgICAgICByZXR1cm4gcmVuZGVyZXI7XHJcbiAgICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IFJlbmRlcmVyRmFjdG9yeSgpO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBOT0RFX1RZUEU6IHtcclxuICAgICAgICBHUk9VUDogXCJncm91cFwiLCBPQkpFQ1Q6IFwib2JqZWN0XCIsIExJR0hUOiBcImxpZ2h0XCIsIFZJRVc6IFwidmlld1wiXHJcbiAgICB9LFxyXG5cclxuICAgIEVWRU5UX1RZUEU6IHtcclxuICAgICAgICBWSUVXX0NIQU5HRUQ6IFwidmlld19jaGFuZ2VkXCIsXHJcbiAgICAgICAgTElHSFRfU1RSVUNUVVJFX0NIQU5HRUQ6IFwibGlnaHRfc3RydWN0dXJlX2NoYW5nZWRcIixcclxuICAgICAgICBMSUdIVF9WQUxVRV9DSEFOR0VEOiBcImxpZ2h0X3ZhbHVlX2NoYW5nZWRcIixcclxuICAgICAgICBTQ0VORV9TSEFQRV9DSEFOR0VEOiBcInNjZW5lX3NoYXBlX2NoYW5nZWRcIixcclxuICAgICAgICBTQ0VORV9TVFJVQ1RVUkVfQ0hBTkdFRDogXCJzY2VuZV9zdHJ1Y3R1cmVfY2hhbmdlZFwiLFxyXG4gICAgICAgIERSQVdBQkxFX1NUQVRFX0NIQU5HRUQ6IFwiZHJhd2FibGVfc3RhdGVfY2hhbmdlZFwiXHJcblxyXG4gICAgfVxyXG59O1xyXG4iLCJ2YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnRyaWIvRXZlbnREaXNwYXRjaGVyLmpzXCIpO1xyXG5cclxudmFyIERyYXdhYmxlQ2xvc3VyZSA9IGZ1bmN0aW9uIChjb250ZXh0LCB0eXBlKSB7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLl92YWxpZCA9IGZhbHNlO1xyXG59O1xyXG5cclxuRHJhd2FibGVDbG9zdXJlLlRZUEVTID0ge1xyXG4gICAgTUVTSDogXCJtZXNoXCIsIFZPTFVNRTogXCJ2b2x1bWVcIlxyXG59O1xyXG5cclxuRHJhd2FibGVDbG9zdXJlLlJFQURZX1NUQVRFID0ge1xyXG4gICAgQ09NUExFVEU6IFwiY29tcGxldGVcIiwgSU5DT01QTEVURTogXCJpbmNvbXBsZXRlXCJcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKERyYXdhYmxlQ2xvc3VyZSwgRXZlbnREaXNwYXRjaGVyLCB7XHJcbiAgICBnZXRUeXBlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XHJcbiAgICB9LCBpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkO1xyXG4gICAgfSwgc2V0U2hhZGVyQ29tcG9zZXI6IGZ1bmN0aW9uIChzaGFkZXJDb21wb3Nlcikge1xyXG4gICAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzXHJcbiAgICB9LCB1cGRhdGU6IGZ1bmN0aW9uIChzY2VuZSkge1xyXG4gICAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzXHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEcmF3YWJsZUNsb3N1cmU7XHJcblxyXG4iLCJ2YXIgdW5pcXVlT2JqZWN0SWQgPSByZXF1aXJlKFwiLi4vLi4vd2ViZ2wvYmFzZS91dGlscy5qc1wiKS5nZXRVbmlxdWVDb3VudGVyKCk7XHJcbi8qKlxyXG4gKiBDb25uZWN0cyBhIG1hdGVyaWFsIG1vZGVsIHdpdGggYSBzZXQgb2YgZGVmYXVsdCBwYXJhbWV0ZXJzIGRlZmluZWQgYnlcclxuICogYW4gWGZsb3cgRGF0YU5vZGUuIFRoZSBNYXRlcmlhbENvbmZpZ3VyYXRpb24gaXMgaW1tdXRhYmxlXHJcbiAqXHJcbiAqIEBwYXJhbSBtb2RlbCBUaGUgbWF0ZXJpYWwgbW9kZWxcclxuICogQHBhcmFtIHtYZmxvdy5EYXRhTm9kZX0gZGF0YU5vZGUgIFRoZSBtYXRlcmlhbCBwYXJhbWV0ZXJzIG9mIHRoaXMgbm9kZVxyXG4gKiBAcGFyYW0ge3t9fSBvcHRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgTWF0ZXJpYWxDb25maWd1cmF0aW9uID0gZnVuY3Rpb24obW9kZWwsIGRhdGFOb2RlLCBvcHQpIHtcclxuICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuXHJcbiAgICB0aGlzLmlkID0gdW5pcXVlT2JqZWN0SWQoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHt7dHlwZTogc3RyaW5nfX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGF0YSBOb2RlIG9mIHRoZSByZW5kZXJPYmplY3RcclxuICAgICAqIEB0eXBlIHtYZmxvdy5EYXRhTm9kZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kYXRhTm9kZSA9IGRhdGFOb2RlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBuYW1lIGZvciBkZWJ1ZyBwdXJwb3Nlc1xyXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm5hbWUgPSBvcHQubmFtZSB8fCBudWxsO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYXRlcmlhbENvbmZpZ3VyYXRpb247XHJcbiIsInZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29udHJpYi9FdmVudERpc3BhdGNoZXIuanNcIik7XHJcblxyXG4vKipcclxuICogQGV4dGVuZHMge0V2ZW50RGlzcGF0Y2hlcn1cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgUGFnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvKiogQHR5cGUgQXJyYXk8RmxvYXQzMkFycmF5PiAqL1xyXG4gICAgdGhpcy5wYWdlcyA9IFtdO1xyXG4gICAgLyoqIEB0eXBlIG51bWJlciAqL1xyXG4gICAgdGhpcy5uZXh0T2Zmc2V0ID0gMDtcclxuICAgIC8qKiBAdHlwZSBBcnJheTwqPiAqL1xyXG4gICAgdGhpcy5mcmVlRW50cmllcyA9IFtdO1xyXG4gICAgLy8gQWRkIGEgZmlyc3QgcGFnZVxyXG4gICAgdGhpcy5hZGRQYWdlKCk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhQYWdlciwgRXZlbnREaXNwYXRjaGVyLCB7XHJcbiAgICBhZGRQYWdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhZ2UgPSBuZXcgRmxvYXQzMkFycmF5KFBhZ2VyLlBBR0VfU0laRSk7XHJcbiAgICAgICAgdGhpcy5wYWdlcy5wdXNoKHBhZ2UpO1xyXG4gICAgICAgIHRoaXMubmV4dE9mZnNldCA9IDA7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nSW5mbyhcIkFkZGluZyBwYWdlXCIsIHRoaXMucGFnZXMubGVuZ3RoLCBcIihcIiwgUGFnZXIuUEFHRV9TSVpFICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogdGhpcy5wYWdlcy5sZW5ndGggLyAxMDI0LCBcImtCKVwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UGFnZUVudHJ5OiBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICAgIGlmICghc2l6ZSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2l6ZSBnaXZlbiBmb3IgcGFnZSBlbnRyeVwiKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXVzZVBhZ2VFbnRyeShzaXplKSB8fCB0aGlzLmNyZWF0ZVBhZ2VFbnRyeShzaXplKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBSZXF1ZXN0ZWQgc2l6ZSBpbiBudW1iZXIgb2YgZmxvYXRzXHJcbiAgICAgKiBAcmV0dXJucyB7eyBwYWdlOiBGbG9hdDMyQXJyYXksIG9mZnNldDogbnVtYmVyLCBzaXplOiBudW1iZXIgfX1cclxuICAgICAqL1xyXG4gICAgcmV1c2VQYWdlRW50cnk6IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgdmFyIHNhbWVTaXplRW50cmllcyA9IHRoaXMuZnJlZUVudHJpZXNbc2l6ZV07XHJcbiAgICAgICAgaWYgKHNhbWVTaXplRW50cmllcyAmJiBzYW1lU2l6ZUVudHJpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzYW1lU2l6ZUVudHJpZXMucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplICBTaXplIGluIG51bWJlciBvZiBmbG9hdHNcclxuICAgICAqIEByZXR1cm5zIHt7IHBhZ2U6IEZsb2F0MzJBcnJheSwgb2Zmc2V0OiBudW1iZXIsIHNpemU6IG51bWJlciB9fVxyXG4gICAgICovXHJcbiAgICBjcmVhdGVQYWdlRW50cnk6IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubmV4dE9mZnNldCArIHNpemUgPiBQYWdlci5QQUdFX1NJWkUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRQYWdlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFBhZ2VFbnRyeShzaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhZ2UgPSB0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgdmFyIGxvY2FsT2Zmc2V0ID0gdGhpcy5uZXh0T2Zmc2V0O1xyXG4gICAgICAgIHRoaXMubmV4dE9mZnNldCArPSBzaXplO1xyXG4gICAgICAgIHJldHVybiB7cGFnZTogcGFnZSwgb2Zmc2V0OiBsb2NhbE9mZnNldCwgc2l6ZTogc2l6ZX07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7eyBwYWdlOiBGbG9hdDMyQXJyYXksIG9mZnNldDogbnVtYmVyLCBzaXplOiBudW1iZXIgfX0gZW50cnlJbmZvXHJcbiAgICAgKi9cclxuICAgIGZyZWVQYWdlRW50cnk6IGZ1bmN0aW9uIChlbnRyeUluZm8pIHtcclxuICAgICAgICB2YXIgc2FtZVNpemVFbnRyaWVzID0gdGhpcy5mcmVlRW50cmllc1tlbnRyeUluZm8uc2l6ZV07XHJcbiAgICAgICAgaWYgKCFzYW1lU2l6ZUVudHJpZXMpIHtcclxuICAgICAgICAgICAgc2FtZVNpemVFbnRyaWVzID0gdGhpcy5mcmVlRW50cmllc1tlbnRyeUluZm8uc2l6ZV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2FtZVNpemVFbnRyaWVzLnB1c2goZW50cnlJbmZvKTtcclxuICAgIH1cclxufSk7XHJcblBhZ2VyLlBBR0VfU0laRSA9IDEgPDwgMTI7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VyO1xyXG5cclxuIiwidmFyIFJlbmRlck5vZGUgPSByZXF1aXJlKFwiLi9yZW5kZXJub2RlLmpzXCIpO1xyXG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xyXG5cclxudmFyIE5PREVfVFlQRSA9IENvbnN0YW50cy5OT0RFX1RZUEU7XHJcbnZhciBFVkVOVF9UWVBFID0gQ29uc3RhbnRzLkVWRU5UX1RZUEU7XHJcblxyXG4vKiogQGNvbnN0ICovXHJcbnZhciBXT1JMRF9NQVRSSVhfT0ZGU0VUID0gMDtcclxuLyoqIEBjb25zdCAqL1xyXG52YXIgTE9DQUxfTUFUUklYX09GRlNFVCA9IFdPUkxEX01BVFJJWF9PRkZTRVQgKyAxNjtcclxuLyoqIEBjb25zdCAqL1xyXG52YXIgV09STERfQkJfT0ZGU0VUID0gTE9DQUxfTUFUUklYX09GRlNFVCArIDE2O1xyXG4vKiogQGNvbnN0ICovXHJcbnZhciBFTlRSWV9TSVpFID0gV09STERfQkJfT0ZGU0VUICsgNjtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMge1JlbmRlck5vZGV9XHJcbiAqL1xyXG52YXIgUmVuZGVyR3JvdXAgPSBmdW5jdGlvbiAoc2NlbmUsIHBhZ2VFbnRyeSwgb3B0KSB7XHJcbiAgICBSZW5kZXJOb2RlLmNhbGwodGhpcywgTk9ERV9UWVBFLkdST1VQLCBzY2VuZSwgcGFnZUVudHJ5LCBvcHQpO1xyXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1hdGVyaWFsIGF0dGFjaGVkIHRvIHRoaXMgZ3JvdXBcclxuICAgICAqIEB0eXBlIHtNYXRlcmlhbENvbmZpZ3VyYXRpb258bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBvcHQubWF0ZXJpYWwgfHwgbnVsbDtcclxuICAgIHRoaXMuYm91bmRpbmdCb3hEaXJ0eSA9IGZhbHNlO1xyXG4gICAgdGhpcy5zZXRXb3JsZFNwYWNlQm91bmRpbmdCb3goWE1MM0QubWF0aC5iYm94LkVNUFRZX0JPWCk7XHJcbn07XHJcblJlbmRlckdyb3VwLkVOVFJZX1NJWkUgPSBFTlRSWV9TSVpFO1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoUmVuZGVyR3JvdXAsIFJlbmRlck5vZGUpO1xyXG5cclxuWE1MM0QuZXh0ZW5kKFJlbmRlckdyb3VwLnByb3RvdHlwZSwge1xyXG4gICAgZ2V0TG9jYWxNYXRyaXg6IGZ1bmN0aW9uIChkZXN0KSB7XHJcbiAgICAgICAgdmFyIG8gPSB0aGlzLm9mZnNldCArIExPQ0FMX01BVFJJWF9PRkZTRVQ7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrLCBvKyspIHtcclxuICAgICAgICAgICAgZGVzdFtpXSA9IHRoaXMucGFnZVtvXTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldExvY2FsTWF0cml4OiBmdW5jdGlvbiAoc291cmNlKSB7XHJcbiAgICAgICAgdmFyIG8gPSB0aGlzLm9mZnNldCArIExPQ0FMX01BVFJJWF9PRkZTRVQ7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrLCBvKyspIHtcclxuICAgICAgICAgICAgdGhpcy5wYWdlW29dID0gc291cmNlW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgICAgICAgdGhpcy5zZXRCb3VuZGluZ0JveERpcnR5KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFdvcmxkU3BhY2VCb3VuZGluZ0JveDogZnVuY3Rpb24gKGJib3gpIHtcclxuICAgICAgICBpZiAodGhpcy5ib3VuZGluZ0JveERpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlV29ybGRTcGFjZUJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBXT1JMRF9CQl9PRkZTRVQ7XHJcbiAgICAgICAgYmJveFswXSA9IHRoaXMucGFnZVtvXTtcclxuICAgICAgICBiYm94WzFdID0gdGhpcy5wYWdlW28gKyAxXTtcclxuICAgICAgICBiYm94WzJdID0gdGhpcy5wYWdlW28gKyAyXTtcclxuICAgICAgICBiYm94WzNdID0gdGhpcy5wYWdlW28gKyAzXTtcclxuICAgICAgICBiYm94WzRdID0gdGhpcy5wYWdlW28gKyA0XTtcclxuICAgICAgICBiYm94WzVdID0gdGhpcy5wYWdlW28gKyA1XTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0V29ybGRTcGFjZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYmJveCkge1xyXG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBXT1JMRF9CQl9PRkZTRVQ7XHJcbiAgICAgICAgdGhpcy5wYWdlW29dID0gYmJveFswXTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDFdID0gYmJveFsxXTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDJdID0gYmJveFsyXTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDNdID0gYmJveFszXTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDRdID0gYmJveFs0XTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDVdID0gYmJveFs1XTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIHVwZGF0ZVdvcmxkU3BhY2VCb3VuZGluZ0JveDogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2hpbGRCQiA9IFhNTDNELm1hdGguYmJveC5jcmVhdGUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGxvY2FsQkIgPSBYTUwzRC5tYXRoLmJib3guY3JlYXRlKCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChvYmouaXNWaXNpYmxlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvYmouZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGNoaWxkQkIpO1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELm1hdGguYmJveC5leHRlbmRXaXRoQm94KGxvY2FsQkIsIGNoaWxkQkIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGxvY2FsQkIpO1xyXG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94RGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KSgpLFxyXG5cclxuICAgIGFkZENoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG4gICAgICAgIHRoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpO1xyXG4gICAgICAgIHRoaXMuc2NlbmUuZGlzcGF0Y2hFdmVudCh7dHlwZTogRVZFTlRfVFlQRS5TQ0VORV9TVFJVQ1RVUkVfQ0hBTkdFRCwgbmV3Q2hpbGQ6IGNoaWxkfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2NlbmUuZGlzcGF0Y2hFdmVudCh7dHlwZTogRVZFTlRfVFlQRS5TQ0VORV9TVFJVQ1RVUkVfQ0hBTkdFRCwgcmVtb3ZlZENoaWxkOiBjaGlsZH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVXb3JsZE1hdHJpeDogZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHZhciBwYWdlID0gdGhpcy5wYWdlO1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHlPZmZzZXQocGFnZSwgb2Zmc2V0ICsgV09STERfTUFUUklYX09GRlNFVCwgcGFnZSwgb2Zmc2V0ICsgTE9DQUxfTUFUUklYX09GRlNFVCwgc291cmNlLCAwKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybURpcnR5ID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRyYW5zZm9ybURpcnR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtRGlydHkpIHtcclxuICAgICAgICAgICAgLy9XZSBjYW4gYmUgc3VyZSBhbGwgY2hpbGQgbm9kZXMgYXJlIGFscmVhZHkgc2V0IHRvIHRyYW5zZm9ybURpcnR5IGZyb20gaGVyZVxyXG4gICAgICAgICAgICAvL3JldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1EaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgb2JqLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtNYXRlcmlhbENvbmZpZ3VyYXRpb258bnVsbH0gbWF0ZXJpYWxcclxuICAgICAqL1xyXG4gICAgc2V0TWF0ZXJpYWw6IGZ1bmN0aW9uIChtYXRlcmlhbCkge1xyXG4gICAgICAgIGlmKHRoaXMuX21hdGVyaWFsID09PSBtYXRlcmlhbClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuX21hdGVyaWFsID0gbWF0ZXJpYWw7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgb2JqLnBhcmVudE1hdGVyaWFsQ2hhbmdlZCAmJiBvYmoucGFyZW50TWF0ZXJpYWxDaGFuZ2VkKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHBhcmVudE1hdGVyaWFsQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9tYXRlcmlhbCkge1xyXG4gICAgICAgICAgICAvLyBMb2NhbCBtYXRlcmlhbCBvdmVycmlkZXMgYW55dGhpbmcgY29taW5nIGZyb20gdXBzdHJlYW1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICBvYmoucGFyZW50TWF0ZXJpYWxDaGFuZ2VkICYmIG9iai5wYXJlbnRNYXRlcmlhbENoYW5nZWQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7TWF0ZXJpYWxDb25maWd1cmF0aW9ufVxyXG4gICAgICovXHJcbiAgICBnZXRNYXRlcmlhbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXRlcmlhbCB8fCB0aGlzLnBhcmVudC5nZXRNYXRlcmlhbCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRCb3VuZGluZ0JveERpcnR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveERpcnR5ID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2V0TG9jYWxWaXNpYmxlOiBmdW5jdGlvbiAobmV3VmFsKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFZpc2libGUgPSBuZXdWYWw7XHJcbiAgICAgICAgdGhpcy5zZXRWaXNpYmxlKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzVmlzaWJsZSgpICYmIG5ld1ZhbCk7XHJcbiAgICAgICAgdGhpcy5zZXRCb3VuZGluZ0JveERpcnR5KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbmRSYXlJbnRlcnNlY3Rpb25zOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiYm94ID0gWE1MM0QubWF0aC5iYm94LmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJheSwgaW50ZXJzZWN0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmdldFdvcmxkU3BhY2VCb3VuZGluZ0JveChiYm94KTtcclxuICAgICAgICAgICAgaWYgKFhNTDNELm1hdGguYmJveC5pbnRlcnNlY3RzKGJib3gsIHJheSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZmluZFJheUludGVyc2VjdGlvbnMocmF5LCBpbnRlcnNlY3Rpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pKClcclxuXHJcbn0pO1xyXG5cclxuLy8gRXhwb3J0XHJcbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyR3JvdXA7XHJcblxyXG4iLCJ2YXIgUmVuZGVyTm9kZSA9IHJlcXVpcmUoXCIuL3JlbmRlcm5vZGUuanNcIik7XHJcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XHJcbnZhciBMaWdodE1vZGVscyA9IHJlcXVpcmUoXCIuLi9saWdodHMvbGlnaHQtbW9kZWxzLmpzXCIpO1xyXG5cclxudmFyIE5PREVfVFlQRSA9IENvbnN0YW50cy5OT0RFX1RZUEU7XHJcbnZhciBFVkVOVF9UWVBFID0gQ29uc3RhbnRzLkVWRU5UX1RZUEU7XHJcblxyXG52YXIgdG1wX3dvcmxkTWF0cml4ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG5cclxudmFyIFNIQURPV01BUF9PRkZTRVRfTUFUUklYID0gbmV3IEZsb2F0MzJBcnJheShbMC41LCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuNSwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjUsIDAuMCwgMC41LCAwLjUsIDAuNSwgMS4wXSk7XHJcblxyXG4vKiogQGNvbnN0ICovXHJcbnZhciBDTElQUExBTkVfTkVBUl9NSU4gPSAxLjA7XHJcblxyXG4vKiogQGNvbnN0ICovXHJcbnZhciBFTlRSWV9TSVpFID0gMTY7XHJcblxyXG52YXIgY19Cb3VuZGluZ0JveCA9IG5ldyBYTUwzRC5tYXRoLmJib3guY3JlYXRlKCk7XHJcblxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGlnaHRNb2RlbCh0eXBlLCBkYXRhLCBsaWdodCkge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBcInBvaW50XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlnaHRNb2RlbHMuUG9pbnRMaWdodE1vZGVsKGRhdGEsIGxpZ2h0KTtcclxuICAgICAgICBjYXNlIFwic3BvdFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExpZ2h0TW9kZWxzLlNwb3RMaWdodE1vZGVsKGRhdGEsIGxpZ2h0KTtcclxuICAgICAgICBjYXNlIFwiZGlyZWN0aW9uYWxcIjpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaWdodE1vZGVscy5EaXJlY3Rpb25hbExpZ2h0TW9kZWwoZGF0YSwgbGlnaHQpO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJVbmtub3duIGxpZ2h0IG1vZGVsOiBcIiwgdHlwZSwgXCIuIFVzaW5nIGRpcmVjdGlvbmFsIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExpZ2h0TW9kZWxzLkRpcmVjdGlvbmFsTGlnaHRNb2RlbChkYXRhLCBsaWdodCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtTY2VuZX0gc2NlbmVcclxuICogQHBhcmFtIHtPYmplY3R9IHBhZ2VFbnRyeVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0XHJcbiAqIEBleHRlbmRzIHtSZW5kZXJOb2RlfVxyXG4gKi9cclxudmFyIFJlbmRlckxpZ2h0ID0gZnVuY3Rpb24gKHNjZW5lLCBwYWdlRW50cnksIG9wdCkge1xyXG4gICAgUmVuZGVyTm9kZS5jYWxsKHRoaXMsIE5PREVfVFlQRS5MSUdIVCwgc2NlbmUsIHBhZ2VFbnRyeSwgb3B0KTtcclxuICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgIHZhciBsaWdodCA9IG9wdC5saWdodCB8fCB7fTtcclxuICAgIHRoaXMudXNlckRhdGEgPSBudWxsO1xyXG4gICAgdGhpcy5sb2NhbEludGVuc2l0eSA9IG9wdC5sb2NhbEludGVuc2l0eSAhPT0gdW5kZWZpbmVkID8gb3B0LmxvY2FsSW50ZW5zaXR5IDogMS4wO1xyXG4gICAgdGhpcy5zZXRMaWdodFR5cGUobGlnaHQudHlwZSwgbGlnaHQuZGF0YSk7XHJcbn07XHJcblJlbmRlckxpZ2h0LkVOVFJZX1NJWkUgPSBFTlRSWV9TSVpFO1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoUmVuZGVyTGlnaHQsIFJlbmRlck5vZGUpO1xyXG5YTUwzRC5leHRlbmQoUmVuZGVyTGlnaHQucHJvdG90eXBlLCB7XHJcblxyXG4gICAgc2V0TGlnaHRUeXBlOiBmdW5jdGlvbiAobW9kZWxJZCwgZGF0YSkge1xyXG4gICAgICAgIG1vZGVsSWQgPSBtb2RlbElkIHx8IFwiZGlyZWN0aW9uYWxcIjtcclxuICAgICAgICBpZiAodGhpcy5tb2RlbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5pZCA9PSBtb2RlbElkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIE5vdGhpbmcgY2hhbmdlZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUubGlnaHRzLnJlbW92ZSh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5saWdodFN0cnVjdHVyZUNoYW5nZWQodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubW9kZWwgPSBjcmVhdGVMaWdodE1vZGVsKG1vZGVsSWQsIGRhdGEsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2NlbmUubGlnaHRzLmFkZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmxpZ2h0U3RydWN0dXJlQ2hhbmdlZChmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEZydXN0dW06IGZ1bmN0aW9uIChhc3BlY3QpIHtcclxuICAgICAgICB0aGlzLnNjZW5lLmdldEJvdW5kaW5nQm94KGNfQm91bmRpbmdCb3gpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmdldEZydXN0dW0oYXNwZWN0LCBjX0JvdW5kaW5nQm94KTtcclxuICAgIH0sXHJcblxyXG4gICAgbGlnaHRWYWx1ZUNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5tb2RlbCkgeyAvLyBGSVhNRTogQ29tcGxleCBkZXBlbmRlbmN5XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuZGlzcGF0Y2hFdmVudCh7dHlwZTogRVZFTlRfVFlQRS5MSUdIVF9WQUxVRV9DSEFOR0VELCBsaWdodDogdGhpc30pO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbGlnaHRTdHJ1Y3R1cmVDaGFuZ2VkOiBmdW5jdGlvbiAocmVtb3ZlZCkge1xyXG4gICAgICAgIHRoaXMuc2NlbmUuZGlzcGF0Y2hFdmVudCh7dHlwZTogRVZFTlRfVFlQRS5MSUdIVF9TVFJVQ1RVUkVfQ0hBTkdFRCwgbGlnaHQ6IHRoaXMsIHJlbW92ZWQ6IHJlbW92ZWR9KTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlV29ybGRNYXRyaXg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXgodG1wX3dvcmxkTWF0cml4KTtcclxuICAgICAgICAgICAgdGhpcy5zZXRXb3JsZE1hdHJpeCh0bXBfd29ybGRNYXRyaXgpO1xyXG4gICAgICAgICAgICAvLyBXZSBjaGFuZ2UgcG9zaXRpb24gLyBkaXJlY3Rpb24gb2YgdGhlIGxpZ2h0XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHRWYWx1ZUNoYW5nZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRyYW5zZm9ybURpcnR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgc2V0VmlzaWJsZTogZnVuY3Rpb24gKG5ld1ZhbCkge1xyXG4gICAgICAgIHZhciB2aXNpYmxlID0gKHRoaXMubG9jYWxWaXNpYmxlICYmIG5ld1ZhbCk7XHJcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSAhPSB2aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHRWYWx1ZUNoYW5nZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldExvY2FsSW50ZW5zaXR5OiBmdW5jdGlvbiAoaW50ZW5zaXR5KSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbEludGVuc2l0eSA9IGludGVuc2l0eTtcclxuICAgICAgICB0aGlzLmxpZ2h0VmFsdWVDaGFuZ2VkKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2NlbmUubGlnaHRzLnJlbW92ZSh0aGlzKTtcclxuICAgICAgICB0aGlzLmxpZ2h0U3RydWN0dXJlQ2hhbmdlZCh0cnVlKTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIGdldFdvcmxkU3BhY2VCb3VuZGluZ0JveDogZnVuY3Rpb24gKGJib3gpIHtcclxuICAgICAgICBYTUwzRC5tYXRoLmJib3guZW1wdHkoYmJveCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJMaWdodDtcclxuXHJcblxyXG4iLCIvKiogQGNvbnN0ICovXHJcbnZhciBXT1JMRF9NQVRSSVhfT0ZGU0VUID0gMDtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHR5cGVcclxuICogQHBhcmFtIHtTY2VuZX0gc2NlbmVcclxuICogQHBhcmFtIHtPYmplY3R9IHBhZ2VFbnRyeVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0XHJcbiAqL1xyXG52YXIgUmVuZGVyTm9kZSA9IGZ1bmN0aW9uICh0eXBlLCBzY2VuZSwgcGFnZUVudHJ5LCBvcHQpIHtcclxuICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuXHJcbiAgICB2YXIgdmlzaWJsZSA9IChvcHQudmlzaWJsZSAhPT0gZmFsc2UpO1xyXG5cclxuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLm5hbWUgPSBvcHQubmFtZSB8fCBcIlwiO1xyXG4gICAgdGhpcy5wYWdlID0gcGFnZUVudHJ5LnBhZ2U7XHJcbiAgICB0aGlzLm9mZnNldCA9IHBhZ2VFbnRyeS5vZmZzZXQ7XHJcbiAgICB0aGlzLmVudHJ5U2l6ZSA9IHBhZ2VFbnRyeS5zaXplO1xyXG4gICAgdGhpcy50cmFuc2Zvcm1EaXJ0eSA9IHRydWU7XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICB0aGlzLnNldFBhcmVudChvcHQucGFyZW50IHx8IHNjZW5lLnJvb3ROb2RlKTtcclxuICAgIC8vIFRoZSBnbG9iYWwgdmlzaWJpbGl0eSBkZXBlbmRzIG9uIHZpc2liaWxpdHkgb2YgcGFyZW50c1xyXG4gICAgdGhpcy52aXNpYmxlID0gdW5kZWZpbmVkO1xyXG4gICAgLy8gYW5kIHdpbGwgYmUgZXZhbHVhdGVkIGJ5IHNldExvY2FsVmlzaWJsZVxyXG4gICAgdGhpcy5zZXRMb2NhbFZpc2libGUodmlzaWJsZSk7XHJcbn07XHJcblxyXG5YTUwzRC5leHRlbmQoUmVuZGVyTm9kZS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBnZXRDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRQYXJlbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFBhcmVudDogZnVuY3Rpb24gKHBhcmVudCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmFkZENoaWxkKSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5hZGRDaGlsZCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVldmFsdWF0ZSB2aXNpYmlsaXR5LCB3aGljaCBtaWdodCBjaGFuZ2UgZHVlIHRvXHJcbiAgICAgICAgLy8gaW52aXNpYmlsaXR5IG9mIHBhcmVudFxyXG4gICAgICAgIHRoaXMuc2V0TG9jYWxWaXNpYmxlKHRoaXMubG9jYWxWaXNpYmxlKTtcclxuICAgIH0sXHJcblxyXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgY2hpbGQudHJhdmVyc2UoY2FsbGJhY2spO1xyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFdvcmxkTWF0cml4OiBmdW5jdGlvbiAoZGVzdCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybURpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4KGRlc3QpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KGRlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbyA9IHRoaXMub2Zmc2V0ICsgV09STERfTUFUUklYX09GRlNFVDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyssIG8rKykge1xyXG4gICAgICAgICAgICBkZXN0W2ldID0gdGhpcy5wYWdlW29dO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2V0V29ybGRNYXRyaXg6IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICB2YXIgbyA9IHRoaXMub2Zmc2V0ICsgV09STERfTUFUUklYX09GRlNFVDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyssIG8rKykge1xyXG4gICAgICAgICAgICB0aGlzLnBhZ2Vbb10gPSBzb3VyY2VbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtRGlydHkgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5zZXRCb3VuZGluZ0JveERpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgaXNWaXNpYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VHJhbnNmb3JtRGlydHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybURpcnR5ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0TG9jYWxWaXNpYmxlOiBmdW5jdGlvbiAobmV3VmFsKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFZpc2libGUgPSBuZXdWYWw7XHJcbiAgICAgICAgdGhpcy5zZXRWaXNpYmxlKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzVmlzaWJsZSgpICYmIG5ld1ZhbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFZpc2libGU6IGZ1bmN0aW9uIChuZXdWYWwpIHtcclxuICAgICAgICB2YXIgZG93bnN0cmVhbSA9IG5ld1ZhbDtcclxuICAgICAgICBpZiAodGhpcy5sb2NhbFZpc2libGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGRvd25zdHJlYW0gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSA9PT0gZG93bnN0cmVhbSkge1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZG93bnN0cmVhbTtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICBvYmouc2V0VmlzaWJsZShkb3duc3RyZWFtKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zY2VuZS5mcmVlUGFnZUVudHJ5KHtwYWdlOiB0aGlzLnBhZ2UsIG9mZnNldDogdGhpcy5vZmZzZXQsIHNpemU6IHRoaXMuZW50cnlTaXplfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbmRSYXlJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbiAoLyogcmF5LCBjbG9zZXN0SW50ZXJzZWN0aW9uKi8pIHtcclxuICAgICAgICAvL1RoaXMgZnVuY3Rpb24gaXMgb3ZlcnJpZGRlbiBieSBncm91cHMgYW5kIGRyYXdhYmxlc1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlck5vZGU7XHJcbiIsInZhciBTeXN0ZW1Ob3RpZmllciA9IHJlcXVpcmUoXCIuLi8uLi93ZWJnbC9zeXN0ZW0vc3lzdGVtLW5vdGlmaWVyLmpzXCIpO1xyXG52YXIgUmVuZGVyTm9kZSA9IHJlcXVpcmUoXCIuL3JlbmRlcm5vZGUuanNcIik7XHJcbnZhciBEcmF3YWJsZUNsb3N1cmU9IHJlcXVpcmUoXCIuL2RyYXdhYmxlY2xvc3VyZS5qc1wiKTtcclxudmFyIEMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XHJcbnZhciBTY2VuZT0gcmVxdWlyZShcIi4vc2NlbmUuanNcIik7XHJcbnZhciBDb21wdXRlUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5Db21wdXRlUmVxdWVzdDtcclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJmYWNlXHJcbiAqL1xyXG52YXIgSVJlbmRlck9iamVjdCA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuSVJlbmRlck9iamVjdC5wcm90b3R5cGUuZ2V0TW9kZWxWaWV3TWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5JUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5nZXRNb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5JUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5nZXRNb2RlbE1hdHJpeE4gPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcbklSZW5kZXJPYmplY3QucHJvdG90eXBlLmdldE1vZGVsVmlld01hdHJpeE4gPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcbklSZW5kZXJPYmplY3QucHJvdG90eXBlLmdldE9iamVjdFNwYWNlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcbklSZW5kZXJPYmplY3QucHJvdG90eXBlLmdldFdvcmxkU3BhY2VCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuSVJlbmRlck9iamVjdC5wcm90b3R5cGUudXBkYXRlV29ybGRTcGFjZU1hdHJpY2VzID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5JUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcbklSZW5kZXJPYmplY3QucHJvdG90eXBlLnNldFRyYW5zZm9ybURpcnR5ID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5JUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5zZXRTaGFkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcbklSZW5kZXJPYmplY3QucHJvdG90eXBlLmhhc1RyYW5zcGFyZW5jeSA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbi8vIEVudHJ5OlxyXG4vKiogQGNvbnN0ICovXHJcbnZhciBXT1JMRF9NQVRSSVhfT0ZGU0VUID0gMDtcclxuLyoqIEBjb25zdCAqL1xyXG52YXIgTE9DQUxfTUFUUklYX09GRlNFVCA9IFdPUkxEX01BVFJJWF9PRkZTRVQgKyAxNjtcclxuLyoqIEBjb25zdCAqL1xyXG52YXIgT0JKRUNUX0JCX09GRlNFVCA9IExPQ0FMX01BVFJJWF9PRkZTRVQgKyAxNjtcclxuLyoqIEBjb25zdCAqL1xyXG52YXIgV09STERfQkJfT0ZGU0VUID0gT0JKRUNUX0JCX09GRlNFVCArIDY7XHJcbi8qKiBAY29uc3QgKi9cclxudmFyIE1PREVMVklFV19NQVRSSVhfT0ZGU0VUID0gV09STERfQkJfT0ZGU0VUICsgNjtcclxuLyoqIEBjb25zdCAqL1xyXG52YXIgTU9ERUxWSUVXUFJPSkVDVElPTl9NQVRSSVhfT0ZGU0VUID0gTU9ERUxWSUVXX01BVFJJWF9PRkZTRVQgKyAxNjtcclxuLyoqIEBjb25zdCAqL1xyXG52YXIgTU9ERUxfTUFUUklYX05fT0ZGU0VUID0gTU9ERUxWSUVXUFJPSkVDVElPTl9NQVRSSVhfT0ZGU0VUICsgMTY7XHJcbi8qKiBAY29uc3QgKi9cclxudmFyIE1PREVMVklFV19NQVRSSVhfTl9PRkZTRVQgPSBNT0RFTF9NQVRSSVhfTl9PRkZTRVQgKyAxNjtcclxuLyoqIEBjb25zdCAqL1xyXG52YXIgRU5UUllfU0laRSA9IE1PREVMVklFV19NQVRSSVhfTl9PRkZTRVQgKyAxNjtcclxuXHJcbi8vbm9pbnNwZWN0aW9uIEpTQ2xvc3VyZUNvbXBpbGVyU3ludGF4LEpTQ2xvc3VyZUNvbXBpbGVyU3ludGF4XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVuZGVyYWJsZSBvYmplY3QgaW4gdGhlIHNjZW5lLlxyXG4gKiBUaGUgUmVuZGVyT2JqZWN0IGhhcyB0aGVzZSByZXNwb25zaWJpbGl0aWVzOlxyXG4gKiAgMS4gS2VlcCB0cmFjayBvZiB0aGUgdHJhbnNmb3JtYXRpb24gaGllcmFyY2h5IGFuZCBib3VuZGluZyBib3hlc1xyXG4gKiAgMi4gQ29ubmVjdCB0aGUgRHJhd2FibGVDbG9zdXJlIHdpdGggdGhlIFNoYWRlckNsb3N1cmVcclxuICpcclxuICogIFRoZSB7QGxpbmsgRHJhd2FibGVDbG9zdXJlfSBpcyBhIERyYXdhYmxlT2JqZWN0IHBsdXMgaXQncyBkYXRhXHJcbiAqICBUaGUge0BsaW5rIFNoYWRlckNsb3N1cmV9IGlzIGEgUHJvZ3JhbU9iamVjdCBwbHVzIGl0J3MgZGF0YVxyXG4gKiAgVGhlIGNvbmNyZXRlIFNoYWRlckNsb3N1cmUgY2FuIHZhcnkgcGVyIERyYXdhYmxlT2JqZWN0IGFuZCBjaGFuZ2VcclxuICogIGR1ZSB0byBzY2VuZSBvciBvYmplY3QgY2hhbmdlcy4gVGh1cyB3ZSBoYXZlIHRvIGtlZXAgdHJhY2sgb2YgdGhlXHJcbiAqICByZWxhdGVkIHtAbGluayBJU2hhZGVyQ29tcG9zZXJ9LlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGltcGxlbWVudHMge0lSZW5kZXJPYmplY3R9XHJcbiAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWdlRW50cnlcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxyXG4gKi9cclxudmFyIFJlbmRlck9iamVjdCA9IGZ1bmN0aW9uIChzY2VuZSwgcGFnZUVudHJ5LCBvcHQpIHtcclxuICAgIFJlbmRlck5vZGUuY2FsbCh0aGlzLCBDLk5PREVfVFlQRS5PQkpFQ1QsIHNjZW5lLCBwYWdlRW50cnksIG9wdCk7XHJcbiAgICBvcHQgPSBvcHQgfHwge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZWVwIHJlZmVyZW5jZSB0byBET00gRWxlbWVudCBuZWVkIGUuZy4gZm9yIHBpY2tpbmdcclxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm5vZGUgPSBvcHQubm9kZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9iamVjdCByZWxhdGVkIGRhdGFcclxuICAgICAqIEB0eXBlIHt7ZGF0YTogRGF0YU5vZGV8bnVsbCwgdHlwZTogc3RyaW5nfX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vYmplY3QgPSBvcHQub2JqZWN0IHx8IHtkYXRhOiBudWxsLCB0eXBlOiBcInRyaWFuZ2xlc1wifTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbiB3ZSByZWx5IG9uIGN1cnJlbnQgV29ybGRNYXRyaXg/XHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmFuc2Zvcm1EaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW4gd2UgcmVseSBvbiBjdXJyZW50IEJvdW5kaW5nIEJveGVzP1xyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYm91bmRpbmdCb3hEaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgdGhpcy50cmFuc2Zvcm1EYXRhUmVxdWVzdCA9IHRoaXMuY3JlYXRlVHJhbnNmb3JtUmVxdWVzdCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRyYXdhYmxlIGNsb3N1cmUgdHJhbnNmb3JtcyBvYmplY3QgZGF0YSBhbmQgdHlwZSBpbnRvXHJcbiAgICAgKiBhIGRyYXdhYmxlIGVudGl0eVxyXG4gICAgICogQHR5cGUge0RyYXdhYmxlQ2xvc3VyZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmF3YWJsZSA9IHRoaXMuY3JlYXRlRHJhd2FibGUoKTtcclxuXHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG9wdC5tYXRlcmlhbCB8fCBudWxsO1xyXG4gICAgdGhpcy5fYWN0dWFsTWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgdGhpcy5pbml0TWF0ZXJpYWwoKTtcclxuXHJcbiAgICAvKioge09iamVjdD99ICoqL1xyXG4gICAgdGhpcy5vdmVycmlkZSA9IG51bGw7XHJcblxyXG5cclxufTtcclxuUmVuZGVyT2JqZWN0LkVOVFJZX1NJWkUgPSBFTlRSWV9TSVpFO1xyXG5cclxuUmVuZGVyT2JqZWN0LklERU5USVRZX01BVFJJWCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKFJlbmRlck9iamVjdCwgUmVuZGVyTm9kZSwge1xyXG4gICAgY3JlYXRlVHJhbnNmb3JtUmVxdWVzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5vYmplY3QuZGF0YSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgQ29tcHV0ZVJlcXVlc3QodGhpcy5vYmplY3QuZGF0YSwgW1wibWVzaFRyYW5zZm9ybVwiXSwgdGhpcy5vblRyYW5zZm9ybURhdGFDaGFuZ2UuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZURyYXdhYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc2NlbmUuY3JlYXRlRHJhd2FibGUodGhpcyk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hZGRFdmVudExpc3RlbmVyKEMuRVZFTlRfVFlQRS5EUkFXQUJMRV9TVEFURV9DSEFOR0VELCBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZ0Lm5ld1N0YXRlID09PSBEcmF3YWJsZUNsb3N1cmUuUkVBRFlfU1RBVEUuQ09NUExFVEUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNjZW5lLm1vdmVGcm9tUXVldWVUb1JlYWR5KHRoYXQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldnQubmV3U3RhdGUgPT09IERyYXdhYmxlQ2xvc3VyZS5SRUFEWV9TVEFURS5JTkNPTVBMRVRFICYmIGV2dC5vbGRTdGF0ZSA9PT0gRHJhd2FibGVDbG9zdXJlLlJFQURZX1NUQVRFLkNPTVBMRVRFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zY2VuZS5tb3ZlRnJvbVJlYWR5VG9RdWV1ZSh0aGF0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC51cGRhdGVUeXBlUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICByZXN1bHQuY2FsY3VsYXRlQm91bmRpbmdCb3goKTtcclxuICAgICAgICAgICAgcmVzdWx0LmFkZEV2ZW50TGlzdGVuZXIoQy5FVkVOVF9UWVBFLlNDRU5FX1NIQVBFX0NIQU5HRUQsIGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2NlbmUuZGlzcGF0Y2hFdmVudCh7dHlwZTogQy5FVkVOVF9UWVBFLlNDRU5FX1NIQVBFX0NIQU5HRUR9KVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUeXBlOiBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHRoaXMub2JqZWN0LnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIC8vIFRPRE86IHRoaXMudHlwZUNoYW5nZWRFdmVudFxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUeXBlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0LnR5cGU7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldERhdGFOb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0ID8gdGhpcy5vYmplY3QuZGF0YSA6IG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldExvY2FsTWF0cml4OiBmdW5jdGlvbiAoZGVzdCkge1xyXG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBMT0NBTF9NQVRSSVhfT0ZGU0VUO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKywgbysrKSB7XHJcbiAgICAgICAgICAgIGRlc3RbaV0gPSB0aGlzLnBhZ2Vbb107XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRMb2NhbE1hdHJpeDogZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBMT0NBTF9NQVRSSVhfT0ZGU0VUO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKywgbysrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFnZVtvXSA9IHNvdXJjZVtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG4gICAgICAgIHRoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1EYXRhUmVxdWVzdCAmJiB0aGlzLnRyYW5zZm9ybURhdGFSZXF1ZXN0LmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5zY2VuZS5yZW1vdmUodGhpcyk7XHJcbiAgICB9LCBvblRyYW5zZm9ybURhdGFDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldE1vZGVsVmlld01hdHJpeDogZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBNT0RFTFZJRVdfTUFUUklYX09GRlNFVDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyssIG8rKykge1xyXG4gICAgICAgICAgICB0YXJnZXRbaV0gPSB0aGlzLnBhZ2Vbb107XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRNb2RlbE1hdHJpeE46IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICB2YXIgbyA9IHRoaXMub2Zmc2V0ICsgTU9ERUxfTUFUUklYX05fT0ZGU0VUO1xyXG4gICAgICAgIHRhcmdldFswXSA9IHRoaXMucGFnZVtvXTtcclxuICAgICAgICB0YXJnZXRbMV0gPSB0aGlzLnBhZ2VbbyArIDFdO1xyXG4gICAgICAgIHRhcmdldFsyXSA9IHRoaXMucGFnZVtvICsgMl07XHJcbiAgICAgICAgdGFyZ2V0WzNdID0gdGhpcy5wYWdlW28gKyA0XTtcclxuICAgICAgICB0YXJnZXRbNF0gPSB0aGlzLnBhZ2VbbyArIDVdO1xyXG4gICAgICAgIHRhcmdldFs1XSA9IHRoaXMucGFnZVtvICsgNl07XHJcbiAgICAgICAgdGFyZ2V0WzZdID0gdGhpcy5wYWdlW28gKyA4XTtcclxuICAgICAgICB0YXJnZXRbN10gPSB0aGlzLnBhZ2VbbyArIDldO1xyXG4gICAgICAgIHRhcmdldFs4XSA9IHRoaXMucGFnZVtvICsgMTBdO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRNb2RlbFZpZXdNYXRyaXhOOiBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIG8gPSB0aGlzLm9mZnNldCArIE1PREVMVklFV19NQVRSSVhfTl9PRkZTRVQ7XHJcbiAgICAgICAgdGFyZ2V0WzBdID0gdGhpcy5wYWdlW29dO1xyXG4gICAgICAgIHRhcmdldFsxXSA9IHRoaXMucGFnZVtvICsgMV07XHJcbiAgICAgICAgdGFyZ2V0WzJdID0gdGhpcy5wYWdlW28gKyAyXTtcclxuICAgICAgICB0YXJnZXRbM10gPSB0aGlzLnBhZ2VbbyArIDRdO1xyXG4gICAgICAgIHRhcmdldFs0XSA9IHRoaXMucGFnZVtvICsgNV07XHJcbiAgICAgICAgdGFyZ2V0WzVdID0gdGhpcy5wYWdlW28gKyA2XTtcclxuICAgICAgICB0YXJnZXRbNl0gPSB0aGlzLnBhZ2VbbyArIDhdO1xyXG4gICAgICAgIHRhcmdldFs3XSA9IHRoaXMucGFnZVtvICsgOV07XHJcbiAgICAgICAgdGFyZ2V0WzhdID0gdGhpcy5wYWdlW28gKyAxMF07XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICBnZXRNb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAoZGVzdCkge1xyXG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBNT0RFTFZJRVdQUk9KRUNUSU9OX01BVFJJWF9PRkZTRVQ7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrLCBvKyspIHtcclxuICAgICAgICAgICAgZGVzdFtpXSA9IHRoaXMucGFnZVtvXTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVdvcmxkU3BhY2VNYXRyaWNlczogZnVuY3Rpb24gKHZpZXcsIHByb2plY3Rpb24pIHtcclxuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1EaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlTW9kZWxWaWV3TWF0cml4KHZpZXcpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTW9kZWxNYXRyaXhOKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNb2RlbFZpZXdNYXRyaXhOKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4KHByb2plY3Rpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVXb3JsZE1hdHJpeDogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdG1wX21hdCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCh0bXBfbWF0KTtcclxuICAgICAgICAgICAgdmFyIHBhZ2UgPSB0aGlzLnBhZ2U7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0KHRtcF9tYXQsIDAsIHBhZ2UsIG9mZnNldCArIExPQ0FMX01BVFJJWF9PRkZTRVQsIHRtcF9tYXQsIDApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1EYXRhUmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMudHJhbnNmb3JtRGF0YVJlcXVlc3QuZ2V0UmVzdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtRGF0YSA9IHJlc3VsdC5nZXRPdXRwdXREYXRhKFwibWVzaFRyYW5zZm9ybVwiKTtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1EYXRhICYmIHRyYW5zZm9ybURhdGEuZ2V0VmFsdWUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseSh0bXBfbWF0LCB0bXBfbWF0LCB0cmFuc2Zvcm1EYXRhLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0V29ybGRNYXRyaXgodG1wX21hdCk7XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3hEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KSgpLFxyXG5cclxuICAgIC8qKiBSZWxpZXMgb24gYW4gdXAtdG8tZGF0ZSB0cmFuc2Zvcm0gbWF0cml4ICoqL1xyXG4gICAgdXBkYXRlTW9kZWxWaWV3TWF0cml4OiBmdW5jdGlvbiAodmlldykge1xyXG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybURpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhZ2UgPSB0aGlzLnBhZ2U7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseU9mZnNldChwYWdlLCBvZmZzZXQgKyBNT0RFTFZJRVdfTUFUUklYX09GRlNFVCwgcGFnZSwgb2Zmc2V0ICsgV09STERfTUFUUklYX09GRlNFVCwgdmlldywgMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZU1vZGVsTWF0cml4TjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY190bXBNYXRyaXggPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRXb3JsZE1hdHJpeChjX3RtcE1hdHJpeCk7XHJcbiAgICAgICAgICAgIHZhciBub3JtYWxNYXRyaXggPSBYTUwzRC5tYXRoLm1hdDQuaW52ZXJ0KGNfdG1wTWF0cml4LCBjX3RtcE1hdHJpeCk7XHJcbiAgICAgICAgICAgIG5vcm1hbE1hdHJpeCA9IG5vcm1hbE1hdHJpeCA/IFhNTDNELm1hdGgubWF0NC50cmFuc3Bvc2Uobm9ybWFsTWF0cml4LCBub3JtYWxNYXRyaXgpIDogUmVuZGVyT2JqZWN0LklERU5USVRZX01BVFJJWDtcclxuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLm9mZnNldCArIE1PREVMX01BVFJJWF9OX09GRlNFVDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrLCBvKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFnZVtvXSA9IG5vcm1hbE1hdHJpeFtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pKCksXHJcblxyXG4gICAgLyoqIFJlbGllcyBvbiBhbiB1cC10by1kYXRlIHZpZXcgbWF0cml4ICoqL1xyXG4gICAgdXBkYXRlTW9kZWxWaWV3TWF0cml4TjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY190bXBNYXRyaXggPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRNb2RlbFZpZXdNYXRyaXgoY190bXBNYXRyaXgpO1xyXG4gICAgICAgICAgICB2YXIgbm9ybWFsTWF0cml4ID0gWE1MM0QubWF0aC5tYXQ0LmludmVydChjX3RtcE1hdHJpeCwgY190bXBNYXRyaXgpO1xyXG4gICAgICAgICAgICBub3JtYWxNYXRyaXggPSBub3JtYWxNYXRyaXggPyBYTUwzRC5tYXRoLm1hdDQudHJhbnNwb3NlKG5vcm1hbE1hdHJpeCwgbm9ybWFsTWF0cml4KSA6IFJlbmRlck9iamVjdC5JREVOVElUWV9NQVRSSVg7XHJcbiAgICAgICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBNT0RFTFZJRVdfTUFUUklYX05fT0ZGU0VUO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyssIG8rKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlW29dID0gbm9ybWFsTWF0cml4W2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSkoKSxcclxuXHJcblxyXG4gICAgLyoqIFJlbGllcyBvbiBhbiB1cC10by1kYXRlIHZpZXcgbWF0cml4ICoqL1xyXG4gICAgdXBkYXRlTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24gKHByb2plY3Rpb24pIHtcclxuICAgICAgICB2YXIgcGFnZSA9IHRoaXMucGFnZTtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0KHBhZ2UsIG9mZnNldCArIE1PREVMVklFV1BST0pFQ1RJT05fTUFUUklYX09GRlNFVCwgcGFnZSwgb2Zmc2V0ICsgTU9ERUxWSUVXX01BVFJJWF9PRkZTRVQsIHByb2plY3Rpb24sIDApO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUcmFuc2Zvcm1EaXJ0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpO1xyXG4gICAgICAgIHRoaXMuc2NlbmUuZGlzcGF0Y2hFdmVudCh7dHlwZTogQy5FVkVOVF9UWVBFLlNDRU5FX1NIQVBFX0NIQU5HRUR9KTtcclxuICAgICAgICB0aGlzLnNjZW5lLnJlcXVlc3RSZWRyYXcoXCJUcmFuc2Zvcm1hdGlvbiBjaGFuZ2VkXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRPYmplY3RTcGFjZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYm94KSB7XHJcbiAgICAgICAgdmFyIG8gPSB0aGlzLm9mZnNldCArIE9CSkVDVF9CQl9PRkZTRVQ7XHJcbiAgICAgICAgdGhpcy5wYWdlW29dID0gYm94WzBdO1xyXG4gICAgICAgIHRoaXMucGFnZVtvICsgMV0gPSBib3hbMV07XHJcbiAgICAgICAgdGhpcy5wYWdlW28gKyAyXSA9IGJveFsyXTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDNdID0gYm94WzNdO1xyXG4gICAgICAgIHRoaXMucGFnZVtvICsgNF0gPSBib3hbNF07XHJcbiAgICAgICAgdGhpcy5wYWdlW28gKyA1XSA9IGJveFs1XTtcclxuICAgICAgICB0aGlzLnNldEJvdW5kaW5nQm94RGlydHkoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0T2JqZWN0U3BhY2VCb3VuZGluZ0JveDogZnVuY3Rpb24gKGJveCkge1xyXG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBPQkpFQ1RfQkJfT0ZGU0VUO1xyXG4gICAgICAgIGJveFswXSA9IHRoaXMucGFnZVtvXTtcclxuICAgICAgICBib3hbMV0gPSB0aGlzLnBhZ2VbbyArIDFdO1xyXG4gICAgICAgIGJveFsyXSA9IHRoaXMucGFnZVtvICsgMl07XHJcbiAgICAgICAgYm94WzNdID0gdGhpcy5wYWdlW28gKyAzXTtcclxuICAgICAgICBib3hbNF0gPSB0aGlzLnBhZ2VbbyArIDRdO1xyXG4gICAgICAgIGJveFs1XSA9IHRoaXMucGFnZVtvICsgNV07XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEJvdW5kaW5nQm94RGlydHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94RGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucGFyZW50LnNldEJvdW5kaW5nQm94RGlydHkoKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0V29ybGRTcGFjZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYmJveCkge1xyXG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBXT1JMRF9CQl9PRkZTRVQ7XHJcbiAgICAgICAgdGhpcy5wYWdlW29dID0gYmJveFswXTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDFdID0gYmJveFsxXTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDJdID0gYmJveFsyXTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDNdID0gYmJveFszXTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDRdID0gYmJveFs0XTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDVdID0gYmJveFs1XTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYmJveCkge1xyXG4gICAgICAgIGlmICh0aGlzLmJvdW5kaW5nQm94RGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVXb3JsZFNwYWNlQm91bmRpbmdCb3goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG8gPSB0aGlzLm9mZnNldCArIFdPUkxEX0JCX09GRlNFVDtcclxuICAgICAgICBiYm94WzBdID0gdGhpcy5wYWdlW29dO1xyXG4gICAgICAgIGJib3hbMV0gPSB0aGlzLnBhZ2VbbyArIDFdO1xyXG4gICAgICAgIGJib3hbMl0gPSB0aGlzLnBhZ2VbbyArIDJdO1xyXG4gICAgICAgIGJib3hbM10gPSB0aGlzLnBhZ2VbbyArIDNdO1xyXG4gICAgICAgIGJib3hbNF0gPSB0aGlzLnBhZ2VbbyArIDRdO1xyXG4gICAgICAgIGJib3hbNV0gPSB0aGlzLnBhZ2VbbyArIDVdO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlV29ybGRTcGFjZUJvdW5kaW5nQm94OiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjX2JveCA9IG5ldyBYTUwzRC5tYXRoLmJib3guY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfdHJhbnMgPSBuZXcgWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmdldE9iamVjdFNwYWNlQm91bmRpbmdCb3goY19ib3gpO1xyXG4gICAgICAgICAgICB0aGlzLmdldFdvcmxkTWF0cml4KGNfdHJhbnMpO1xyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLmJib3gudHJhbnNmb3JtKGNfYm94LCBjX3RyYW5zLCBjX2JveCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGNfYm94KTtcclxuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveERpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSkoKSxcclxuXHJcbiAgICBzZXRMb2NhbFZpc2libGU6IGZ1bmN0aW9uIChuZXdWYWwpIHtcclxuICAgICAgICB0aGlzLmxvY2FsVmlzaWJsZSA9IG5ld1ZhbDtcclxuICAgICAgICB0aGlzLnNldFZpc2libGUodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNWaXNpYmxlKCkgJiYgbmV3VmFsKTtcclxuICAgICAgICB0aGlzLnNldEJvdW5kaW5nQm94RGlydHkoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UHJvZ3JhbTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdhYmxlLmdldFByb2dyYW0oKTtcclxuICAgIH0sXHJcblxyXG4gICAgaGFzVHJhbnNwYXJlbmN5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLmdldFByb2dyYW0oKTtcclxuICAgICAgICByZXR1cm4gcHJvZ3JhbSA/IHByb2dyYW0uaGFzVHJhbnNwYXJlbmN5KCkgOiBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlRm9yUmVuZGVyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgU3lzdGVtTm90aWZpZXIuc2V0Tm9kZSh0aGlzLm5vZGUpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd2FibGUgJiYgdGhpcy5kcmF3YWJsZS51cGRhdGUodGhpcy5zY2VuZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIk1lc2ggRXJyb3I6IFwiICsgZS5tZXNzYWdlLCB0aGlzLm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTeXN0ZW1Ob3RpZmllci5zZXROb2RlKG51bGwpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmaW5kUmF5SW50ZXJzZWN0aW9uczogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYmJveCA9IFhNTDNELm1hdGguYmJveC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgb3B0ID0ge2Rpc3Q6IDB9O1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJheSwgaW50ZXJzZWN0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmdldFdvcmxkU3BhY2VCb3VuZGluZ0JveChiYm94KTtcclxuICAgICAgICAgICAgaWYgKFhNTDNELm1hdGguYmJveC5pbnRlcnNlY3RzKGJib3gsIHJheSwgb3B0KSkge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSkoKSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge01hdGVyaWFsQ29uZmlndXJhdGlvbnxudWxsfSBtYXRlcmlhbFxyXG4gICAgICovXHJcbiAgICBzZXRNYXRlcmlhbDogZnVuY3Rpb24gKG1hdGVyaWFsKSB7XHJcbiAgICAgICAgaWYodGhpcy5fbWF0ZXJpYWwgPT09IG1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuICAgICAgICBpZiAobWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0dWFsTWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3R1YWxNYXRlcmlhbCA9IHRoaXMucGFyZW50LmdldE1hdGVyaWFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWF0ZXJpYWxDaGFuZ2VkKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHBhcmVudE1hdGVyaWFsQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9tYXRlcmlhbCkge1xyXG4gICAgICAgICAgICAvLyBMb2NhbCBtYXRlcmlhbCBvdmVycmlkZXMgdGhlIGNoYW5nZSBmcm9tIGFib3ZlXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0TWF0ZXJpYWwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdE1hdGVyaWFsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdHVhbE1hdGVyaWFsID0gdGhpcy5fbWF0ZXJpYWw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0dWFsTWF0ZXJpYWwgPSB0aGlzLnBhcmVudC5nZXRNYXRlcmlhbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1hdGVyaWFsQ2hhbmdlZCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtYXRlcmlhbENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwibWF0ZXJpYWwgY2hhbmdlZFwiLCB0aGlzLl9hY3R1YWxNYXRlcmlhbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZHJhd2FibGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvbXBvc2VyID0gdGhpcy5zY2VuZS5zaGFkZXJGYWN0b3J5LmNyZWF0ZUNvbXBvc2VyRnJvbU1hdGVyaWFsQ29uZmlndXJhdGlvbih0aGlzLl9hY3R1YWxNYXRlcmlhbCk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd2FibGUuc2V0U2hhZGVyQ29tcG9zZXIoY29tcG9zZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuXHJcbi8vIEV4cG9ydFxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlck9iamVjdDtcclxuXHJcbiIsInZhciBSZW5kZXJOb2RlID0gcmVxdWlyZShcIi4vcmVuZGVybm9kZS5qc1wiKTtcclxudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIEZydXN0dW0gPSByZXF1aXJlKFwiLi4vdG9vbHMvZnJ1c3R1bS5qc1wiKS5GcnVzdHVtO1xyXG5cclxudmFyIE5PREVfVFlQRSA9IENvbnN0YW50cy5OT0RFX1RZUEU7XHJcbnZhciBFVkVOVF9UWVBFID0gQ29uc3RhbnRzLkVWRU5UX1RZUEU7XHJcblxyXG4gICAgLyoqIEBjb25zdCAqL1xyXG4gICAgdmFyIFZJRVdfVE9fV09STERfTUFUUklYX09GRlNFVCA9IDA7XHJcbiAgICAvKiogQGNvbnN0ICovXHJcbiAgICB2YXIgV09STERfVE9fVklFV19NQVRSSVhfT0ZGU0VUID0gMTY7XHJcbiAgICAvKiogQGNvbnN0ICovXHJcbiAgICB2YXIgUFJPSkVDVElPTl9NQVRSSVhfT0ZGU0VUID0gMzI7XHJcbiAgICAvKiogQGNvbnN0ICovXHJcbiAgICB2YXIgRU5UUllfU0laRSA9IFBST0pFQ1RJT05fTUFUUklYX09GRlNFVCArIDE2O1xyXG5cclxuICAgIC8qKiBAY29uc3QgKi9cclxuICAgIHZhciBDTElQUExBTkVfTkVBUl9NSU4gPSAwLjAxO1xyXG5cclxuICAgIC8qKiBAY29uc3QgKi9cclxuICAgIHZhciBERUZBVUxUX0ZJRUxET0ZWSUVXID0gNDUgLyAxODAgKiBNYXRoLlBJO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4dGVuZHMge1JlbmRlck5vZGV9XHJcbiAgICAgKi9cclxuICAgIHZhciBSZW5kZXJWaWV3ID0gZnVuY3Rpb24oc2NlbmUsIHBhZ2VFbnRyeSwgb3B0KSB7XHJcbiAgICAgICAgUmVuZGVyTm9kZS5jYWxsKHRoaXMsIE5PREVfVFlQRS5WSUVXLCBzY2VuZSwgcGFnZUVudHJ5LCBvcHQpO1xyXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gb3B0LnBvc2l0aW9uIHx8IFhNTDNELm1hdGgudmVjMy5jcmVhdGUoKTtcclxuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gb3B0Lm9yaWVudGF0aW9uIHx8IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB0aGlzLmZpZWxkT2ZWaWV3ID0gb3B0LmZpZWxkT2ZWaWV3ICE9PSB1bmRlZmluZWQgPyBvcHQuZmllbGRPZlZpZXcgOiBERUZBVUxUX0ZJRUxET0ZWSUVXO1xyXG4gICAgICAgIHRoaXMud29ybGRTcGFjZVBvc2l0aW9uID0gWE1MM0QubWF0aC52ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbk92ZXJyaWRlID0gb3B0LnByb2plY3Rpb25PdmVycmlkZTtcclxuICAgICAgICB0aGlzLnZpZXdEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZnJ1c3R1bSA9IG5ldyBGcnVzdHVtKDEsIDEwMDAwMCwgMCwgdGhpcy5maWVsZE9mVmlldywgMSk7XHJcbiAgICAgICAgdGhpcy5sYXN0QXNwZWN0UmF0aW8gPSAxO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclZpZXcuRU5UUllfU0laRSA9IEVOVFJZX1NJWkU7XHJcblxyXG4gICAgWE1MM0QuY3JlYXRlQ2xhc3MoUmVuZGVyVmlldywgUmVuZGVyTm9kZSk7XHJcblxyXG4gICAgWE1MM0QuZXh0ZW5kKFJlbmRlclZpZXcucHJvdG90eXBlLCB7XHJcbiAgICAgICAgZ2V0RnJ1c3R1bTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZydXN0dW07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdXBkYXRlVmlld01hdHJpeDogKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdG1wX21hdDQgPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIHZhciB0bXBfcGFyZW50ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5pZGVudGl0eSh0bXBfbWF0NCk7XHJcbiAgICAgICAgICAgICAgICB0bXBfbWF0NFsxMl0gPSB0aGlzLnBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgdG1wX21hdDRbMTNdID0gdGhpcy5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgIHRtcF9tYXQ0WzE0XSA9IHRoaXMucG9zaXRpb25bMl07XHJcbiAgICAgICAgICAgICAgICAvLyB0bXAgPSBUICogT1xyXG4gICAgICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5KHRtcF9tYXQ0LCB0bXBfbWF0NCwgdGhpcy5vcmllbnRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCh0bXBfcGFyZW50KTtcclxuICAgICAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseSh0bXBfbWF0NCwgdG1wX3BhcmVudCwgdG1wX21hdDQpO1xyXG4gICAgICAgICAgICAgICAgWE1MM0QubWF0aC52ZWMzLnNldCh0aGlzLndvcmxkU3BhY2VQb3NpdGlvbiwgdG1wX21hdDRbMTJdLCB0bXBfbWF0NFsxM10sIHRtcF9tYXQ0WzE0XSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZpZXdUb1dvcmxkTWF0cml4KHRtcF9tYXQ0KTtcclxuICAgICAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5pbnZlcnQodG1wX21hdDQsIHRtcF9tYXQ0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0V29ybGRUb1ZpZXdNYXRyaXgodG1wX21hdDQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3RGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKCksXHJcblxyXG4gICAgICAgIHVwZGF0ZVByb2plY3Rpb25NYXRyaXg6IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRtcCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihhc3BlY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb2plY3Rpb25PdmVycmlkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJvamVjdGlvbk1hdHJpeCh0aGlzLnByb2plY3Rpb25PdmVycmlkZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQ29ycmVjdGx5IGNvbXB1dGUgZnJ1c3RydW0gZnJvbSBwcm9qZWN0aW9uIG1hdHJpeCAoaWYgcG9zc2libGUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcnVzdHVtLnNldEZydXN0dW0oMSwgMTAwMDAwLCAwLCB0aGlzLmZpZWxkT2ZWaWV3LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNsaXBQbGFuZSA9IHRoaXMuZ2V0Q2xpcHBpbmdQbGFuZXMoKSxcclxuICAgICAgICAgICAgICAgICAgICBuZWFyID0gY2xpcFBsYW5lLm5lYXIsXHJcbiAgICAgICAgICAgICAgICAgICAgZmFyID0gY2xpcFBsYW5lLmZhcixcclxuICAgICAgICAgICAgICAgICAgICBmb3Z5ID0gdGhpcy5maWVsZE9mVmlldztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgcGVyc3BlY3RpdmUgcHJvamVjdGlvbk1hdHJpeFxyXG4gICAgICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0LnBlcnNwZWN0aXZlKHRtcCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IHByb2plY3Rpb25NYXRyaXhcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJvamVjdGlvbk1hdHJpeCh0bXApO1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIEZydXN0dW1cclxuICAgICAgICAgICAgICAgIHRoaXMuZnJ1c3R1bS5zZXRGcnVzdHVtKG5lYXIsIGZhciwgMCwgZm92eSwgYXNwZWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RBc3BlY3RSYXRpbyA9IGFzcGVjdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKCksXHJcblxyXG4gICAgICAgIGdldENsaXBwaW5nUGxhbmVzOiAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB0X21hdCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuICAgICAgICAgICAgdmFyIGJiID0gbmV3IFhNTDNELm1hdGguYmJveC5jcmVhdGUoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuZ2V0Qm91bmRpbmdCb3goYmIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFhNTDNELm1hdGguYmJveC5pc0VtcHR5KGJiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5lYXI6IDEsIGZhcjogMTAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0V29ybGRUb1ZpZXdNYXRyaXgodF9tYXQpO1xyXG4gICAgICAgICAgICAgICAgWE1MM0QubWF0aC5iYm94LnRyYW5zZm9ybShiYiwgdF9tYXQsIGJiKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbmVhciA9IC1iYls1XSxcclxuICAgICAgICAgICAgICAgICAgICBmYXIgPSAtYmJbMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kID0gTWF0aC5tYXgoKGZhciAtIG5lYXIpICogMC4wMDUsIDAuMDUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCB0aGUgdmlldyBmcnVzdHVtIGEgYml0IHRvIGVuc3VyZSAyRCBvYmplY3RzIHBhcmFsbGVsIHRvIHRoZSBjYW1lcmEgYXJlIHJlbmRlcmVkXHJcbiAgICAgICAgICAgICAgICBmYXIgKz0gZXhwYW5kO1xyXG4gICAgICAgICAgICAgICAgbmVhciAtPSBleHBhbmQ7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtuZWFyOiBNYXRoLm1heChuZWFyLCBleHBhbmQsIENMSVBQTEFORV9ORUFSX01JTiksIGZhcjogZmFyfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKCksXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBzb3VyY2VcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0TWF0cml4OiBmdW5jdGlvbihzb3VyY2UsIG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgbyA9IHRoaXMub2Zmc2V0ICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTY7IGkrKywgbysrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2Vbb10gPSBzb3VyY2VbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRXb3JsZFRvVmlld01hdHJpeDogZnVuY3Rpb24oc291cmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TWF0cml4KHNvdXJjZSwgV09STERfVE9fVklFV19NQVRSSVhfT0ZGU0VUKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRWaWV3VG9Xb3JsZE1hdHJpeDogZnVuY3Rpb24oc291cmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TWF0cml4KHNvdXJjZSwgVklFV19UT19XT1JMRF9NQVRSSVhfT0ZGU0VUKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbihzb3VyY2UpIHtcclxuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLm9mZnNldCArIFBST0pFQ1RJT05fTUFUUklYX09GRlNFVDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDE2OyBpKyssIG8rKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlW29dID0gc291cmNlW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbkRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0UHJvamVjdGlvbk92ZXJyaWRlOiBmdW5jdGlvbihwcm9qQWRhcHRlcikge1xyXG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25PdmVycmlkZSA9IHByb2pBZGFwdGVyO1xyXG4gICAgICAgICAgICB0aGlzLnNldFByb2plY3Rpb25EaXJ0eSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLnJlcXVlc3RSZWRyYXcoXCJQcm9qZWN0aW9uIGNoYW5nZWRcIik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0VHJhbnNmb3JtRGlydHk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJvamVjdGlvbkRpcnR5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUucmVxdWVzdFJlZHJhdyhcIlRyYW5zZm9ybWF0aW9uIGNoYW5nZWRcIik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0UHJvamVjdGlvbkRpcnR5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbihuZXdQb3MpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzBdID0gbmV3UG9zWzBdO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdID0gbmV3UG9zWzFdO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzJdID0gbmV3UG9zWzJdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVwZGF0ZU9yaWVudGF0aW9uOiBmdW5jdGlvbihuZXdPcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcmllbnRhdGlvbltpXSA9IG5ld09yaWVudGF0aW9uW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdXBkYXRlRmllbGRPZlZpZXc6IGZ1bmN0aW9uKG5ld0Zvdikge1xyXG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmllbGRPZlZpZXcgPSBuZXdGb3Y7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0Vmlld1RvV29ybGRNYXRyaXg6IGZ1bmN0aW9uIChkZXN0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXdEaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3TWF0cml4KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLm9mZnNldCArIFZJRVdfVE9fV09STERfTUFUUklYX09GRlNFVDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrLCBvKyspIHtcclxuICAgICAgICAgICAgICAgIGRlc3RbaV0gPSB0aGlzLnBhZ2Vbb107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRXb3JsZFRvVmlld01hdHJpeDogZnVuY3Rpb24gKGRlc3QpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmlld0RpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdNYXRyaXgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbyA9IHRoaXMub2Zmc2V0ICsgV09STERfVE9fVklFV19NQVRSSVhfT0ZGU0VUO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyssIG8rKykge1xyXG4gICAgICAgICAgICAgICAgZGVzdFtpXSA9IHRoaXMucGFnZVtvXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldFByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKGRlc3QsIGFzcGVjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvamVjdGlvbkRpcnR5IHx8IGFzcGVjdCAhPSB0aGlzLmxhc3RBc3BlY3RSYXRpbykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeChhc3BlY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG8gPSB0aGlzLm9mZnNldCArIFBST0pFQ1RJT05fTUFUUklYX09GRlNFVDtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrLCBvKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXN0W2ldID0gdGhpcy5wYWdlW29dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldFdvcmxkU3BhY2VQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndvcmxkU3BhY2VQb3NpdGlvbjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRXb3JsZFNwYWNlQm91bmRpbmdCb3g6IGZ1bmN0aW9uKGJib3gpIHtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC5iYm94LmVtcHR5KGJib3gpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEV4cG9ydFxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJWaWV3O1xyXG5cclxuIiwidmFyIFBhZ2VyID0gcmVxdWlyZShcIi4vcGFnZXIuanNcIik7XHJcbnZhciBSZW5kZXJPYmplY3QgPSByZXF1aXJlKFwiLi9yZW5kZXJvYmplY3QuanNcIik7XHJcbnZhciBSZW5kZXJWaWV3ID0gcmVxdWlyZShcIi4vcmVuZGVydmlldy5qc1wiKTtcclxudmFyIFJlbmRlckdyb3VwID0gcmVxdWlyZShcIi4vcmVuZGVyZ3JvdXAuanNcIik7XHJcbnZhciBSZW5kZXJMaWdodCA9IHJlcXVpcmUoXCIuL3JlbmRlcmxpZ2h0LmpzXCIpO1xyXG52YXIgTWF0ZXJpYWxDb25maWd1cmF0aW9uID0gcmVxdWlyZShcIi4vbWF0ZXJpYWwtY29uZmlndXJhdGlvbi5qc1wiKTtcclxudmFyIExpZ2h0TWFuYWdlciA9IHJlcXVpcmUoXCIuLi9saWdodHMvbGlnaHQtbWFuYWdlci5qc1wiKTtcclxudmFyIEMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XHJcbnZhciBJbnB1dE5vZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLklucHV0Tm9kZTtcclxudmFyIERhdGFOb2RlID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9ncmFwaC5qc1wiKS5EYXRhTm9kZTtcclxudmFyIEJ1ZmZlckVudHJ5ID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9kYXRhLmpzXCIpLkJ1ZmZlckVudHJ5O1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIFVSSSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy91cmkuanNcIikuVVJJO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBQYWdlclxyXG4gKi9cclxudmFyIFNjZW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgUGFnZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFhNTDNELm1hdGguYmJveC5jcmVhdGUoKTtcclxuICAgIHRoaXMubGlnaHRzID0gbmV3IExpZ2h0TWFuYWdlcigpO1xyXG5cclxuICAgIC8qKiBAdHlwZSBSZW5kZXJWaWV3ICovXHJcbiAgICB0aGlzLmFjdGl2ZVZpZXcgPSBudWxsO1xyXG5cclxuICAgIC8qKiBAdHlwZSBNYXRlcmlhbENvbmZpZ3VyYXRpb24gKi9cclxuICAgIHRoaXMuX2RlZmF1bHRNYXRlcmlhbCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5yb290Tm9kZSA9IHRoaXMuY3JlYXRlUm9vdE5vZGUoKTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoU2NlbmUsIFBhZ2VyKTtcclxuXHJcblxyXG5YTUwzRC5leHRlbmQoU2NlbmUucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIHtSZW5kZXJWaWV3fVxyXG4gICAgICovXHJcbiAgICBnZXRBY3RpdmVWaWV3OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVmlldztcclxuICAgIH0sIC8qKlxyXG4gICAgICogQHBhcmFtIHtSZW5kZXJWaWV3fSB2aWV3XHJcbiAgICAgKi9cclxuICAgIHNldEFjdGl2ZVZpZXc6IGZ1bmN0aW9uICh2aWV3KSB7XHJcbiAgICAgICAgaWYgKHZpZXcgIT0gdGhpcy5hY3RpdmVWaWV3KSB7XHJcbiAgICAgICAgICAgIGlmICghdmlldylcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjdGl2ZSB2aWV3IG11c3Qgbm90IGJlIG51bGxcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IHZpZXc7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTogQy5FVkVOVF9UWVBFLlZJRVdfQ0hBTkdFRCwgbmV3VmlldzogdGhpcy5hY3RpdmVWaWV3fSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3Q/fSBvcHRcclxuICAgICAqIEByZXR1cm5zIHtSZW5kZXJPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVJlbmRlck9iamVjdDogZnVuY3Rpb24gKG9wdCkge1xyXG4gICAgICAgIHZhciBwYWdlRW50cnkgPSB0aGlzLmdldFBhZ2VFbnRyeShSZW5kZXJPYmplY3QuRU5UUllfU0laRSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJPYmplY3QodGhpcywgcGFnZUVudHJ5LCBvcHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVSZW5kZXJHcm91cDogZnVuY3Rpb24gKG9wdCkge1xyXG4gICAgICAgIHZhciBwYWdlRW50cnkgPSB0aGlzLmdldFBhZ2VFbnRyeShSZW5kZXJHcm91cC5FTlRSWV9TSVpFKTtcclxuICAgICAgICByZXR1cm4gbmV3IFJlbmRlckdyb3VwKHRoaXMsIHBhZ2VFbnRyeSwgb3B0KTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlUmVuZGVyVmlldzogZnVuY3Rpb24gKG9wdCkge1xyXG4gICAgICAgIHZhciBwYWdlRW50cnkgPSB0aGlzLmdldFBhZ2VFbnRyeShSZW5kZXJWaWV3LkVOVFJZX1NJWkUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVuZGVyVmlldyh0aGlzLCBwYWdlRW50cnksIG9wdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVJlbmRlckxpZ2h0OiBmdW5jdGlvbiAob3B0KSB7XHJcbiAgICAgICAgdmFyIHBhZ2VFbnRyeSA9IHRoaXMuZ2V0UGFnZUVudHJ5KFJlbmRlckxpZ2h0LkVOVFJZX1NJWkUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVuZGVyTGlnaHQodGhpcywgcGFnZUVudHJ5LCBvcHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVNYXRlcmlhbENvbmZpZ3VyYXRpb246IGZ1bmN0aW9uKG1vZGVsLCBkYXRhLCBvcHQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1hdGVyaWFsQ29uZmlndXJhdGlvbihtb2RlbCwgZGF0YSwgb3B0KTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlUm9vdE5vZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFnZUVudHJ5ID0gdGhpcy5nZXRQYWdlRW50cnkoUmVuZGVyR3JvdXAuRU5UUllfU0laRSk7XHJcbiAgICAgICAgdmFyIHJvb3QgPSBuZXcgUmVuZGVyR3JvdXAodGhpcywgcGFnZUVudHJ5LCB7XHJcbiAgICAgICAgICAgIG1hdGVyaWFsOiB0aGlzLmdldERlZmF1bHRNYXRlcmlhbCgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcm9vdC5zZXRXb3JsZE1hdHJpeChYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCkpO1xyXG4gICAgICAgIHJvb3Quc2V0TG9jYWxNYXRyaXgoWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpKTtcclxuICAgICAgICByb290LnRyYW5zZm9ybURpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgcm9vdC52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5yb290Tm9kZS5ib3VuZGluZ0JveERpcnR5KSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IFRoZXJlIHNob3VsZCBhbHdheXMgYmUgYW4gYWN0aXZlIHZpZXdcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVWaWV3ICYmIHRoaXMuYWN0aXZlVmlldy5zZXRQcm9qZWN0aW9uRGlydHkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yb290Tm9kZS5nZXRXb3JsZFNwYWNlQm91bmRpbmdCb3godGhpcy5ib3VuZGluZ0JveCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYmIpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgWE1MM0QubWF0aC5iYm94LmNvcHkoYmIsIHRoaXMuYm91bmRpbmdCb3gpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVEcmF3YWJsZTogZnVuY3Rpb24gKC8qb2JqKi8pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2VuZTo6Y3JlYXRlRHJhd2FibGUgbm90IGltcGxlbWVudGVkXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXF1ZXN0UmVkcmF3OiBmdW5jdGlvbiAoLypyZWFzb24qLykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjZW5lOjpyZXF1ZXN0UmVkcmF3IG5vdCBpbXBsZW1lbnRlZFwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMucm9vdE5vZGUudHJhdmVyc2UoY2FsbGJhY2spO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYWxsIG9iamVjdHMgaW50ZXJzZWN0ZWQgYnkgdGhlIGdpdmVuIHJheSwgYmFzZWQgb24gdGhlaXIgYm91bmRpbmcgYm94ZXNcclxuICAgICAqIEBwYXJhbSByYXlcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2YgUmVuZGVyT2JqZWN0cyB0aGF0IHdlcmUgaGl0IGJ5IHRoaXMgcmF5XHJcbiAgICAgKi9cclxuICAgIGZpbmRSYXlJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbiAocmF5KSB7XHJcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLnJvb3ROb2RlLmZpbmRSYXlJbnRlcnNlY3Rpb25zKHJheSwgaW50ZXJzZWN0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldERlZmF1bHRNYXRlcmlhbDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYoIXRoaXMuX2RlZmF1bHRNYXRlcmlhbCkge1xyXG4gICAgICAgICAgICB2YXIgaW5wdXROb2RlID0gbmV3IElucHV0Tm9kZSgpO1xyXG4gICAgICAgICAgICBpbnB1dE5vZGUuZGF0YSA9IG5ldyBCdWZmZXJFbnRyeShYQy5EQVRBX1RZUEUuRkxPQVQzLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwXSkpO1xyXG4gICAgICAgICAgICBpbnB1dE5vZGUubmFtZSA9IFwiZGlmZnVzZUNvbG9yXCI7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBEYXRhTm9kZShmYWxzZSk7XHJcbiAgICAgICAgICAgIGRhdGEuYXBwZW5kQ2hpbGQoaW5wdXROb2RlKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRNYXRlcmlhbCA9IHRoaXMuY3JlYXRlTWF0ZXJpYWxDb25maWd1cmF0aW9uKFxyXG4gICAgICAgICAgICAgICAge1widHlwZVwiOiBcInVyblwiLCBcInVyblwiOiBuZXcgVVJJKFwidXJuOnhtbDNkOnNoYWRlcjptYXR0ZVwiKX0sXHJcbiAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAge25hbWU6IFwiZGVmYXVsdFwifVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdE1hdGVyaWFsO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNjZW5lO1xyXG4iLCJ2YXIgRGF0YUNoYW5nZU5vdGlmaWVyID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9kYXRhLmpzXCIpLkRhdGFDaGFuZ2VOb3RpZmllcjtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBEYXRhQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBEYXRhQ2hhbmdlTm90aWZpZXIuYWRkTGlzdGVuZXIodGhpcy5kYXRhRW50cnlDaGFuZ2VkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge1hmbG93LkRhdGFFbnRyeX0gZW50cnlcclxuICogQHBhcmFtIHtYZmxvdy5EQVRBX0VOVFJZX1NUQVRFfSBub3RpZmljYXRpb25cclxuICovXHJcbkRhdGFDaGFuZ2VMaXN0ZW5lci5wcm90b3R5cGUuZGF0YUVudHJ5Q2hhbmdlZCA9IGZ1bmN0aW9uIChlbnRyeSwgbm90aWZpY2F0aW9uKSB7XHJcbiAgICBpZiAoZW50cnkudXNlckRhdGEud2ViZ2xEYXRhKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiBlbnRyeS51c2VyRGF0YS53ZWJnbERhdGEpIHtcclxuICAgICAgICAgICAgdmFyIG9sZENoYW5nZWQgPSBlbnRyeS51c2VyRGF0YS53ZWJnbERhdGFbaV0uY2hhbmdlZDtcclxuICAgICAgICAgICAgZW50cnkudXNlckRhdGEud2ViZ2xEYXRhW2ldLmNoYW5nZWQgPSBNYXRoLm1heChvbGRDaGFuZ2VkLCBub3RpZmljYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGF0YUNoYW5nZUxpc3RlbmVyO1xyXG4iLCJ2YXIgdmVjMyA9IFhNTDNELm1hdGgudmVjMztcclxudmFyIHRtcDEgPSB2ZWMzLmNyZWF0ZSgpO1xyXG52YXIgdG1wMiA9IHZlYzMuY3JlYXRlKCk7XHJcblxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyUGxhbmVcclxuICogQHBhcmFtIHtudW1iZXJ9IGZhclBsYW5lXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z4XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3RcclxuICogQHBhcmFtIHtib29sZWFufSBvcnRob2dyYXBoaWNcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgRnJ1c3R1bSA9IGZ1bmN0aW9uIChuZWFyUGxhbmUsIGZhclBsYW5lLCBmb3Z4LCBmb3Z5LCBhc3BlY3QsIG9ydGhvZ3JhcGhpYykge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGlmICh0eXBlb2Yob3J0aG9ncmFwaGljKSA9PT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICB0aGlzLm9ydGhvZ3JhcGhpYyA9IGZhbHNlOyBlbHNlXHJcbiAgICAgICAgdGhpcy5vcnRob2dyYXBoaWMgPSBvcnRob2dyYXBoaWM7XHJcbiAgICB0aGlzLnNldEZydXN0dW0obmVhclBsYW5lLCBmYXJQbGFuZSwgZm92eCwgZm92eSwgYXNwZWN0LCB0aGlzLm9ydGhvZ3JhcGhpYyk7XHJcbn07XHJcblxyXG5YTUwzRC5leHRlbmQoRnJ1c3R1bS5wcm90b3R5cGUsIHtcclxuICAgIHNldEZydXN0dW06IGZ1bmN0aW9uIChuZWFyUGxhbmUsIGZhclBsYW5lLCBmb3Z4LCBmb3Z5LCBhc3BlY3QsIG9ydGhvZ3JhcGhpYykge1xyXG4gICAgICAgIGlmIChmb3Z4ICYmIGZvdnkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvdnggYW5kIGZvdnkgY2Fubm90IGJvdGggYmUgbm9uLXplcm8uXCIpO1xyXG5cclxuICAgICAgICBpZiAoZm92eCkge1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gbmVhclBsYW5lICogTWF0aC50YW4oZm92eCAvIDIpO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnQgPSAtdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgdGhpcy50b3AgPSAoKHRoaXMucmlnaHQgLSB0aGlzLmxlZnQpIC8gYXNwZWN0KSAvIDI7XHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gLXRoaXMudG9wO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9wID0gbmVhclBsYW5lICogTWF0aC50YW4oMC41ICogZm92eSk7XHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gLXRoaXMudG9wO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gKHRoaXMudG9wIC0gdGhpcy5ib3R0b20pICogYXNwZWN0IC8gMjtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gLXRoaXMucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubmVhclBsYW5lID0gbmVhclBsYW5lO1xyXG4gICAgICAgIHRoaXMuZmFyUGxhbmUgPSBmYXJQbGFuZTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZihvcnRob2dyYXBoaWMpID09PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgICAgICB0aGlzLm9ydGhvZ3JhcGhpYyA9IGZhbHNlOyBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMub3J0aG9ncmFwaGljID0gb3J0aG9ncmFwaGljO1xyXG5cclxuICAgIH0sIGdldFByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uIChtYXRyaXgpIHtcclxuICAgICAgICB2YXIgbGltaXRNYXggPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIHZhciByaWdodFBsdXNMZWZ0ID0gdGhpcy5yaWdodCArIHRoaXMubGVmdDtcclxuICAgICAgICB2YXIgcmlnaHRNaW51c0xlZnQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xyXG5cclxuICAgICAgICB2YXIgdG9wUGx1c0JvdHRvbSA9IHRoaXMudG9wICsgdGhpcy5ib3R0b207XHJcbiAgICAgICAgdmFyIHRvcE1pbnVzQm90dG9tID0gdGhpcy50b3AgLSB0aGlzLmJvdHRvbTtcclxuXHJcbiAgICAgICAgdmFyIGZhclBsdXNOZWFyID0gdGhpcy5mYXJQbGFuZSArIHRoaXMubmVhclBsYW5lO1xyXG4gICAgICAgIHZhciBmYXJNaW51c05lYXIgPSB0aGlzLmZhclBsYW5lIC0gdGhpcy5uZWFyUGxhbmU7XHJcblxyXG4gICAgICAgIGlmICgoTWF0aC5hYnMocmlnaHRNaW51c0xlZnQpIDwgMSAmJiBNYXRoLmFicyhyaWdodFBsdXNMZWZ0KSA+IGxpbWl0TWF4ICogTWF0aC5hYnMocmlnaHRNaW51c0xlZnQpKSB8fCAoTWF0aC5hYnModG9wTWludXNCb3R0b20pIDwgMSAmJiBNYXRoLmFicyh0b3BQbHVzQm90dG9tKSA+IGxpbWl0TWF4ICogTWF0aC5hYnModG9wTWludXNCb3R0b20pKSB8fCAoTWF0aC5hYnMoZmFyTWludXNOZWFyKSA8IDEgJiYgTWF0aC5hYnMoZmFyUGx1c05lYXIpID4gbGltaXRNYXggKiBNYXRoLmFicyhmYXJNaW51c05lYXIpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgdmlld2luZyBmcnVzdHVtOiBwcm9qZWN0aW9uIG1hdHJpeCBjYW5ub3QgYmUgY29tcHV0ZWQuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIEEsIEIsIEMsIEQsIEUsIEY7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9ydGhvZ3JhcGhpYykge1xyXG4gICAgICAgICAgICB2YXIgdHggPSAtcmlnaHRQbHVzTGVmdCAvIHJpZ2h0TWludXNMZWZ0O1xyXG4gICAgICAgICAgICB2YXIgdHkgPSAtdG9wUGx1c0JvdHRvbSAvIHRvcE1pbnVzQm90dG9tO1xyXG4gICAgICAgICAgICB2YXIgdHogPSAtZmFyUGx1c05lYXIgLyBmYXJNaW51c05lYXI7XHJcblxyXG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKHJpZ2h0TWludXNMZWZ0KSA8IDEgJiYgMiA+IGxpbWl0TWF4ICogTWF0aC5hYnMocmlnaHRNaW51c0xlZnQpKSB8fCAoTWF0aC5hYnModG9wTWludXNCb3R0b20pIDwgMSAmJiAyID4gbGltaXRNYXggKiBNYXRoLmFicyh0b3BNaW51c0JvdHRvbSkpIHx8IChNYXRoLmFicyhmYXJNaW51c05lYXIpIDwgMSAmJiAyID4gbGltaXRNYXggKiBNYXRoLmFicyhmYXJNaW51c05lYXIpKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIHZpZXdpbmcgZnJ1c3R1bTogIHByb2plY3Rpb24gbWF0cml4IGNhbm5vdCBiZSBjb21wdXRlZC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEEgPSAyIC8gcmlnaHRNaW51c0xlZnQ7XHJcbiAgICAgICAgICAgIEIgPSAyIC8gdG9wTWludXNCb3R0b207XHJcbiAgICAgICAgICAgIEMgPSAtMiAvIGZhck1pbnVzTmVhcjtcclxuXHJcbiAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5pZGVudGl0eShtYXRyaXgpO1xyXG4gICAgICAgICAgICBtYXRyaXhbMF0gPSBBO1xyXG4gICAgICAgICAgICBtYXRyaXhbNV0gPSBCO1xyXG4gICAgICAgICAgICBtYXRyaXhbMTBdID0gQztcclxuICAgICAgICAgICAgbWF0cml4WzEyXSA9IHR4O1xyXG4gICAgICAgICAgICBtYXRyaXhbMTNdID0gdHk7XHJcbiAgICAgICAgICAgIG1hdHJpeFsxNF0gPSB0ejtcclxuICAgICAgICAgICAgbWF0cml4WzE1XSA9IDEuMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBBID0gcmlnaHRQbHVzTGVmdCAvIHJpZ2h0TWludXNMZWZ0O1xyXG4gICAgICAgICAgICBCID0gdG9wUGx1c0JvdHRvbSAvIHRvcE1pbnVzQm90dG9tO1xyXG4gICAgICAgICAgICBDID0gLWZhclBsdXNOZWFyIC8gZmFyTWludXNOZWFyO1xyXG5cclxuICAgICAgICAgICAgdmFyIGZhclRpbWVzTmVhciA9IC0yICogdGhpcy5mYXJQbGFuZSAqIHRoaXMubmVhclBsYW5lO1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZmFyTWludXNOZWFyKSA8IDEgJiYgTWF0aC5hYnMoZmFyVGltZXNOZWFyKSA+IGxpbWl0TWF4ICogTWF0aC5hYnMoZmFyTWludXNOZWFyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIHZpZXdpbmcgZnJ1c3R1bTogcHJvamVjdGlvbiBtYXRyaXggY2Fubm90IGJlIGNvbXB1dGVkLlwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRCA9IGZhclRpbWVzTmVhciAvIGZhck1pbnVzTmVhcjtcclxuXHJcbiAgICAgICAgICAgIHZhciB0d29UaW1lc05lYXIgPSAyICogdGhpcy5uZWFyUGxhbmU7XHJcblxyXG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKHJpZ2h0TWludXNMZWZ0KSA8IDEgJiYgTWF0aC5hYnModHdvVGltZXNOZWFyKSA+IGxpbWl0TWF4ICogTWF0aC5hYnMocmlnaHRNaW51c0xlZnQpKSB8fCAoTWF0aC5hYnModG9wTWludXNCb3R0b20pIDwgMSAmJiBNYXRoLmFicyh0d29UaW1lc05lYXIpID4gbGltaXRNYXggKiBNYXRoLmFicyh0b3BNaW51c0JvdHRvbSkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgdmlld2luZyBmcnVzdHVtOiBwcm9qZWN0aW9uIG1hdHJpeCBjYW5ub3QgYmUgY29tcHV0ZWQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBFID0gdHdvVGltZXNOZWFyIC8gcmlnaHRNaW51c0xlZnQ7XHJcbiAgICAgICAgICAgIEYgPSB0d29UaW1lc05lYXIgLyB0b3BNaW51c0JvdHRvbTtcclxuXHJcbiAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5pZGVudGl0eShtYXRyaXgpO1xyXG4gICAgICAgICAgICBtYXRyaXhbMF0gPSBFO1xyXG4gICAgICAgICAgICBtYXRyaXhbNV0gPSBGO1xyXG4gICAgICAgICAgICBtYXRyaXhbOF0gPSBBO1xyXG4gICAgICAgICAgICBtYXRyaXhbOV0gPSBCO1xyXG4gICAgICAgICAgICBtYXRyaXhbMTBdID0gQztcclxuICAgICAgICAgICAgbWF0cml4WzExXSA9IC0xO1xyXG4gICAgICAgICAgICBtYXRyaXhbMTRdID0gRDtcclxuICAgICAgICAgICAgbWF0cml4WzE1XSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRQbGFuZXM6IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBjX2EgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX2IgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX2MgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX2QgPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICB2YXIgY19lID0gdmVjMy5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY19mID0gdmVjMy5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY19nID0gdmVjMy5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY19vID0gdmVjMy5jcmVhdGUoKTtcclxuXHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocCwgTSkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHZlYzMudHJhbnNmb3JtTWF0NChjX2EsIFt0aGlzLmxlZnQsIHRoaXMuYm90dG9tLCAtdGhpcy5uZWFyUGxhbmVdLCBNKTtcclxuICAgICAgICAgICAgdmFyIGIgPSB2ZWMzLnRyYW5zZm9ybU1hdDQoY19iLCBbdGhpcy5sZWZ0LCB0aGlzLnRvcCwgLXRoaXMubmVhclBsYW5lXSwgTSk7XHJcbiAgICAgICAgICAgIHZhciBjID0gdmVjMy50cmFuc2Zvcm1NYXQ0KGNfYywgW3RoaXMucmlnaHQsIHRoaXMudG9wLCAtdGhpcy5uZWFyUGxhbmVdLCBNKTtcclxuICAgICAgICAgICAgdmFyIGQgPSB2ZWMzLnRyYW5zZm9ybU1hdDQoY19kLCBbdGhpcy5yaWdodCwgdGhpcy5ib3R0b20sIC10aGlzLm5lYXJQbGFuZV0sIE0pO1xyXG4gICAgICAgICAgICB2YXIgZSwgZiwgZywgaCwgbztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm9ydGhvZ3JhcGhpYykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLmZhclBsYW5lIC8gdGhpcy5uZWFyUGxhbmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmFyTGVmdCA9IHMgKiB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmFyUmlnaHQgPSBzICogdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgICAgIHZhciBmYXJUb3AgPSBzICogdGhpcy50b3A7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmFyQm90dG9tID0gcyAqIHRoaXMuYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgZSA9IHZlYzMudHJhbnNmb3JtTWF0NChjX2UsIFtmYXJMZWZ0LCBmYXJCb3R0b20sIC10aGlzLmZhclBsYW5lXSwgTSk7XHJcbiAgICAgICAgICAgICAgICBmID0gdmVjMy50cmFuc2Zvcm1NYXQ0KGNfZiwgW2ZhckxlZnQsIGZhclRvcCwgLXRoaXMuZmFyUGxhbmVdLCBNKTtcclxuICAgICAgICAgICAgICAgIGcgPSB2ZWMzLnRyYW5zZm9ybU1hdDQoY19nLCBbZmFyUmlnaHQsIGZhclRvcCwgLXRoaXMuZmFyUGxhbmVdLCBNKTtcclxuICAgICAgICAgICAgICAgIG8gPSB2ZWMzLnRyYW5zZm9ybU1hdDQoY19vLCBbMCwgMCwgMF0sIE0pO1xyXG4gICAgICAgICAgICAgICAgcFswXS5zZXRGcm9tUG9pbnRzKG8sIGMsIGIpO1xyXG4gICAgICAgICAgICAgICAgcFsxXS5zZXRGcm9tUG9pbnRzKG8sIGQsIGMpO1xyXG4gICAgICAgICAgICAgICAgcFsyXS5zZXRGcm9tUG9pbnRzKG8sIGEsIGQpO1xyXG4gICAgICAgICAgICAgICAgcFszXS5zZXRGcm9tUG9pbnRzKG8sIGIsIGEpO1xyXG4gICAgICAgICAgICAgICAgcFs0XS5zZXRGcm9tUG9pbnRzKGEsIGQsIGMpO1xyXG4gICAgICAgICAgICAgICAgcFs1XS5zZXRGcm9tUG9pbnRzKGUsIGYsIGcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZSA9IHZlYzMudHJhbnNmb3JtTWF0NChjX2UsIFt0aGlzLmxlZnQsIHRoaXMuYm90dG9tLCAtdGhpcy5mYXJQbGFuZV0sIE0pO1xyXG4gICAgICAgICAgICAgICAgZiA9IHZlYzMudHJhbnNmb3JtTWF0NChjX2YsIFt0aGlzLmxlZnQsIHRoaXMudG9wLCAtdGhpcy5mYXJQbGFuZV0sIE0pO1xyXG4gICAgICAgICAgICAgICAgZyA9IHZlYzMudHJhbnNmb3JtTWF0NChjX2csIFt0aGlzLnJpZ2h0LCB0aGlzLnRvcCwgLXRoaXMuZmFyUGxhbmVdLCBNKTtcclxuICAgICAgICAgICAgICAgIGggPSB2ZWMzLnRyYW5zZm9ybU1hdDQoY19vLCBbdGhpcy5yaWdodCwgdGhpcy5ib3R0b20sIC10aGlzLmZhclBsYW5lXSwgTSk7XHJcbiAgICAgICAgICAgICAgICBwWzBdLnNldEZyb21Qb2ludHMoYywgZywgZik7XHJcbiAgICAgICAgICAgICAgICBwWzFdLnNldEZyb21Qb2ludHMoZCwgaCwgZyk7XHJcbiAgICAgICAgICAgICAgICBwWzJdLnNldEZyb21Qb2ludHMoYSwgZSwgaCk7XHJcbiAgICAgICAgICAgICAgICBwWzNdLnNldEZyb21Qb2ludHMoYiwgZiwgZSk7XHJcbiAgICAgICAgICAgICAgICBwWzRdLnNldEZyb21Qb2ludHMoYSwgZCwgYyk7XHJcbiAgICAgICAgICAgICAgICBwWzVdLnNldEZyb21Qb2ludHMoZSwgZiwgZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSgpKVxyXG5cclxuXHJcbn0pO1xyXG5cclxuXHJcbnZhciBQbGFuZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZGlzdGFuY2UgPSAwO1xyXG4gICAgdGhpcy5ub3JtYWwgPSB2ZWMzLmNyZWF0ZSgpO1xyXG59O1xyXG5cclxuWE1MM0QuZXh0ZW5kKFBsYW5lLnByb3RvdHlwZSwge1xyXG4gICAgc2V0RnJvbVBvaW50czogZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyLCBwb2ludDMpIHtcclxuICAgICAgICB2ZWMzLmNyb3NzKHRoaXMubm9ybWFsLCB2ZWMzLnN1Yih0bXAyLCBwb2ludDMsIHBvaW50MSksIHZlYzMuc3ViKHRtcDEsIHBvaW50MiwgcG9pbnQxKSk7XHJcbiAgICAgICAgdmVjMy5ub3JtYWxpemUodGhpcy5ub3JtYWwsIHRoaXMubm9ybWFsKTtcclxuICAgICAgICB0aGlzLmRpc3RhbmNlID0gLXZlYzMuZG90KHRoaXMubm9ybWFsLCBwb2ludDEpO1xyXG4gICAgfSwgc2V0OiBmdW5jdGlvbiAoeCwgeSwgeiwgZGlzdGFuY2UpIHtcclxuICAgICAgICB2ZWMzLnNldCh0aGlzLm5vcm1hbCwgeCwgeSwgeik7XHJcbiAgICAgICAgdmVjMy5ub3JtYWxpemUodGhpcy5ub3JtYWwsIHRoaXMubm9ybWFsKTtcclxuICAgICAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxudmFyIEZydXN0dW1UZXN0ID0gZnVuY3Rpb24gKGZydXN0dW0sIGNhbWVyYU1hdHJpeCkge1xyXG4gICAgdGhpcy5mcnVzdHVtUGxhbmVzID0gW25ldyBQbGFuZSgpLCBuZXcgUGxhbmUoKSwgbmV3IFBsYW5lKCksIG5ldyBQbGFuZSgpLCBuZXcgUGxhbmUoKSwgbmV3IFBsYW5lKCldO1xyXG4gICAgaWYgKGZydXN0dW0gJiYgY2FtZXJhTWF0cml4KSB7XHJcbiAgICAgICAgdGhpcy5zZXQoZnJ1c3R1bSwgY2FtZXJhTWF0cml4KTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5YTUwzRC5leHRlbmQoRnJ1c3R1bVRlc3QucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0ZydXN0dW19IGZydXN0dW1cclxuICAgICAqIEBwYXJhbSB7bWF0NH0gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHNldDogZnVuY3Rpb24gKGZydXN0dW0sIG1hdHJpeCkge1xyXG4gICAgICAgIGZydXN0dW0uZ2V0UGxhbmVzKHRoaXMuZnJ1c3R1bVBsYW5lcywgbWF0cml4KTtcclxuXHJcbiAgICB9LCAvKipcclxuICAgICAqIEBwYXJhbSBiYm94XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgaXNCb3hWaXNpYmxlOiAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGJib3gpIHtcclxuICAgICAgICAgICAgaWYgKFhNTDNELm1hdGguYmJveC5pc0VtcHR5KGJib3gpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mcnVzdHVtUGxhbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGxhbmUgPSB0aGlzLmZydXN0dW1QbGFuZXNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gcGxhbmUubm9ybWFsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJieCA9IG5vcm1hbFswXSA+PSAwLjAgPyBiYm94WzNdIDogYmJveFswXTtcclxuICAgICAgICAgICAgICAgIHZhciBiYnkgPSBub3JtYWxbMV0gPj0gMC4wID8gYmJveFs0XSA6IGJib3hbMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgYmJ6ID0gbm9ybWFsWzJdID49IDAuMCA/IGJib3hbNV0gOiBiYm94WzJdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGRpc3RhbmNlXHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBiYnggKiBub3JtYWxbMF0gKyBiYnkgKiBub3JtYWxbMV0gKyBiYnogKiBub3JtYWxbMl0gKyBwbGFuZS5kaXN0YW5jZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBoaWdoZXN0IHBvaW50IGlzIGJlbG93IHBsYW5lIHRoZW4gYWxsIGJlbG93LlxyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgMC4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0oKSlcclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBQbGFuZTogUGxhbmUsXHJcbiAgICBGcnVzdHVtOiBGcnVzdHVtLFxyXG4gICAgRnJ1c3R1bVRlc3Q6IEZydXN0dW1UZXN0XHJcbn07XHJcbiIsIi8qKlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBPYmplY3RTb3J0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG59O1xyXG5cclxudmFyIGNfYmJveCA9IFhNTDNELm1hdGguYmJveC5jcmVhdGUoKTtcclxudmFyIGNfY2VudGVyID0gWE1MM0QubWF0aC52ZWMzLmNyZWF0ZSgpO1xyXG5cclxuWE1MM0QuZXh0ZW5kKE9iamVjdFNvcnRlci5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtHTFNjZW5lfSBzY2VuZVxyXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXk/fSB2aWV3TWF0cml4IE1hdHJpeCB0byBhcHBseSB0byBvYmplY3RzIHdvcmxkIHNwYWNlIGV4dGVuZCBiZWZvcmUgc29ydGluZ1xyXG4gICAgICovXHJcbiAgICBzb3J0U2NlbmU6IGZ1bmN0aW9uIChzY2VuZSwgdmlld01hdHJpeCkge1xyXG4gICAgICAgIHZhciBzb3VyY2VPYmplY3RBcnJheSA9IHNjZW5lLnJlYWR5LCBvcGFxdWUgPSB7fSwgdHJhbnNwYXJlbnQgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIHRyYW5zcGFyZW50QXJyYXkgPSBbXSwgb2JqO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc291cmNlT2JqZWN0QXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG9iaiA9IHNvdXJjZU9iamVjdEFycmF5W2ldO1xyXG4gICAgICAgICAgICBpZiAob2JqLmluRnJ1c3R1bSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvYmouaGFzVHJhbnNwYXJlbmN5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50QXJyYXkucHVzaChvYmopO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb2dyYW0gPSBvYmouZ2V0UHJvZ3JhbSgpO1xyXG4gICAgICAgICAgICAgICAgb3BhcXVlW3Byb2dyYW0uaWRdID0gb3BhcXVlW3Byb2dyYW0uaWRdIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgb3BhcXVlW3Byb2dyYW0uaWRdLnB1c2gob2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU29ydCBvcGFxdWUgb2JqZWN0cyBmcm9tIGZyb250IHRvIGJhY2sgaW4gb3JkZXJcclxuICAgICAgICAvLyB0byBoYXZlIGVhcmxpZXIgei1mYWlsc1xyXG4gICAgICAgIGZvciAodmFyIHByb2dJZCBpbiBvcGFxdWUpIHtcclxuICAgICAgICAgICAgdmFyIHdpdGhpblNoYWRlciA9IG9wYXF1ZVtwcm9nSWRdO1xyXG4gICAgICAgICAgICB2YXIgc29ydGVkQXJyYXkgPSBuZXcgQXJyYXkod2l0aGluU2hhZGVyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB3aXRoaW5TaGFkZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG9iaiA9IHdpdGhpblNoYWRlcltpXTtcclxuICAgICAgICAgICAgICAgIG9iai5nZXRXb3JsZFNwYWNlQm91bmRpbmdCb3goY19iYm94KTtcclxuICAgICAgICAgICAgICAgIFhNTDNELm1hdGguYmJveC5jZW50ZXIoY19jZW50ZXIsIGNfYmJveCk7XHJcbiAgICAgICAgICAgICAgICB2aWV3TWF0cml4ICYmIFhNTDNELm1hdGgudmVjMy50cmFuc2Zvcm1NYXQ0KGNfY2VudGVyLCBjX2NlbnRlciwgdmlld01hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICBzb3J0ZWRBcnJheVtpXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBvYmo6IG9iaiwgZGVwdGg6IGNfY2VudGVyWzJdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNvcnRlZEFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiLmRlcHRoIC0gYS5kZXB0aDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG9wYXF1ZVtwcm9nSWRdID0gc29ydGVkQXJyYXkubWFwKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUub2JqOyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vU29ydCB0cmFuc3BhcmVudCBvYmplY3RzIGZyb20gYmFjayB0byBmcm9udFxyXG4gICAgICAgIHZhciB0bGVuZ3RoID0gdHJhbnNwYXJlbnRBcnJheS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHRsZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0bGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG9iaiA9IHRyYW5zcGFyZW50QXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICBvYmouZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGNfYmJveCk7XHJcbiAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLmJib3guY2VudGVyKGNfY2VudGVyLCBjX2Jib3gpO1xyXG4gICAgICAgICAgICAgICAgdmlld01hdHJpeCAmJiBYTUwzRC5tYXRoLnZlYzMudHJhbnNmb3JtTWF0NChjX2NlbnRlciwgY19jZW50ZXIsIHZpZXdNYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNwYXJlbnRBcnJheVtpXSA9IFtvYmosIGNfY2VudGVyWzJdXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdHJhbnNwYXJlbnRBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYVsxXSAtIGJbMV07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNwYXJlbnRbaV0gPSB0cmFuc3BhcmVudEFycmF5W2ldWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0bGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgdHJhbnNwYXJlbnRbMF0gPSB0cmFuc3BhcmVudEFycmF5WzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvcGFxdWU6IG9wYXF1ZSwgdHJhbnNwYXJlbnQ6IHRyYW5zcGFyZW50XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RTb3J0ZXI7XHJcblxyXG5cclxuIiwiLyoqIENhbGN1bGF0ZSB0aGUgb2Zmc2V0IG9mIHRoZSBnaXZlbiBlbGVtZW50IGFuZCByZXR1cm4gaXQuXHJcbiAqXHJcbiAqICBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxyXG4gKiAgQHJldHVybiB7e3RvcDpudW1iZXIsIGxlZnQ6bnVtYmVyfX0gdGhlIG9mZnNldFxyXG4gKlxyXG4gKiAgVGhpcyBjb2RlIGlzIHRha2VuIGZyb20gaHR0cDovL2phdmFzY3JpcHQuaW5mby90dXRvcmlhbC9jb29yZGluYXRlcyAuXHJcbiAqICBXZSBkb24ndCB3YW50IHRvIGRvIGl0IHdpdGggdGhlIG9mZnNldFBhcmVudCB3YXksIGJlY2F1c2UgdGhlIHhtbDNkXHJcbiAqICBlbGVtZW50IGlzIGFjdHVhbGx5IGludmlzaWJsZSBhbmQgdGh1cyBvZmZzZXRQYXJlbnQgd2lsbCByZXR1cm4gbnVsbFxyXG4gKiAgYXQgbGVhc3QgaW4gV2ViS2l0LiBBbHNvIGl0J3Mgc2xvdy4gU28gd2UgdXNlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLlxyXG4gKiAgSG93ZXZlciBpdCByZXR1cm5zIHRoZSBib3ggcmVsYXRpdmUgdG8gdGhlIHdpbmRvdywgbm90IHRoZSBkb2N1bWVudC5cclxuICogIFRodXMsIHdlIG5lZWQgdG8gaW5jb3Jwb3JhdGUgdGhlIHNjcm9sbCBmYWN0b3IuIEFuZCBiZWNhdXNlIElFIGlzIHNvXHJcbiAqICBhd2Vzb21lIHNvbWUgd29ya2Fyb3VuZHMgaGF2ZSB0byBiZSBkb25lIGFuZCB0aGUgY29kZSBnZXRzIGNvbXBsaWNhdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KGVsZW1lbnQpIHtcclxuICAgIHZhciBib3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgdmFyIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG4gICAgLy8gZ2V0IHNjcm9sbCBmYWN0b3IgKGV2ZXJ5IGJyb3dzZXIgZXhjZXB0IElFIHN1cHBvcnRzIHBhZ2Ugb2Zmc2V0cylcclxuICAgIHZhciBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3A7XHJcbiAgICB2YXIgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0O1xyXG5cclxuICAgIC8vIHRoZSBkb2N1bWVudCAoYGh0bWxgIG9yIGBib2R5YCkgY2FuIGJlIHNoaWZ0ZWQgZnJvbSBsZWZ0LXVwcGVyIGNvcm5lciBpbiBJRS4gR2V0IHRoZSBzaGlmdC5cclxuICAgIHZhciBjbGllbnRUb3AgPSBkb2NFbGVtLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xyXG4gICAgdmFyIGNsaWVudExlZnQgPSBkb2NFbGVtLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDA7XHJcblxyXG4gICAgdmFyIHRvcCA9IGJveC50b3AgKyBzY3JvbGxUb3AgLSBjbGllbnRUb3A7XHJcbiAgICB2YXIgbGVmdCA9IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnQ7XHJcblxyXG4gICAgLy8gZm9yIEZpcmVmb3ggYW4gYWRkaXRpb25hbCByb3VuZGluZyBpcyBzb21ldGltZXMgcmVxdWlyZWRcclxuICAgIHJldHVybiB7dG9wOiBNYXRoLnJvdW5kKHRvcCksIGxlZnQ6IE1hdGgucm91bmQobGVmdCl9O1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgLyoqIENvbnZlcnQgYSBnaXZlbiBtb3VzZSBwYWdlIHBvc2l0aW9uIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBnaXZlbiB0YXJnZXQgZWxlbWVudC5cclxuICAgICAqICBNb3N0IHByb2JhYmx5IHRoZSBwYWdlIHBvc2l0aW9uIGFyZSB0aGUgTW91c2VFdmVudCdzIHBhZ2VYIGFuZCBwYWdlWSBhdHRyaWJ1dGVzLlxyXG4gICAgICpcclxuICAgICAqICBAcGFyYW0geyFPYmplY3R9IHhtbDNkRWwgdGhlIHhtbDNkIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGNvb3JkcyBuZWVkIHRvIGJlIHRyYW5zbGF0ZWRcclxuICAgICAqICBAcGFyYW0geyFudW1iZXJ9IHBhZ2VYIHRoZSB4LWNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIHBhZ2VcclxuICAgICAqICBAcGFyYW0geyFudW1iZXJ9IHBhZ2VZIHRoZSB5LWNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIHBhZ2VcclxuICAgICAqICBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSB0aGUgY29udmVydGVkIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRQYWdlQ29vcmRzOiBmdW5jdGlvbiAoeG1sM2RFbCwgcGFnZVgsIHBhZ2VZKSB7XHJcbiAgICAgICAgdmFyIG9mZiA9IGNhbGN1bGF0ZU9mZnNldCh4bWwzZEVsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHt4OiBwYWdlWCAtIG9mZi5sZWZ0LCB5OiBwYWdlWSAtIG9mZi50b3B9O1xyXG4gICAgfVxyXG59O1xyXG4iLCJ2YXIgVGV4dHVyZU1hbmFnZXIgPSByZXF1aXJlKFwidGV4dHVyZS1tYW5hZ2VyXCIpLlNpbXBsZVRleHR1cmVNYW5hZ2VyO1xyXG52YXIgR0xUZXh0dXJlID0gcmVxdWlyZShcIi4vdGV4dHVyZS5qc1wiKS5HTFRleHR1cmU7XHJcbnZhciBHTEN1YmVNYXAgPSByZXF1aXJlKFwiLi90ZXh0dXJlLmpzXCIpLkdMQ3ViZU1hcDtcclxudmFyIEdMQ2FudmFzVGFyZ2V0ID0gcmVxdWlyZShcIi4vcmVuZGVydGFyZ2V0LmpzXCIpLkdMQ2FudmFzVGFyZ2V0O1xyXG52YXIgUHJvZ3JhbUZhY3RvcnkgPSByZXF1aXJlKFwiLi8uLi9zaGFkZXIvcHJvZ3JhbWZhY3RvcnkuanNcIik7XHJcbnZhciBYQyA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG5cclxudmFyIENPTlRFWFRfT1BUSU9OUyA9IHtcclxuICAgIGFscGhhOiB0cnVlLCBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLCBhbnRpYWxpYXM6IHRydWUsIHN0ZW5jaWw6IHRydWUsIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnQhfSBjYW52YXNcclxuICovXHJcbmZ1bmN0aW9uIGdldENvbnRleHRGb3JDYW52YXMoY2FudmFzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgQ09OVEVYVF9PUFRJT05TKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnRleHQgdGhhdCBpbmNsdWRlcyBhbGwgR0wgcmVsYXRlZCByZXNvdXJjZXMgLyBoYW5kbGVyc1xyXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50IX0gY2FudmFzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBHTENvbnRleHQgPSBmdW5jdGlvbiAoY2FudmFzLCBpZCkge1xyXG4gICAgdGhpcy5nbCA9IGdldENvbnRleHRGb3JDYW52YXMoY2FudmFzKTtcclxuICAgIHRoaXMuaWQgPSBpZDtcclxuICAgIHRoaXMuY2FudmFzVGFyZ2V0ID0gbmV3IEdMQ2FudmFzVGFyZ2V0KHRoaXMsIGNhbnZhcy5jbGllbnRXaWR0aCwgY2FudmFzLmNsaWVudEhlaWdodCk7XHJcbiAgICB0aGlzLnByb2dyYW1GYWN0b3J5ID0gbmV3IFByb2dyYW1GYWN0b3J5KHRoaXMpO1xyXG4gICAgdGhpcy50ZXh0dXJlTWFuYWdlciA9IG5ldyBUZXh0dXJlTWFuYWdlcih7IHVuaXRzOiB0aGlzLmdsLmdldFBhcmFtZXRlcihXZWJHTFJlbmRlcmluZ0NvbnRleHQuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMgKX0pO1xyXG4gICAgdGhpcy5zdGF0cyA9IHtcclxuICAgICAgICBtYXRlcmlhbHM6IDAsIG1lc2hlczogMFxyXG4gICAgfTtcclxuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHBvcHVsYXRlRXh0ZW5zaW9ucyh0aGlzLmdsKTtcclxuXHJcbn07XHJcblxyXG52YXIgRVhURU5TSU9OUyA9IEdMQ29udGV4dC5FWFRFTlNJT05TID0ge307XHJcbkVYVEVOU0lPTlMuU1RBTkRBUkRfREVSSVZBVEVTID0gJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyc7XHJcbkVYVEVOU0lPTlMuTVVMVElQTEVfUkVOREVSX1RBUkdFVFMgPSAnV0VCR0xfZHJhd19idWZmZXJzJztcclxuRVhURU5TSU9OUy5ERVBUSF9URVhUVVJFID0gJ1dFQkdMX2RlcHRoX3RleHR1cmUnO1xyXG5FWFRFTlNJT05TLkZMT0FUX0NPTE9SX0JVRkZFUiA9ICdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnO1xyXG5FWFRFTlNJT05TLkZMT0FUX1RFWFRVUkVTID0gJ09FU190ZXh0dXJlX2Zsb2F0JztcclxuRVhURU5TSU9OUy5VSU5UMzJfSU5ESUNFUyA9ICdPRVNfZWxlbWVudF9pbmRleF91aW50JztcclxuXHJcblhNTDNELmV4dGVuZChHTENvbnRleHQucHJvdG90eXBlLCB7XHJcbiAgICBnZXRYZmxvd0VudHJ5V2ViR2xEYXRhOiBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0WGZsb3dFbnRyeVdlYkdsRGF0YShlbnRyeSwgdGhpcy5pZCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChyZWFzb24pIHtcclxuICAgICAgICAvL2hhbmRsZXIucmVkcmF3KHJlYXNvbiwgZm9yY2VQaWNraW5nKTtcclxuICAgIH0sXHJcblxyXG4gICAgaGFuZGxlUmVzaXplRXZlbnQ6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5jYW52YXNUYXJnZXQgPSBuZXcgR0xDYW52YXNUYXJnZXQodGhpcywgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFN0YXRpc3RpY3M6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0cztcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RXh0ZW5zaW9uQnlOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnNbbmFtZV07XHJcbiAgICB9ICxcclxuXHJcbiAgICBjcmVhdGVUZXh0dXJlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdMVGV4dHVyZSh0aGlzKTtcclxuICAgIH0gLFxyXG4gICAgY3JlYXRlQ3ViZU1hcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHTEN1YmVNYXAodGhpcyk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuXHJcbmZ1bmN0aW9uIGdldFhmbG93RW50cnlXZWJHbERhdGEoZW50cnksIGNhbnZhc0lkKXtcclxuICAgIGlmKCFlbnRyeSkgcmV0dXJuIG51bGw7XHJcbiAgICBpZighZW50cnkudXNlckRhdGEud2ViZ2xEYXRhKVxyXG4gICAgICAgIGVudHJ5LnVzZXJEYXRhLndlYmdsRGF0YSA9IHt9O1xyXG4gICAgaWYoIWVudHJ5LnVzZXJEYXRhLndlYmdsRGF0YVtjYW52YXNJZF0pXHJcbiAgICAgICAgZW50cnkudXNlckRhdGEud2ViZ2xEYXRhW2NhbnZhc0lkXSA9IHtcclxuICAgICAgICAgICAgY2hhbmdlZCA6IFhDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9ORVdcclxuICAgICAgICB9O1xyXG4gICAgcmV0dXJuIGVudHJ5LnVzZXJEYXRhLndlYmdsRGF0YVtjYW52YXNJZF07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcclxuICogQHJldHVybnMge3t9fVxyXG4gKi9cclxuZnVuY3Rpb24gcG9wdWxhdGVFeHRlbnNpb25zKGdsKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBmb3IgKHZhciBuYW1lIGluIEVYVEVOU0lPTlMpIHtcclxuICAgICAgICB2YXIgZXh0ZW5zaW9uTmFtZSA9IEVYVEVOU0lPTlNbbmFtZV07XHJcbiAgICAgICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbihleHRlbnNpb25OYW1lKTtcclxuICAgICAgICBpZiAoIWV4dCkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dJbmZvKGV4dGVuc2lvbk5hbWUsIFwiaXMgbm90IHN1cHBvcnRlZCBvbiB5b3VyIGdyYXBoaWNzIGNhcmRcIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0W2V4dGVuc2lvbk5hbWVdID0gZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR0xDb250ZXh0O1xyXG5cclxuXHJcbiIsInZhciBGdWxsc2NyZWVuUXVhZCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICB0aGlzLmdsID0gY29udGV4dC5nbDtcclxuICAgIHRoaXMuY3JlYXRlR0xBc3NldHMoKTtcclxufTtcclxuXHJcblhNTDNELmV4dGVuZChGdWxsc2NyZWVuUXVhZC5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBjcmVhdGVHTEFzc2V0czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgdGhpcy5wb3NCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5wb3NCdWZmZXIpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAwLCAtMSwgMSwgMCwgMSwgLTEsIDAsIC0xLCAtMSwgMF0pLCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRyYXc6IGZ1bmN0aW9uIChwcm9ncmFtKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICB2YXIgcG9zQXR0ciA9IHByb2dyYW0uYXR0cmlidXRlc1tcInBvc2l0aW9uXCJdO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc0F0dHIubG9jYXRpb24pO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnBvc0J1ZmZlcik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NBdHRyLmxvY2F0aW9uLCAzLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG5cclxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcclxuXHJcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc0F0dHIubG9jYXRpb24pO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bGxzY3JlZW5RdWFkO1xyXG5cclxuIiwiXHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGNvbnRleHRcclxuICogQHBhcmFtIHR5cGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgR0xNZXNoID0gZnVuY3Rpb24gKGNvbnRleHQsIHR5cGUpIHtcclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB0aGlzLmdsVHlwZSA9IGdldEdMVHlwZUZyb21TdHJpbmcodHlwZSk7XHJcbiAgICB0aGlzLmJ1ZmZlcnMgPSB7fTtcclxuICAgIHRoaXMudW5pZm9ybU92ZXJyaWRlID0ge307XHJcbiAgICB0aGlzLm1pbkluZGV4ID0gMDtcclxuICAgIHRoaXMubWF4SW5kZXggPSAwO1xyXG4gICAgdGhpcy5pc0luZGV4ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMudmVydGV4Q291bnQgPSBudWxsO1xyXG4gICAgdGhpcy5taW5BdHRyaWJ1dGVDb3VudCA9IC0xO1xyXG4gICAgdGhpcy5jb250ZXh0LmdldFN0YXRpc3RpY3MoKS5tZXNoZXMrKztcclxuICAgIHRoaXMubXVsdGlEcmF3ID0gKHRoaXMuZ2xUeXBlID09IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5MSU5FX1NUUklQIHx8IHRoaXMuZ2xUeXBlID09IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRV9TVFJJUCk7XHJcbn07XHJcblxyXG5YTUwzRC5leHRlbmQoR0xNZXNoLnByb3RvdHlwZSwge1xyXG4gICAgc2V0SW5kZXhSYW5nZTogZnVuY3Rpb24gKG1pbkluZGV4LCBtYXhJbmRleCkge1xyXG4gICAgICAgIHRoaXMubWluSW5kZXggPSBtaW5JbmRleDtcclxuICAgICAgICB0aGlzLm1heEluZGV4ID0gbWF4SW5kZXg7XHJcbiAgICB9LFxyXG5cclxuICAgIGNoZWNrQnVmZmVyQ29tcGF0aWJsZTogZnVuY3Rpb24gKG5hbWUsIHhmbG93RGF0YUJ1ZmZlcikge1xyXG4gICAgICAgIHZhciBjbnQgPSB4Zmxvd0RhdGFCdWZmZXIuZ2V0SXRlcmF0ZUNvdW50KCk7XHJcbiAgICAgICAgdGhpcy5taW5BdHRyaWJ1dGVDb3VudCA9ICh0aGlzLm1pbkF0dHJpYnV0ZUNvdW50ID09IC0xID8gY250IDogTWF0aC5taW4odGhpcy5taW5BdHRyaWJ1dGVDb3VudCwgY250KSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzSW5kZXhlZCkge1xyXG4gICAgICAgICAgICBpZiAoY250IDw9IHRoaXMubWF4SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluZGV4IHJhbmdlIG9mIFtcIiArIHRoaXMubWluSW5kZXggKyBcIiwgXCIgKyB0aGlzLm1heEluZGV4ICsgXCJdIFwiICsgXCIgZ29lcyBiZXlvbmQgZWxlbWVudCBjb3VudCBcIiArIGNudCArIFwiIG9mIGF0dHJpYnV0ZSAnXCIgKyBuYW1lICsgXCInXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZlcnRleENvdW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjbnQgPCB0aGlzLnZlcnRleENvdW50KVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVydGV4Q291bnQgXCIgKyB0aGlzLnZlcnRleENvdW50ICsgXCIgaXMgbGFyZ2VyIHRoYW4gZWxlbWVudCBjb3VudCBcIiArIGNudCArIFwiIG9mIGF0dHJpYnV0ZSAnXCIgKyBuYW1lICsgXCInXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlQnVmZmVyOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmJ1ZmZlcnNbbmFtZV07XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEJ1ZmZlcjogZnVuY3Rpb24gKG5hbWUsIGJ1ZmZlcikge1xyXG4gICAgICAgIHRoaXMuYnVmZmVyc1tuYW1lXSA9IGJ1ZmZlcjtcclxuICAgICAgICB0aGlzLmlzSW5kZXhlZCA9IHRoaXMuaXNJbmRleGVkIHx8IG5hbWUgPT0gXCJpbmRleFwiO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYnVmZmVycyA9IHt9O1xyXG4gICAgICAgIHRoaXMudW5pZm9ybU92ZXJyaWRlID0ge307XHJcbiAgICAgICAgdGhpcy5taW5JbmRleCA9IHRoaXMubWF4SW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuaXNJbmRleGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5taW5BdHRyaWJ1dGVDb3VudCA9IC0xO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRVbmlmb3JtT3ZlcnJpZGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy51bmlmb3JtT3ZlcnJpZGVbbmFtZV07XHJcbiAgICAgICAgdGhpcy51bmlmb3JtT3ZlcnJpZGVbbmFtZV0gPSB2YWx1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VmVydGV4Q291bnQ6IGZ1bmN0aW9uICh2ZXJ0ZXhDb3VudCkge1xyXG4gICAgICAgIHRoaXMudmVydGV4Q291bnQgPSB2ZXJ0ZXhDb3VudDtcclxuICAgIH0sXHJcblxyXG4gICAgaXNSZWFkeVRvUmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluQXR0cmlidXRlQ291bnQgPiAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldEVsZW1lbnRDb3VudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcnMuaW5kZXgubGVuZ3RoO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy9YTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBjYWxjdWxhdGUgZWxlbWVudCBjb3VudC5cIiwgZSk7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH0sIC8qKlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0VmVydGV4Q291bnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudmVydGV4Q291bnQgIT0gbnVsbCA/IHRoaXMudmVydGV4Q291bnQgOiB0aGlzLm1pbkF0dHJpYnV0ZUNvdW50ICk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvL1hNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQ291bGQgbm90IGNhbGN1bGF0ZSB2ZXJ0ZXggY291bnQuXCIsIGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtBYnN0cmFjdFNoYWRlckNsb3N1cmV9IHByb2dyYW1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9iaW5kVmVydGV4QnVmZmVyczogZnVuY3Rpb24ocHJvZ3JhbSkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbCwgc0F0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZXMsIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnMsIGksIG5hbWU7XHJcblxyXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc0F0dHJpYnV0ZXMpO1xyXG4gICAgICAgIHZhciBrZXlMZW5ndGggPSBrZXlzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleUxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyc1tuYW1lXTtcclxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gc0F0dHJpYnV0ZXNbbmFtZV0ubG9jYXRpb247XHJcblxyXG4gICAgICAgICAgICBpZiAoIWJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihsb2NhdGlvbiwgYnVmZmVyLnR1cGxlU2l6ZSwgYnVmZmVyLmdsVHlwZSwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX3VuYmluZFZlcnRleEJ1ZmZlcnM6IGZ1bmN0aW9uIChwcm9ncmFtKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsLCBzQXR0cmlidXRlcyA9IHByb2dyYW0uYXR0cmlidXRlcztcclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHNBdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFkZXJBdHRyaWJ1dGUgPSBzQXR0cmlidXRlc1tuYW1lXTtcclxuICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlckF0dHJpYnV0ZS5sb2NhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0Fic3RyYWN0U2hhZGVyQ2xvc3VyZX0gcHJvZ3JhbVxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZHJhdzogZnVuY3Rpb24gKHByb2dyYW0pIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2wsIHNBdHRyaWJ1dGVzID0gcHJvZ3JhbS5hdHRyaWJ1dGVzLCBidWZmZXJzID0gdGhpcy5idWZmZXJzLCB0cmlDb3VudCA9IDAsIG9mZnNldCwgajtcclxuXHJcbiAgICAgICAgLy9CaW5kIHZlcnRleCBidWZmZXJzXHJcbiAgICAgICAgdGhpcy5fYmluZFZlcnRleEJ1ZmZlcnMocHJvZ3JhbSk7XHJcblxyXG4gICAgICAgIC8vRHJhdyB0aGUgb2JqZWN0XHJcbiAgICAgICAgaWYgKHRoaXMuaXNJbmRleGVkKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleEJ1ZmZlciA9IGJ1ZmZlcnMuaW5kZXg7XHJcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsaW5kZXhCdWZmZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlEcmF3ICYmIHRoaXMudmVydGV4Q291bnQpIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGhpcy52ZXJ0ZXhDb3VudC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMudmVydGV4Q291bnRbal07XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKHRoaXMuZ2xUeXBlLCBjb3VudCwgaW5kZXhCdWZmZXIuZ2xUeXBlLCBvZmZzZXQgKiBpbmRleEJ1ZmZlci5ieXRlc1BlckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBjb3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyh0aGlzLmdsVHlwZSwgdGhpcy5nZXRFbGVtZW50Q291bnQoKSwgaW5kZXhCdWZmZXIuZ2xUeXBlLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cmlDb3VudCA9IHRoaXMuZ2V0RWxlbWVudENvdW50KCkgLyAzO1xyXG4gICAgICAgIH0gZWxzZSB7IC8vIG5vdCBpbmRleGVkXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpRHJhdyAmJiB0aGlzLnZlcnRleENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMudmVydGV4Q291bnQubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLnZlcnRleENvdW50W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXModGhpcy5nbFR5cGUsIG9mZnNldCwgY291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBjb3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXModGhpcy5nbFR5cGUsIDAsIHRoaXMuZ2V0VmVydGV4Q291bnQoKSk7XHJcbiAgICAgICAgICAgICAgICB0cmlDb3VudCA9IHRoaXMuZ2V0VmVydGV4Q291bnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9VbmJpbmQgdmVydGV4IGJ1ZmZlcnNcclxuICAgICAgICB0aGlzLl91bmJpbmRWZXJ0ZXhCdWZmZXJzKHByb2dyYW0pO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKHByb2dyYW0udW5kb1VuaWZvcm1WYXJpYWJsZU92ZXJyaWRlKVxyXG4gICAgICAgICAgICBwcm9ncmFtLnVuZG9Vbmlmb3JtVmFyaWFibGVPdmVycmlkZSh0aGlzLnVuaWZvcm1PdmVycmlkZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0cmlDb3VudDtcclxuICAgIH1cclxuXHJcblxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZU5hbWVcclxuICovXHJcbnZhciBnZXRHTFR5cGVGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHR5cGVOYW1lKSB7XHJcbiAgICB2YXIgR0wgPSB3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgaWYgKHR5cGVOYW1lICYmIHR5cGVOYW1lLnRvTG93ZUdMYXNlKVxyXG4gICAgICAgIHR5cGVOYW1lID0gdHlwZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIHN3aXRjaCAodHlwZU5hbWUpIHtcclxuICAgICAgICBjYXNlIFwidHJpYW5nbGVzXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBHTC5UUklBTkdMRVM7XHJcbiAgICAgICAgY2FzZSBcInRyaXN0cmlwc1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gR0wuVFJJQU5HTEVfU1RSSVA7XHJcbiAgICAgICAgY2FzZSBcInBvaW50c1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gR0wuUE9JTlRTO1xyXG4gICAgICAgIGNhc2UgXCJsaW5lc1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gR0wuTElORVM7XHJcbiAgICAgICAgY2FzZSBcImxpbmVzdHJpcHNcIjpcclxuICAgICAgICAgICAgcmV0dXJuIEdMLkxJTkVfU1RSSVA7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwcmltaXRpdmUgdHlwZTogXCIgKyB0eXBlTmFtZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdMTWVzaDtcclxuIiwiXHJcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xyXG52YXIgU3lzdGVtTm90aWZpZXIgPSByZXF1aXJlKFwiLi4vc3lzdGVtL3N5c3RlbS1ub3RpZmllci5qc1wiKTtcclxuXHJcbi8vbm9pbnNwZWN0aW9uIEpTVmFsaWRhdGVKU0RvY1xyXG4vKipcclxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGFkZXJTb3VyY2VcclxuICogQHJldHVybiB7V2ViR0xTaGFkZXJ9XHJcbiAqL1xyXG52YXIgY3JlYXRlV2ViR0xTaGFkZXJGcm9tU291cmNlID0gZnVuY3Rpb24gKGdsLCB0eXBlLCBzaGFkZXJTb3VyY2UpIHtcclxuICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XHJcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xyXG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG5cclxuICAgIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBXZWJHTFJlbmRlcmluZ0NvbnRleHQuQ09NUElMRV9TVEFUVVMpID09IDApIHtcclxuICAgICAgICB2YXIgbWVzc2FnZSA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcclxuICAgICAgICB2YXIgZXJyb3JTdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgIGlmICh0eXBlID09IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5WRVJURVhfU0hBREVSKVxyXG4gICAgICAgICAgICBlcnJvclN0cmluZyA9IFwiVmVydGV4IHNoYWRlciBmYWlsZWQgdG8gY29tcGlsZTogXFxuXCI7IGVsc2VcclxuICAgICAgICAgICAgZXJyb3JTdHJpbmcgPSBcIkZyYWdtZW50IHNoYWRlciBmYWlsZWQgdG8gY29tcGlsZTogXFxuXCI7XHJcblxyXG4gICAgICAgIGVycm9yU3RyaW5nICs9IG1lc3NhZ2UgKyBcIlxcbi0tLS0tLS0tXFxuXCI7XHJcbiAgICAgICAgZXJyb3JTdHJpbmcgKz0gXCJTaGFkZXIgU291cmNlOlxcbi0tLS0tLS0tXFxuXCI7XHJcbiAgICAgICAgZXJyb3JTdHJpbmcgKz0gWE1MM0QuZGVidWcuZm9ybWF0U291cmNlQ29kZShzaGFkZXJTb3VyY2UpO1xyXG4gICAgICAgIGdsLmdldEVycm9yKCk7XHJcbiAgICAgICAgU3lzdGVtTm90aWZpZXIuc2VuZEV2ZW50KCdnbHNsJywge1xyXG4gICAgICAgICAgICAgICAgZ2xzbFR5cGU6IFwiY29tcGlsZV9lcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgc2hhZGVyVHlwZTogdHlwZSA9PSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuVkVSVEVYX1NIQURFUiA/IFwidmVydGV4XCIgOiBcImZyYWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBjb2RlOiBzaGFkZXJTb3VyY2UsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmcpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2hhZGVyO1xyXG59O1xyXG5cclxuLy9ub2luc3BlY3Rpb24gSlNWYWxpZGF0ZUpTRG9jXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcclxuICogQHBhcmFtIHZlcnRleFNvdXJjZXNcclxuICogQHBhcmFtIGZyYWdtZW50U291cmNlc1xyXG4gKiBAcmV0dXJucyB7V2ViR0xQcm9ncmFtfVxyXG4gKi9cclxudmFyIGNyZWF0ZVByb2dyYW1Gcm9tU291cmNlcyA9IGZ1bmN0aW9uIChnbCwgdmVydGV4U291cmNlcywgZnJhZ21lbnRTb3VyY2VzKSB7XHJcbiAgICB2YXIgc2hkLCBzLCBzcmM7XHJcbiAgICB2YXIgc2hhZGVycyA9IFtdO1xyXG4gICAgZm9yIChzIGluIHZlcnRleFNvdXJjZXMpIHtcclxuICAgICAgICBzcmMgPSB2ZXJ0ZXhTb3VyY2VzW3NdO1xyXG4gICAgICAgIHNoZCA9IGNyZWF0ZVdlYkdMU2hhZGVyRnJvbVNvdXJjZShnbCwgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlZFUlRFWF9TSEFERVIsIHNyYyk7XHJcbiAgICAgICAgc2hhZGVycy5wdXNoKHNoZCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKHMgaW4gZnJhZ21lbnRTb3VyY2VzKSB7XHJcbiAgICAgICAgc3JjID0gZnJhZ21lbnRTb3VyY2VzW3NdO1xyXG4gICAgICAgIHNoZCA9IGNyZWF0ZVdlYkdMU2hhZGVyRnJvbVNvdXJjZShnbCwgV2ViR0xSZW5kZXJpbmdDb250ZXh0LkZSQUdNRU5UX1NIQURFUiwgc3JjKTtcclxuICAgICAgICBzaGFkZXJzLnB1c2goc2hkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVQcm9ncmFtRnJvbVNoYWRlcnMoZ2wsIHNoYWRlcnMpO1xyXG59O1xyXG5cclxuLy9ub2luc3BlY3Rpb24gSlNWYWxpZGF0ZUpTRG9jXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcclxuICogQHBhcmFtIHtPYmplY3R9IHNoYWRlcnNcclxuICogQHJldHVybiB7V2ViR0xQcm9ncmFtfVxyXG4gKi9cclxudmFyIGNyZWF0ZVByb2dyYW1Gcm9tU2hhZGVycyA9IGZ1bmN0aW9uIChnbCwgc2hhZGVycykge1xyXG4gICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICBmb3IgKHZhciBzIGluIHNoYWRlcnMpIHtcclxuICAgICAgICB2YXIgc2hhZGVyID0gc2hhZGVyc1tzXTtcclxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgc2hhZGVyKTtcclxuICAgIH1cclxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgaWYgKGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgV2ViR0xSZW5kZXJpbmdDb250ZXh0LkxJTktfU1RBVFVTKSA9PSAwKSB7XHJcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcclxuICAgICAgICB2YXIgZXJyb3JTdHJpbmcgPSBcIlNoYWRlciBsaW5raW5nIGZhaWxlZDogXFxuXCI7XHJcbiAgICAgICAgZXJyb3JTdHJpbmcgKz0gbWVzc2FnZTtcclxuICAgICAgICBlcnJvclN0cmluZyArPSBcIlxcbi0tLS0tLS0tXFxuXCI7XHJcbiAgICAgICAgZ2wuZ2V0RXJyb3IoKTtcclxuICAgICAgICBTeXN0ZW1Ob3RpZmllci5zZW5kRXZlbnQoJ2dsc2wnLCB7Z2xzbFR5cGU6IFwibGlua19lcnJvclwiLCBtZXNzYWdlOiBtZXNzYWdlfSk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9ncmFtO1xyXG59O1xyXG5cclxudmFyIHRhbGx5ID0gZnVuY3Rpb24gKGdsLCBoYW5kbGUsIHByb2dyYW1PYmplY3QpIHtcclxuICAgIHZhciBpO1xyXG4gICAgLy8gVGFsbHkgc2hhZGVyIGF0dHJpYnV0ZXNcclxuICAgIHZhciBudW1BdHRyaWJ1dGVzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihoYW5kbGUsIGdsLkFDVElWRV9BVFRSSUJVVEVTKTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBudW1BdHRyaWJ1dGVzOyBpKyspIHtcclxuICAgICAgICB2YXIgYXR0ID0gZ2wuZ2V0QWN0aXZlQXR0cmliKGhhbmRsZSwgaSk7XHJcbiAgICAgICAgaWYgKCFhdHQpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIHZhciBhdHRJbmZvID0ge307XHJcbiAgICAgICAgYXR0SW5mby5uYW1lID0gYXR0Lm5hbWU7XHJcbiAgICAgICAgYXR0SW5mby5zaXplID0gYXR0LnNpemU7XHJcbiAgICAgICAgYXR0SW5mby5nbFR5cGUgPSBhdHQudHlwZTtcclxuICAgICAgICBhdHRJbmZvLmxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oaGFuZGxlLCBhdHQubmFtZSk7XHJcbiAgICAgICAgcHJvZ3JhbU9iamVjdC5hdHRyaWJ1dGVzW2F0dC5uYW1lXSA9IGF0dEluZm87XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFRhbGx5IHNoYWRlciB1bmlmb3JtcyBhbmQgc2FtcGxlcnNcclxuICAgIHZhciBudW1Vbmlmb3JtcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoaGFuZGxlLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG51bVVuaWZvcm1zOyBpKyspIHtcclxuICAgICAgICB2YXIgdW5pID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShoYW5kbGUsIGkpO1xyXG4gICAgICAgIGlmICghdW5pKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB2YXIgdW5pSW5mbyA9IHt9O1xyXG4gICAgICAgIHVuaUluZm8ubmFtZSA9IHVuaS5uYW1lO1xyXG4gICAgICAgIHVuaUluZm8uc2l6ZSA9IHVuaS5zaXplO1xyXG4gICAgICAgIHVuaUluZm8uZ2xUeXBlID0gdW5pLnR5cGU7XHJcbiAgICAgICAgdW5pSW5mby5sb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihoYW5kbGUsIHVuaS5uYW1lKTtcclxuXHJcbiAgICAgICAgdmFyIG5hbWUgPSB1bmlJbmZvLm5hbWU7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBhcnJheSBpZGVudGlmaWVyIGZyb20gbmFtZSwgdGhpcyBpcyBoYW5kbGVkIGJ5IHNpemVcclxuICAgICAgICBpZiAobmFtZS5zdWJzdHJpbmcobmFtZS5sZW5ndGggLSAzKSA9PSBcIlswXVwiKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmxlbmd0aCAtIDMpOyAvLyBSZW1vdmUgWzBdXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodW5pLnR5cGUgPT0gZ2wuU0FNUExFUl8yRCB8fCB1bmkudHlwZSA9PSBnbC5TQU1QTEVSX0NVQkUpIHtcclxuICAgICAgICAgICAgLy8gU2V0IGFsbCB0ZXh0dXJlIHVuaXRzIHRvIDAsIG5lZWRzIHRvIGJlIEludDMyQXJyYXlcclxuICAgICAgICAgICAgdW5pSW5mby5jYWNoZWRVbml0cyA9IG5ldyBJbnQzMkFycmF5KHVuaUluZm8uc2l6ZSk7XHJcbiAgICAgICAgICAgIHVuaUluZm8udGV4dHVyZXMgPSBbXTtcclxuICAgICAgICAgICAgLy8gQ2FjaGVzIHRoaXMgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgdXRpbHMuc2V0VW5pZm9ybShnbCwgdW5pSW5mbywgdW5pSW5mby5jYWNoZWRVbml0cyk7XHJcblxyXG4gICAgICAgICAgICBwcm9ncmFtT2JqZWN0LnNhbXBsZXJzW25hbWVdID0gdW5pSW5mbztcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgcHJvZ3JhbU9iamVjdC51bmlmb3Jtc1tuYW1lXSA9IHVuaUluZm87XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxudmFyIHVuaXF1ZU9iamVjdElkID0gdXRpbHMuZ2V0VW5pcXVlQ291bnRlcigpO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcclxuICogQHBhcmFtIHt7IGZyYWdtZW50OiBzdHJpbmcsIHZlcnRleDogc3RyaW5nIH19IHNvdXJjZXNcclxuICovXHJcbnZhciBQcm9ncmFtT2JqZWN0ID0gZnVuY3Rpb24gKGdsLCBzb3VyY2VzKSB7XHJcbiAgICB0aGlzLmdsID0gZ2w7XHJcbiAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xyXG5cclxuICAgIHRoaXMuaWQgPSB1bmlxdWVPYmplY3RJZCgpO1xyXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XHJcbiAgICB0aGlzLnVuaWZvcm1zID0ge307XHJcbiAgICB0aGlzLnNhbXBsZXJzID0ge307XHJcbiAgICB0aGlzLmhhbmRsZSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5jcmVhdGUoKTtcclxufTtcclxuXHJcblhNTDNELmV4dGVuZChQcm9ncmFtT2JqZWN0LnByb3RvdHlwZSwge1xyXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJDcmVhdGUgc2hhZGVyIHByb2dyYW06IFwiLCB0aGlzLmlkKTtcclxuICAgICAgICB0aGlzLmhhbmRsZSA9IGNyZWF0ZVByb2dyYW1Gcm9tU291cmNlcyh0aGlzLmdsLCBbdGhpcy5zb3VyY2VzLnZlcnRleF0sIFt0aGlzLnNvdXJjZXMuZnJhZ21lbnRdKTtcclxuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgU3lzdGVtTm90aWZpZXIuc2VuZEV2ZW50KCdnbHNsJywge2dsc2xUeXBlOiBcInN1Y2Nlc3NcIn0pO1xyXG4gICAgICAgIHRoaXMuYmluZCgpO1xyXG4gICAgICAgIHRhbGx5KHRoaXMuZ2wsIHRoaXMuaGFuZGxlLCB0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgYmluZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5oYW5kbGUpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJUcnlpbmcgdG8gYmluZCBpbnZhbGlkIEdMUHJvZ3JhbS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLmhhbmRsZSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNvbWUgb2YgdGhlIGRlcGVuZGVudCB0ZXh0dXJlcyBtYXkgaGF2ZSBjaGFuZ2VkIHRoZWlyIHRleHR1cmUgdW5pdHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuc2FtcGxlcnMpIHtcclxuICAgICAgICAgICAgdmFyIHNhbXBsZXIgPSB0aGlzLnNhbXBsZXJzW25hbWVdO1xyXG4gICAgICAgICAgICBpZihzYW1wbGVyLnRleHR1cmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTYW1wbGVyRnJvbVRleHR1cmVzKHNhbXBsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIH0sIGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLmhhbmRsZTtcclxuICAgIH0sIHNldFVuaWZvcm1WYXJpYWJsZXM6IGZ1bmN0aW9uIChlbnZOYW1lcywgc3lzTmFtZXMsIGlucHV0Q29sbGVjdGlvbikge1xyXG4gICAgICAgIHZhciBpLCBiYXNlLCBvdmVycmlkZSwgbmFtZTtcclxuICAgICAgICBpZiAoZW52TmFtZXMgJiYgaW5wdXRDb2xsZWN0aW9uLmVudkJhc2UpIHtcclxuICAgICAgICAgICAgaSA9IGVudk5hbWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgYmFzZSA9IGlucHV0Q29sbGVjdGlvbi5lbnZCYXNlO1xyXG4gICAgICAgICAgICBvdmVycmlkZSA9IGlucHV0Q29sbGVjdGlvbi5lbnZPdmVycmlkZTtcclxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IGVudk5hbWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRVbmlmb3JtVmFyaWFibGUobmFtZSwgb3ZlcnJpZGUgJiYgb3ZlcnJpZGVbbmFtZV0gIT09IHVuZGVmaW5lZCA/IG92ZXJyaWRlW25hbWVdIDogYmFzZVtuYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN5c05hbWVzICYmIGlucHV0Q29sbGVjdGlvbi5zeXNCYXNlKSB7XHJcbiAgICAgICAgICAgIGkgPSBzeXNOYW1lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGJhc2UgPSBpbnB1dENvbGxlY3Rpb24uc3lzQmFzZTtcclxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IHN5c05hbWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRVbmlmb3JtVmFyaWFibGUobmFtZSwgYmFzZVtuYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBzZXRVbmlmb3JtVmFyaWFibGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XHJcbiAgICAgICAgaWYgKHRoaXMudW5pZm9ybXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgdXRpbHMuc2V0VW5pZm9ybSh0aGlzLmdsLCB0aGlzLnVuaWZvcm1zW25hbWVdLCB2YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNhbXBsZXJzW25hbWVdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VW5pZm9ybVNhbXBsZXIodGhpcy5zYW1wbGVyc1tuYW1lXSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB0ZXh0dXJlIHVuaXRzIGZyb20gdGhlIHRleHR1cmVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2FtcGxlclxyXG4gICAgICogQHBhcmFtIHNhbXBsZXJcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBzZXRTYW1wbGVyRnJvbVRleHR1cmVzOiBmdW5jdGlvbiAoc2FtcGxlcikge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IHNhbXBsZXIudGV4dHVyZXM7XHJcbiAgICAgICAgdmFyIGNhY2hlZFVuaXRzID0gc2FtcGxlci5jYWNoZWRVbml0cztcclxuICAgICAgICB2YXIgdGV4dHVyZVVuaXRzQ2hhbmdlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0ZXh0dXJlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB1bml0ID0gdGV4dHVyZXNbaV0udW5pdDtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRleHR1cmUgaXMgbm90IGJvdW5kIHRvIGEgdGV4dHVyZSB1bml0ICgtMSksIGJpbmQgaXQgbm93XHJcbiAgICAgICAgICAgIGlmICh1bml0ID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB1bml0ID0gdGV4dHVyZXNbaV0uX2JpbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW5pdCAhPSBjYWNoZWRVbml0c1tpXSkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVkVW5pdHNbaV0gPSB1bml0O1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZVVuaXRzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRleHR1cmVVbml0c0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJTZXR0aW5nIG5ldyB0ZXh0dXJlIHVuaXRzOlwiLCBzYW1wbGVyLm5hbWUsIGNhY2hlZFVuaXRzKTtcclxuICAgICAgICAgICAgdXRpbHMuc2V0VW5pZm9ybSh0aGlzLmdsLCBzYW1wbGVyLCBjYWNoZWRVbml0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTYW1wbGVyRnJvbUFycmF5OiBmdW5jdGlvbihzYW1wbGVyLCBhcnIpIHtcclxuICAgICAgICB2YXIgY2FjaGVkVW5pdHMgPSBzYW1wbGVyLmNhY2hlZFVuaXRzO1xyXG4gICAgICAgIHZhciB0ZXh0dXJlVW5pdHNDaGFuZ2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHVuaXQgPSBhcnJbaV07XHJcbiAgICAgICAgICAgIGlmICh1bml0ICE9IGNhY2hlZFVuaXRzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZWRVbml0c1tpXSA9IHVuaXQ7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlVW5pdHNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGV4dHVyZVVuaXRzQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICB1dGlscy5zZXRVbmlmb3JtKHRoaXMuZ2wsIHNhbXBsZXIsIGNhY2hlZFVuaXRzKTtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJTZXR0aW5nIGdsb2JhbCB0ZXh0dXJlIHVuaXRzOlwiLCBzYW1wbGVyLm5hbWUsIGNhY2hlZFVuaXRzLCB0aGlzLmlkKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzYW1wbGVyXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxHTFRleHR1cmU+fEludDMyQXJyYXl9IHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHNldFVuaWZvcm1TYW1wbGVyOiBmdW5jdGlvbiAoc2FtcGxlciwgdmFsdWUpIHtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5hc3NlcnQodmFsdWUgJiYgc2FtcGxlcik7XHJcbiAgICAgICAgLy8gVGV4dHVyZXMgYXJlIGFsd2F5cyBhbiBhcnJheSB2YWx1ZVxyXG4gICAgICAgIFhNTDNELmRlYnVnLmFzc2VydChBcnJheS5pc0FycmF5KHZhbHVlKSwgXCJQcm9ncmFtOjpzZXRVbmlmb3JtU2FtcGxlcjogVW5leHBlY3RlZCB2YWx1ZS5cIik7XHJcbiAgICAgICAgLy8gV2UgaGF2ZSBhdCBsZWFzdCBvbmUgZW50cnlcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5hc3NlcnQodmFsdWUubGVuZ3RoLCBcIlByb2dyYW06OnNldFVuaWZvcm1TYW1wbGVyOiBObyBlbnRyeSBpbiB2YWx1ZS5cIik7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgR0xUZXh0dXJlcyB0aGF0IGtub3cgdGhlaXIgY3VycmVudCB0ZXh0dXJlIHVuaXQsXHJcbiAgICAgICAgICogb3RoZXJ3aXNlIGEgdHlwZWQgYXJyYXkgY29udGFpbmluZyB0aGUgdGV4dHVyZSB1bml0cyB3ZSBoYXZlIHRvIGJpbmQuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGhhc1RleHR1cmVzID0gdmFsdWVbMF0udW5pdCAhPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGlmKGhhc1RleHR1cmVzKSB7XHJcbiAgICAgICAgICAgIHNhbXBsZXIudGV4dHVyZXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5zZXRTYW1wbGVyRnJvbVRleHR1cmVzKHNhbXBsZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2FtcGxlckZyb21BcnJheShzYW1wbGVyLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvZ3JhbU9iamVjdDtcclxuXHJcbiIsIi8qKlxyXG4gKiBAaW50ZXJmYWNlXHJcbiAqL1xyXG52YXIgSVJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuSVJlbmRlclRhcmdldC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuSVJlbmRlclRhcmdldC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5JUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuSVJlbmRlclRhcmdldC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5JUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuSVJlbmRlclRhcmdldC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcmFwcGVyIHRvIGhhbmRsZSBzY3JlZW4gY29udGV4dCBhcyByZW5kZXIgdGFyZ2V0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0dMQ29udGV4dH0gY29udGV4dFxyXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcclxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxyXG4gKiBAaW1wbGVtZW50cyBJUmVuZGVyVGFyZ2V0XHJcbiAqL1xyXG52YXIgR0xDYW52YXNUYXJnZXQgPSBmdW5jdGlvbiAoY29udGV4dCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG59O1xyXG5cclxudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuWE1MM0QuZXh0ZW5kKEdMQ2FudmFzVGFyZ2V0LnByb3RvdHlwZSwge1xyXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcclxuICAgIH0sIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcclxuICAgIH0sIGdldFNjYWxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9LCBiaW5kOiBlbXB0eSwgdW5iaW5kOiBlbXB0eSwgcmVzaXplOiBlbXB0eVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gY29udGV4dFxyXG4gKiBAcGFyYW0gb3B0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAaW1wbGVtZW50cyBJUmVuZGVyVGFyZ2V0XHJcbiAqL1xyXG52YXIgR0xSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoY29udGV4dCwgb3B0KSB7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy53aWR0aCA9IG9wdC53aWR0aCB8fCA4MDA7XHJcbiAgICB0aGlzLmhlaWdodCA9IG9wdC5oZWlnaHQgfHwgNjAwO1xyXG4gICAgdGhpcy5zY2FsZSA9IG9wdC5zY2FsZSB8fCAxO1xyXG4gICAgdGhpcy5vcHQgPSB0aGlzLmZpbGxPcHRpb25zKG9wdCk7XHJcbiAgICB0aGlzLmhhbmRsZSA9IG51bGw7XHJcbiAgICB0aGlzLmNvbG9yVGFyZ2V0ID0ge2hhbmRsZTogbnVsbCwgaXNUZXh0dXJlOiBmYWxzZX07XHJcbiAgICB0aGlzLmRlcHRoVGFyZ2V0ID0ge2hhbmRsZTogbnVsbCwgaXNUZXh0dXJlOiBmYWxzZX07XHJcbiAgICB0aGlzLnN0ZW5jaWxUYXJnZXQgPSB7aGFuZGxlOiBudWxsLCBpc1RleHR1cmU6IGZhbHNlfTtcclxuICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcclxufTtcclxuXHJcblhNTDNELmV4dGVuZChHTFJlbmRlclRhcmdldC5wcm90b3R5cGUsIHtcclxuICAgIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XHJcbiAgICB9LCBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XHJcbiAgICB9LCBnZXRTY2FsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlO1xyXG4gICAgfSwgYmluZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjcmVhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCF0aGlzLmhhbmRsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZyYW1lQnVmZmVyKHRoaXMub3B0LmNvbG9yRm9ybWF0LCB0aGlzLm9wdC5kZXB0aEZvcm1hdCwgdGhpcy5vcHQuc3RlbmNpbEZvcm1hdCk7XHJcbiAgICAgICAgICAgIGNyZWF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy52YWxpZCkge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5oYW5kbGUpO1xyXG4gICAgICAgICAgICAvLyBTZXQgZGVmYXVsdCB2aWV3cG9ydFxyXG4gICAgICAgICAgICBjcmVhdGVkICYmIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9LCB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgIH0sIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5iaW5kKCk7XHJcbiAgICB9LCBjcmVhdGVGcmFtZUJ1ZmZlcjogZnVuY3Rpb24gKGNvbG9yRm9ybWF0LCBkZXB0aEZvcm1hdCwgc3RlbmNpbEZvcm1hdCkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGUgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5oYW5kbGUpO1xyXG4gICAgICAgIGNvbG9yRm9ybWF0ICYmIHRoaXMuY3JlYXRlQ29sb3JUYXJnZXQoY29sb3JGb3JtYXQpO1xyXG4gICAgICAgIGRlcHRoRm9ybWF0ICYmIHRoaXMuY3JlYXRlRGVwdGhUYXJnZXQoZGVwdGhGb3JtYXQpO1xyXG4gICAgICAgIHN0ZW5jaWxGb3JtYXQgJiYgdGhpcy5jcmVhdGVTdGVuY2lsVGFyZ2V0KHN0ZW5jaWxGb3JtYXQpO1xyXG4gICAgICAgIHRoaXMuY2hlY2tTdGF0dXMoKTtcclxuICAgIH0sIGNyZWF0ZUNvbG9yVGFyZ2V0OiBmdW5jdGlvbiAoY29sb3JGb3JtYXQpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0LmNvbG9yQXNSZW5kZXJidWZmZXIpIHtcclxuICAgICAgICAgICAgdmFyIGN0ID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBjdCk7XHJcbiAgICAgICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBjb2xvckZvcm1hdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XHJcblxyXG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlJFTkRFUkJVRkZFUiwgY3QpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jb2xvclRhcmdldCA9IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZTogY3QsIGlzVGV4dHVyZTogZmFsc2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL29wdC5nZW5lcmF0ZU1pcG1hcCA9IG9wdC5nZW5lcmF0ZUNvbG9yc01pcG1hcDtcclxuICAgICAgICAgICAgdmFyIGN0ZXggPSB0aGlzLmNvbnRleHQuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgICAgICBjdGV4LmNyZWF0ZVRleDJERnJvbURhdGEoY29sb3JGb3JtYXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBnbC5SR0JBLCB0aGlzLm9wdC5jb2xvclR5cGUgfHwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5vcHQpO1xyXG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIGN0ZXguaGFuZGxlLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5jb2xvclRhcmdldCA9IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZTogY3RleCwgaXNUZXh0dXJlOiB0cnVlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSwgY3JlYXRlRGVwdGhUYXJnZXQ6IGZ1bmN0aW9uIChkZXB0aEZvcm1hdCkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcclxuICAgICAgICB0aGlzLm9wdC5pc0RlcHRoID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5vcHQuZGVwdGhBc1JlbmRlcmJ1ZmZlcikge1xyXG4gICAgICAgICAgICB2YXIgZHQgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuICAgICAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIGR0KTtcclxuICAgICAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGRlcHRoRm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcclxuXHJcbiAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIGR0KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGVwdGhUYXJnZXQgPSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGR0LCBpc1RleHR1cmU6IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL29wdC5nZW5lcmF0ZU1pcG1hcCA9IG9wdC5nZW5lcmF0ZURlcHRoTWlwbWFwO1xyXG4gICAgICAgICAgICB2YXIgZHRleCA9IHRoaXMuY29udGV4dC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgICAgIGR0ZXguY3JlYXRlVGV4MkRGcm9tRGF0YShkZXB0aEZvcm1hdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGdsLkRFUFRIX0NPTVBPTkVOVCwgZ2wuRkxPQVQsIHRoaXMub3B0KTtcclxuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIGR0ZXguaGFuZGxlLCAwKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGVwdGhUYXJnZXQgPSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGR0ZXgsIGlzVGV4dHVyZTogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgY3JlYXRlU3RlbmNpbFRhcmdldDogZnVuY3Rpb24gKHN0ZW5jaWxGb3JtYXQpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0LnN0ZW5jaWxBc1JlbmRlcmJ1ZmZlcikge1xyXG4gICAgICAgICAgICB2YXIgc3QgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuICAgICAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHN0KTtcclxuICAgICAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIHN0ZW5jaWxGb3JtYXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLlNURU5DSUxfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBzdCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0ZW5jaWxUYXJnZXQgPSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGU6IHN0LCBpc1RleHR1cmU6IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL29wdC5nZW5lcmF0ZU1pcG1hcCA9IG9wdC5nZW5lcmF0ZVN0ZW5jaWxNaXBtYXA7XHJcbiAgICAgICAgICAgIHZhciBzdGV4ID0gdGhpcy5jb250ZXh0LmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICAgICAgc3RleC5jcmVhdGVUZXgyREZyb21EYXRhKHN0ZW5jaWxGb3JtYXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBnbC5TVEVOQ0lMX0NPTVBPTkVOVCwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5vcHQpO1xyXG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuU1RFTkNJTF9BVFRBQ0hNRU5ULCBnbC5URVhUVVJFXzJELCBzdGV4LmhhbmRsZSwgMCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0ZW5jaWxUYXJnZXQgPSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGU6IHN0ZXgsIGlzVGV4dHVyZTogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgY2hlY2tTdGF0dXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcblxyXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5oYW5kbGUpO1xyXG4gICAgICAgIC8vRmluYWxpemUgZnJhbWVidWZmZXIgY3JlYXRpb25cclxuICAgICAgICB2YXIgZmJTdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChmYlN0YXR1cykge1xyXG4gICAgICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFOlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOlxyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRcIik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVDpcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlRcIik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6XHJcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU1wiKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEOlxyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRFwiKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBcIiArIGZiU3RhdHVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcblxyXG4gICAgICAgIHRoaXMudmFsaWQgPSAoZmJTdGF0dXMgPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkO1xyXG4gICAgfSwgZmlsbE9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG4gICAgICAgIHZhciBvcHQgPSB7XHJcbiAgICAgICAgICAgIHdyYXBTOiBnbC5DTEFNUF9UT19FREdFLFxyXG4gICAgICAgICAgICB3cmFwVDogZ2wuQ0xBTVBfVE9fRURHRSxcclxuICAgICAgICAgICAgbWluRmlsdGVyOiBnbC5ORUFSRVNULFxyXG4gICAgICAgICAgICBtYWdGaWx0ZXI6IGdsLk5FQVJFU1QsXHJcbiAgICAgICAgICAgIGRlcHRoTW9kZTogZ2wuTFVNSU5BTkNFLFxyXG4gICAgICAgICAgICBkZXB0aENvbXBhcmVNb2RlOiBnbC5DT01QQVJFX1JfVE9fVEVYVFVSRSxcclxuICAgICAgICAgICAgZGVwdGhDb21wYXJlRnVuYzogZ2wuTEVRVUFMLFxyXG4gICAgICAgICAgICBjb2xvcnNBc1JlbmRlcmJ1ZmZlcjogZmFsc2UsXHJcbiAgICAgICAgICAgIGRlcHRoQXNSZW5kZXJidWZmZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICBzdGVuY2lsQXNSZW5kZXJidWZmZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICBpc0RlcHRoOiBmYWxzZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGl0ZW0gaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBvcHRbaXRlbV0gPSBvcHRpb25zW2l0ZW1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0O1xyXG4gICAgfSwgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5oYW5kbGUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG4gICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuaGFuZGxlKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY29sb3JUYXJnZXQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3JUYXJnZXQuaXNUZXh0dXJlKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvclRhcmdldC5oYW5kbGUuZGlzcG9zZSgpOyBlbHNlXHJcbiAgICAgICAgICAgICAgICBnbC5kZWxldGVSZW5kZXJCdWZmZXIodGhpcy5jb2xvclRhcmdldC5oYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kZXB0aFRhcmdldCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kZXB0aFRhcmdldC5pc1RleHR1cmUpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoVGFyZ2V0LmhhbmRsZS5kaXNwb3NlKCk7IGVsc2VcclxuICAgICAgICAgICAgICAgIGdsLmRlbGV0ZVJlbmRlckJ1ZmZlcih0aGlzLmRlcHRoVGFyZ2V0LmhhbmRsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN0ZW5jaWxUYXJnZXQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RlbmNpbFRhcmdldC5pc1RleHR1cmUpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZW5jaWxUYXJnZXQuaGFuZGxlLmRpc3Bvc2UoKTsgZWxzZVxyXG4gICAgICAgICAgICAgICAgZ2wuZGVsZXRlUmVuZGVyQnVmZmVyKHRoaXMuc3RlbmNpbFRhcmdldC5oYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG52YXIgR0xTY2FsZWRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoY29udGV4dCwgbWF4RGltZW5zaW9uLCBvcHQpIHtcclxuICAgIEdMUmVuZGVyVGFyZ2V0LmNhbGwodGhpcywgY29udGV4dCwgb3B0KTtcclxuICAgIHRoaXMuc2NhbGVUb01heERpbWVuc2lvbihtYXhEaW1lbnNpb24pO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoR0xTY2FsZWRSZW5kZXJUYXJnZXQsIEdMUmVuZGVyVGFyZ2V0KTtcclxuWE1MM0QuZXh0ZW5kKEdMU2NhbGVkUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSwge1xyXG4gICAgc2NhbGVUb01heERpbWVuc2lvbjogZnVuY3Rpb24gKG1heERpbWVuc2lvbikge1xyXG4gICAgICAgIHZhciBoRGlmZiA9IHRoaXMuaGVpZ2h0IC0gbWF4RGltZW5zaW9uO1xyXG4gICAgICAgIHZhciB3RGlmZiA9IHRoaXMud2lkdGggLSBtYXhEaW1lbnNpb247XHJcblxyXG4gICAgICAgIGlmIChoRGlmZiA+IDAgfHwgd0RpZmYgPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZTtcclxuICAgICAgICAgICAgaWYgKGhEaWZmID4gd0RpZmYpIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlID0gbWF4RGltZW5zaW9uIC8gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZSA9IG1heERpbWVuc2lvbiAvIHRoaXMud2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IE1hdGguZmxvb3IodGhpcy53aWR0aCAqIHNjYWxlKTtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLmZsb29yKHRoaXMuaGVpZ2h0ICogc2NhbGUpO1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dFxyXG4gICAgICogQHBhcmFtIG9wdFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAaW1wbGVtZW50cyBJUmVuZGVyVGFyZ2V0XHJcbiAgICAgKi9cclxuICAgIHZhciBHTEN1YmVNYXBSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoY29udGV4dCwgb3B0KSB7XHJcbiAgICAgICAgdmFyIGdsID0gY29udGV4dC5nbDtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHQud2lkdGggfHwgODAwO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy53aWR0aDtcclxuICAgICAgICB0aGlzLnNjYWxlID0gb3B0LnNjYWxlIHx8IDE7XHJcbiAgICAgICAgdGhpcy5vcHQgPSB0aGlzLmZpbGxPcHRpb25zKG9wdCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY3RleCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kdGV4ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN0ZXggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29sb3JUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGVwdGhUYXJnZXQgPSAgbnVsbDtcclxuICAgICAgICB0aGlzLnN0ZW5jaWxUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmdsU2lkZXMgPSBbZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLCBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWl07XHJcbiAgICAgICAgdGhpcy5mcmFtZWJ1ZmZlcnMgPSBbXTtcclxuICAgIH07XHJcblxyXG4gICAgWE1MM0QuZXh0ZW5kKEdMQ3ViZU1hcFJlbmRlclRhcmdldC5wcm90b3R5cGUsIHtcclxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U2NhbGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uIChzaWRlKSB7XHJcbiAgICAgICAgICAgIHZhciBjcmVhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZyYW1lYnVmZmVycy5sZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmFtZUJ1ZmZlcnModGhpcy5vcHQuY29sb3JGb3JtYXQsIHRoaXMub3B0LmRlcHRoRm9ybWF0LCB0aGlzLm9wdC5zdGVuY2lsRm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXJzW3NpZGVdKTtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBkZWZhdWx0IHZpZXdwb3J0XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVkICYmIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5iaW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5iaW5kKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVhdGVGcmFtZUJ1ZmZlcnM6IGZ1bmN0aW9uIChjb2xvckZvcm1hdCwgZGVwdGhGb3JtYXQsIHN0ZW5jaWxGb3JtYXQpIHtcclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG5cclxuICAgICAgICAgICAgaWYoY29sb3JGb3JtYXQpIHsgLy9UT0RPIGNoZWNrIGlmIHJlbmRlcmJ1ZmZlcnMgaW5zdGVhZCBvZiB0ZXh0dXJlcy4uLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdGV4ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUN1YmVNYXAoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3RleC5jcmVhdGVUZXgyREZyb21EYXRhKGNvbG9yRm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuUkdCQSwgdGhpcy5vcHQuY29sb3JUeXBlIHx8IGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMub3B0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JUYXJnZXQgPSB7IGhhbmRsZTogdGhpcy5jdGV4LCAgaXNUZXh0dXJlOiB0cnVlfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihkZXB0aEZvcm1hdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHQuaXNEZXB0aCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0LmRlcHRoQXNSZW5kZXJidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kdGV4ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUN1YmVNYXAoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmR0ZXguY3JlYXRlVGV4MkRGcm9tRGF0YShkZXB0aEZvcm1hdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGdsLkRFUFRIX0NPTVBPTkVOVCwgZ2wuRkxPQVQsIHRoaXMub3B0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlcHRoVGFyZ2V0ID0geyBoYW5kbGU6IHRoaXMuZHRleCwgIGlzVGV4dHVyZTogdHJ1ZX07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoc3RlbmNpbEZvcm1hdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGV4ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUN1YmVNYXAoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RleC5jcmVhdGVUZXgyREZyb21EYXRhKHN0ZW5jaWxGb3JtYXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBnbC5TVEVOQ0lMX0NPTVBPTkVOVCwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5vcHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGVuY2lsVGFyZ2V0ID0geyBoYW5kbGU6IHRoaXMuc3RleCwgaXNUZXh0dXJlOiB0cnVlfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZ2xTaWRlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZWJ1ZmZlcnNbaV0gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBjb2xvckZvcm1hdCAmJiB0aGlzLmNyZWF0ZUNvbG9yVGFyZ2V0KGNvbG9yRm9ybWF0LCBpKTtcclxuICAgICAgICAgICAgICAgIGRlcHRoRm9ybWF0ICYmIHRoaXMuY3JlYXRlRGVwdGhUYXJnZXQoZGVwdGhGb3JtYXQsIGkpO1xyXG4gICAgICAgICAgICAgICAgc3RlbmNpbEZvcm1hdCAmJiB0aGlzLmNyZWF0ZVN0ZW5jaWxUYXJnZXQoc3RlbmNpbEZvcm1hdCwgaSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU3RhdHVzKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVhdGVDb2xvclRhcmdldDogZnVuY3Rpb24gKGNvbG9yRm9ybWF0LCBzaWRlKSB7XHJcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcclxuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCB0aGlzLmdsU2lkZXNbc2lkZV0sIHRoaXMuY3RleC5oYW5kbGUsIDApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlRGVwdGhUYXJnZXQ6IGZ1bmN0aW9uIChkZXB0aEZvcm1hdCwgc2lkZSkge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHQuZGVwdGhBc1JlbmRlcmJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmR0ZXgpIHRoaXMuZHRleCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kdGV4W3NpZGVdID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5kdGV4W3NpZGVdKTtcclxuICAgICAgICAgICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBkZXB0aEZvcm1hdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHRoaXMuZHRleFtzaWRlXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVwdGhUYXJnZXQpIHRoaXMuZGVwdGhUYXJnZXQgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhUYXJnZXRbc2lkZV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlOiB0aGlzLmR0ZXhbc2lkZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUZXh0dXJlOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5UMCwgdGhpcy5nbFNpZGVzW3NpZGVdLCB0aGlzLmR0ZXguaGFuZGxlLCAwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNyZWF0ZVN0ZW5jaWxUYXJnZXQ6IGZ1bmN0aW9uIChzdGVuY2lsRm9ybWF0LCBzaWRlKSB7XHJcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcclxuXHJcbiAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5TVEVOQ0lMX0FUVEFDSE1FTlQsIHRoaXMuZ2xTaWRlc1tzaWRlXSwgdGhpcy5zdGV4LmhhbmRsZSwgMCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaGVja1N0YXR1czogZnVuY3Rpb24gKHNpZGUpIHtcclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG5cclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyc1tzaWRlXSk7XHJcbiAgICAgICAgICAgIC8vRmluYWxpemUgZnJhbWVidWZmZXIgY3JlYXRpb25cclxuICAgICAgICAgICAgdmFyIGZiU3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKGZiU3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFOlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOlxyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzpcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBcIiArIGZiU3RhdHVzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSAoZmJTdGF0dXMgPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbGxPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgICAgIHZhciBvcHQgPSB7XHJcbiAgICAgICAgICAgICAgICB3cmFwUzogZ2wuQ0xBTVBfVE9fRURHRSxcclxuICAgICAgICAgICAgICAgIHdyYXBUOiBnbC5DTEFNUF9UT19FREdFLFxyXG4gICAgICAgICAgICAgICAgbWluRmlsdGVyOiBnbC5ORUFSRVNULFxyXG4gICAgICAgICAgICAgICAgbWFnRmlsdGVyOiBnbC5ORUFSRVNULFxyXG4gICAgICAgICAgICAgICAgZGVwdGhNb2RlOiBnbC5MVU1JTkFOQ0UsXHJcbiAgICAgICAgICAgICAgICBkZXB0aENvbXBhcmVNb2RlOiBnbC5DT01QQVJFX1JfVE9fVEVYVFVSRSxcclxuICAgICAgICAgICAgICAgIGRlcHRoQ29tcGFyZUZ1bmM6IGdsLkxFUVVBTCxcclxuICAgICAgICAgICAgICAgIGNvbG9yc0FzUmVuZGVyYnVmZmVyOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGRlcHRoQXNSZW5kZXJidWZmZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc3RlbmNpbEFzUmVuZGVyYnVmZmVyOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGlzRGVwdGg6IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpdGVtIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIG9wdFtpdGVtXSA9IG9wdGlvbnNbaXRlbV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvcHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZyYW1lYnVmZmVycy5sZW5ndGggPD0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcclxuICAgICAgICAgICAgZm9yKHZhciBzaWRlIGluIHRoaXMuZnJhbWVidWZmZXJzKVxyXG4gICAgICAgICAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlcnNbc2lkZV0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3JUYXJnZXQuaGFuZGxlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvclRhcmdldC5oYW5kbGUuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlcHRoVGFyZ2V0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoVGFyZ2V0LmhhbmRsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RlbmNpbFRhcmdldCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RlbmNpbFRhcmdldC5oYW5kbGUuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZyYW1lYnVmZmVycyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBHTENhbnZhc1RhcmdldDogR0xDYW52YXNUYXJnZXQsXHJcbiAgICBHTFJlbmRlclRhcmdldDogR0xSZW5kZXJUYXJnZXQsXHJcbiAgICBHTFNjYWxlZFJlbmRlclRhcmdldDogR0xTY2FsZWRSZW5kZXJUYXJnZXQsXHJcbiAgICBHTEN1YmVNYXBSZW5kZXJUYXJnZXQ6IEdMQ3ViZU1hcFJlbmRlclRhcmdldFxyXG59O1xyXG5cclxuXHJcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xyXG52YXIgU3RhdGVNYWNoaW5lID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnRyaWIvc3RhdGUtbWFjaGluZS5qc1wiKTtcclxudmFyIFNhbXBsZXJDb25maWcgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2RhdGEuanNcIikuU2FtcGxlckNvbmZpZztcclxudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcbnZhciB1bmlxdWVPYmplY3RJZCA9IHV0aWxzLmdldFVuaXF1ZUNvdW50ZXIoKTtcclxuXHJcbi8vbm9pbnNwZWN0aW9uIEpTVmFsaWRhdGVKU0RvY1xyXG4vKipcclxuICogQHBhcmFtIHtHTENvbnRleHR9IGNvbnRleHRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgR0xUZXh0dXJlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgIFNhbXBsZXJDb25maWcuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtHTENvbnRleHR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmlkID0gdW5pcXVlT2JqZWN0SWQoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuaXQgdGhlIHRleHR1cmUgaXMgY3VycmVudGx5IGJvdW5kIHRvIChvciAtMSBpZiBib3VuZCB0byBubyB1bml0KVxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy51bml0ID0gLTE7XHJcblxyXG4gICAgdGhpcy5zZXREZWZhdWx0cygpO1xyXG5cclxuICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgdGhpcy5oYW5kbGUgPSBudWxsO1xyXG5cclxuICAgIHRoaXMudGV4dHVyZVR5cGUgPSBjb250ZXh0LmdsLlRFWFRVUkVfMkQ7XHJcblxyXG4gICAgdGhpcy50ZXh0dXJlVW5pdENhbGxiYWNrID0gdGhpcy5sb3N0VGV4dHVyZVVuaXQuYmluZCh0aGlzKTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKEdMVGV4dHVyZSwgU2FtcGxlckNvbmZpZyk7XHJcblxyXG5HTFRleHR1cmUuU3RhdGUgPSB7XHJcbiAgICBOT05FOiBcIm5vbmVcIiwgTE9BRElORzogXCJsb2FkaW5nXCIsIFJFQURZOiBcInJlYWR5XCIsIEVSUk9SOiBcImVycm9yXCJcclxufTtcclxuXHJcblxyXG52YXIgZ2V0T3JDcmVhdGVGYWxsYmFja1RleHR1cmUgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBjX2ZhbGxiYWNrVGV4dHVyZSA9IG51bGw7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKCFjX2ZhbGxiYWNrVGV4dHVyZSkge1xyXG4gICAgICAgICAgICBjX2ZhbGxiYWNrVGV4dHVyZSA9IG5ldyBHTFRleHR1cmUoY29udGV4dCk7XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gMTY7XHJcbiAgICAgICAgICAgIHZhciB0ZXhlbHMgPSBuZXcgVWludDhBcnJheShzaXplICogc2l6ZSAqIDMpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleGVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGV4ZWxzW2ldID0gMTI4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNfZmFsbGJhY2tUZXh0dXJlLmNyZWF0ZVRleDJERnJvbURhdGEoV2ViR0xSZW5kZXJpbmdDb250ZXh0LlJHQiwgc2l6ZSwgc2l6ZSwgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlJHQiwgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0JZVEUsIHtcclxuICAgICAgICAgICAgICAgIHRleGVsczogdGV4ZWxzLCB3cmFwUzogV2ViR0xSZW5kZXJpbmdDb250ZXh0LlJFUEVBVCwgd3JhcFQ6IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5SRVBFQVQsIG1pbkZpbHRlcjogV2ViR0xSZW5kZXJpbmdDb250ZXh0LkxJTkVBUiwgbWFnRmlsdGVyOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuTElORUFSXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY19mYWxsYmFja1RleHR1cmU7XHJcbiAgICB9XHJcbn0oKSk7XHJcblxyXG52YXIgaXNQb3dlck9mVHdvID0gZnVuY3Rpb24gKGRpbWVuc2lvbikge1xyXG4gICAgcmV0dXJuIChkaW1lbnNpb24gJiAoZGltZW5zaW9uIC0gMSkpID09IDA7XHJcbn07XHJcbnZhciBuZXh0SGlnaGVzdFBvd2VyT2ZUd28gPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgLS14O1xyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCAzMjsgaSA8PD0gMSkge1xyXG4gICAgICAgIHggPSB4IHwgeCA+PiBpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHggKyAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNjYWxlIHVwIHRoZSB0ZXh0dXJlIHRvIHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgdHdvIGRpbWVuc2lvbnMuXHJcbiAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH1cclxuICovXHJcbnZhciBzY2FsZUltYWdlID0gZnVuY3Rpb24gKGltYWdlLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICBjYW52YXMud2lkdGggPSBuZXh0SGlnaGVzdFBvd2VyT2ZUd28od2lkdGgpO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IG5leHRIaWdoZXN0UG93ZXJPZlR3byhoZWlnaHQpO1xyXG5cclxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgIGlmIChpbWFnZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgIHRtcENhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRtcENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdmFyIHRtcENvbnRleHQgPSB0bXBDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICAgIHZhciBpbWFnZURhdGEgPSB0bXBDb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICBpbWFnZURhdGEuZGF0YS5zZXQoaW1hZ2UuZGF0YSk7XHJcbiAgICAgICAgdG1wQ29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcclxuXHJcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodG1wQ2FudmFzLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjYW52YXM7XHJcbn07XHJcblxyXG52YXIgZ2xUZXh0dXJlRm9ybWF0RnJvbVhmbG93ID0gZnVuY3Rpb24gKGZvcm1hdCwgZ2wpIHtcclxuICAgIHN3aXRjaCAoZm9ybWF0KSB7XHJcbiAgICAgICAgY2FzZSBYQy5URVhUVVJFX0ZPUk1BVC5BTFBIQTpcclxuICAgICAgICAgICAgcmV0dXJuIGdsLkFMUEhBO1xyXG4gICAgICAgIGNhc2UgWEMuVEVYVFVSRV9GT1JNQVQuUkdCOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2wuUkdCO1xyXG4gICAgICAgIGNhc2UgWEMuVEVYVFVSRV9GT1JNQVQuUkdCQTpcclxuICAgICAgICAgICAgcmV0dXJuIGdsLlJHQkE7XHJcbiAgICAgICAgY2FzZSBYQy5URVhUVVJFX0ZPUk1BVC5MVU1JTkFOQ0U6XHJcbiAgICAgICAgICAgIHJldHVybiBnbC5MVU1JTkFOQ0U7XHJcbiAgICAgICAgY2FzZSBYQy5URVhUVVJFX0ZPUk1BVC5MVU1JTkFOQ0VfQUxQSEE6XHJcbiAgICAgICAgICAgIHJldHVybiBnbC5MVU1JTkFOQ0VfQUxQSEE7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgVGV4dHVyZSBGb3JtYXQhXCIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIGdsVGV4dHVyZVR5cGVGcm9tWGZsb3cgPSBmdW5jdGlvbiAodHlwZSwgZ2wpIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgWEMuVEVYVFVSRV9UWVBFLkZMT0FUOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2wuRkxPQVQ7XHJcbiAgICAgICAgY2FzZSBYQy5URVhUVVJFX1RZUEUuVUJZVEU6XHJcbiAgICAgICAgICAgIHJldHVybiBnbC5VTlNJR05FRF9CWVRFO1xyXG4gICAgICAgIGNhc2UgWEMuVEVYVFVSRV9UWVBFLlVTSE9SVF80XzRfNF80OlxyXG4gICAgICAgICAgICByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNDtcclxuICAgICAgICBjYXNlIFhDLlRFWFRVUkVfVFlQRS5VU0hPUlRfNV81XzVfMTpcclxuICAgICAgICAgICAgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XHJcbiAgICAgICAgY2FzZSBYQy5URVhUVVJFX1RZUEUuVVNIT1JUXzVfNl81OlxyXG4gICAgICAgICAgICByZXR1cm4gZ2wuR0xfVU5TSUdORURfU0hPUlRfNV82XzU7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgVGV4dHVyZSBUeXBlIVwiKTtcclxuICAgIH1cclxufTtcclxuXHJcblhNTDNELmV4dGVuZChHTFRleHR1cmUucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7WGZsb3cuVGV4dHVyZUVudHJ5fSB0ZXh0dXJlRW50cnlcclxuICAgICAqL1xyXG4gICAgdXBkYXRlRnJvbVRleHR1cmVFbnRyeTogZnVuY3Rpb24gKHRleHR1cmVFbnRyeSkge1xyXG4gICAgICAgIGlmICghdGV4dHVyZUVudHJ5LmlzTG9hZGluZygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KHRleHR1cmVFbnRyeS5nZXRTYW1wbGVyQ29uZmlnKCkpO1xyXG4gICAgICAgICAgICB2YXIgaW1nID0gdGV4dHVyZUVudHJ5LmFzR0xUZXh0dXJlVmFsdWUoKTtcclxuICAgICAgICAgICAgaWYgKCFpbWcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsZWQoKTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVPclVwZGF0ZVRleHR1cmUoaW1nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgLyoqXHJcbiAgICAgKiBXZSBuZWVkIHRvIHNjYWxlIHRleHR1cmUgd2hlbiBvbmUgb2YgdGhlIHdyYXAgbW9kZXMgaXMgbm90IENMQU1QX1RPX0VER0UgYW5kXHJcbiAgICAgKiBvbmUgb2YgdGhlIHRleHR1cmUgZGltZW5zaW9ucyBpcyBub3QgcG93ZXIgb2YgdHdvLlxyXG4gICAgICogT3RoZXJ3aXNlIHJlbmRlcmVkIHRleHR1cmUgd2lsbCBiZSBqdXN0IGJsYWNrLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgbmVlZHNTY2FsZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZ2VuZXJhdGVNaXBNYXAgfHwgdGhpcy53cmFwUyAhPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSB8fCB0aGlzLndyYXBUICE9IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKSAmJiAoIWlzUG93ZXJPZlR3byh3aWR0aCkgfHwgIWlzUG93ZXJPZlR3byhoZWlnaHQpKVxyXG4gICAgfSxcclxuXHJcblxyXG4gICAgX2JpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgdmFyIHRleHR1cmVNYW5hZ2VyID0gdGhpcy5jb250ZXh0LnRleHR1cmVNYW5hZ2VyO1xyXG4gICAgICAgIHZhciB1bml0ID0gdGhpcy51bml0ID0gdGV4dHVyZU1hbmFnZXIuYmluZCh0aGlzLmlkLCB7IGRpc3Bvc2U6IHRoaXMudGV4dHVyZVVuaXRDYWxsYmFjayB9KTtcclxuICAgICAgICBpZiAodW5pdCA9PSAtMikge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkFsbCBhdmFpbGFibGUgdGV4dHVyZSB1bml0cyBhcmUgZnVsbC5cIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShXZWJHTFJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTAgKyB1bml0KTtcclxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUodGhpcy50ZXh0dXJlVHlwZSwgdGhpcy5oYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5pdDtcclxuICAgIH0sXHJcblxyXG4gICAgdW5iaW5kOiBmdW5jdGlvbiAodW5pdCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcsIHRleHR1cmUgbWFuYWdlciB3aWxsIGhhbmRsZSB0aGlzXHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgdmFyIHRleHR1cmVNYW5hZ2VyID0gdGhpcy5jb250ZXh0LnRleHR1cmVNYW5hZ2VyO1xyXG4gICAgICAgIHRleHR1cmVNYW5hZ2VyLmRpc3Bvc2UodGhpcy5pZCk7XHJcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLmhhbmRsZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNhbkJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50ID09IEdMVGV4dHVyZS5TdGF0ZS5SRUFEWTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlT3JVcGRhdGVUZXh0dXJlOiBmdW5jdGlvbiAodGV4ZWxTb3VyY2UpIHtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmhhbmRsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZSA9IHRoaXMuY29udGV4dC5nbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmVGcm9tRGF0YSh0ZXhlbFNvdXJjZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVRleHR1cmVGcm9tRGF0YTogZnVuY3Rpb24gKHRleGVsU291cmNlKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG4gICAgICAgIHRoaXMuX2JpbmQoKTtcclxuXHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX1dSQVBfUywgdGhpcy53cmFwUyk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX1dSQVBfVCwgdGhpcy53cmFwVCk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMubWluRmlsdGVyKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4dHVyZVR5cGUsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5tYWdGaWx0ZXIpO1xyXG5cclxuICAgICAgICB2YXIgdHlwZSA9IGdsVGV4dHVyZVR5cGVGcm9tWGZsb3codGV4ZWxTb3VyY2UudGV4ZWxUeXBlLCBnbCk7XHJcbiAgICAgICAgdmFyIGZvcm1hdCA9IGdsVGV4dHVyZUZvcm1hdEZyb21YZmxvdyh0ZXhlbFNvdXJjZS50ZXhlbEZvcm1hdCwgZ2wpO1xyXG5cclxuICAgICAgICB2YXIgd2lkdGggPSB0ZXhlbFNvdXJjZS53aWR0aDtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRleGVsU291cmNlLmhlaWdodDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdGVNaXBNYXAgJiYgdGhpcy5uZWVkc1NjYWxlKHdpZHRoLCBoZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBnbC5GTE9BVClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBnZW5lcmF0ZSBNaXBNYXBzIGJ1dCB0ZXh0dXJlIGRhdGEgaXMgZmxvYXQgYW5kIG5vdCBwb3dlciBvZiB0d28gaW4gc2l6ZSFcIik7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRleGVsU291cmNlID0gc2NhbGVJbWFnZSh0ZXhlbFNvdXJjZSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGV4ZWxTb3VyY2UgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgZm9ybWF0LCB0eXBlLCB0ZXhlbFNvdXJjZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRleGVsU291cmNlLmRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2ViR0wgZG9lcyBub3Qgc3VwcG9ydCBVaW50OENsYW1wZWRBcnJheSwgd2hpY2ggaXMgKGNvcnJlY3RseSkgdXNlZCBieSBhc3luYy4gWGZsb3cuIFdlIGp1c3QgYnVpbGQgYSBuZXcgdmlld1xyXG4gICAgICAgICAgICAgICAgLy8gb24gdG9wIG9mIHRoZSB1bmRlcmx5aW5nIGFycmF5IGJ1ZmZlciB3aGljaCBzaG91bGQgYmUgcmVsYXRpdmVseSBmYXN0XHJcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBuZXcgVWludDhBcnJheSh0ZXhlbFNvdXJjZS5kYXRhLmJ1ZmZlcikpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdHlwZSwgdGV4ZWxTb3VyY2UuZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmdlbmVyYXRlTWlwTWFwKVxyXG4gICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcCh0aGlzLnRleHR1cmVUeXBlKTtcclxuXHJcbiAgICAgICAgdGhpcy5jcmVhdGVkKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVRleDJERnJvbURhdGE6IGZ1bmN0aW9uIChpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgc291cmNlRm9ybWF0LCBzb3VyY2VUeXBlLCBvcHQpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcblxyXG4gICAgICAgIHZhciBvcHQgPSBvcHQgfHwge307XHJcbiAgICAgICAgdmFyIHRleGVscyA9IG9wdC50ZXhlbHM7XHJcblxyXG4gICAgICAgIGlmICghdGV4ZWxzKSB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VUeXBlID09IGdsLkZMT0FUKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXhlbHMgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLmhhbmRsZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICB0aGlzLl9iaW5kKCk7XHJcblxyXG4gICAgICAgIC8vIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9XUkFQX1MsIG9wdC53cmFwUyk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX1dSQVBfVCwgb3B0LndyYXBUKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4dHVyZVR5cGUsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgb3B0Lm1pbkZpbHRlcik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX01BR19GSUxURVIsIG9wdC5tYWdGaWx0ZXIpO1xyXG5cclxuICAgICAgICBpZiAoIW9wdC5pc0RlcHRoKSB7XHJcbiAgICAgICAgICAgIGlmICh0ZXhlbHMgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgc291cmNlRm9ybWF0LCBzb3VyY2VUeXBlLCBuZXcgVWludDhBcnJheSh0ZXhlbHMuYnVmZmVyKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBzb3VyY2VGb3JtYXQsIHNvdXJjZVR5cGUsIHRleGVscyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBzb3VyY2VGb3JtYXQsIHNvdXJjZVR5cGUsIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdC5nZW5lcmF0ZU1pcG1hcCkge1xyXG4gICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcCh0aGlzLnRleHR1cmVUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jcmVhdGVkKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGxvc3RUZXh0dXJlVW5pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy51bml0ID0gLTE7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcblN0YXRlTWFjaGluZS5jcmVhdGUoe1xyXG4gICAgdGFyZ2V0OiBHTFRleHR1cmUucHJvdG90eXBlLFxyXG4gICAgaW5pdGlhbDogR0xUZXh0dXJlLlN0YXRlLk5PTkUsXHJcbiAgICBldmVudHM6IFt7bmFtZTogJ2NyZWF0ZWQnLCBmcm9tOiAnKicsIHRvOiBHTFRleHR1cmUuU3RhdGUuUkVBRFl9LCB7XHJcbiAgICAgICAgbmFtZTogJ2ZhaWxlZCcsIGZyb206ICcqJywgdG86IEdMVGV4dHVyZS5TdGF0ZS5FUlJPUlxyXG4gICAgfSwge25hbWU6ICdsb2FkcycsIGZyb206ICcqJywgdG86IEdMVGV4dHVyZS5TdGF0ZS5MT0FESU5HfV1cclxufSk7XHJcblxyXG4vL25vaW5zcGVjdGlvbiBKU1ZhbGlkYXRlSlNEb2NcclxuLyoqXHJcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEdMQ3ViZU1hcCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICBHTFRleHR1cmUuY2FsbCh0aGlzLCBjb250ZXh0LCBjb250ZXh0LmdsLlRFWFRVUkVfQ1VCRV9NQVApO1xyXG4gICAgdmFyIGdsID0gY29udGV4dC5nbDtcclxuICAgIHRoaXMudGV4dHVyZVR5cGUgPSBjb250ZXh0LmdsLlRFWFRVUkVfQ1VCRV9NQVA7XHJcbiAgICB0aGlzLmdsU2lkZXMgPSBbZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLCBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gsIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZLCBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWl07XHJcblxyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhHTEN1YmVNYXAsIEdMVGV4dHVyZSwge1xyXG4gICAgdXBkYXRlVGV4dHVyZUZyb21EYXRhOiBmdW5jdGlvbiAodGV4ZWxTb3VyY2UpIHtcclxuICAgICAgICBkZWJ1Zy5sb2coXCJ1cGRhdGVUZXh0dXJlRnJvbURhdGEgbm90IGltcGxlbWVudGVkIGZvciBDdWJlTWFwcGluZyFcIik7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVRleDJERnJvbURhdGE6IGZ1bmN0aW9uIChpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgc291cmNlRm9ybWF0LCBzb3VyY2VUeXBlLCBvcHQpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcblxyXG4gICAgICAgIHZhciBvcHQgPSBvcHQgfHwge307XHJcbiAgICAgICAgdmFyIHRleGVscyA9IG9wdC50ZXhlbHM7XHJcblxyXG4gICAgICAgIGlmICghdGV4ZWxzKSB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VUeXBlID09IGdsLkZMT0FUKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXhlbHMgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLmhhbmRsZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICB0aGlzLl9iaW5kKCk7XHJcblxyXG4gICAgICAgIC8vIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9XUkFQX1MsIG9wdC53cmFwUyk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX1dSQVBfVCwgb3B0LndyYXBUKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4dHVyZVR5cGUsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgb3B0Lm1pbkZpbHRlcik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX01BR19GSUxURVIsIG9wdC5tYWdGaWx0ZXIpO1xyXG5cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5nbFNpZGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghb3B0LmlzRGVwdGgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXhlbHMgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQodGhpcy5nbFNpZGVzW2ldLCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgc291cmNlRm9ybWF0LCBzb3VyY2VUeXBlLCBuZXcgVWludDhBcnJheSh0ZXhlbHMuYnVmZmVyKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQodGhpcy5nbFNpZGVzW2ldLCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgc291cmNlRm9ybWF0LCBzb3VyY2VUeXBlLCB0ZXhlbHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRCh0aGlzLmdsU2lkZXNbaV0sIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBzb3VyY2VGb3JtYXQsIHNvdXJjZVR5cGUsIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0LmdlbmVyYXRlTWlwbWFwKSB7XHJcbiAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRoaXMudGV4dHVyZVR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNyZWF0ZWQoKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5HTEN1YmVNYXAuU3RhdGUgPSB7XHJcbiAgICBOT05FOiBcIm5vbmVcIiwgTE9BRElORzogXCJsb2FkaW5nXCIsIFJFQURZOiBcInJlYWR5XCIsIEVSUk9SOiBcImVycm9yXCJcclxufTtcclxuXHJcblN0YXRlTWFjaGluZS5jcmVhdGUoe1xyXG4gICAgdGFyZ2V0OiBHTEN1YmVNYXAucHJvdG90eXBlLFxyXG4gICAgaW5pdGlhbDogR0xDdWJlTWFwLlN0YXRlLk5PTkUsXHJcbiAgICBldmVudHM6IFt7bmFtZTogJ2NyZWF0ZWQnLCBmcm9tOiAnKicsIHRvOiBHTEN1YmVNYXAuU3RhdGUuUkVBRFl9LCB7XHJcbiAgICAgICAgbmFtZTogJ2ZhaWxlZCcsIGZyb206ICcqJywgdG86IEdMQ3ViZU1hcC5TdGF0ZS5FUlJPUlxyXG4gICAgfSwge25hbWU6ICdsb2FkcycsIGZyb206ICcqJywgdG86IEdMQ3ViZU1hcC5TdGF0ZS5MT0FESU5HfV1cclxufSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBHTFRleHR1cmU6IEdMVGV4dHVyZSxcclxuICAgIEdMQ3ViZU1hcDogR0xDdWJlTWFwXHJcbn07XHJcblxyXG5cclxuIiwicmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL2FycmF5LmpzXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCB1bmlmb3JtcyBmb3IgYWN0aXZlIHByb2dyYW1cclxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxyXG4gICAgICogQHBhcmFtIHVcclxuICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdHJhbnNwb3NlZFxyXG4gICAgICovXHJcbiAgICBzZXRVbmlmb3JtOiBmdW5jdGlvbiAoZ2wsIHUsIHZhbHVlLCB0cmFuc3Bvc2VkKSB7XHJcblxyXG4gICAgICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xyXG4gICAgICAgIHN3aXRjaCAodS5nbFR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAzNTY3MDogLy9nbC5CT09MXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gYSBVbml0OEFycmF5IGludG8gYSBKUyBBcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaXYodS5sb2NhdGlvbiwgQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHZhbHVlLCBmdW5jdGlvbih2KSB7IHJldHVybiB2OyB9KSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSh1LmxvY2F0aW9uLCB2YWx1ZSB8fCAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDUxMjQ6ICAvL2dsLklOVFxyXG4gICAgICAgICAgICBjYXNlIDM1Njc4OiAvL2dsLlNBTVBMRVJfMkRcclxuICAgICAgICAgICAgY2FzZSAzNTY4MDogLy9nbC5TQU1QTEVSX0NVQkVcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaXYodS5sb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkodS5sb2NhdGlvbiwgdmFsdWUgfHwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMzU2NzE6IC8vIGdsLkJPT0xfVkVDMlxyXG4gICAgICAgICAgICBjYXNlIDM1NjY3OlxyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJpdih1LmxvY2F0aW9uLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gZ2wuSU5UX1ZFQzJcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMzU2NzI6IC8vIGdsLkJPT0xfVkVDM1xyXG4gICAgICAgICAgICBjYXNlIDM1NjY4OlxyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNpdih1LmxvY2F0aW9uLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gZ2wuSU5UX1ZFQzNcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMzU2NzM6IC8vIGdsLkJPT0xfVkVDNFxyXG4gICAgICAgICAgICBjYXNlIDM1NjY5OlxyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRpdih1LmxvY2F0aW9uLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gZ2wuSU5UX1ZFQzRcclxuXHJcbiAgICAgICAgICAgIGNhc2UgNTEyNjpcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWZ2KHUubG9jYXRpb24sIHZhbHVlKTsgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZih1LmxvY2F0aW9uLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gZ2wuRkxPQVRcclxuICAgICAgICAgICAgY2FzZSAzNTY2NDpcclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZnYodS5sb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIGdsLkZMT0FUX1ZFQzJcclxuICAgICAgICAgICAgY2FzZSAzNTY2NTpcclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYodS5sb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIGdsLkZMT0FUX1ZFQzNcclxuICAgICAgICAgICAgY2FzZSAzNTY2NjpcclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00ZnYodS5sb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIGdsLkZMT0FUX1ZFQzRcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMzU2NzQ6XHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KHUubG9jYXRpb24sIHRyYW5zcG9zZWQgfHwgZmFsc2UsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrOy8vIGdsLkZMT0FUX01BVDJcclxuICAgICAgICAgICAgY2FzZSAzNTY3NTpcclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodS5sb2NhdGlvbiwgdHJhbnNwb3NlZCB8fCBmYWxzZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7Ly8gZ2wuRkxPQVRfTUFUM1xyXG4gICAgICAgICAgICBjYXNlIDM1Njc2OlxyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih1LmxvY2F0aW9uLCB0cmFuc3Bvc2VkIHx8IGZhbHNlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhazsvLyBnbC5GTE9BVF9NQVQ0XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJVbmtub3duIHVuaWZvcm0gdHlwZSBcIiArIHUuZ2xUeXBlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VW5pcXVlQ291bnRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjX2NvdW50ZXIgPSAwO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjX2NvdW50ZXIrKztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNoZWNrRXJyb3I6IGZ1bmN0aW9uIChnbCwgdGV4dCkge1xyXG4gICAgICAgIHZhciBlcnJvciA9IGdsLmdldEVycm9yKCk7XHJcbiAgICAgICAgaWYgKGVycm9yICE9PSBnbC5OT19FUlJPUikge1xyXG4gICAgICAgICAgICB2YXIgdGV4dEVyciA9IFwiXCIgKyBlcnJvcjtcclxuICAgICAgICAgICAgc3dpdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMjgwOlxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRFcnIgPSBcIjEyODAgKCBHTF9JTlZBTElEX0VOVU0gKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMjgxOlxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRFcnIgPSBcIjEyODEgKCBHTF9JTlZBTElEX1ZBTFVFIClcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTI4MjpcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0RXJyID0gXCIxMjgyICggR0xfSU5WQUxJRF9PUEVSQVRJT04gKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMjgzOlxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRFcnIgPSBcIjEyODMgKCBHTF9TVEFDS19PVkVSRkxPVyApXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEyODQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVyciA9IFwiMTI4NCAoIEdMX1NUQUNLX1VOREVSRkxPVyApXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEyODU6XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVyciA9IFwiMTI4NSAoIEdMX09VVF9PRl9NRU1PUlkgKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSBcIkdMIGVycm9yIFwiICsgdGV4dEVyciArIFwiIG9jY3VyZWQuXCI7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0ICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBtc2cgKz0gXCIgXCIgKyB0ZXh0O1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy50cmFjZShtc2cpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc3VwcG9ydGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuICEhKHdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQgJiYgKGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKSkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4iLCJ2YXIgQWJzdHJhY3RDYW52YXNIYW5kbGVyID0gcmVxdWlyZShcIi4uL3JlbmRlcmVyL2NhbnZhcy1oYW5kbGVyLmpzXCIpO1xyXG52YXIgT3B0aW9ucyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9vcHRpb25zLmpzXCIpO1xyXG52YXIgeG1sM2RGb3JtYXRIYW5kbGVyID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvZm9ybWF0aGFuZGxlci5qc1wiKS54bWwzZEZvcm1hdEhhbmRsZXI7XHJcblxyXG52YXIgTUFYRlBTID0gMzA7XHJcblxyXG52YXIgT1BUSU9OX0NPTlRJTlVPVVMgPSBcInJlbmRlcmVyLWNvbnRpbnVvdXNcIjtcclxuT3B0aW9ucy5yZWdpc3RlcihPUFRJT05fQ09OVElOVU9VUywgZmFsc2UpO1xyXG5cclxuLyoqXHJcbiAqIEdMQ2FudmFzSGFuZGxlciBjbGFzcy5cclxuICogUmVnaXN0ZXJzIGFuZCBoYW5kbGVzIHRoZSBldmVudHMgdGhhdCBoYXBwZW4gb24gdGhlIGNhbnZhcyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0geG1sM2RFbGVtXHJcbiAqICAgICAgICAgICAgdGhlIHJvb3QgeG1sM2Qgbm9kZSwgY29udGFpbmluZyB0aGUgWE1MM0Qgc2NlbmUgc3RydWN0dXJlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdENhbnZhc0hhbmRsZXJcclxuICovXHJcbmZ1bmN0aW9uIEdMQ2FudmFzSGFuZGxlcih4bWwzZEVsZW0sIGNhbnZhcykge1xyXG4gICAgQWJzdHJhY3RDYW52YXNIYW5kbGVyLmNhbGwodGhpcywgeG1sM2RFbGVtLCBjYW52YXMpO1xyXG4gICAgdGhpcy5yZW5kZXJJbnRlcmZhY2UgPSB7fTtcclxuXHJcbiAgICB0aGlzLmxhc3RQaWNrT2JqID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmxhc3RLbm93bkRpbWVuc2lvbnMgPSB7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0fTtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG59XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhHTENhbnZhc0hhbmRsZXIsIEFic3RyYWN0Q2FudmFzSGFuZGxlcik7XHJcblxyXG5HTENhbnZhc0hhbmRsZXIucHJvdG90eXBlLnNldFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyKSB7XHJcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcbn07XHJcblxyXG5HTENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgdGhpcy5jb25maWd1cmVDYW52YXMoKTtcclxuXHJcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhdCByZWd1bGFyIGludGVydmFscyBieSByZXF1ZXN0QW5pbUZyYW1lIHRvXHJcbiAgICAvLyBkZXRlcm1pbmUgaWYgYSByZWRyYXdcclxuICAgIC8vIGlzIG5lZWRlZFxyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy50aWNrID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBpZighdGhhdC5yZW5kZXJlcilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBYTUwzRC51cGRhdGVYZmxvd09ic2VydmVyKCk7XHJcbiAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGF0LmNhbnZhc1NpemVDaGFuZ2VkKCkgfHwgdGhhdC5yZW5kZXJlci5uZWVkc1JlZHJhdygpIHx8IE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX0NPTlRJTlVPVVMpKSB7XHJcbiAgICAgICAgICAgIHRoYXQuZGlzcGF0Y2hVcGRhdGVFdmVudCgpO1xyXG4gICAgICAgICAgICB0aGF0LmRyYXcoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbUZyYW1lKHRoYXQudGljaywgTUFYRlBTKTtcclxuICAgIH07XHJcblxyXG4gICAgICAvLyBCbG9jayB0aGUgcmlnaHQtY2xpY2sgY29udGV4dCBtZW51IG9uIHRoZSBjYW52YXMgdW5sZXNzIGl0J3MgZXhwbGljaXRseSB0b2dnbGVkXHJcbiAgICB2YXIgY20gPSB0aGlzLl94bWwzZEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGV4dG1lbnVcIik7XHJcbiAgICBpZiAoIWNtIHx8IGNtID09IFwiZmFsc2VcIikge1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuR0xDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5jb25maWd1cmVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgeG1sM2RFbGVtZW50ID0gdGhpcy5feG1sM2RFbGVtZW50O1xyXG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcclxuXHJcbiAgICB2YXIgcGFyZW50ID0geG1sM2RFbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgICAvLyBQbGFjZSB4bWwzZEVsZW1lbnQgaW5zaWRlIGFuIGludmlzYmxlIGRpdlxyXG4gICAgdmFyIGhpZGVEaXYgPSBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGhpZGVEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShoaWRlRGl2LCB4bWwzZEVsZW1lbnQpO1xyXG4gICAgaGlkZURpdi5hcHBlbmRDaGlsZCh4bWwzZEVsZW1lbnQpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBjYW52YXMgYW5kIGFwcGVuZCBpdCB3aGVyZSB0aGUgeG1sM2QgZWxlbWVudCB3YXMgYmVmb3JlXHJcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNhbnZhcywgaGlkZURpdik7XHJcblxyXG4gICAgdmFyIHN0eWxlID0gY2FudmFzLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh4bWwzZEVsZW1lbnQpO1xyXG4gICAgaWYgKCFjYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yKSB7XHJcbiAgICAgICAgdmFyIGJnY29sb3IgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiYmFja2dyb3VuZC1jb2xvclwiKTtcclxuICAgICAgICBpZiAoYmdjb2xvciAmJiBiZ2NvbG9yICE9IFwidHJhbnNwYXJlbnRcIilcclxuICAgICAgICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGJnY29sb3I7XHJcbiAgICB9XHJcbiAgICAvLyBOZWVkIHRvIGJlIHNldCBmb3IgY29ycmVjdCBjYW52YXMgc2l6ZVxyXG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XHJcblxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCaW5kcyB0aGUgcGlja2luZyBidWZmZXIgYW5kIHBhc3NlcyB0aGUgcmVxdWVzdCBmb3IgYSBwaWNraW5nIHBhc3MgdG8gdGhlXHJcbiAqIHJlbmRlcmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNYXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNZXHJcbiAqIEByZXR1cm4ge0RyYXdhYmxlfG51bGx9IG5ld2x5IHBpY2tlZCBvYmplY3RcclxuICovXHJcbkdMQ2FudmFzSGFuZGxlci5wcm90b3R5cGUuZ2V0UGlja09iamVjdEJ5UG9pbnQgPSBmdW5jdGlvbiAoY2FudmFzWCwgY2FudmFzWSkge1xyXG4gICAgLy8gVE9ET1xyXG4gICAgLy9pZiAoIXRoaXMucmVuZGVyT3B0aW9ucy5waWNraW5nRW5hYmxlZClcclxuICAgIC8vICAgIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0UmVuZGVyT2JqZWN0RnJvbVBpY2tpbmdCdWZmZXIoY2FudmFzWCwgY2FudmFzWSk7XHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICogQHJldHVybnMge0hUTUxFbGVtZW50fVxyXG4gKi9cclxuR0xDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5nZXRQaWNrZWRPYmplY3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBpY2tlZE9iamVjdCA/IHRoaXMucmVuZGVyZXIucGlja2VkT2JqZWN0Lm5vZGUgOiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNYXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNZXHJcbiAqIEByZXR1cm4ge3ZlYzN8bnVsbH0gVGhlIHdvcmxkIHNwYWNlIG5vcm1hbCBvbiB0aGUgb2JqZWN0J3Mgc3VyZmFjZSBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXNcclxuICovXHJcbkdMQ2FudmFzSGFuZGxlci5wcm90b3R5cGUuZ2V0V29ybGRTcGFjZU5vcm1hbEJ5UG9pbnQgPSBmdW5jdGlvbiAoY2FudmFzWCwgY2FudmFzWSkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0V29ybGRTcGFjZU5vcm1hbEJ5UG9pbnQoY2FudmFzWCwgY2FudmFzWSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IGNhbnZhc1hcclxuICogQHBhcmFtIHtudW1iZXJ9IGNhbnZhc1lcclxuICogQHJldHVybiB7dmVjM3xudWxsfSBUaGUgd29ybGQgc3BhY2UgcG9zaXRpb24gb24gdGhlIG9iamVjdCdzIHN1cmZhY2UgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzXHJcbiAqL1xyXG5HTENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmdldFdvcmxkU3BhY2VQb3NpdGlvbkJ5UG9pbnQgPSBmdW5jdGlvbiAoY2FudmFzWCwgY2FudmFzWSkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0V29ybGRTcGFjZVBvc2l0aW9uQnlQb2ludChjYW52YXNYLCBjYW52YXNZKTtcclxufTtcclxuXHJcbkdMQ2FudmFzSGFuZGxlci5wcm90b3R5cGUuY2FudmFzU2l6ZUNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xyXG4gICAgaWYgKGNhbnZhcy5jbGllbnRXaWR0aCAhPT0gdGhpcy5sYXN0S25vd25EaW1lbnNpb25zLndpZHRoIHx8IGNhbnZhcy5jbGllbnRIZWlnaHQgIT09IHRoaXMubGFzdEtub3duRGltZW5zaW9ucy5oZWlnaHQpIHtcclxuXHJcbiAgICAgICAgdGhpcy5sYXN0S25vd25EaW1lbnNpb25zLndpZHRoID0gY2FudmFzLndpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xyXG4gICAgICAgIHRoaXMubGFzdEtub3duRGltZW5zaW9ucy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmhhbmRsZVJlc2l6ZUV2ZW50KGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaFJlc2l6ZUV2ZW50KHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHR9KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbnZhciBjX3RpbWVyID0gd2luZG93LnBlcmZvcm1hbmNlIHx8IERhdGU7XHJcblxyXG4vKipcclxuICogQ2FsbGVkIGJ5IHRpY2soKSB0byByZWRyYXcgdGhlIHNjZW5lIGlmIG5lZWRlZFxyXG4gKi9cclxuR0xDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IGNfdGltZXIubm93KCk7XHJcbiAgICAgICAgdmFyIHN0YXRzID0gdGhpcy5yZW5kZXJlci5yZW5kZXJUb0NhbnZhcygpO1xyXG4gICAgICAgIHZhciBlbmQgPSBjX3RpbWVyLm5vdygpO1xyXG5cclxuXHJcbiAgICAgICAgdmFyIGZhY3RvcnkgPSB4bWwzZEZvcm1hdEhhbmRsZXIuZ2V0RmFjdG9yeShcIndlYmdsXCIsIHRoaXMuaWQpO1xyXG4gICAgICAgIHZhciB4bWwzZEFkYXB0ZXIgPSBmYWN0b3J5LmdldEFkYXB0ZXIodGhpcy5feG1sM2RFbGVtZW50KTtcclxuICAgICAgICB4bWwzZEFkYXB0ZXIub25GcmFtZURyYXduKCk7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEZyYW1lRHJhd25FdmVudChzdGFydCwgZW5kLCBzdGF0cyk7XHJcblxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0V4Y2VwdGlvbihlKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5HTENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmdldE1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICB2YXIgcmN0ID0gdGhpcy5fY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiAoZXZ0LmNsaWVudFggLSByY3QubGVmdCksIHk6IChldnQuY2xpZW50WSAtIHJjdC50b3ApXHJcbiAgICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAgR0xDYW52YXNIYW5kbGVyO1xyXG5cclxuIiwidmFyIEdMUHJvZ3JhbU9iamVjdCA9IHJlcXVpcmUoXCIuLi9iYXNlL3Byb2dyYW0uanNcIik7XHJcbnZhciBYZmxvd1V0aWxzPSByZXF1aXJlKFwiLi4veGZsb3cvdXRpbHMuanNcIik7XHJcblxyXG4vKipcclxuICogQSBTaGFkZXJDbG9zdXJlIGNvbm5lY3RzIGEgbWVzaC1zcGVjaWZpYyBHTFByb2dyYW0gd2l0aCBpdCdzIFhmbG93IGRhdGFcclxuICogQHBhcmFtIHtHTENvbnRleHR9IGNvbnRleHRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgQWJzdHJhY3RTaGFkZXJDbG9zdXJlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHTFByb2dyYW1PYmplY3R8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAvKipcclxuICAgICAqIEEgZmxhZyB1c2VkIGJ5IHNoYWRlcmNvbXBvc2VyIHRvIHNvcnQgb3V0IG9ic29sZXRlIHNoYWRlcmNsb3N1cmVzXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vYnNvbGV0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5pZCA9IFwiXCI7XHJcblxyXG4gICAgdGhpcy51bmlmb3JtQ29sbGVjdGlvbiA9IHtcclxuICAgICAgICBlbnZCYXNlOiB7fSwgZW52T3ZlcnJpZGU6IG51bGwsIHN5c0Jhc2U6IG51bGxcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9yZXMsIGlmIHRoZSB1bmRlcmx5aW5nIHNoYWRlciBoYXMgc2VtaS10cmFuc3BhcmVuY2llc1xyXG4gICAgICogYW5kIHRodXMgbmVlZHMgdG8gY29uc2lkZXJlZCBmb3IgYWxwaGEtYmxlbmRpbmdcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmlzVHJhbnNwYXJlbnQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzb3VyY2Ugb2YgYSBzaGFkZXJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7e3ZlcnRleDogc3RyaW5nLCBmcmFnbWVudDogc3RyaW5nfX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zb3VyY2UgPSB7XHJcbiAgICAgICAgdmVydGV4OiBcIlwiLCBmcmFnbWVudDogXCJcIlxyXG4gICAgfVxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQWJzdHJhY3RTaGFkZXJDbG9zdXJlLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcclxuICAgICAgICAgICAgd3JpdGVhYmxlOiBmYWxzZSwgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9ncmFtID8gdGhpcy5wcm9ncmFtLmF0dHJpYnV0ZXMgOiB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgdW5pZm9ybXM6IHtcclxuICAgICAgICAgICAgd3JpdGVhYmxlOiBmYWxzZSwgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9ncmFtID8gdGhpcy5wcm9ncmFtLnVuaWZvcm1zIDoge31cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHNhbXBsZXJzOiB7XHJcbiAgICAgICAgICAgIHdyaXRlYWJsZTogZmFsc2UsIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbSA/IHRoaXMucHJvZ3JhbS5zYW1wbGVycyA6IHt9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoQWJzdHJhY3RTaGFkZXJDbG9zdXJlLCBudWxsLCB7XHJcblxyXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAodGhhdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS52ZXJ0ZXggPT09IHRoYXQuc291cmNlLnZlcnRleCAmJiB0aGlzLnNvdXJjZS5mcmFnbWVudCA9PT0gdGhhdC5zb3VyY2UuZnJhZ21lbnQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGhhc1RyYW5zcGFyZW5jeTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzVHJhbnNwYXJlbnQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc291cmNlLmZyYWdtZW50IHx8ICF0aGlzLnNvdXJjZS52ZXJ0ZXgpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJObyBzb3VyY2UgZm91bmQgZm9yIHNoYWRlclwiLCB0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHByb2dyYW1PYmplY3QgPSBuZXcgR0xQcm9ncmFtT2JqZWN0KHRoaXMuY29udGV4dC5nbCwgdGhpcy5zb3VyY2UpO1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW1PYmplY3Q7XHJcbiAgICAgICAgdGhpcy5pZCA9IHByb2dyYW1PYmplY3QuaWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2dyYW0uYmluZCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2dyYW0udW5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9ncmFtLmlzVmFsaWQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge1hmbG93LkNvbXB1dGVSZXN1bHR9IHhmbG93UmVzdWx0XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVVuaWZvcm1zRnJvbUNvbXB1dGVSZXN1bHQ6IGZ1bmN0aW9uICh4Zmxvd1Jlc3VsdCkge1xyXG4gICAgICAgIHZhciBtYXAgPSB4Zmxvd1Jlc3VsdC5nZXRPdXRwdXRNYXAoKTtcclxuXHJcbiAgICAgICAgdmFyIGVudkJhc2UgPSB0aGlzLnVuaWZvcm1Db2xsZWN0aW9uLmVudkJhc2UgPSB7fTtcclxuICAgICAgICB0aGlzLnNldERlZmF1bHRVbmlmb3Jtcyh0aGlzLnVuaWZvcm1Db2xsZWN0aW9uLmVudkJhc2UpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xyXG4gICAgICAgICAgICBlbnZCYXNlW25hbWVdID0gWGZsb3dVdGlscy5nZXRHTFVuaWZvcm1WYWx1ZUZyb21YZmxvd0RhdGFFbnRyeShtYXBbbmFtZV0sIHRoaXMuY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGVudkJhc2UpO1xyXG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybVZhcmlhYmxlcyhuYW1lcywgbnVsbCwgdGhpcy51bmlmb3JtQ29sbGVjdGlvbik7XHJcblxyXG4gICAgICAgIHRoaXMuaXNUcmFuc3BhcmVudCA9IHRoaXMuZ2V0VHJhbnNwYXJlbmN5RnJvbUlucHV0RGF0YShtYXApO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRVbmlmb3JtVmFyaWFibGVzOiBmdW5jdGlvbiAoZW52TmFtZXMsIHN5c05hbWVzLCB1bmlmb3JtQ29sbGVjdGlvbikge1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbS5zZXRVbmlmb3JtVmFyaWFibGVzKGVudk5hbWVzLCBzeXNOYW1lcywgdW5pZm9ybUNvbGxlY3Rpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTeXN0ZW1Vbmlmb3JtVmFyaWFibGVzOiBmdW5jdGlvbiAoc3lzTmFtZXMsIHN5c1ZhbHVlcykge1xyXG4gICAgICAgIHRoaXMudW5pZm9ybUNvbGxlY3Rpb24uc3lzQmFzZSA9IHN5c1ZhbHVlcztcclxuICAgICAgICB0aGlzLnNldFVuaWZvcm1WYXJpYWJsZXMobnVsbCwgc3lzTmFtZXMsIHRoaXMudW5pZm9ybUNvbGxlY3Rpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBjaGFuZ2VVbmlmb3JtVmFyaWFibGVPdmVycmlkZTogZnVuY3Rpb24gKHByZXZPdmVycmlkZSwgbmV3T3ZlcnJpZGUpIHtcclxuICAgICAgICB2YXIgb3ZlcnJpZGVOYW1lcyA9IHByZXZPdmVycmlkZSA/IE9iamVjdC5rZXlzKHByZXZPdmVycmlkZSkgOiBbXTtcclxuICAgICAgICBpZiAobmV3T3ZlcnJpZGUpIG92ZXJyaWRlTmFtZXMucHVzaC5hcHBseShvdmVycmlkZU5hbWVzLCBPYmplY3Qua2V5cyhuZXdPdmVycmlkZSkpO1xyXG4gICAgICAgIHRoaXMudW5pZm9ybUNvbGxlY3Rpb24uZW52T3ZlcnJpZGUgPSBuZXdPdmVycmlkZTtcclxuICAgICAgICB0aGlzLnNldFVuaWZvcm1WYXJpYWJsZXMob3ZlcnJpZGVOYW1lcywgbnVsbCwgdGhpcy51bmlmb3JtQ29sbGVjdGlvbik7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFNoYWRlckNsb3N1cmU7XHJcblxyXG4iLCJ2YXIgR0xTY2VuZSA9IHJlcXVpcmUoXCIuLi9zY2VuZS9nbHNjZW5lLmpzXCIpO1xyXG52YXIgR0xMaWdodHMgPSByZXF1aXJlKFwiLi4vc2NlbmUvZ2xsaWdodHMuanNcIik7XHJcbnZhciBNYXRlcmlhbEV2ZW50cyA9IHJlcXVpcmUoXCIuLi9tYXRlcmlhbHMvZXZlbnRzLmpzXCIpO1xyXG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnRyaWIvRXZlbnREaXNwYXRjaGVyLmpzXCIpO1xyXG52YXIgQ29tcHV0ZVJlcXVlc3QgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL3JlcXVlc3QuanNcIikuQ29tcHV0ZVJlcXVlc3Q7XHJcbnZhciBYQyA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2VcclxuICovXHJcbnZhciBJU2hhZGVyQ29tcG9zZXIgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcblxyXG4vKipcclxuICogQGVudW1cclxuICovXHJcbklTaGFkZXJDb21wb3Nlci5VcGRhdGVTdGF0ZSA9IHtcclxuICAgIFNIQURFUl9VUERBVEVEOiAxLCBTSEFERVJfQ09NUElMRUQ6IDIsIFNIQURFUl9VTkNIQU5HRUQ6IDNcclxufTtcclxuXHJcbklTaGFkZXJDb21wb3Nlci5TdGF0ZSA9IHtcclxuICAgIE9LOiAxLCBOT19TQ1JJUFQ6IDIsIE5PX1BST0dSQU06IDNcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge3NjZW5lfSBzY2VuZVxyXG4gKiBAcGFyYW0ge3t9PX0gb3B0XHJcbiAqL1xyXG5JU2hhZGVyQ29tcG9zZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChzY2VuZSwgb3B0KSB7XHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICogQHJldHVybnMgQWJzdHJhY3RTaGFkZXJDbG9zdXJlfG51bGxcclxuICovXHJcbklTaGFkZXJDb21wb3Nlci5wcm90b3R5cGUuZ2V0U2hhZGVyQ2xvc3VyZSA9IGZ1bmN0aW9uIChzY2VuZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fVxyXG4gKi9cclxuSVNoYWRlckNvbXBvc2VyLnByb3RvdHlwZS5nZXRSZXF1ZXN0RmllbGRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHt7fX1cclxuICovXHJcbklTaGFkZXJDb21wb3Nlci5wcm90b3R5cGUuZ2V0U2hhZGVyQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB7fTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBBYnN0cmFjdFNoYWRlckNvbXBvc2VyID0gZnVuY3Rpb24gKGNvbnRleHQsIHNoYWRlckluZm8pIHtcclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB0aGlzLnNoYWRlckNsb3N1cmVzID0gW107XHJcbiAgICB0aGlzLmRhdGFDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLnVwZGF0ZUxpZ2h0VmFsdWVzID0gZmFsc2U7XHJcbiAgICB0aGlzLnJlcXVlc3QgPSBudWxsO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoQWJzdHJhY3RTaGFkZXJDb21wb3NlciwgRXZlbnREaXNwYXRjaGVyLCB7XHJcblxyXG4gICAgLy8gSW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NcclxuICAgIHNldFNoYWRlckluZm86IG51bGwsXHJcblxyXG5cclxuICAgIHVwZGF0ZVJlcXVlc3Q6IGZ1bmN0aW9uICh4Zmxvd0RhdGFOb2RlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdCkgdGhpcy5yZXF1ZXN0LmNsZWFyKCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVxdWVzdCA9IG5ldyBDb21wdXRlUmVxdWVzdCh4Zmxvd0RhdGFOb2RlLCB0aGlzLmdldFJlcXVlc3RGaWVsZHMoKSwgdGhpcy5vblNoYWRlclJlcXVlc3RDaGFuZ2UuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5zZXRTaGFkZXJSZWNvbXBpbGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25TaGFkZXJJbmZvQ2hhbmdlZDogZnVuY3Rpb24gKHNoYWRlckluZm8pIHtcclxuICAgICAgICB0aGlzLnNldFNoYWRlckluZm8oc2hhZGVySW5mbyk7XHJcbiAgICAgICAgdGhpcy5zZXRTaGFkZXJSZWNvbXBpbGUoKTtcclxuICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyhcIlNoYWRlciBzY3JpcHQgY2hhbmdlZFwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25TaGFkZXJSZXF1ZXN0Q2hhbmdlOiBmdW5jdGlvbiAocmVxdWVzdCwgY2hhbmdlVHlwZSkge1xyXG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmIChjaGFuZ2VUeXBlID09IFhDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSlcclxuICAgICAgICAgICAgdGhpcy5zZXRTaGFkZXJSZWNvbXBpbGUoKTtcclxuICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyhcIlNoYWRlciBkYXRhIGNoYW5nZWRcIik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmVcclxuICAgICAqIEBwYXJhbSB7e309fSBvcHRcclxuICAgICAqL1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoc2NlbmUsIG9wdCkge1xyXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIC8vIENsZWFuIHVwIHNoYWRlckNsb3N1cmVzIHRoYXQgYXJlIG5vdCB1c2VkIVxyXG4gICAgICAgIHZhciBpID0gdGhpcy5zaGFkZXJDbG9zdXJlcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zaGFkZXJDbG9zdXJlc1tpXS5vYnNvbGV0ZSkgdGhpcy5zaGFkZXJDbG9zdXJlcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuc2hhZGVyQ2xvc3VyZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRhdGFDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmdldFNoYWRlckRhdGFSZXN1bHQoKTtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXJDbG9zdXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaGFkZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlQ2xvc3VyZUZyb21Db21wdXRlUmVzdWx0KHNoYWRlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZUxpZ2h0VmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyQ2xvc3VyZXMuZm9yRWFjaChmdW5jdGlvbiAoc2hhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZUNsb3N1cmVGcm9tTGlnaHRQYXJhbWV0ZXJzKHNoYWRlciwgc2NlbmUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtBYnN0cmFjdFNoYWRlckNsb3N1cmV9IHNoYWRlckNsb3N1cmVcclxuICAgICAqIEBwYXJhbSB7WGZsb3cuQ29tcHV0ZVJlc3VsdH0gcmVzdWx0XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUNsb3N1cmVGcm9tQ29tcHV0ZVJlc3VsdDogZnVuY3Rpb24gKHNoYWRlckNsb3N1cmUsIHJlc3VsdCkge1xyXG4gICAgICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQuZ2V0T3V0cHV0TWFwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2hhZGVyQ2xvc3VyZS5iaW5kKCk7XHJcbiAgICAgICAgc2hhZGVyQ2xvc3VyZS51cGRhdGVVbmlmb3Jtc0Zyb21Db21wdXRlUmVzdWx0KHJlc3VsdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZUNsb3N1cmVGcm9tTGlnaHRQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoc2hhZGVyQ2xvc3VyZSwgc2NlbmUpIHtcclxuICAgICAgICBzaGFkZXJDbG9zdXJlLmJpbmQoKTtcclxuICAgICAgICBzaGFkZXJDbG9zdXJlLnNldFN5c3RlbVVuaWZvcm1WYXJpYWJsZXMoR0xMaWdodHMuQUxMX1BBUkFNRVRFUlMsIHNjZW5lLnN5c3RlbVVuaWZvcm1zKTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlU3lzdGVtVW5pZm9ybXM6IGZ1bmN0aW9uIChuYW1lcywgc2NlbmUpIHtcclxuICAgICAgICB0aGlzLnNoYWRlckNsb3N1cmVzLmZvckVhY2goZnVuY3Rpb24gKHNoYWRlcikge1xyXG4gICAgICAgICAgICBzaGFkZXIuYmluZCgpO1xyXG4gICAgICAgICAgICBzaGFkZXIuc2V0U3lzdGVtVW5pZm9ybVZhcmlhYmxlcyhuYW1lcywgc2NlbmUuc3lzdGVtVW5pZm9ybXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgY3JlYXRlU2hhZGVyQ2xvc3VyZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFic3RyYWN0Q29tcG9zZXI6OmNyZWF0ZVNoYWRlckNsb3N1cmUgbmVlZHMgdG8gYmUgb3ZlcnJpZGRlblwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlT2JqZWN0RGF0YVJlcXVlc3Q6IGZ1bmN0aW9uIChvYmplY3REYXRhTm9kZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdENvbXBvc2VyOjpjcmVhdGVPYmplY3REYXRhUmVxdWVzdCBuZWVkcyB0byBiZSBvdmVycmlkZGVuXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXN0cmlidXRlT2JqZWN0U2hhZGVyRGF0YTogZnVuY3Rpb24gKG9iamVjdFJlcXVlc3QsIGF0dHJpYnV0ZUNhbGxiYWNrLCB1bmlmb3JtQ2FsbGJhY2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdENvbXBvc2VyOjpkaXN0cmlidXRlT2JqZWN0U2hhZGVyRGF0YSBuZWVkcyB0byBiZSBvdmVycmlkZGVuXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTaGFkZXJDbG9zdXJlOiBmdW5jdGlvbiAoc2NlbmUsIHZzUmVxdWVzdCkge1xyXG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLmNyZWF0ZVNoYWRlckNsb3N1cmUoKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc2hhZGVyLmNyZWF0ZVNvdXJjZXMoc2NlbmUsIHRoaXMuZ2V0U2hhZGVyRGF0YVJlc3VsdCgpLCB2c1JlcXVlc3QpXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaGFkZXI6IFwiICsgZS5tZXNzYWdlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNoYWRlckNsb3N1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNoYWRlckNsb3N1cmVzW2ldLmVxdWFscyhzaGFkZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRlckNsb3N1cmVzW2ldLm9ic29sZXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaGFkZXJDbG9zdXJlc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplU2hhZGVyQ2xvc3VyZShzaGFkZXIsIHNjZW5lKTtcclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfSxcclxuXHJcbiAgICBpbml0aWFsaXplU2hhZGVyQ2xvc3VyZTogZnVuY3Rpb24gKHNoYWRlckNsb3N1cmUsIHNjZW5lKSB7XHJcbiAgICAgICAgc2hhZGVyQ2xvc3VyZS5jb21waWxlKCk7XHJcblxyXG4gICAgICAgIHNjZW5lLmRpc3BhdGNoRXZlbnQoe3R5cGU6IE1hdGVyaWFsRXZlbnRzLk1BVEVSSUFMX0lOSVRJQUxJWkVEfSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDbG9zdXJlRnJvbUNvbXB1dGVSZXN1bHQoc2hhZGVyQ2xvc3VyZSwgdGhpcy5nZXRTaGFkZXJEYXRhUmVzdWx0KCkpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ2xvc3VyZUZyb21MaWdodFBhcmFtZXRlcnMoc2hhZGVyQ2xvc3VyZSwgc2NlbmUpO1xyXG4gICAgICAgIHRoaXMuc2hhZGVyQ2xvc3VyZXMucHVzaChzaGFkZXJDbG9zdXJlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2hhZGVyUmVjb21waWxlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zaGFkZXJDbG9zdXJlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlckNsb3N1cmVzW2ldLm9ic29sZXRlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiBNYXRlcmlhbEV2ZW50cy5NQVRFUklBTF9TVFJVQ1RVUkVfQ0hBTkdFRH0pO1xyXG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGlnaHRWYWx1ZXMgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7WGZsb3cuQ29tcHV0ZVJlc3VsdHxudWxsfVxyXG4gICAgICovXHJcbiAgICBnZXRTaGFkZXJEYXRhUmVzdWx0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCA/IHRoaXMucmVxdWVzdC5nZXRSZXN1bHQoKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG5cclxufSk7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBpbXBsZW1lbnRzIElTaGFkZXJDb21wb3NlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBEZWZhdWx0Q29tcG9zZXIgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoRGVmYXVsdENvbXBvc2VyLCBBYnN0cmFjdFNoYWRlckNvbXBvc2VyLCB7XHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U2hhZGVyQ2xvc3VyZTogZnVuY3Rpb24gKHNjZW5lLCB2c1JlcXVlc3QpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1GYWN0b3J5LmdldEZhbGxiYWNrUHJvZ3JhbSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTaGFkZXJBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtjb2xvcjogbnVsbCwgbm9ybWFsOiBudWxsIC8qIGZvciBwaWNraW5nICovfTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UmVxdWVzdEZpZWxkczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbXCJkaWZmdXNlQ29sb3JcIiwgXCJ1c2VWZXJ0ZXhDb2xvclwiXTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlT2JqZWN0RGF0YVJlcXVlc3Q6IGZ1bmN0aW9uIChvYmplY3REYXRhTm9kZSwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXB1dGVSZXF1ZXN0KG9iamVjdERhdGFOb2RlLCBbXCJwb3NpdGlvblwiLCBcImNvbG9yXCIsIFwibm9ybWFsXCIsIFwiZGlmZnVzZUNvbG9yXCIsIFwidXNlVmVydGV4Q29sb3JcIl0sIGNhbGxiYWNrKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGlzdHJpYnV0ZU9iamVjdFNoYWRlckRhdGE6IGZ1bmN0aW9uIChvYmplY3RSZXF1ZXN0LCBhdHRyaWJ1dGVDYWxsYmFjaywgdW5pZm9ybUNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdFJlcXVlc3QuZ2V0UmVzdWx0KCk7XHJcblxyXG4gICAgICAgIHZhciBkYXRhTWFwID0gcmVzdWx0LmdldE91dHB1dE1hcCgpLCByZXF1ZXN0RmllbGRzID0gdGhpcy5nZXRSZXF1ZXN0RmllbGRzKCk7XHJcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkYXRhTWFwKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0RmllbGRzLmluZGV4T2YobmFtZSkgIT0gLTEpXHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtQ2FsbGJhY2sobmFtZSwgZGF0YU1hcFtuYW1lXSk7IGVsc2VcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUNhbGxiYWNrKG5hbWUsIGRhdGFNYXBbbmFtZV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBBYnN0cmFjdFNoYWRlckNvbXBvc2VyOiBBYnN0cmFjdFNoYWRlckNvbXBvc2VyLFxyXG4gICAgRGVmYXVsdENvbXBvc2VyOiBEZWZhdWx0Q29tcG9zZXJcclxufVxyXG5cclxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBNQVRFUklBTF9TVFJVQ1RVUkVfQ0hBTkdFRDogXCJtYXRlcmlhbF9zdHJ1Y3R1cmVfY2hhbmdlZFwiLFxyXG4gICAgTUFURVJJQUxfSU5JVElBTElaRUQ6IFwibWF0ZXJpYWxfaW5pdGlhbGl6ZWRcIlxyXG59O1xyXG4iLCJ2YXIgQWJzdHJhY3RTaGFkZXJDbG9zdXJlID0gcmVxdWlyZShcIi4vLi4vYWJzdHJhY3RzaGFkZXJjbG9zdXJlLmpzXCIpO1xyXG52YXIgSlNTaGFkZXJDb21wb3NlciA9IHJlcXVpcmUoXCIuL2pzc2hhZGVyY29tcG9zZXIuanNcIik7XHJcbnZhciBTeXN0ZW1Ob3RpZmllciA9IHJlcXVpcmUoXCIuLi8uLi9zeXN0ZW0vc3lzdGVtLW5vdGlmaWVyLmpzXCIpO1xyXG52YXIgZ2V0SlNTeXN0ZW1Db25maWd1cmF0aW9uID0gcmVxdWlyZShcIi4vanNzeXN0ZW1jb25maWd1cmF0aW9uLmpzXCIpO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIE9wdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vdXRpbHMvb3B0aW9ucy5qc1wiKTtcclxuXHJcbnZhciBjX1N5c3RlbVVwZGF0ZSA9IHtcclxuICAgIFwicG9pbnRMaWdodE9uXCI6IHtcclxuICAgICAgICBzdGF0aWNWYWx1ZTogXCJNQVhfUE9JTlRMSUdIVFNcIixcclxuICAgICAgICBzdGF0aWNTaXplOiBbXCJwb2ludExpZ2h0T25cIiwgXCJwb2ludExpZ2h0QXR0ZW51YXRpb25cIiwgXCJwb2ludExpZ2h0SW50ZW5zaXR5XCIsIFwicG9pbnRMaWdodFBvc2l0aW9uXCIsIFwicG9pbnRMaWdodENhc3RTaGFkb3dcIiwgXCJwb2ludExpZ2h0U2hhZG93Qmlhc1wiLCBcInBvaW50TGlnaHRTaGFkb3dNYXBcIiwgXCJwb2ludExpZ2h0TWF0cml4XCIsIFwicG9pbnRMaWdodE5lYXJGYXJcIl1cclxuICAgIH0sIFwiZGlyZWN0aW9uYWxMaWdodE9uXCI6IHtcclxuICAgICAgICBzdGF0aWNWYWx1ZTogXCJNQVhfRElSRUNUSU9OQUxMSUdIVFNcIixcclxuICAgICAgICBzdGF0aWNTaXplOiBbXCJkaXJlY3Rpb25hbExpZ2h0T25cIiwgXCJkaXJlY3Rpb25hbExpZ2h0SW50ZW5zaXR5XCIsIFwiZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblwiLCBcImRpcmVjdGlvbmFsTGlnaHRDYXN0U2hhZG93XCIsIFwiZGlyZWN0aW9uYWxMaWdodFNoYWRvd0JpYXNcIiwgXCJkaXJlY3Rpb25hbExpZ2h0U2hhZG93TWFwXCIsIFwiZGlyZWN0aW9uYWxMaWdodE1hdHJpeFwiXVxyXG4gICAgfSwgXCJzcG90TGlnaHRPblwiOiB7XHJcbiAgICAgICAgc3RhdGljVmFsdWU6IFwiTUFYX1NQT1RMSUdIVFNcIixcclxuICAgICAgICBzdGF0aWNTaXplOiBbXCJzcG90TGlnaHRPblwiLCBcInNwb3RMaWdodEF0dGVudWF0aW9uXCIsIFwic3BvdExpZ2h0SW50ZW5zaXR5XCIsIFwic3BvdExpZ2h0UG9zaXRpb25cIiwgXCJzcG90TGlnaHREaXJlY3Rpb25cIiwgXCJzcG90TGlnaHRDb3NGYWxsb2ZmQW5nbGVcIiwgXCJzcG90TGlnaHRDb3NTb2Z0RmFsbG9mZkFuZ2xlXCIsIFwic3BvdExpZ2h0Q2FzdFNoYWRvd1wiLCBcInNwb3RMaWdodFNoYWRvd0JpYXNcIiwgXCJzcG90TGlnaHRTaGFkb3dNYXBcIiwgXCJzcG90TGlnaHRNYXRyaXhcIl1cclxuICAgIH1cclxufTtcclxuXHJcbnZhciBjX2pzU2hhZGVyQ2FjaGUgPSB7fTtcclxuXHJcblxyXG5mdW5jdGlvbiBjb252ZXJ0RW52TmFtZShuYW1lKSB7XHJcbiAgICByZXR1cm4gKFwiX2Vudl9cIiArIG5hbWUpLnJlcGxhY2UoL18rL2csIFwiX1wiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkRGVmYXVsdENoYW5uZWxpbmcodnNDb25maWcsIGlucHV0TmFtZSkge1xyXG4gICAgdmFyIG91dHB1dE5hbWUgPSBjb252ZXJ0RW52TmFtZShpbnB1dE5hbWUpO1xyXG4gICAgdnNDb25maWcuY2hhbm5lbEF0dHJpYnV0ZShpbnB1dE5hbWUsIG91dHB1dE5hbWUsIG51bGwpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gY2hhbm5lbFZzQXR0cmlidXRlKHZzQ29uZmlnLCBpbnB1dE5hbWUsIHNwYWNlSW5mbykge1xyXG4gICAgaWYgKCFzcGFjZUluZm8gfHwgIXNwYWNlSW5mb1tpbnB1dE5hbWVdKSB7XHJcbiAgICAgICAgYWRkRGVmYXVsdENoYW5uZWxpbmcodnNDb25maWcsIGlucHV0TmFtZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpID0gc3BhY2VJbmZvW2lucHV0TmFtZV0ubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHNwYWNlSW5mb1tpbnB1dE5hbWVdW2ldO1xyXG4gICAgICAgIHZhciBvdXRwdXROYW1lID0gY29udmVydEVudk5hbWUoZW50cnkubmFtZSksIGNvZGUgPSBudWxsO1xyXG4gICAgICAgIHN3aXRjaCAoZW50cnkuc3BhY2UpIHtcclxuICAgICAgICAgICAgY2FzZSBTaGFkZS5TUEFDRV9WRUNUT1JfVFlQRVMuT0JKRUNUOlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU2hhZGUuU1BBQ0VfVkVDVE9SX1RZUEVTLlZJRVdfUE9JTlQ6XHJcbiAgICAgICAgICAgICAgICB2c0NvbmZpZy5hZGRJbnB1dFBhcmFtZXRlcihYQy5EQVRBX1RZUEUuRkxPQVQ0WDQsIFwibW9kZWxWaWV3TWF0cml4XCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgY29kZSA9IG91dHB1dE5hbWUgKyBcIiA9ICggbW9kZWxWaWV3TWF0cml4ICogdmVjNCgjSXtcIiArIGlucHV0TmFtZSArIFwifSwgMS4wKSApLnh5ejtcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFNoYWRlLlNQQUNFX1ZFQ1RPUl9UWVBFUy5WSUVXX05PUk1BTDpcclxuICAgICAgICAgICAgICAgIHZzQ29uZmlnLmFkZElucHV0UGFyYW1ldGVyKFhDLkRBVEFfVFlQRS5GTE9BVDNYMywgXCJtb2RlbFZpZXdNYXRyaXhOXCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgY29kZSA9IG91dHB1dE5hbWUgKyBcIiA9IG5vcm1hbGl6ZSggbW9kZWxWaWV3TWF0cml4TiAqICNJe1wiICsgaW5wdXROYW1lICsgXCJ9ICk7XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTaGFkZS5TUEFDRV9WRUNUT1JfVFlQRVMuV09STERfUE9JTlQ6XHJcbiAgICAgICAgICAgICAgICB2c0NvbmZpZy5hZGRJbnB1dFBhcmFtZXRlcihYQy5EQVRBX1RZUEUuRkxPQVQ0WDQsIFwibW9kZWxNYXRyaXhcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb2RlID0gb3V0cHV0TmFtZSArIFwiID0gKCBtb2RlbE1hdHJpeCAqIHZlYzQoI0l7XCIgKyBpbnB1dE5hbWUgKyBcIn0sIDEuMCkgKS54eXo7XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTaGFkZS5TUEFDRV9WRUNUT1JfVFlQRVMuV09STERfTk9STUFMOlxyXG4gICAgICAgICAgICAgICAgdnNDb25maWcuYWRkSW5wdXRQYXJhbWV0ZXIoWEMuREFUQV9UWVBFLkZMT0FUM1gzLCBcIm1vZGVsTWF0cml4TlwiLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGNvZGUgPSBvdXRwdXROYW1lICsgXCIgPSBub3JtYWxpemUoIG1vZGVsTWF0cml4TiAqICNJe1wiICsgaW5wdXROYW1lICsgXCJ9ICk7XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGhhbmRsZSBTcGFjZSBUeXBlOiBcIiArIGVudHJ5LnNwYWNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdnNDb25maWcuY2hhbm5lbEF0dHJpYnV0ZShpbnB1dE5hbWUsIG91dHB1dE5hbWUsIGNvZGUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7WEMuREFUQV9UWVBFfSB4Zmxvd1R5cGVcclxuICovXHJcbnZhciBjb252ZXJ0WGZsb3cyU2hhZGVUeXBlID0gZnVuY3Rpb24gKHhmbG93VHlwZSwgc291cmNlKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0ge31cclxuICAgIHN3aXRjaCAoeGZsb3dUeXBlKSB7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuQk9PTDpcclxuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSBTaGFkZS5UWVBFUy5CT09MRUFOO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFhDLkRBVEFfVFlQRS5JTlQ6XHJcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gU2hhZGUuVFlQRVMuSU5UO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFhDLkRBVEFfVFlQRS5GTE9BVDpcclxuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSBTaGFkZS5UWVBFUy5OVU1CRVI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLkZMT0FUMjpcclxuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSBTaGFkZS5UWVBFUy5PQkpFQ1Q7XHJcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0gU2hhZGUuT0JKRUNUX0tJTkRTLkZMT0FUMjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQzOlxyXG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IFNoYWRlLlRZUEVTLk9CSkVDVDtcclxuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBTaGFkZS5PQkpFQ1RfS0lORFMuRkxPQVQzO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFhDLkRBVEFfVFlQRS5GTE9BVDQ6XHJcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gU2hhZGUuVFlQRVMuT0JKRUNUO1xyXG4gICAgICAgICAgICByZXN1bHQua2luZCA9IFNoYWRlLk9CSkVDVF9LSU5EUy5GTE9BVDQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLkZMT0FUM1gzOlxyXG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IFNoYWRlLlRZUEVTLk9CSkVDVDtcclxuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBTaGFkZS5PQkpFQ1RfS0lORFMuTUFUUklYMztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQ0WDQ6XHJcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gU2hhZGUuVFlQRVMuT0JKRUNUO1xyXG4gICAgICAgICAgICByZXN1bHQua2luZCA9IFNoYWRlLk9CSkVDVF9LSU5EUy5NQVRSSVg0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFhDLkRBVEFfVFlQRS5URVhUVVJFOlxyXG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IFNoYWRlLlRZUEVTLk9CSkVDVDtcclxuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBTaGFkZS5PQkpFQ1RfS0lORFMuVEVYVFVSRTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuVU5LTk9XTjpcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIFhmbG93IERhdGFUeXBlOiBcIiArIHhmbG93VHlwZSk7XHJcbiAgICB9XHJcbiAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSBjb250ZXh0XHJcbiAqIEBwYXJhbSBzb3VyY2VUZW1wbGF0ZVxyXG4gKiBAcGFyYW0gZGF0YUNhbGxiYWNrXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEpTU2hhZGVyQ2xvc3VyZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBzb3VyY2VUZW1wbGF0ZSwgZXh0cmFjdGVkUGFyYW1zKSB7XHJcbiAgICBBYnN0cmFjdFNoYWRlckNsb3N1cmUuY2FsbCh0aGlzLCBjb250ZXh0KTtcclxuICAgIHRoaXMuc291cmNlVGVtcGxhdGUgPSBzb3VyY2VUZW1wbGF0ZTtcclxuICAgIHRoaXMuZXh0cmFjdGVkUGFyYW1zID0gZXh0cmFjdGVkUGFyYW1zO1xyXG4gICAgdGhpcy51bmlmb3JtU2V0dGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgfTtcclxuICAgIHRoaXMudW5pZm9ybUNvbnZlcnRlciA9IFtdO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoSlNTaGFkZXJDbG9zdXJlLCBBYnN0cmFjdFNoYWRlckNsb3N1cmUsIHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7R0xTY2VuZX0gc2NlbmVcclxuICAgICAqIEBwYXJhbSB7WGZsb3cuQ29tcHV0ZVJlc3VsdH0gc2hhZGVyUmVzdWx0XHJcbiAgICAgKiBAcGFyYW0gb2JqZWN0RGF0YVxyXG4gICAgICovXHJcbiAgICBjcmVhdGVTb3VyY2VzOiBmdW5jdGlvbiAoc2NlbmUsIHNoYWRlclJlc3VsdCwgdnNSZXF1ZXN0KSB7XHJcblxyXG4gICAgICAgIHZhciB2c0RhdGFSZXN1bHQgPSB2c1JlcXVlc3QuZ2V0UmVzdWx0KCk7XHJcblxyXG4gICAgICAgIHZhciBjb250ZXh0RGF0YSA9IHtcclxuICAgICAgICAgICAgXCJ0aGlzXCI6IGdldEpTU3lzdGVtQ29uZmlndXJhdGlvbih0aGlzLmNvbnRleHQpLFxyXG4gICAgICAgICAgICBcImdsb2JhbC5zaGFkZVwiOiBbe1wiZXh0cmFcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJhbnlcIiwgXCJnbG9iYWxcIjogdHJ1ZSwgXCJpbmZvXCI6IHt9fX1dXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHN5c3RlbVVuaWZvcm1zID0gc2NlbmUuc3lzdGVtVW5pZm9ybXMsIHN5c3RlbUluZm8gPSBjb250ZXh0RGF0YVtcInRoaXNcIl0uaW5mbztcclxuICAgICAgICBmb3IgKHZhciBzeXN0ZW1Tb3VyY2UgaW4gY19TeXN0ZW1VcGRhdGUpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gY19TeXN0ZW1VcGRhdGVbc3lzdGVtU291cmNlXTtcclxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHN5c3RlbVVuaWZvcm1zW3N5c3RlbVNvdXJjZV0gJiYgc3lzdGVtVW5pZm9ybXNbc3lzdGVtU291cmNlXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHN5c3RlbUluZm9bZW50cnkuc3RhdGljVmFsdWVdLnN0YXRpY1ZhbHVlID0gbGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJ5LnN0YXRpY1NpemUubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1JbmZvW2VudHJ5LnN0YXRpY1NpemVbaV1dLnN0YXRpY1NpemUgPSBsZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY29udGV4dEluZm8gPSBjb250ZXh0RGF0YVtcImdsb2JhbC5zaGFkZVwiXVswXS5leHRyYS5pbmZvO1xyXG5cclxuICAgICAgICB2YXIgc2hhZGVyRW50cmllcyA9IHNoYWRlclJlc3VsdCAmJiBzaGFkZXJSZXN1bHQuZ2V0T3V0cHV0TWFwKCksIHZzU2hhZGVyT3V0cHV0ID0gdnNEYXRhUmVzdWx0ICYmIHZzRGF0YVJlc3VsdC5vdXRwdXROYW1lcztcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV4dHJhY3RlZFBhcmFtcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1OYW1lID0gdGhpcy5leHRyYWN0ZWRQYXJhbXNbaV07XHJcbiAgICAgICAgICAgIGlmICh2c1NoYWRlck91dHB1dCAmJiB2c1NoYWRlck91dHB1dC5pbmRleE9mKHBhcmFtTmFtZSkgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHRJbmZvW3BhcmFtTmFtZV0gPSBjb252ZXJ0WGZsb3cyU2hhZGVUeXBlKHZzRGF0YVJlc3VsdC5nZXRPdXRwdXRUeXBlKHBhcmFtTmFtZSksIHZzRGF0YVJlc3VsdC5pc091dHB1dFVuaWZvcm0ocGFyYW1OYW1lKSA/IFNoYWRlLlNPVVJDRVMuVU5JRk9STSA6IFNoYWRlLlNPVVJDRVMuVkVSVEVYKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFkZXJFbnRyaWVzICYmIHNoYWRlckVudHJpZXNbcGFyYW1OYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dEluZm9bcGFyYW1OYW1lXSA9IGNvbnZlcnRYZmxvdzJTaGFkZVR5cGUoc2hhZGVyRW50cmllc1twYXJhbU5hbWVdLnR5cGUsIFNoYWRlLlNPVVJDRVMuVU5JRk9STSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJDT05URVhUOlwiLCBjb250ZXh0RGF0YSk7XHJcblxyXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBwcm9wYWdhdGVDb25zdGFudHM6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbGlkYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICBzYW5pdGl6ZTogdHJ1ZSxcclxuICAgICAgICAgICAgdHJhbnNmb3JtU3BhY2VzOiBPcHRpb25zLmdldFZhbHVlKFwic2hhZGVqcy10cmFuc2Zvcm1TcGFjZXNcIiksXHJcbiAgICAgICAgICAgIGV4dHJhY3RVbmlmb3JtRXhwcmVzc2lvbnM6IE9wdGlvbnMuZ2V0VmFsdWUoXCJzaGFkZWpzLWV4dHJhY3RVbmlmb3JtRXhwcmVzc2lvbnNcIilcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBjb21waWxlT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgdXNlU3RhdGljOiB0cnVlLCB1bmlmb3JtRXhwcmVzc2lvbnM6IG9wdGlvbnMudW5pZm9ybUV4cHJlc3Npb25zXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgaW1wbGVtZW50YXRpb24gPSBzY2VuZS5kZWZlcnJlZCA/IFwieG1sM2QtZ2xzbC1kZWZlcnJlZFwiIDogXCJ4bWwzZC1nbHNsLWZvcndhcmRcIjtcclxuXHJcbiAgICAgICAgdmFyIGpzU2hhZGVyS2V5ID0gaW1wbGVtZW50YXRpb24gKyBcIjtcIiArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpICsgXCI7XCIgKyBKU09OLnN0cmluZ2lmeShjb250ZXh0SW5mbykgKyBcIjtcIiArIHRoaXMuc291cmNlVGVtcGxhdGU7XHJcblxyXG4gICAgICAgIHZhciBjYWNoZUVudHJ5O1xyXG4gICAgICAgIGlmICghKGNhY2hlRW50cnkgPSBjX2pzU2hhZGVyQ2FjaGVbanNTaGFkZXJLZXldKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdvcmtTZXQgPSBuZXcgU2hhZGUuV29ya2luZ1NldCgpO1xyXG4gICAgICAgICAgICAgICAgd29ya1NldC5wYXJzZSh0aGlzLnNvdXJjZVRlbXBsYXRlLCB7bG9jOiB0cnVlfSk7XHJcbiAgICAgICAgICAgICAgICB3b3JrU2V0LmFuYWx5emUoY29udGV4dERhdGEsIGltcGxlbWVudGF0aW9uLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHZhciBzcGFjZUluZm8gPSB3b3JrU2V0LmdldFByb2Nlc3NpbmdEYXRhKCdzcGFjZUluZm8nKTtcclxuICAgICAgICAgICAgICAgIHZhciBnbHNsU2hhZGVyID0gd29ya1NldC5jb21waWxlRnJhZ21lbnRTaGFkZXIoY29tcGlsZU9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhY2hlRW50cnkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBnbHNsU2hhZGVyLnNvdXJjZSwgdW5pZm9ybVNldHRlcjogZ2xzbFNoYWRlci51bmlmb3JtU2V0dGVyLCBzcGFjZUluZm86IHNwYWNlSW5mb1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybVNldHRlciA9IGdsc2xTaGFkZXIudW5pZm9ybVNldHRlcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50OiBnbHNsU2hhZGVyLnNvdXJjZSwgdmVydGV4OiB0aGlzLmNyZWF0ZVZlcnRleFNoYWRlcih2c1JlcXVlc3QsIHZzRGF0YVJlc3VsdCwgc3BhY2VJbmZvKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNjZW5lLmRlZmVycmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVFbnRyeS5zaWduYXR1cmVzID0gd29ya1NldC5nZXRQcm9jZXNzaW5nRGF0YShcImNvbG9yQ2xvc3VyZVNpZ25hdHVyZXNcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoT3B0aW9ucy5nZXRWYWx1ZShcInNoYWRlanMtY2FjaGVcIikpXHJcbiAgICAgICAgICAgICAgICAgICAgY19qc1NoYWRlckNhY2hlW2pzU2hhZGVyS2V5XSA9IGNhY2hlRW50cnk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIFN5c3RlbU5vdGlmaWVyLnNlbmRFdmVudCgnc2hhZGVqcycsIHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFkZWpzVHlwZTogXCJlcnJvclwiLCBldmVudDogZSwgY29kZTogdGhpcy5zb3VyY2VUZW1wbGF0ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFwiU2hhZGUuanMgQ29tcGlsZSBFcnJvcjpcXG5cIiArIGUubWVzc2FnZSArIFwiXFxuLS0tLS0tLS0tLS0tXFxuXCIgKyBcIlNoYWRlciBTb3VyY2U6XCIgKyBcIlxcbi0tLS0tLS0tLS0tLVxcblwiICsgWE1MM0QuZGVidWcuZm9ybWF0U291cmNlQ29kZSh0aGlzLnNvdXJjZVRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc291cmNlID0ge1xyXG4gICAgICAgICAgICBmcmFnbWVudDogY2FjaGVFbnRyeS5zb3VyY2UsIHZlcnRleDogdGhpcy5jcmVhdGVWZXJ0ZXhTaGFkZXIodnNSZXF1ZXN0LCB2c0RhdGFSZXN1bHQsIGNhY2hlRW50cnkuc3BhY2VJbmZvKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVuaWZvcm1TZXR0ZXIgPSBjYWNoZUVudHJ5LnVuaWZvcm1TZXR0ZXI7XHJcbiAgICAgICAgaWYgKHNjZW5lLmRlZmVycmVkKSB7XHJcbiAgICAgICAgICAgIHNjZW5lLmNvbG9yQ2xvc3VyZVNpZ25hdHVyZXMucHVzaC5hcHBseShzY2VuZS5jb2xvckNsb3N1cmVTaWduYXR1cmVzLCBjYWNoZUVudHJ5LnNpZ25hdHVyZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIGVycm9ycy5cclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1Zyh0aGlzLnNvdXJjZS52ZXJ0ZXgpO1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKHRoaXMuc291cmNlLmZyYWdtZW50KTtcclxuXHJcbiAgICAgICAgU3lzdGVtTm90aWZpZXIuc2VuZEV2ZW50KCdzaGFkZWpzJywge1xyXG4gICAgICAgICAgICBzaGFkZWpzVHlwZTogXCJzdWNjZXNzXCIsIHZlcnRleFNoYWRlcjogdGhpcy5zb3VyY2UudmVydGV4LCBmcmFnbWVudFNoYWRlcjogdGhpcy5zb3VyY2UuZnJhZ21lbnRcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVZlcnRleFNoYWRlcjogZnVuY3Rpb24gKHZzUmVxdWVzdCwgdnNEYXRhUmVzdWx0LCBzcGFjZUluZm8pIHtcclxuICAgICAgICB2YXIgdnNDb25maWcgPSB2c1JlcXVlc3QuZ2V0Q29uZmlnKCk7XHJcbiAgICAgICAgdmFyIG5hbWVzID0gdnNEYXRhUmVzdWx0Lm91dHB1dE5hbWVzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY2hhbm5lbFZzQXR0cmlidXRlKHZzQ29uZmlnLCBuYW1lc1tpXSwgc3BhY2VJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdnNDb25maWcuYWRkSW5wdXRQYXJhbWV0ZXIoWEMuREFUQV9UWVBFLkZMT0FUNFg0LCBcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIiwgdHJ1ZSk7XHJcbiAgICAgICAgdnNDb25maWcuYWRkQ29kZUZyYWdtZW50KFwiZ2xfUG9zaXRpb24gPSBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ICogdmVjNCgjSXtwb3NpdGlvbn0sIDEuMCk7XCIpO1xyXG4gICAgICAgIHJldHVybiB2c1JlcXVlc3QuZ2V0VmVydGV4U2hhZGVyKCkuZ2V0R0xTTENvZGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VW5pZm9ybVZhcmlhYmxlczogZnVuY3Rpb24gKGVudk5hbWVzLCBzeXNOYW1lcywgaW5wdXRDb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy51bmlmb3JtU2V0dGVyKGVudk5hbWVzLCBzeXNOYW1lcywgaW5wdXRDb2xsZWN0aW9uLCB0aGlzLnByb2dyYW0uc2V0VW5pZm9ybVZhcmlhYmxlLmJpbmQodGhpcy5wcm9ncmFtKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRyYW5zcGFyZW5jeUZyb21JbnB1dERhdGE6IGZ1bmN0aW9uIChkYXRhTWFwKSB7XHJcbiAgICAgICAgLy8gVE9ETzogQ29tcHV0ZSBUcmFuc3BhcmVuY3lcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qIERlZmF1bHQgdmFsdWVzIGFyZSBjb21waWxlZCBpbnRvIHNoYWRlLmpzICovXHJcbiAgICBzZXREZWZhdWx0VW5pZm9ybXM6IGZ1bmN0aW9uICgpIHtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEpTU2hhZGVyQ2xvc3VyZTtcclxuXHJcbiIsInZhciBBYnN0cmFjdFNoYWRlckNvbXBvc2VyID0gcmVxdWlyZShcIi4vLi4vYWJzdHJhY3RzaGFkZXJjb21wb3Nlci5qc1wiKS5BYnN0cmFjdFNoYWRlckNvbXBvc2VyO1xyXG52YXIgSlNTaGFkZXJDbG9zdXJlID0gcmVxdWlyZShcIi4vanNzaGFkZXJjbG9zdXJlLmpzXCIpO1xyXG52YXIgVlNDb25maWcgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4veGZsb3cvcHJvY2Vzc2luZy92cy1jb25uZWN0LmpzXCIpLlZTQ29uZmlnO1xyXG52YXIgVmVydGV4U2hhZGVyUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5WZXJ0ZXhTaGFkZXJSZXF1ZXN0O1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge0dMQ29udGV4dH0gY29udGV4dFxyXG4gKiBAcGFyYW0ge01hdGVyaWFsQ29uZmlndXJhdGlvbn0gY29uZmlnXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0U2hhZGVyQ29tcG9zZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgSlNTaGFkZXJDb21wb3NlciA9IGZ1bmN0aW9uIChjb250ZXh0LCBjb25maWcpIHtcclxuICAgIEFic3RyYWN0U2hhZGVyQ29tcG9zZXIuY2FsbCh0aGlzLCBjb250ZXh0LCBjb25maWcpO1xyXG5cclxuICAgIGlmICghd2luZG93LlNoYWRlKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNoYWRlLmpzIGxpYnJhcnkgbm90IGZvdW5kXCIpO1xyXG5cclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcblxyXG4gICAgLyoqIEB0eXBlIHN0cmluZyovXHJcbiAgICB0aGlzLnNvdXJjZVRlbXBsYXRlID0gY29uZmlnLm1vZGVsLnNjcmlwdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZXh0cmFjdGVkUGFyYW1zID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge1hmbG93LkNvbXB1dGVSZXF1ZXN0fG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVxdWVzdCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5zZXRTaGFkZXJJbmZvKGNvbmZpZyk7XHJcbn07XHJcblxyXG5KU1NoYWRlckNvbXBvc2VyLmNvbnZlcnRTeXNOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHJldHVybiBuYW1lO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoSlNTaGFkZXJDb21wb3NlciwgQWJzdHJhY3RTaGFkZXJDb21wb3Nlciwge1xyXG4gICAgc2V0U2hhZGVySW5mbzogZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXh0cmFjdGVkUGFyYW1zID0gU2hhZGUuZXh0cmFjdFBhcmFtZXRlcnModGhpcy5zb3VyY2VUZW1wbGF0ZSwge2ltcGxlbWVudGF0aW9uOiBcInhtbDNkLWdsc2wtZm9yd2FyZFwifSkuc2hhZGVyUGFyYW1ldGVycztcclxuICAgICAgICAgICAgLy8gRklYTUU6IFNoYWRlci5qcyBzaG91bGQgYWx3YXlzIHJlcXVlc3QgcG9zaXRpb24gKGluIGNhc2VcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGlnbm9yZSBlcnJvcnMgaGVyZS4gVGhleSB3aWxsIHJlb2NjdXIgd2hlbiB1cGRhdGluZyBjb25uZWN0ZWQgbWVzaCBjbG9zdXJlc1xyXG4gICAgICAgICAgICB0aGlzLmV4dHJhY3RlZFBhcmFtcyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5leHRyYWN0ZWRQYXJhbXMuaW5kZXhPZihcInBvc2l0aW9uXCIpID09IC0xKSB0aGlzLmV4dHJhY3RlZFBhcmFtcy5wdXNoKFwicG9zaXRpb25cIik7XHJcblxyXG4gICAgICAgIC8vIFRoZSBjb21wb3NlciBpcyBpbnRlcmVzdGVkIGluIGNoYW5nZXMgb2YgYWxsIHBvc3NpYmxlIHNoYWRlciBwYXJhbWV0ZXJzIChleHRyYWN0ZWQpXHJcbiAgICAgICAgLy8gdGhlIGluc3RhbmNlcyAoY2xvc3VyZXMpIHdpbGwgb25seSBzZXQgdGhvc2UsIHRoYXQgb2NjdXIgaW4gdGhlIGluc3RhbmNlXHJcbiAgICAgICAgaWYgKHRoaXMuZXh0cmFjdGVkUGFyYW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlcXVlc3QoY29uZmlnLmRhdGFOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFJlcXVlc3RGaWVsZHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0ZWRQYXJhbXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFNoYWRlckF0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge2NvbG9yOiBudWxsLCBub3JtYWw6IG51bGwsIHRleGNvb3JkOiBudWxsfTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlU2hhZGVyQ2xvc3VyZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSlNTaGFkZXJDbG9zdXJlKHRoaXMuY29udGV4dCwgdGhpcy5zb3VyY2VUZW1wbGF0ZSwgdGhpcy5leHRyYWN0ZWRQYXJhbXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVPYmplY3REYXRhUmVxdWVzdDogZnVuY3Rpb24gKG9iamVjdERhdGFOb2RlLCBjYWxsYmFjaykge1xyXG5cclxuICAgICAgICB2YXIgdnNDb25maWcgPSBuZXcgVlNDb25maWcoKTtcclxuICAgICAgICB2YXIgbmFtZXMgPSB0aGlzLmV4dHJhY3RlZFBhcmFtcy5zbGljZSgpO1xyXG4gICAgICAgIC8vaWYobmFtZXMuaW5kZXhPZihcInBvc2l0aW9uXCIpID09IC0xKSBuYW1lcy5wdXNoKFwicG9zaXRpb25cIik7XHJcbiAgICAgICAgdnNDb25maWcuYWRkQXR0cmlidXRlKFhDLkRBVEFfVFlQRS5GTE9BVDMsIFwicG9zaXRpb25cIiwgdHJ1ZSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcInBvc2l0aW9uXCIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB2YXIgeGZsb3dJbmZvID0gb2JqZWN0RGF0YU5vZGUuZ2V0T3V0cHV0Q2hhbm5lbEluZm8obmFtZSk7XHJcbiAgICAgICAgICAgIGlmICh4Zmxvd0luZm8pIHtcclxuICAgICAgICAgICAgICAgIHZzQ29uZmlnLmFkZEF0dHJpYnV0ZSh4Zmxvd0luZm8udHlwZSwgbmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZXJ0ZXhTaGFkZXJSZXF1ZXN0KG9iamVjdERhdGFOb2RlLCB2c0NvbmZpZywgY2FsbGJhY2spO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXN0cmlidXRlT2JqZWN0U2hhZGVyRGF0YTogZnVuY3Rpb24gKG9iamVjdFJlcXVlc3QsIGF0dHJpYnV0ZUNhbGxiYWNrLCB1bmlmb3JtQ2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgdmVydGV4U2hhZGVyID0gb2JqZWN0UmVxdWVzdC5nZXRWZXJ0ZXhTaGFkZXIoKTtcclxuICAgICAgICB2YXIgaW5wdXROYW1lcyA9IHZlcnRleFNoYWRlci5pbnB1dE5hbWVzO1xyXG4gICAgICAgIHZhciBpLCBuYW1lLCBlbnRyeTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGlucHV0TmFtZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgbmFtZSA9IGlucHV0TmFtZXNbaV07XHJcbiAgICAgICAgICAgIGVudHJ5ID0gdmVydGV4U2hhZGVyLmdldElucHV0RGF0YShuYW1lKTtcclxuICAgICAgICAgICAgaWYgKHZlcnRleFNoYWRlci5pc0lucHV0VW5pZm9ybShuYW1lKSlcclxuICAgICAgICAgICAgICAgIHVuaWZvcm1DYWxsYmFjayhuYW1lLCBlbnRyeSk7IGVsc2VcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUNhbGxiYWNrKG5hbWUsIGVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG91dHB1dE5hbWVzID0gdmVydGV4U2hhZGVyLm91dHB1dE5hbWVzO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdXRwdXROYW1lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBuYW1lID0gb3V0cHV0TmFtZXNbaV07XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXhTaGFkZXIuaXNPdXRwdXRGcmFnbWVudFVuaWZvcm0obmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHVuaWZvcm1DYWxsYmFjayh2ZXJ0ZXhTaGFkZXIuZ2V0T3V0cHV0U291cmNlTmFtZShuYW1lKSwgdmVydGV4U2hhZGVyLmdldFVuaWZvcm1PdXRwdXREYXRhKG5hbWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSlNTaGFkZXJDb21wb3NlcjtcclxuXHJcblxyXG4iLCJ2YXIgR0xDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvY29udGV4dC5qc1wiKTtcclxudmFyIHNpbmdsZXRvbiA9IG51bGw7XHJcblxyXG52YXIgU1lTVEVNX0NPTlRFWFRfVEVNUExBVEUgPSB7XHJcbiAgICBcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwiYW55XCIsIFwiaW5mb1wiOiB7XHJcbiAgICAgICAgXCJjb29yZHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJmbG9hdDNcIiwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxyXG4gICAgICAgIFwiY2FtZXJhUG9zaXRpb25cIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJmbG9hdDNcIiwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxyXG4gICAgICAgIFwidmlld01hdHJpeFwiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcIm1hdHJpeDRcIiwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxyXG4gICAgICAgIFwidmlld0ludmVyc2VNYXRyaXhcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJtYXRyaXg0XCIsIFwic291cmNlXCI6IFwidW5pZm9ybVwifSxcclxuICAgICAgICBcIm1vZGVsTWF0cml4XCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwibWF0cml4NFwiLCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIn0sXHJcbiAgICAgICAgXCJtb2RlbFZpZXdNYXRyaXhcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJtYXRyaXg0XCIsIFwic291cmNlXCI6IFwidW5pZm9ybVwifSxcclxuICAgICAgICBcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJtYXRyaXg0XCIsIFwic291cmNlXCI6IFwidW5pZm9ybVwifSxcclxuICAgICAgICBcIm1vZGVsTWF0cml4TlwiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcIm1hdHJpeDNcIiwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxyXG4gICAgICAgIFwibW9kZWxWaWV3TWF0cml4TlwiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcIm1hdHJpeDNcIiwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxyXG5cclxuICAgICAgICBcIk1BWF9QT0lOVExJR0hUU1wiOiB7XCJ0eXBlXCI6IFwiaW50XCIsIFwic291cmNlXCI6IFwiY29uc3RhbnRcIiwgXCJzdGF0aWNWYWx1ZVwiOiA1fSxcclxuICAgICAgICBcInBvaW50TGlnaHRPblwiOiB7XCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwiYm9vbGVhblwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwifSxcclxuICAgICAgICBcInBvaW50TGlnaHRBdHRlbnVhdGlvblwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJmbG9hdDNcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJwb2ludExpZ2h0SW50ZW5zaXR5XCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcImZsb2F0M1wifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBvaW50TGlnaHRQb3NpdGlvblwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJmbG9hdDNcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJwb2ludExpZ2h0Q2FzdFNoYWRvd1wiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcImJvb2xlYW5cIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJwb2ludExpZ2h0U2hhZG93Qmlhc1wiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm51bWJlclwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBvaW50TGlnaHRTaGFkb3dNYXBcIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwidGV4dHVyZVwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBvaW50TGlnaHRNYXRyaXhcIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG4gICAgICAgICAgICBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwibWF0cml4NFwifSxcclxuICAgICAgICAgICAgXCJzdGF0aWNTaXplXCI6IDUsXHJcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBvaW50TGlnaHRQcm9qZWN0aW9uXCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcclxuICAgICAgICAgICAgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcIm1hdHJpeDRcIn0sXHJcbiAgICAgICAgICAgIFwic3RhdGljU2l6ZVwiOiA1LFxyXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJwb2ludExpZ2h0TmVhckZhclwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXHJcbiAgICAgICAgICAgIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJmbG9hdDJcIn0sXHJcbiAgICAgICAgICAgIFwic3RhdGljU2l6ZVwiOiA1LFxyXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiTUFYX0RJUkVDVElPTkFMTElHSFRTXCI6IHtcInR5cGVcIjogXCJpbnRcIiwgXCJzb3VyY2VcIjogXCJjb25zdGFudFwiLCBcInN0YXRpY1ZhbHVlXCI6IDV9LFxyXG4gICAgICAgIFwiZGlyZWN0aW9uYWxMaWdodE9uXCI6IHtcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJib29sZWFuXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxyXG4gICAgICAgIFwiZGlyZWN0aW9uYWxMaWdodEludGVuc2l0eVwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJmbG9hdDNcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uXCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcImZsb2F0M1wifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImRpcmVjdGlvbmFsTGlnaHRDYXN0U2hhZG93XCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwiYm9vbGVhblwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImRpcmVjdGlvbmFsTGlnaHRTaGFkb3dCaWFzXCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwibnVtYmVyXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGlyZWN0aW9uYWxMaWdodFNoYWRvd01hcFwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJ0ZXh0dXJlXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGlyZWN0aW9uYWxMaWdodE1hdHJpeFwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXHJcbiAgICAgICAgICAgIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJtYXRyaXg0XCJ9LFxyXG4gICAgICAgICAgICBcInN0YXRpY1NpemVcIjogNSxcclxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIk1BWF9TUE9UTElHSFRTXCI6IHtcInR5cGVcIjogXCJpbnRcIiwgXCJzb3VyY2VcIjogXCJjb25zdGFudFwiLCBcInN0YXRpY1ZhbHVlXCI6IDV9LFxyXG4gICAgICAgIFwic3BvdExpZ2h0T25cIjoge1widHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcImJvb2xlYW5cIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIn0sXHJcbiAgICAgICAgXCJzcG90TGlnaHRBdHRlbnVhdGlvblwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJmbG9hdDNcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzcG90TGlnaHRJbnRlbnNpdHlcIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwiZmxvYXQzXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic3BvdExpZ2h0UG9zaXRpb25cIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwiZmxvYXQzXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic3BvdExpZ2h0RGlyZWN0aW9uXCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcImZsb2F0M1wifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNwb3RMaWdodENvc0ZhbGxvZmZBbmdsZVwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm51bWJlclwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNwb3RMaWdodENvc1NvZnRGYWxsb2ZmQW5nbGVcIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJudW1iZXJcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzcG90TGlnaHRDYXN0U2hhZG93XCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwiYm9vbGVhblwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNwb3RMaWdodFNoYWRvd0JpYXNcIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJudW1iZXJcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzcG90TGlnaHRTaGFkb3dNYXBcIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwidGV4dHVyZVwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNwb3RMaWdodE1hdHJpeFwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXHJcbiAgICAgICAgICAgIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJtYXRyaXg0XCJ9LFxyXG4gICAgICAgICAgICBcInN0YXRpY1NpemVcIjogNSxcclxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic3Nhb01hcFwiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcInRleHR1cmVcIiwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxyXG4gICAgICAgIFwiZW52aXJvbm1lbnRcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJ0ZXh0dXJlXCIsIFwic291cmNlXCI6IFwidW5pZm9ybVwifVxyXG4gICAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3lzdGVtQ29uZmlndXJhdGlvbihjb250ZXh0KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gU1lTVEVNX0NPTlRFWFRfVEVNUExBVEU7XHJcbiAgICB2YXIgZXh0ID0gY29udGV4dC5nZXRFeHRlbnNpb25CeU5hbWUoR0xDb250ZXh0LkVYVEVOU0lPTlMuU1RBTkRBUkRfREVSSVZBVEVTKTtcclxuICAgIGlmIChleHQpIHtcclxuICAgICAgICByZXN1bHQuaW5mby5md2lkdGggPSB7dHlwZTogU2hhZGUuVFlQRVMuRlVOQ1RJT059O1xyXG4gICAgICAgIHJlc3VsdC5pbmZvLmR4ID0ge3R5cGU6IFNoYWRlLlRZUEVTLkZVTkNUSU9OfTtcclxuICAgICAgICByZXN1bHQuaW5mby5keSA9IHt0eXBlOiBTaGFkZS5UWVBFUy5GVU5DVElPTn07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgaWYgKCFzaW5nbGV0b24pIHtcclxuICAgICAgICBzaW5nbGV0b24gPSBjcmVhdGVTeXN0ZW1Db25maWd1cmF0aW9uKGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNpbmdsZXRvbjtcclxufTtcclxuXHJcblxyXG5cclxuIiwidmFyIEpTU2hhZGVyQ29tcG9zZXIgPSByZXF1aXJlKFwiLi9qcy9qc3NoYWRlcmNvbXBvc2VyLmpzXCIpO1xyXG52YXIgVVJOU2hhZGVyQ29tcG9zZXIgPSByZXF1aXJlKFwiLi91cm4vdXJuc2hhZGVyY29tcG9zZXIuanNcIik7XHJcbnZhciBEZWZhdWx0Q29tcG9zZXIgPSByZXF1aXJlKFwiLi9hYnN0cmFjdHNoYWRlcmNvbXBvc2VyLmpzXCIpLkRlZmF1bHRDb21wb3NlcjtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0dMQ29udGV4dH0gY29udGV4dFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBTaGFkZXJDb21wb3NlckZhY3RvcnkgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsIElTaGFkZXJDb21wb3Nlcj59ICovXHJcbiAgICB0aGlzLmNvbXBvc2VycyA9IHt9O1xyXG4gICAgdGhpcy5kZWZhdWx0Q29tcG9zZXIgPSBuZXcgRGVmYXVsdENvbXBvc2VyKGNvbnRleHQpO1xyXG4gICAgdGhpcy5saWdodFZhbHVlc0RpcnR5ID0gdHJ1ZTtcclxufTtcclxuXHJcblxyXG5YTUwzRC5leHRlbmQoU2hhZGVyQ29tcG9zZXJGYWN0b3J5LnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtNYXRlcmlhbENvbmZpZ3VyYXRpb259IG1hdGVyaWFsQ29uZmlndXJhdGlvblxyXG4gICAgICogQHJldHVybnMge0lTaGFkZXJDb21wb3Nlcn1cclxuICAgICAqL1xyXG4gICAgY3JlYXRlQ29tcG9zZXJGcm9tTWF0ZXJpYWxDb25maWd1cmF0aW9uOiBmdW5jdGlvbiAobWF0ZXJpYWxDb25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFtYXRlcmlhbENvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdENvbXBvc2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jb21wb3NlcnNbbWF0ZXJpYWxDb25maWd1cmF0aW9uLmlkXTtcclxuICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGVsVHlwZSA9IG1hdGVyaWFsQ29uZmlndXJhdGlvbi5tb2RlbC50eXBlO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlbFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidXJuXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBVUk5TaGFkZXJDb21wb3Nlcih0aGlzLmNvbnRleHQsIG1hdGVyaWFsQ29uZmlndXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHRcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L3NoYWRlLWphdmFzY3JpcHRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEpTU2hhZGVyQ29tcG9zZXIodGhpcy5jb250ZXh0LCBtYXRlcmlhbENvbmZpZ3VyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNhbiBub3QgY3JlYXRlIHNoYWRlciBvZiB0eXBlOlwiLCBtb2RlbFR5cGUsIG1hdGVyaWFsQ29uZmlndXJhdGlvbi5tb2RlbClcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiTm8gc2hhZGVyIGNvdWxkIGJlIGNyZWF0ZWQgZm9yICdcIiArIG1hdGVyaWFsQ29uZmlndXJhdGlvbi5uYW1lICsgXCInOlwiLCBlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5kZWZhdWx0Q29tcG9zZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb3NlcnNbbWF0ZXJpYWxDb25maWd1cmF0aW9uLmlkXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5nZXRTdGF0aXN0aWNzKCkubWF0ZXJpYWxzKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCB0aGlzLmRlZmF1bHRDb21wb3NlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VGVtcGxhdGVCeUlkOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb3NlcnNbaWRdO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChzY2VuZSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5jb21wb3NlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb3NlcnNbaV0udXBkYXRlKHNjZW5lLCB7dXBkYXRlTGlnaHRWYWx1ZXM6IHRoaXMubGlnaHRWYWx1ZXNEaXJ0eX0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxpZ2h0VmFsdWVzRGlydHkgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0TGlnaHRTdHJ1Y3R1cmVEaXJ0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2V0U2hhZGVyUmVjb21waWxlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNoYWRlclJlY29tcGlsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5jb21wb3NlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb3NlcnNbaV0uc2V0U2hhZGVyUmVjb21waWxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVTeXN0ZW1Vbmlmb3JtczogZnVuY3Rpb24gKG5hbWVzLCBzY2VuZSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5jb21wb3NlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb3NlcnNbaV0udXBkYXRlU3lzdGVtVW5pZm9ybXMobmFtZXMsIHNjZW5lKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldExpZ2h0VmFsdWVDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmNvbXBvc2Vycykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvc2Vyc1tpXS51cGRhdGVMaWdodFZhbHVlcyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNoYWRlckNvbXBvc2VyRmFjdG9yeTtcclxuXHJcblxyXG4iLCJ2YXIgRVZFTlRfVFlQRSA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJlci9zY2VuZS9jb25zdGFudHMuanNcIikuRVZFTlRfVFlQRTtcclxudmFyIFRhcmdldHMgPSByZXF1aXJlKFwiLi4vYmFzZS9yZW5kZXJ0YXJnZXRcIik7XHJcblxyXG52YXIgTGlnaHRQYXNzID0gcmVxdWlyZShcIi4uL3JlbmRlci1wYXNzZXMvbGlnaHQtcGFzc1wiKTtcclxudmFyIFBvaW50TGlnaHRQYXNzID0gcmVxdWlyZShcIi4uL3JlbmRlci1wYXNzZXMvcG9pbnRsaWdodC1wYXNzXCIpO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XHJcbiAqIEBwYXJhbSB7R0xTY2VuZX0gc2NlbmVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgU2hhZG93TWFwU2VydmljZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBzY2VuZSkge1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIHNjZW5lLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfVFlQRS5MSUdIVF9TVFJVQ1RVUkVfQ0hBTkdFRCwgdGhpcy5vbkxpZ2h0U3RydWN0dXJlQ2hhbmdlZC5iaW5kKHRoaXMpKTtcclxuICAgIHNjZW5lLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfVFlQRS5MSUdIVF9WQUxVRV9DSEFOR0VELCB0aGlzLm9uTGlnaHRWYWx1ZUNoYW5nZWQuYmluZCh0aGlzKSk7XHJcbiAgICBzY2VuZS5hZGRFdmVudExpc3RlbmVyKEVWRU5UX1RZUEUuU0NFTkVfU0hBUEVfQ0hBTkdFRCwgdGhpcy5vblNjZW5lU2hhcGVDaGFuZ2VkLmJpbmQodGhpcykpO1xyXG5cclxuICAgIHRoaXMuc2hhZG93TWFwSW5mb3MgPSBbXTtcclxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG59O1xyXG5cclxuWE1MM0QuZXh0ZW5kKFNoYWRvd01hcFNlcnZpY2UucHJvdG90eXBlLCB7XHJcbiAgICBvbkxpZ2h0U3RydWN0dXJlQ2hhbmdlZDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIGxpZ2h0ID0gZXZlbnQubGlnaHQsIHJlbW92ZSA9IGxpZ2h0LnJlbW92ZWQsIHNoYWRvd01hcEluZm9zID0gdGhpcy5zaGFkb3dNYXBJbmZvcztcclxuICAgICAgICBpZiAocmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUxpZ2h0KHNoYWRvd01hcEluZm9zLCBsaWdodCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGxpZ2h0TmVlZHNTaGFkb3dNYXAobGlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRMaWdodChzaGFkb3dNYXBJbmZvcywgbGlnaHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyaW5nKFwibGlnaHQgYWRkZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG9uTGlnaHRWYWx1ZUNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnJlcXVlc3RSZW5kZXJpbmcoXCJsaWdodCB2YWx1ZSBjaGFuZ2VkXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblNjZW5lU2hhcGVDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyaW5nKFwic2NlbmUgc2hhcGUgY2hhbmdlZFwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVxdWVzdFJlbmRlcmluZzogZnVuY3Rpb24ocmVhc29uKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZUZvclJlbmRlcmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB2YXIgc2hhZG93TWFwcyA9IHRoaXMuc2hhZG93TWFwSW5mb3M7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhZG93TWFwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc2hhZG93TWFwc1tpXS5wYXNzLnJlbmRlclNjZW5lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZmlsbEdsb2JhbFBhcmFtZXRlcnM6IGZ1bmN0aW9uKGdsb2JhbHMpIHtcclxuICAgICAgICB2YXIgc2hhZG93VW5pdHMgPSBtZXJnZVNoYWRvd1BhcmFtZXRlcnModGhpcy5zaGFkb3dNYXBJbmZvcylcclxuICAgICAgICBYTUwzRC5leHRlbmQoZ2xvYmFscywgc2hhZG93VW5pdHMpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5mdW5jdGlvbiBsaWdodE5lZWRzU2hhZG93TWFwKGxpZ2h0KSB7XHJcbiAgICByZXR1cm4gISFsaWdodC5tb2RlbC5nZXRQYXJhbWV0ZXIoXCJjYXN0U2hhZG93XCIpWzBdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRMaWdodChzaGFkb3dNYXBJbmZvcywgbGlnaHQpIHtcclxuICAgIHZhciBjb250ZXh0ID0gbGlnaHQuc2NlbmUuY29udGV4dDtcclxuICAgIHZhciBwYXNzSW5mbyA9IGNyZWF0ZVBhc3NJbmZvKGxpZ2h0LCBjb250ZXh0KTtcclxuICAgIHNoYWRvd01hcEluZm9zLnB1c2gocGFzc0luZm8pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlTGlnaHQoc2hhZG93TWFwSW5mb3MsIGxpZ2h0KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYWRvd01hcEluZm9zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHNoYWRvd01hcEluZm9zW2ldLmxpZ2h0ID09PSBsaWdodCkge1xyXG4gICAgICAgICAgICBzaGFkb3dNYXBJbmZvcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBGcmVlIHBhc3MgYW5kIG90aGVyIHJlc291cmNlcywgZnJlZSB0ZXh0dXJlIHNsb3RcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUGFzc0luZm8obGlnaHQsIGNvbnRleHQpIHtcclxuICAgIHZhciBzaXplID0gTWF0aC5tYXgoY29udGV4dC5jYW52YXNUYXJnZXQud2lkdGgsIGNvbnRleHQuY2FudmFzVGFyZ2V0LmhlaWdodCkgKiAyO1xyXG4gICAgdmFyIHBhcmFtcyA9IHtcclxuICAgICAgICB3aWR0aDogc2l6ZSxcclxuICAgICAgICBoZWlnaHQ6IHNpemUsXHJcbiAgICAgICAgY29sb3JGb3JtYXQ6IGNvbnRleHQuZ2wuUkdCQSxcclxuICAgICAgICBkZXB0aEZvcm1hdDogY29udGV4dC5nbC5ERVBUSF9DT01QT05FTlQxNixcclxuICAgICAgICBzdGVuY2lsRm9ybWF0OiBudWxsLFxyXG4gICAgICAgIGRlcHRoQXNSZW5kZXJidWZmZXI6IHRydWVcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHBhc3MgPSBsaWdodC5tb2RlbC5pZCA9PSBcInBvaW50XCIgPyBjcmVhdGVQb2ludExpZ2h0UGFzcyhsaWdodCwgY29udGV4dCwgcGFyYW1zKSA6IGNyZWF0ZUxpZ2h0UGFzcyhsaWdodCwgY29udGV4dCwgcGFyYW1zKTtcclxuICAgIHBhc3MuaW5pdChjb250ZXh0KTtcclxuXHJcbiAgICAvLyBCaW5kIHRhcmdldCBpbiBvcmRlciB0byBjcmVhdGUgdGV4dHVyZSBtYXBcclxuICAgIHBhc3Mub3V0cHV0LmJpbmQoKTtcclxuXHJcbiAgICAvLyBUT0RPOiBCZXR0ZXIgd2F5IHRvIGZpeCB0aGUgdGV4dHVyZSB1bml0P1xyXG4gICAgdmFyIHVuaXRFbnRyeSA9IGNvbnRleHQudGV4dHVyZU1hbmFnZXIuZ2V0RW50cnkocGFzcy5vdXRwdXQuY29sb3JUYXJnZXQuaGFuZGxlLmlkKTtcclxuICAgIHVuaXRFbnRyeS5maXhlZCA9IHRydWU7XHJcblxyXG4gICAgcGFzcy5vdXRwdXQudW5iaW5kKCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsaWdodDogbGlnaHQsIHBhc3M6IHBhc3MsIHNsb3Q6IHVuaXRFbnRyeS5zbG90XHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGlnaHRQYXNzKGxpZ2h0LCBjb250ZXh0LCBwYXJhbXMpIHtcclxuICAgIHZhciBsaWdodEZyYW1lYnVmZmVyID0gbmV3IFRhcmdldHMuR0xSZW5kZXJUYXJnZXQoY29udGV4dCwgcGFyYW1zKTtcclxuICAgIHJldHVybiBuZXcgTGlnaHRQYXNzKHtjb250ZXh0OiBjb250ZXh0fSwgbGlnaHRGcmFtZWJ1ZmZlciwgbGlnaHQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVQb2ludExpZ2h0UGFzcyhsaWdodCwgY29udGV4dCwgcGFyYW1zKSB7XHJcbiAgICB2YXIgbGlnaHRGcmFtZWJ1ZmZlciA9IG5ldyBUYXJnZXRzLkdMQ3ViZU1hcFJlbmRlclRhcmdldChjb250ZXh0LCBwYXJhbXMpO1xyXG4gICAgcmV0dXJuIG5ldyBQb2ludExpZ2h0UGFzcyh7Y29udGV4dDogY29udGV4dH0sIGxpZ2h0RnJhbWVidWZmZXIsIGxpZ2h0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWVyZ2VTaGFkb3dQYXJhbWV0ZXJzKHNoYWRvd01hcEluZm9zKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBbXCJzcG90XCIsIFwicG9pbnRcIiwgXCJkaXJlY3Rpb25hbFwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdmFyIHNhbWVNb2RlbCA9IHNoYWRvd01hcEluZm9zLmZpbHRlcihmdW5jdGlvbihpbmZvKSB7IHJldHVybiBpbmZvLmxpZ2h0Lm1vZGVsLmlkID09IG1vZGVsOyB9KVxyXG4gICAgICAgIHJlc3VsdFttb2RlbCArIFwiTGlnaHRTaGFkb3dNYXBcIl0gPSBzYW1lTW9kZWwubWFwKGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmZvLnNsb3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2hhZG93TWFwU2VydmljZTtcclxuIiwiWE1MM0Quc2hhZGVycy5yZWdpc3RlcihcImRpZmZ1c2VcIiwge1xyXG5cclxuICAgIHZlcnRleCA6IFtcclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgbm9ybWFsO1wiLFxyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgY29sb3I7XCIsXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiB0ZXhjb29yZDtcIixcclxuXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ05vcm1hbDtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4UG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ0V5ZVZlY3RvcjtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMiBmcmFnVGV4Q29vcmQ7XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleENvbG9yO1wiLFxyXG5cclxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDtcIixcclxuICAgICAgICBcInVuaWZvcm0gbWF0MyBtb2RlbFZpZXdNYXRyaXhOO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGV5ZVBvc2l0aW9uO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICAgdmVjMyBwb3MgPSBwb3NpdGlvbjtcIixcclxuICAgICAgICBcIiAgICB2ZWMzIG5vcm0gPSBub3JtYWw7XCIsXHJcblxyXG4gICAgICAgIFwiICAgIGdsX1Bvc2l0aW9uID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQocG9zLCAxLjApO1wiLFxyXG4gICAgICAgIFwiICAgIGZyYWdOb3JtYWwgPSBub3JtYWxpemUobW9kZWxWaWV3TWF0cml4TiAqIG5vcm0pO1wiLFxyXG4gICAgICAgIFwiICAgIGZyYWdWZXJ0ZXhQb3NpdGlvbiA9IChtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvcywgMS4wKSkueHl6O1wiLFxyXG4gICAgICAgIFwiICAgIGZyYWdFeWVWZWN0b3IgPSBub3JtYWxpemUoZnJhZ1ZlcnRleFBvc2l0aW9uKTtcIixcclxuICAgICAgICBcIiAgICBmcmFnVGV4Q29vcmQgPSB0ZXhjb29yZDtcIixcclxuICAgICAgICBcIiAgICBmcmFnVmVydGV4Q29sb3IgPSBjb2xvcjtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIGZyYWdtZW50IDogW1xyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCBhbWJpZW50SW50ZW5zaXR5O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2VDb2xvcjtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZUNvbG9yO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCB0cmFuc3BhcmVuY3k7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcIixcclxuICAgICAgICBcInVuaWZvcm0gYm9vbCB1c2VWZXJ0ZXhDb2xvcjtcIixcclxuXHJcbiAgICAgICAgXCIjaWYgSEFTX0VNSVNTSVZFVEVYVFVSRVwiLFxyXG4gICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVUZXh0dXJlO1wiLFxyXG4gICAgICAgIFwiI2VuZGlmXCIsXHJcbiAgICAgICAgXCIjaWYgSEFTX0RJRkZVU0VURVhUVVJFXCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBkaWZmdXNlVGV4dHVyZTtcIixcclxuICAgICAgICBcIiNlbmRpZlwiLFxyXG5cclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnTm9ybWFsO1wiLFxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdWZXJ0ZXhQb3NpdGlvbjtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnRXllVmVjdG9yO1wiLFxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMyIGZyYWdUZXhDb29yZDtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4Q29sb3I7XCIsXHJcblxyXG4gICAgICAgIFwiI2lmIE1BWF9QT0lOVExJR0hUUyA+IDBcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0QXR0ZW51YXRpb25bTUFYX1BPSU5UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bTUFYX1BPSU5UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0SW50ZW5zaXR5W01BWF9QT0lOVExJR0hUU107XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIGJvb2wgcG9pbnRMaWdodE9uW01BWF9QT0lOVExJR0hUU107XCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgXCIjaWYgTUFYX0RJUkVDVElPTkFMTElHSFRTID4gMFwiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bTUFYX0RJUkVDVElPTkFMTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0SW50ZW5zaXR5W01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIGJvb2wgZGlyZWN0aW9uYWxMaWdodE9uW01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgXCIjaWYgTUFYX1NQT1RMSUdIVFMgPiAwXCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0QXR0ZW51YXRpb25bTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uW01BWF9TUE9UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRJbnRlbnNpdHlbTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBib29sIHNwb3RMaWdodE9uW01BWF9TUE9UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHRDb3NGYWxsb2ZmQW5nbGVbTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHRDb3NTb2Z0RmFsbG9mZkFuZ2xlW01BWF9TUE9UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0U29mdG5lc3NbTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwiI2VuZGlmXCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgZmxvYXQgYWxwaGEgPSAgbWF4KDAuMCwgMS4wIC0gdHJhbnNwYXJlbmN5KTtcIixcclxuICAgICAgICBcIiAgdmVjMyBvYmpEaWZmdXNlID0gZGlmZnVzZUNvbG9yO1wiLFxyXG4gICAgICAgIFwiICBpZih1c2VWZXJ0ZXhDb2xvcilcIixcclxuICAgICAgICBcIiAgICBvYmpEaWZmdXNlICo9IGZyYWdWZXJ0ZXhDb2xvcjtcIixcclxuICAgICAgICBcIiAgI2lmIEhBU19ESUZGVVNFVEVYVFVSRVwiLFxyXG4gICAgICAgIFwiICAgIHZlYzQgdGV4RGlmZnVzZSA9IHRleHR1cmUyRChkaWZmdXNlVGV4dHVyZSwgZnJhZ1RleENvb3JkKTtcIixcclxuICAgICAgICBcIiAgICBhbHBoYSAqPSB0ZXhEaWZmdXNlLmE7XCIsXHJcbiAgICAgICAgXCIgICAgb2JqRGlmZnVzZSAqPSB0ZXhEaWZmdXNlLnJnYjtcIixcclxuICAgICAgICBcIiAgI2VuZGlmXCIsXHJcbiAgICAgICAgXCIgIGlmIChhbHBoYSA8IDAuMDUpIGRpc2NhcmQ7XCIsXHJcblxyXG4gICAgICAgIFwiICAjaWYgSEFTX0VNSVNTSVZFVEVYVFVSRVwiLFxyXG4gICAgICAgIFwiICAgIHZlYzMgY29sb3IgPSBlbWlzc2l2ZUNvbG9yICogdGV4dHVyZTJEKGVtaXNzaXZlVGV4dHVyZSwgZnJhZ1RleENvb3JkKS5yZ2IgKyAoYW1iaWVudEludGVuc2l0eSAqIG9iakRpZmZ1c2UpO1wiLFxyXG4gICAgICAgIFwiICAjZWxzZVwiLFxyXG4gICAgICAgIFwiICAgIHZlYzMgY29sb3IgPSBlbWlzc2l2ZUNvbG9yICsgKGFtYmllbnRJbnRlbnNpdHkgKiBvYmpEaWZmdXNlKTtcIixcclxuICAgICAgICBcIiAgI2VuZGlmXCIsXHJcblxyXG4gICAgICAgIFwiICAjaWYgTUFYX1BPSU5UTElHSFRTID4gMFwiLFxyXG4gICAgICAgIFwiICAgIGZvciAoaW50IGk9MDsgaTxNQVhfUE9JTlRMSUdIVFM7IGkrKykge1wiLFxyXG4gICAgICAgIFwiICAgICAgaWYgKCFwb2ludExpZ2h0T25baV0pXCIsXHJcbiAgICAgICAgXCIgICAgICAgICBjb250aW51ZTtcIixcclxuICAgICAgICBcIiAgICAgIHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuICAgICAgICBcIiAgICAgIHZlYzMgTCA9IGxQb3NpdGlvbi54eXogLSBmcmFnVmVydGV4UG9zaXRpb247XCIsXHJcbiAgICAgICAgXCIgICAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKEwpO1wiLFxyXG4gICAgICAgIFwiICAgICAgTCA9IG5vcm1hbGl6ZShMKTtcIixcclxuICAgICAgICBcIiAgICAgIGZsb2F0IGF0dGVuID0gMS4wIC8gKHBvaW50TGlnaHRBdHRlbnVhdGlvbltpXS54ICsgcG9pbnRMaWdodEF0dGVudWF0aW9uW2ldLnkgKiBkaXN0ICsgcG9pbnRMaWdodEF0dGVudWF0aW9uW2ldLnogKiBkaXN0ICogZGlzdCk7XCIsXHJcbiAgICAgICAgXCIgICAgICB2ZWMzIElkaWZmID0gcG9pbnRMaWdodEludGVuc2l0eVtpXSAqIG9iakRpZmZ1c2UgKiBtYXgoZG90KGZyYWdOb3JtYWwsTCksMC4wKTtcIixcclxuICAgICAgICBcIiAgICAgIGNvbG9yID0gY29sb3IgKyBhdHRlbipJZGlmZjtcIixcclxuICAgICAgICBcIiAgICB9XCIsXHJcbiAgICAgICAgXCIgICNlbmRpZlwiLFxyXG5cclxuICAgICAgICBcIiNpZiBNQVhfRElSRUNUSU9OQUxMSUdIVFMgPiAwXCIsXHJcbiAgICAgICAgXCIgIGZvciAoaW50IGk9MDsgaTxNQVhfRElSRUNUSU9OQUxMSUdIVFM7IGkrKykge1wiLFxyXG4gICAgICAgIFwiICAgICAgaWYgKCFkaXJlY3Rpb25hbExpZ2h0T25baV0pXCIsXHJcbiAgICAgICAgXCIgICAgICAgICBjb250aW51ZTtcIixcclxuICAgICAgICBcIiAgICB2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNChkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uW2ldLCAwLjApO1wiLFxyXG4gICAgICAgIFwiICAgIHZlYzMgTCA9ICBub3JtYWxpemUoLWxEaXJlY3Rpb24ueHl6KTtcIixcclxuICAgICAgICBcIiAgICB2ZWMzIElkaWZmID0gZGlyZWN0aW9uYWxMaWdodEludGVuc2l0eVtpXSAqIG9iakRpZmZ1c2UgKiBtYXgoZG90KGZyYWdOb3JtYWwsTCksMC4wKTtcIixcclxuICAgICAgICBcIiAgICBjb2xvciA9IGNvbG9yICsgSWRpZmY7XCIsXHJcbiAgICAgICAgXCIgIH1cIixcclxuICAgICAgICBcIiNlbmRpZlwiLFxyXG5cclxuICAgICAgICBcIiNpZiBNQVhfU1BPVExJR0hUUyA+IDBcIixcclxuICAgICAgICBcIiAgZm9yIChpbnQgaT0wOyBpPE1BWF9TUE9UTElHSFRTOyBpKyspIHtcIixcclxuICAgICAgICBcIiAgICAgIGlmICghc3BvdExpZ2h0T25baV0pXCIsXHJcbiAgICAgICAgXCIgICAgICAgICBjb250aW51ZTtcIixcclxuICAgICAgICBcIiAgICB2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBzcG90TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuICAgICAgICBcIiAgICB2ZWMzIEwgPSBsUG9zaXRpb24ueHl6IC0gZnJhZ1ZlcnRleFBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwiICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoTCk7XCIsXHJcbiAgICAgICAgXCIgICAgTCA9IG5vcm1hbGl6ZShMKTtcIixcclxuICAgICAgICBcIiAgICBmbG9hdCBhdHRlbiA9IDEuMCAvIChzcG90TGlnaHRBdHRlbnVhdGlvbltpXS54ICsgc3BvdExpZ2h0QXR0ZW51YXRpb25baV0ueSAqIGRpc3QgKyBzcG90TGlnaHRBdHRlbnVhdGlvbltpXS56ICogZGlzdCAqIGRpc3QpO1wiLFxyXG4gICAgICAgIFwiICAgIHZlYzMgSWRpZmYgPSBzcG90TGlnaHRJbnRlbnNpdHlbaV0gKiBvYmpEaWZmdXNlICogbWF4KGRvdChmcmFnTm9ybWFsLEwpLDAuMCk7XCIsXHJcbiAgICAgICAgXCIgICAgdmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoLXNwb3RMaWdodERpcmVjdGlvbltpXSwgMC4wKTtcIixcclxuICAgICAgICBcIiAgICB2ZWMzIEQgPSBub3JtYWxpemUobERpcmVjdGlvbi54eXopO1wiLFxyXG4gICAgICAgIFwiICAgIGZsb2F0IGFuZ2xlID0gZG90KEwsIEQpO1wiLFxyXG4gICAgICAgIFwiICAgIGlmKGFuZ2xlID4gc3BvdExpZ2h0Q29zRmFsbG9mZkFuZ2xlW2ldKSB7XCIsXHJcbiAgICAgICAgXCIgICAgICAgZmxvYXQgc29mdG5lc3MgPSAxLjA7XCIsXHJcbiAgICAgICAgXCIgICAgICAgaWYgKGFuZ2xlIDwgc3BvdExpZ2h0Q29zU29mdEZhbGxvZmZBbmdsZVtpXSlcIixcclxuICAgICAgICBcIiAgICAgICAgICAgc29mdG5lc3MgPSAoYW5nbGUgLSBzcG90TGlnaHRDb3NGYWxsb2ZmQW5nbGVbaV0pIC8gIChzcG90TGlnaHRDb3NTb2Z0RmFsbG9mZkFuZ2xlW2ldIC0gIHNwb3RMaWdodENvc0ZhbGxvZmZBbmdsZVtpXSk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgY29sb3IgKz0gYXR0ZW4gKiBzb2Z0bmVzcyAqIElkaWZmO1wiLFxyXG4gICAgICAgIFwiICAgIH1cIixcclxuICAgICAgICBcIiAgfVwiLFxyXG4gICAgICAgIFwiI2VuZGlmXCIsXHJcblxyXG4gICAgICAgIFwiICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCBhbHBoYSk7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICBhZGREaXJlY3RpdmVzOiBmdW5jdGlvbihkaXJlY3RpdmVzLCBsaWdodHMsIHBhcmFtcykge1xyXG4gICAgICAgIFtcInBvaW50XCIsIFwiZGlyZWN0aW9uYWxcIiwgXCJzcG90XCJdLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIG51bUxpZ2h0cyA9IGxpZ2h0cy5nZXRNb2RlbENvdW50KHR5cGUpO1xyXG4gICAgICAgICAgICBkaXJlY3RpdmVzLnB1c2goXCJNQVhfXCIgKyB0eXBlLnRvVXBwZXJDYXNlKCkgKyBcIkxJR0hUUyBcIiArIG51bUxpZ2h0cyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZGlyZWN0aXZlcy5wdXNoKFwiSEFTX0RJRkZVU0VURVhUVVJFIFwiICsgKCdkaWZmdXNlVGV4dHVyZScgaW4gcGFyYW1zID8gXCIxXCIgOiBcIjBcIikpO1xyXG4gICAgICAgIGRpcmVjdGl2ZXMucHVzaChcIkhBU19FTUlTU0lWRVRFWFRVUkUgXCIgKyAoJ2VtaXNzaXZlVGV4dHVyZScgaW4gcGFyYW1zID8gXCIxXCIgOiBcIjBcIikpO1xyXG4gICAgfSxcclxuICAgIGhhc1RyYW5zcGFyZW5jeTogZnVuY3Rpb24ocGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcy50cmFuc3BhcmVuY3kgJiYgcGFyYW1zLnRyYW5zcGFyZW5jeS5nZXRWYWx1ZSgpWzBdID4gMC4wMDE7XHJcbiAgICB9LFxyXG4gICAgdW5pZm9ybXM6IHtcclxuICAgICAgICBkaWZmdXNlQ29sb3IgICAgOiBbMS4wLCAxLjAsIDEuMF0sXHJcbiAgICAgICAgZW1pc3NpdmVDb2xvciAgIDogWzAuMCwgMC4wLCAwLjBdLFxyXG4gICAgICAgIHRyYW5zcGFyZW5jeSAgICA6IDAuMCxcclxuICAgICAgICBhbWJpZW50SW50ZW5zaXR5OiAwLjAsXHJcbiAgICAgICAgdXNlVmVydGV4Q29sb3IgOiBmYWxzZVxyXG4gICAgfSxcclxuICAgIHNhbXBsZXJzOiB7XHJcbiAgICAgICAgZGlmZnVzZVRleHR1cmUgOiBudWxsLFxyXG4gICAgICAgIGVtaXNzaXZlVGV4dHVyZSA6IG51bGxcclxuICAgIH0sXHJcbiAgICBhdHRyaWJ1dGVzOiB7XHJcbiAgICAgICAgbm9ybWFsIDoge1xyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGV4Y29vcmQ6IG51bGwsXHJcbiAgICAgICAgY29sb3I6IG51bGxcclxuICAgIH1cclxufSk7XHJcbiIsIlhNTDNELnNoYWRlcnMucmVnaXN0ZXIoXCJtYXR0ZVwiLCB7XHJcblxyXG4gICAgdmVydGV4OiBbXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcIixcclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1wiLFxyXG5cclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4Q29sb3I7XCIsXHJcblxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXg7XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgIGZyYWdWZXJ0ZXhDb2xvciA9IGNvbG9yO1wiLFxyXG4gICAgICAgIFwiICAgZ2xfUG9zaXRpb24gPSBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIGZyYWdtZW50OiBbXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZUNvbG9yO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBib29sIHVzZVZlcnRleENvbG9yO1wiLFxyXG5cclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4Q29sb3I7XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgICB2ZWMzIGNvbG9yID0gZGlmZnVzZUNvbG9yO1wiLFxyXG4gICAgICAgIFwiICAgIGlmICh1c2VWZXJ0ZXhDb2xvcilcIixcclxuICAgICAgICBcIiAgICAgICBjb2xvciAqPSAgZnJhZ1ZlcnRleENvbG9yO1wiLFxyXG4gICAgICAgIFwiICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuMCk7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICB1bmlmb3Jtczoge1xyXG4gICAgICAgIGRpZmZ1c2VDb2xvciA6IFsxLjAsIDEuMCwgMS4wXSxcclxuICAgICAgICB1c2VWZXJ0ZXhDb2xvcjogZmFsc2VcclxuICAgIH0sXHJcbiAgICBhdHRyaWJ1dGVzOiB7XHJcbiAgICAgICAgY29sb3I6IG51bGwsXHJcbiAgICAgICAgbm9ybWFsOiBudWxsIC8vIEZvciBwaWNraW5nXHJcbiAgICB9XHJcbn0pO1xyXG5cclxuWE1MM0Quc2hhZGVycy5yZWdpc3RlcihcImZsYXRcIiwgWE1MM0Quc2hhZGVycy5nZXRTY3JpcHQoXCJtYXR0ZVwiKSk7XHJcbiIsIlhNTDNELnNoYWRlcnMucmVnaXN0ZXIoXCJwaG9uZ1wiLCB7XHJcblxyXG4gICAgdmVydGV4IDogW1xyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBub3JtYWw7XCIsXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBjb2xvcjtcIixcclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIHRleGNvb3JkO1wiLFxyXG5cclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnTm9ybWFsO1wiLFxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdWZXJ0ZXhQb3NpdGlvbjtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnRXllVmVjdG9yO1wiLFxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMyIGZyYWdUZXhDb29yZDtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4Q29sb3I7XCIsXHJcblxyXG4gICAgICAgIFwiI2lmIChIQVNfUE9JTlRMSUdIVF9TSEFET1dNQVBTIHx8IEhBU19ESVJFQ1RJT05BTExJR0hUX1NIQURPV01BUFMgfHwgSEFTX1NQT1RMSUdIVF9TSEFET1dNQVBTKVwiLFxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdXb3JsZFBvc2l0aW9uO1wiLCAvL25lZWRlZCBieSBhbnkgb2YgdGhlIGxpZ2h0IHR5cGVzXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcIixcclxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDMgbW9kZWxWaWV3TWF0cml4TjtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBleWVQb3NpdGlvbjtcIixcclxuXHJcbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxyXG4gICAgICAgIFwiICAgIHZlYzMgcG9zID0gcG9zaXRpb247XCIsXHJcbiAgICAgICAgXCIgICAgdmVjMyBub3JtID0gbm9ybWFsO1wiLFxyXG4gICAgICAgIFwiICAgIGdsX1Bvc2l0aW9uID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQocG9zLCAxLjApO1wiLFxyXG4gICAgICAgIFwiICAgIGZyYWdOb3JtYWwgPSBub3JtYWxpemUobW9kZWxWaWV3TWF0cml4TiAqIG5vcm0pO1wiLFxyXG4gICAgICAgIFwiICAgIGZyYWdWZXJ0ZXhQb3NpdGlvbiA9IChtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvcywgMS4wKSkueHl6O1wiLFxyXG4gICAgICAgIFwiICAgIGZyYWdFeWVWZWN0b3IgPSBub3JtYWxpemUoZnJhZ1ZlcnRleFBvc2l0aW9uKTtcIixcclxuICAgICAgICBcIiAgICBmcmFnVGV4Q29vcmQgPSB0ZXhjb29yZDtcIixcclxuICAgICAgICBcIiAgICBmcmFnVmVydGV4Q29sb3IgPSBjb2xvcjtcIixcclxuICAgICAgICBcIiNpZiAoSEFTX1BPSU5UTElHSFRfU0hBRE9XTUFQUyB8fCBIQVNfRElSRUNUSU9OQUxMSUdIVF9TSEFET1dNQVBTIHx8IEhBU19TUE9UTElHSFRfU0hBRE9XTUFQUylcIixcclxuICAgICAgICBcIiAgICBmcmFnV29ybGRQb3NpdGlvbiA9IChtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCkpLnh5ejtcIixcclxuICAgICAgICBcIiNlbmRpZlwiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgZnJhZ21lbnQgOiBbXHJcbiAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IGFtYmllbnRJbnRlbnNpdHk7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZUNvbG9yO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlQ29sb3I7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBzcGVjdWxhckNvbG9yO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCB0cmFuc3BhcmVuY3k7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcIixcclxuICAgICAgICBcInVuaWZvcm0gYm9vbCB1c2VWZXJ0ZXhDb2xvcjtcIixcclxuXHRcdFwidW5pZm9ybSB2ZWMzIGNvb3JkcztcIixcclxuXHJcbiAgICAgICAgXCIjaWYgSEFTX0VNSVNTSVZFVEVYVFVSRVwiLFxyXG4gICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVUZXh0dXJlO1wiLFxyXG4gICAgICAgIFwiI2VuZGlmXCIsXHJcbiAgICAgICAgXCIjaWYgSEFTX0RJRkZVU0VURVhUVVJFXCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBkaWZmdXNlVGV4dHVyZTtcIixcclxuICAgICAgICBcIiNlbmRpZlwiLFxyXG4gICAgICAgIFwiI2lmIEhBU19TUEVDVUxBUlRFWFRVUkVcIixcclxuICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyVGV4dHVyZTtcIixcclxuICAgICAgICBcIiNlbmRpZlwiLFxyXG5cclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnTm9ybWFsO1wiLFxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdWZXJ0ZXhQb3NpdGlvbjtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnRXllVmVjdG9yO1wiLFxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMyIGZyYWdUZXhDb29yZDtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4Q29sb3I7XCIsXHJcblxyXG4gICAgICAgIFwiI2lmIChIQVNfUE9JTlRMSUdIVF9TSEFET1dNQVBTIHx8IEhBU19ESVJFQ1RJT05BTExJR0hUX1NIQURPV01BUFMgfHwgSEFTX1NQT1RMSUdIVF9TSEFET1dNQVBTKVwiLFxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdXb3JsZFBvc2l0aW9uO1wiLCAgLy9pZiB0aGVyZSBpcyBTaGFkb3cgd2UgbmVlZCB3b3JsZCBwb3NpdGlvbiBhbmQgdW5wYWNraW5nIGZ1bmN0aW9uXHJcbiAgICAgICAgXCJmbG9hdCB1bnBhY2tEZXB0aCggY29uc3QgaW4gdmVjNCByZ2JhX2RlcHRoICkge1wiLFxyXG4gICAgICAgIFwiICBjb25zdCB2ZWM0IGJpdF9zaGlmdCA9IHZlYzQoIDEuMCAvICggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wICksIDEuMCAvICggMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAyNTYuMCwgMS4wICk7XCIsXHJcbiAgICAgICAgXCIgIGZsb2F0IGRlcHRoID0gZG90KCByZ2JhX2RlcHRoLCBiaXRfc2hpZnQgKTtcIixcclxuICAgICAgICBcIiAgcmV0dXJuIGRlcHRoO1wiLFxyXG4gICAgICAgIFwifVwiLFxyXG4gICAgICAgIFwiI2VuZGlmXCIsXHJcblxyXG4gICAgICAgIFwiI2lmIE1BWF9QT0lOVExJR0hUUyA+IDBcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0QXR0ZW51YXRpb25bTUFYX1BPSU5UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bTUFYX1BPSU5UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0SW50ZW5zaXR5W01BWF9QT0lOVExJR0hUU107XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIGJvb2wgcG9pbnRMaWdodE9uW01BWF9QT0lOVExJR0hUU107XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIGJvb2wgcG9pbnRMaWdodENhc3RTaGFkb3dbTUFYX1BPSU5UTElHSFRTXTtcIixcclxuICAgICAgICAgICAgXCIjaWYgSEFTX1BPSU5UTElHSFRfU0hBRE9XTUFQU1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlckN1YmUgcG9pbnRMaWdodFNoYWRvd01hcFtNQVhfUE9JTlRMSUdIVFNdO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodFNoYWRvd0JpYXNbTUFYX1BPSU5UTElHSFRTXTtcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzIgcG9pbnRMaWdodE5lYXJGYXJbTUFYX1BPSU5UTElHSFRTXTtcIixcclxuICAgICAgICAgICAgXCJmbG9hdCB2ZWNUb0RlcHRoKHZlYzMgdmVjLCBmbG9hdCBuLCBmbG9hdCBmKXtcIixcclxuICAgICAgICAgICAgICAgIFwidmVjMyBhYnNWZWMgPSBhYnModmVjKTtcIiArXHJcbiAgICAgICAgICAgICAgICBcImZsb2F0IG1heENvbXAgPSBtYXgoYWJzVmVjLngsIG1heChhYnNWZWMueSwgYWJzVmVjLnopKTtcIixcclxuICAgICAgICAgICAgICAgIFwiZmxvYXQgcmVzID0gKGYrbikvKGYtbiktKDIuMCpmKm4pLyhmLW4pL21heENvbXA7XCIsXHJcbiAgICAgICAgICAgICAgICBcInJldHVybiByZXMqMC41KzAuNTtcIixcclxuICAgICAgICAgICAgXCJ9XCIsXHJcbiAgICAgICAgICAgIFwiI2VuZGlmXCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgXCIjaWYgTUFYX1NQT1RMSUdIVFMgPiAwXCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0QXR0ZW51YXRpb25bTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uW01BWF9TUE9UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRJbnRlbnNpdHlbTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBib29sIHNwb3RMaWdodE9uW01BWF9TUE9UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHRDb3NGYWxsb2ZmQW5nbGVbTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHRDb3NTb2Z0RmFsbG9mZkFuZ2xlW01BWF9TUE9UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0U29mdG5lc3NbTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBib29sIHNwb3RMaWdodENhc3RTaGFkb3dbTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgICAgICBcIiNpZiBIQVNfU1BPVExJR0hUX1NIQURPV01BUFNcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIG1hdDQgc3BvdExpZ2h0TWF0cml4WyBNQVhfU1BPVExJR0hUUyBdO1wiLC8vdXNlZCBmb3Igc2hhZG93bWFwY29vcmQgY2FsY3VsYXRpb25cclxuICAgICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBzcG90TGlnaHRTaGFkb3dNYXBbTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0U2hhZG93Qmlhc1tNQVhfU1BPVExJR0hUU107XCIsXHJcbiAgICAgICAgICAgIFwiI2VuZGlmXCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcblxyXG4gICAgICAgIFwiI2lmIE1BWF9ESVJFQ1RJT05BTExJR0hUUyA+IDBcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uW01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodEludGVuc2l0eVtNQVhfRElSRUNUSU9OQUxMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBib29sIGRpcmVjdGlvbmFsTGlnaHRPbltNQVhfRElSRUNUSU9OQUxMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBib29sIGRpcmVjdGlvbmFsTGlnaHRDYXN0U2hhZG93W01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXHJcbiAgICAgICAgICAgIFwiI2lmIEhBU19ESVJFQ1RJT05BTExJR0hUX1NIQURPV01BUFNcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIG1hdDQgZGlyZWN0aW9uYWxMaWdodE1hdHJpeFtNQVhfRElSRUNUSU9OQUxMSUdIVFNdO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dNYXBbTUFYX0RJUkVDVElPTkFMTElHSFRTXTtcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dCaWFzW01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXHJcbiAgICAgICAgICAgIFwiI2VuZGlmXCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcblxyXG5cdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBzc2FvTWFwO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgLy9jYWxjdWxhdGUgc2hhZG93bWFwIGNvb3JkcyAodmVjdG9yIGZvciBwb2ludGxpZ2h0KVxyXG4gICAgICAgIFwiI2lmIE1BWF9QT0lOVExJR0hUUyA+IDAgJiYgSEFTX1BPSU5UTElHSFRfU0hBRE9XTUFQU1wiLFxyXG4gICAgICAgIFwiICAgIHZlYzMgcG9pbnRMaWdodFNoYWRvd01hcERpcmVjdGlvbltNQVhfUE9JTlRMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwiICAgIGZvcihpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRMSUdIVFM7IGkrKykge1wiLFxyXG4gICAgICAgIFwiICAgICAgIHBvaW50TGlnaHRTaGFkb3dNYXBEaXJlY3Rpb25baV0gPSBmcmFnV29ybGRQb3NpdGlvbiAtIHBvaW50TGlnaHRQb3NpdGlvbltpXTtcIixcclxuICAgICAgICBcIiAgICB9XCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuICAgICAgICBcIiNpZiBNQVhfU1BPVExJR0hUUyA+IDAgJiYgSEFTX1NQT1RMSUdIVF9TSEFET1dNQVBTXCIsXHJcbiAgICAgICAgXCIgICAgdmVjNCBzcG90TGlnaHRTaGFkb3dNYXBDb29yZFtNQVhfU1BPVExJR0hUU107XCIsXHJcbiAgICAgICAgXCIgICAgZm9yKGludCBpID0gMDsgaSA8IE1BWF9TUE9UTElHSFRTOyBpKyspIHtcIixcclxuICAgICAgICBcIiAgICAgIHNwb3RMaWdodFNoYWRvd01hcENvb3JkW2ldID0gc3BvdExpZ2h0TWF0cml4W2ldICogdmVjNChmcmFnV29ybGRQb3NpdGlvbiwgMS4wKTtcIixcclxuICAgICAgICBcIiAgICB9XCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuICAgICAgICBcIiNpZiBNQVhfRElSRUNUSU9OQUxMSUdIVFMgPiAwICYmIEhBU19ESVJFQ1RJT05BTExJR0hUX1NIQURPV01BUFNcIixcclxuICAgICAgICBcIiAgICB2ZWM0IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dNYXBDb29yZFtNQVhfRElSRUNUSU9OQUxMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwiICAgIGZvcihpbnQgaSA9IDA7IGkgPCBNQVhfRElSRUNUSU9OQUxMSUdIVFM7IGkrKykge1wiLFxyXG4gICAgICAgIFwiICAgICAgZGlyZWN0aW9uYWxMaWdodFNoYWRvd01hcENvb3JkW2ldID0gZGlyZWN0aW9uYWxMaWdodE1hdHJpeFtpXSAqIHZlYzQoZnJhZ1dvcmxkUG9zaXRpb24sIDEuMCk7XCIsXHJcbiAgICAgICAgXCIgICAgfVwiLFxyXG4gICAgICAgIFwiI2VuZGlmXCIsXHJcblxyXG4gICAgICAgIFwiICBmbG9hdCBhbHBoYSA9ICBtYXgoMC4wLCAxLjAgLSB0cmFuc3BhcmVuY3kpO1wiLFxyXG4gICAgICAgIFwiICB2ZWMzIG9iakRpZmZ1c2UgPSBkaWZmdXNlQ29sb3I7XCIsXHJcbiAgICAgICAgXCIgIGlmKHVzZVZlcnRleENvbG9yKVwiLFxyXG4gICAgICAgIFwiICAgIG9iakRpZmZ1c2UgKj0gZnJhZ1ZlcnRleENvbG9yO1wiLFxyXG4gICAgICAgIFwiICAjaWYgSEFTX0RJRkZVU0VURVhUVVJFXCIsXHJcbiAgICAgICAgXCIgICAgdmVjNCB0ZXhEaWZmdXNlID0gdGV4dHVyZTJEKGRpZmZ1c2VUZXh0dXJlLCBmcmFnVGV4Q29vcmQpO1wiLFxyXG4gICAgICAgIFwiICAgIGFscGhhICo9IHRleERpZmZ1c2UuYTtcIixcclxuICAgICAgICBcIiAgICBvYmpEaWZmdXNlICo9IHRleERpZmZ1c2UucmdiO1wiLFxyXG4gICAgICAgIFwiICAjZW5kaWZcIixcclxuICAgICAgICBcIiAgaWYgKGFscGhhIDwgMC4wNSkgZGlzY2FyZDtcIixcclxuICAgICAgICBcIiAgI2lmIEhBU19FTUlTU0lWRVRFWFRVUkVcIixcclxuICAgICAgICBcIiAgICB2ZWMzIGNvbG9yID0gZW1pc3NpdmVDb2xvciAqIHRleHR1cmUyRChlbWlzc2l2ZVRleHR1cmUsIGZyYWdUZXhDb29yZCkucmdiICsgKGFtYmllbnRJbnRlbnNpdHkgKiBvYmpEaWZmdXNlKTtcIixcclxuICAgICAgICBcIiAgI2Vsc2VcIixcclxuICAgICAgICBcIiAgICB2ZWMzIGNvbG9yID0gZW1pc3NpdmVDb2xvciArIChhbWJpZW50SW50ZW5zaXR5ICogb2JqRGlmZnVzZSk7XCIsXHJcbiAgICAgICAgXCIgICNlbmRpZlwiLFxyXG4gICAgICAgIFwiICB2ZWMzIG9ialNwZWN1bGFyID0gc3BlY3VsYXJDb2xvcjtcIixcclxuICAgICAgICBcIiAgI2lmIEhBU19TUEVDVUxBUlRFWFRVUkVcIixcclxuICAgICAgICBcIiAgICBvYmpTcGVjdWxhciA9IG9ialNwZWN1bGFyICogdGV4dHVyZTJEKHNwZWN1bGFyVGV4dHVyZSwgZnJhZ1RleENvb3JkKS5yZ2I7XCIsXHJcbiAgICAgICAgXCIgICNlbmRpZlwiLFxyXG5cdFx0XCIgICNpZiBIQVNfU1NBT01BUFwiLFxyXG5cdFx0XCJcdCBmbG9hdCBzc2FvID0gMS4wIC0gdGV4dHVyZTJEKHNzYW9NYXAsIGdsX0ZyYWdDb29yZC54eSAvIGNvb3Jkcy54eSkucjtcIixcclxuICAgICAgICBcIiAgI2VuZGlmXCIsXHJcblxyXG4gICAgICAgIFwiICBmbG9hdCBzaGFkb3dJbmZsdWVuY2UgPSAwLjA7XCIsIC8vdXNlZCBmb3Igc2FtcGxpbmcgc2hhZG93XHJcblxyXG5cdFx0XCIjaWYgTUFYX1BPSU5UTElHSFRTID4gMFwiLFxyXG4gICAgICAgIFwiICBmb3IgKGludCBpID0gMDsgaSA8IE1BWF9QT0lOVExJR0hUUzsgaSsrKSB7XCIsXHJcbiAgICAgICAgXCIgICAgc2hhZG93SW5mbHVlbmNlID0gMS4wO1wiLFxyXG4gICAgICAgIFwiICAgIGlmKHBvaW50TGlnaHRPbltpXSl7XCIsXHJcbiAgICAgICAgXCIgICAjaWYgSEFTX1BPSU5UTElHSFRfU0hBRE9XTUFQU1wiLFxyXG4gICAgICAgIFwiICAgICAgIGlmKHBvaW50TGlnaHRDYXN0U2hhZG93W2ldKXtcIixcclxuICAgICAgICBcIiAgICAgICAgICAgc2hhZG93SW5mbHVlbmNlID0gMC4wO1wiLFxyXG4gICAgICAgIFwiICAgICAgICAgICBmbG9hdCBsc0RlcHRoID0gdmVjVG9EZXB0aChwb2ludExpZ2h0U2hhZG93TWFwRGlyZWN0aW9uW2ldLCBwb2ludExpZ2h0TmVhckZhcltpXS54LCBwb2ludExpZ2h0TmVhckZhcltpXS55ICk7XCIsXHJcbiAgICAgICAgXCJcdFx0ICAgIGZsb2F0IGRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmVDdWJlKHBvaW50TGlnaHRTaGFkb3dNYXBbaV0sIHBvaW50TGlnaHRTaGFkb3dNYXBEaXJlY3Rpb25baV0pKSArICBwb2ludExpZ2h0U2hhZG93Qmlhc1tpXTtcIixcclxuICAgICAgICBcIiAgICAgICAgICAgaWYobHNEZXB0aCA8IGRlcHRoKVwiLFxyXG4gICAgICAgIFwiICAgICAgICAgICAgICAgc2hhZG93SW5mbHVlbmNlID0gMS4wO1wiLFxyXG4gICAgICAgIFwiICAgICAgIH1cIixcclxuICAgICAgICBcIiAgICAgICBpZihzaGFkb3dJbmZsdWVuY2UgPiAwLjApe1wiLFxyXG4gICAgICAgIFwiICAgI2VuZGlmXCIsXHJcbiAgICAgICAgXCIgICAgICAgdmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxyXG4gICAgICAgIFwiICAgICAgIHZlYzMgTCA9IGxQb3NpdGlvbi54eXogLSBmcmFnVmVydGV4UG9zaXRpb247XCIsXHJcbiAgICAgICAgXCIgICAgICAgZmxvYXQgZGlzdCA9IGxlbmd0aChMKTtcIixcclxuICAgICAgICBcIiAgICAgICBMID0gbm9ybWFsaXplKEwpO1wiLFxyXG4gICAgICAgIFwiICAgICAgIHZlYzMgUiA9IG5vcm1hbGl6ZShyZWZsZWN0KEwsZnJhZ05vcm1hbCkpO1wiLFxyXG4gICAgICAgIFwiICAgICAgIGZsb2F0IGF0dGVuID0gMS4wIC8gKHBvaW50TGlnaHRBdHRlbnVhdGlvbltpXS54ICsgcG9pbnRMaWdodEF0dGVudWF0aW9uW2ldLnkgKiBkaXN0ICsgcG9pbnRMaWdodEF0dGVudWF0aW9uW2ldLnogKiBkaXN0ICogZGlzdCk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgdmVjMyBJZGlmZiA9IHBvaW50TGlnaHRJbnRlbnNpdHlbaV0gKiBvYmpEaWZmdXNlICogbWF4KGRvdChmcmFnTm9ybWFsLEwpLDAuMCk7XCIsXHJcblx0XHRcIiAgICNpZiBIQVNfU1NBT01BUFwiLFxyXG5cdFx0XCIgICAgICAgSWRpZmYgKj0gc3NhbztcIixcclxuXHRcdFwiICAgI2VuZGlmXCIsXHJcbiAgICAgICAgXCIgICAgICAgdmVjMyBJc3BlYyA9IHBvaW50TGlnaHRJbnRlbnNpdHlbaV0gKiBvYmpTcGVjdWxhciAqIHBvdyhtYXgoZG90KFIsZnJhZ0V5ZVZlY3RvciksMC4wKSwgc2hpbmluZXNzKjEyOC4wKTtcIixcclxuICAgICAgICBcIiAgICAgICBjb2xvciA9IGNvbG9yICsgKGF0dGVuKnNoYWRvd0luZmx1ZW5jZSooSWRpZmYgKyBJc3BlYykpO1wiLFxyXG4gICAgICAgIFwiICAgI2lmIEhBU19QT0lOVExJR0hUX1NIQURPV01BUFNcIixcclxuICAgICAgICBcIiAgICAgICB9XCIsICAvL3BvaW50bGlnaHQgdmlzaWJsZVxyXG4gICAgICAgIFwiICAgI2VuZGlmXCIsXHJcbiAgICAgICAgXCIgICAgIH1cIiwgLy9wb2ludExpZ2h0IG9uXHJcbiAgICAgICAgXCIgIH1cIiwgLy9wb2ludExpZ2h0IGxvb3BcclxuICAgICAgICBcIiNlbmRpZlwiLFxyXG5cclxuICAgICAgICBcIiNpZiBNQVhfU1BPVExJR0hUUyA+IDBcIixcclxuICAgICAgICBcIiAgZm9yIChpbnQgaT0wOyBpPE1BWF9TUE9UTElHSFRTOyBpKyspIHtcIixcclxuICAgICAgICBcIiAgICBzaGFkb3dJbmZsdWVuY2UgPSAxLjA7XCIsXHJcbiAgICAgICAgXCIgICAgaWYoc3BvdExpZ2h0T25baV0pIHtcIixcclxuICAgICAgICBcIiAgI2lmIEhBU19TUE9UTElHSFRfU0hBRE9XTUFQU1wiLFxyXG4gICAgICAgIFwiICAgICAgIGlmKHNwb3RMaWdodENhc3RTaGFkb3dbaV0pe1wiLFxyXG4gICAgICAgIFwiICAgICAgICAgICBzaGFkb3dJbmZsdWVuY2UgPSAwLjA7XCIsXHJcbiAgICAgICAgXCIgICAgICAgICAgIHZlYzQgbHNwb3MgPSBzcG90TGlnaHRTaGFkb3dNYXBDb29yZFtpXTtcIixcclxuICAgICAgICBcIlx0XHRcdHZlYzMgcGVyc3BlY3RpdmVEaXZQb3MgPSBsc3Bvcy54eXogLyBsc3Bvcy53ICogMC41ICsgMC41O1wiLFxyXG4gICAgICAgIFwiXHRcdFx0ZmxvYXQgbHNEZXB0aCA9IHBlcnNwZWN0aXZlRGl2UG9zLno7XCIsXHJcbiAgICAgICAgXCJcdFx0XHR2ZWMyIGxpZ2h0dXYgPSBwZXJzcGVjdGl2ZURpdlBvcy54eTtcIixcclxuICAgICAgICBcIlx0XHRcdGZsb2F0IGRlcHRoID0gdW5wYWNrRGVwdGgodGV4dHVyZTJEKHNwb3RMaWdodFNoYWRvd01hcFtpXSwgbGlnaHR1dikpICsgc3BvdExpZ2h0U2hhZG93Qmlhc1tpXTtcIixcclxuICAgICAgICBcIiAgICAgICAgICAgaWYobHNEZXB0aCA8IGRlcHRoKVwiLFxyXG4gICAgICAgIFwiICAgICAgICAgICAgICAgc2hhZG93SW5mbHVlbmNlID0gMS4wO1wiLFxyXG4gICAgICAgIFwiICAgICAgIH1cIixcclxuICAgICAgICBcIiAgICAgICBpZihzaGFkb3dJbmZsdWVuY2UgPiAwLjApe1wiLFxyXG4gICAgICAgIFwiICAjZW5kaWZcIixcclxuICAgICAgICBcIiAgICAgICB2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBzcG90TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuICAgICAgICBcIiAgICAgICB2ZWMzIEwgPSBsUG9zaXRpb24ueHl6IC0gZnJhZ1ZlcnRleFBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwiICAgICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoTCk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgTCA9IG5vcm1hbGl6ZShMKTtcIixcclxuICAgICAgICBcIiAgICAgICB2ZWMzIFIgPSBub3JtYWxpemUocmVmbGVjdChMLGZyYWdOb3JtYWwpKTtcIixcclxuICAgICAgICBcIiAgICAgICBmbG9hdCBhdHRlbiA9IDEuMCAvIChzcG90TGlnaHRBdHRlbnVhdGlvbltpXS54ICsgc3BvdExpZ2h0QXR0ZW51YXRpb25baV0ueSAqIGRpc3QgKyBzcG90TGlnaHRBdHRlbnVhdGlvbltpXS56ICogZGlzdCAqIGRpc3QpO1wiLFxyXG4gICAgICAgIFwiICAgICAgIHZlYzMgSWRpZmYgPSBzcG90TGlnaHRJbnRlbnNpdHlbaV0gKiBvYmpEaWZmdXNlICogbWF4KGRvdChmcmFnTm9ybWFsLEwpLDAuMCk7XCIsXHJcbiAgICAgICAgXCIgICAjaWYgSEFTX1NTQU9NQVBcIixcclxuICAgICAgICBcIlx0ICAgIElkaWZmICo9IHNzYW87XCIsXHJcbiAgICAgICAgXCIgICAjZW5kaWZcIixcclxuICAgICAgICBcIiAgICAgICB2ZWMzIElzcGVjID0gc3BvdExpZ2h0SW50ZW5zaXR5W2ldICogb2JqU3BlY3VsYXIgKiBwb3cobWF4KGRvdChSLGZyYWdFeWVWZWN0b3IpLDAuMCksIHNoaW5pbmVzcyoxMjguMCk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgdmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoLXNwb3RMaWdodERpcmVjdGlvbltpXSwgMC4wKTtcIixcclxuICAgICAgICBcIiAgICAgICB2ZWMzIEQgPSBub3JtYWxpemUobERpcmVjdGlvbi54eXopO1wiLFxyXG4gICAgICAgIFwiICAgICAgIGZsb2F0IGFuZ2xlID0gZG90KEwsIEQpO1wiLFxyXG4gICAgICAgIFwiICAgICAgIGlmKGFuZ2xlID4gc3BvdExpZ2h0Q29zRmFsbG9mZkFuZ2xlW2ldKSB7XCIsXHJcbiAgICAgICAgXCIgICAgICAgICAgIGZsb2F0IHNvZnRuZXNzID0gMS4wO1wiLFxyXG4gICAgICAgIFwiICAgICAgICAgICBpZiAoYW5nbGUgPCBzcG90TGlnaHRDb3NTb2Z0RmFsbG9mZkFuZ2xlW2ldKVwiLFxyXG4gICAgICAgIFwiICAgICAgICAgICAgICAgc29mdG5lc3MgPSAoYW5nbGUgLSBzcG90TGlnaHRDb3NGYWxsb2ZmQW5nbGVbaV0pIC8gIChzcG90TGlnaHRDb3NTb2Z0RmFsbG9mZkFuZ2xlW2ldIC0gIHNwb3RMaWdodENvc0ZhbGxvZmZBbmdsZVtpXSk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgICAgIGNvbG9yICs9IGF0dGVuKnNvZnRuZXNzKnNoYWRvd0luZmx1ZW5jZSooSWRpZmYgKyBJc3BlYyk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgfVwiLFxyXG4gICAgICAgIFwiICAgI2lmIEhBU19TUE9UTElHSFRfU0hBRE9XTUFQU1wiLFxyXG4gICAgICAgIFwiICAgICAgIH1cIiwgLy9saWdodCB2aXNpYmxlIGlmIHNoYWRvdyBlbmFibGVkXHJcbiAgICAgICAgXCIgICAjZW5kaWZcIixcclxuICAgICAgICBcIiAgIH0gXCIsIC8vIHNwb3RsaWdodCBvblxyXG4gICAgICAgIFwiICB9XCIsIC8vIGxpZ2h0IGxvb3BcclxuICAgICAgICBcIiNlbmRpZlwiLFxyXG5cclxuICAgICAgICBcIiNpZiBNQVhfRElSRUNUSU9OQUxMSUdIVFMgPiAwXCIsXHJcbiAgICAgICAgXCIgIGZvciAoaW50IGk9MDsgaTxNQVhfRElSRUNUSU9OQUxMSUdIVFM7IGkrKykge1wiLFxyXG4gICAgICAgIFwiICAgc2hhZG93SW5mbHVlbmNlID0gMS4wO1wiLFxyXG4gICAgICAgIFwiICAgaWYoZGlyZWN0aW9uYWxMaWdodE9uW2ldKXtcIixcclxuICAgICAgICBcIiAgICNpZiBIQVNfRElSRUNUSU9OQUxMSUdIVF9TSEFET1dNQVBTXCIsXHJcbiAgICAgICAgXCIgICAgICAgaWYoZGlyZWN0aW9uYWxMaWdodENhc3RTaGFkb3dbaV0pe1wiLFxyXG4gICAgICAgIFwiICAgICAgICAgICBzaGFkb3dJbmZsdWVuY2UgPSAwLjA7XCIsXHJcbiAgICAgICAgXCIgICAgICAgICAgIHZlYzQgbHNwb3MgPSBkaXJlY3Rpb25hbExpZ2h0U2hhZG93TWFwQ29vcmRbaV07XCIsXHJcbiAgICAgICAgXCIgICAgICAgICAgIHZlYzMgb3J0aG9nb25hbERpdlBvcyA9IGxzcG9zLnh5eiAvIGxzcG9zLncgKjAuNSArIDAuNTtcIixcclxuICAgICAgICBcIiAgICAgICAgICAgZmxvYXQgbHNEZXB0aCA9IG9ydGhvZ29uYWxEaXZQb3MuejtcIixcclxuICAgICAgICBcIiAgICAgICAgICAgdmVjMiBsaWdodHV2ID0gb3J0aG9nb25hbERpdlBvcy54eTtcIixcclxuICAgICAgICBcIiAgICAgICAgICAgICAgIGZsb2F0IGRlcHRoID0gdW5wYWNrRGVwdGgodGV4dHVyZTJEKGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dNYXBbaV0sIGxpZ2h0dXYpKStkaXJlY3Rpb25hbExpZ2h0U2hhZG93Qmlhc1tpXTtcIixcclxuICAgICAgICBcIiAgICAgICAgICAgICAgIGlmKGxzRGVwdGggPCBkZXB0aCkgc2hhZG93SW5mbHVlbmNlID0gMS4wO1wiLFxyXG4gICAgICAgIFwiICAgICAgIH1cIixcclxuICAgICAgICBcIiAgICAgICBpZihzaGFkb3dJbmZsdWVuY2UgPiAwLjApe1wiLFxyXG4gICAgICAgIFwiICAgI2VuZGlmXCIsXHJcbiAgICAgICAgXCIgICAgICAgdmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbltpXSwgMC4wKTtcIixcclxuICAgICAgICBcIiAgICAgICB2ZWMzIEwgPSAgbm9ybWFsaXplKC1sRGlyZWN0aW9uLnh5eik7XCIsXHJcbiAgICAgICAgXCIgICAgICAgdmVjMyBSID0gbm9ybWFsaXplKHJlZmxlY3QoTCxmcmFnTm9ybWFsKSk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgdmVjMyBJZGlmZiA9IGRpcmVjdGlvbmFsTGlnaHRJbnRlbnNpdHlbaV0gKiBvYmpEaWZmdXNlICogbWF4KGRvdChmcmFnTm9ybWFsLEwpLDAuMCk7XCIsXHJcblx0XHRcIiAgICNpZiBIQVNfU1NBT01BUFwiLFxyXG5cdFx0XCIgICAgICAgSWRpZmYgKj0gc3NhbztcIixcclxuXHRcdFwiICAgI2VuZGlmXCIsXHJcbiAgICAgICAgXCIgICAgICAgdmVjMyBJc3BlYyA9IGRpcmVjdGlvbmFsTGlnaHRJbnRlbnNpdHlbaV0gKiBvYmpTcGVjdWxhciAqIHBvdyhtYXgoZG90KFIsZnJhZ0V5ZVZlY3RvciksMC4wKSwgc2hpbmluZXNzKjEyOC4wKTtcIixcclxuICAgICAgICBcIiAgICAgICBjb2xvciA9IGNvbG9yICsgc2hhZG93SW5mbHVlbmNlKigoSWRpZmYgKyBJc3BlYykpO1wiLFxyXG4gICAgICAgIFwiICAgI2lmIEhBU19ESVJFQ1RJT05BTExJR0hUX1NIQURPV01BUFNcIixcclxuICAgICAgICBcIiAgICAgICB9XCIsIC8vbGlnaHQgdmlzaWJsZVxyXG4gICAgICAgIFwiICAgI2VuZGlmXCIsXHJcbiAgICAgICAgXCIgICB9XCIsIC8vZGlyTGlnaHQgb25cclxuICAgICAgICBcIiAgfVwiLCAvLyBkaXJMaWdodCBsb29wXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuICAgICAgICBcIiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgYWxwaGEpO1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgYWRkRGlyZWN0aXZlczogZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIGxpZ2h0cywgcGFyYW1zKSB7XHJcbiAgICAgICAgW1wicG9pbnRcIiwgXCJkaXJlY3Rpb25hbFwiLCBcInNwb3RcIl0uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgbnVtTGlnaHRzID0gbGlnaHRzLmdldE1vZGVsQ291bnQodHlwZSk7XHJcbiAgICAgICAgICAgIHZhciBjYXN0U2hhZG93cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZihudW1MaWdodHMpIHtcclxuICAgICAgICAgICAgICAgIGNhc3RTaGFkb3dzID0gQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChsaWdodHMuZ2V0TW9kZWxFbnRyeSh0eXBlKS5wYXJhbWV0ZXJzW1wiY2FzdFNoYWRvd1wiXSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGlyZWN0aXZlcy5wdXNoKFwiTUFYX1wiICsgdHlwZS50b1VwcGVyQ2FzZSgpICsgXCJMSUdIVFMgXCIgKyBudW1MaWdodHMpO1xyXG4gICAgICAgICAgICBkaXJlY3RpdmVzLnB1c2goXCJIQVNfXCIgKyB0eXBlLnRvVXBwZXJDYXNlKCkgKyBcIkxJR0hUX1NIQURPV01BUFMgXCIgKyAoY2FzdFNoYWRvd3MgPyAxIDogMCkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkaXJlY3RpdmVzLnB1c2goXCJIQVNfRElGRlVTRVRFWFRVUkUgXCIgKyAoJ2RpZmZ1c2VUZXh0dXJlJyBpbiBwYXJhbXMgPyBcIjFcIiA6IFwiMFwiKSk7XHJcbiAgICAgICAgZGlyZWN0aXZlcy5wdXNoKFwiSEFTX1NQRUNVTEFSVEVYVFVSRSBcIiArICgnc3BlY3VsYXJUZXh0dXJlJyBpbiBwYXJhbXMgPyBcIjFcIiA6IFwiMFwiKSk7XHJcbiAgICAgICAgZGlyZWN0aXZlcy5wdXNoKFwiSEFTX0VNSVNTSVZFVEVYVFVSRSBcIiArICgnZW1pc3NpdmVUZXh0dXJlJyBpbiBwYXJhbXMgPyBcIjFcIiA6IFwiMFwiKSk7XHJcbiAgICAgICAgZGlyZWN0aXZlcy5wdXNoKFwiSEFTX1NTQU9NQVAgXCIgKyAoWE1MM0Qub3B0aW9ucy5nZXRWYWx1ZShcInJlbmRlcmVyLXNzYW9cIikgPyBcIjFcIiA6IFwiMFwiKSk7XHJcbiAgICB9LFxyXG4gICAgaGFzVHJhbnNwYXJlbmN5OiBmdW5jdGlvbihwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gcGFyYW1zLnRyYW5zcGFyZW5jeSAmJiBwYXJhbXMudHJhbnNwYXJlbmN5LmdldFZhbHVlKClbMF0gPiAwLjAwMTtcclxuICAgIH0sXHJcbiAgICB1bmlmb3Jtczoge1xyXG4gICAgICAgIGRpZmZ1c2VDb2xvciAgICA6IFsxLjAsIDEuMCwgMS4wXSxcclxuICAgICAgICBlbWlzc2l2ZUNvbG9yICAgOiBbMC4wLCAwLjAsIDAuMF0sXHJcbiAgICAgICAgc3BlY3VsYXJDb2xvciAgIDogWzAuMCwgMC4wLCAwLjBdLFxyXG4gICAgICAgIHRyYW5zcGFyZW5jeSAgICA6IDAuMCxcclxuICAgICAgICBzaGluaW5lc3MgICAgICAgOiAwLjIsXHJcbiAgICAgICAgYW1iaWVudEludGVuc2l0eTogMC4wLFxyXG4gICAgICAgIHVzZVZlcnRleENvbG9yIDogZmFsc2VcclxuICAgIH0sXHJcblxyXG4gICAgc2FtcGxlcnM6IHtcclxuICAgICAgICBkaWZmdXNlVGV4dHVyZSA6IG51bGwsXHJcbiAgICAgICAgZW1pc3NpdmVUZXh0dXJlIDogbnVsbCxcclxuICAgICAgICBzcGVjdWxhclRleHR1cmUgOiBudWxsLFxyXG4gICAgICAgIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dNYXAgOiBudWxsLFxyXG4gICAgICAgIHNwb3RMaWdodFNoYWRvd01hcCA6IG51bGwsXHJcbiAgICAgICAgcG9pbnRMaWdodFNoYWRvd01hcCA6IG51bGwsXHJcblx0XHRzc2FvTWFwOiBudWxsXHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJpYnV0ZXM6IHtcclxuICAgICAgICBub3JtYWwgOiB7XHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0ZXhjb29yZDogbnVsbCxcclxuICAgICAgICBjb2xvcjogbnVsbFxyXG4gICAgfVxyXG59KTtcclxuIiwiWE1MM0Quc2hhZGVycy5yZWdpc3RlcihcInBvaW50XCIsIHtcclxuXHJcbiAgICB2ZXJ0ZXggOiBbXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcIixcclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1wiLFxyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzIgdGV4Y29vcmQ7XCIsXHJcblxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdOb3JtYWw7XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleFBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdFeWVWZWN0b3I7XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzIgZnJhZ1RleENvb3JkO1wiLFxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdWZXJ0ZXhDb2xvcjtcIixcclxuXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcIixcclxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcIixcclxuICAgICAgICBcInVuaWZvcm0gbWF0MyBtb2RlbFZpZXdNYXRyaXhOO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGV5ZVBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGNvb3JkcztcIixcclxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgcG9pbnRTaXplO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICAgdmVjMyBwb3MgPSBwb3NpdGlvbjtcIixcclxuXHJcbiAgICAgICAgXCIgICAgZ2xfUG9zaXRpb24gPSBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ICogdmVjNChwb3MsIDEuMCk7XCIsXHJcbiAgICAgICAgXCIgICAgZnJhZ1ZlcnRleFBvc2l0aW9uID0gKG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zLCAxLjApKS54eXo7XCIsXHJcbiAgICAgICAgXCIgICAgZnJhZ0V5ZVZlY3RvciA9IG5vcm1hbGl6ZShmcmFnVmVydGV4UG9zaXRpb24pO1wiLFxyXG4gICAgICAgIFwiICAgIGZyYWdUZXhDb29yZCA9IHRleGNvb3JkO1wiLFxyXG4gICAgICAgIFwiICAgIGZyYWdWZXJ0ZXhDb2xvciA9IGNvbG9yO1wiLFxyXG4gICAgICAgIFwiICAgIHZlYzQgcG9zMiA9IHZlYzQoZnJhZ1ZlcnRleFBvc2l0aW9uLCAxLjApOyBwb3MyLnggKz0gcG9pbnRTaXplO1wiLFxyXG4gICAgICAgIFwiICAgIGdsX1BvaW50U2l6ZSA9IGRpc3RhbmNlKCBnbF9Qb3NpdGlvbi54eSwgKHByb2plY3Rpb25NYXRyaXggKiBwb3MyKS54eSApICogY29vcmRzLnggLyBnbF9Qb3NpdGlvbi53O1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgZnJhZ21lbnQgOiBbXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZUNvbG9yO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCB0cmFuc3BhcmVuY3k7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcIixcclxuICAgICAgICBcInVuaWZvcm0gYm9vbCB1c2VWZXJ0ZXhDb2xvcjtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMiB0ZXhDb29yZE9mZnNldDtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMiB0ZXhDb29yZFNpemU7XCIsXHJcblxyXG4gICAgICAgIFwiI2lmIEhBU19ESUZGVVNFVEVYVFVSRVwiLFxyXG4gICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgZGlmZnVzZVRleHR1cmU7XCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ05vcm1hbDtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4UG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ0V5ZVZlY3RvcjtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMiBmcmFnVGV4Q29vcmQ7XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleENvbG9yO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgIGZsb2F0IGFscGhhID0gIG1heCgwLjAsIDEuMCAtIHRyYW5zcGFyZW5jeSk7XCIsXHJcbiAgICAgICAgXCIgIHZlYzMgb2JqRGlmZnVzZSA9IGRpZmZ1c2VDb2xvcjtcIixcclxuICAgICAgICBcIiAgaWYodXNlVmVydGV4Q29sb3IpXCIsXHJcbiAgICAgICAgXCIgICAgb2JqRGlmZnVzZSAqPSBmcmFnVmVydGV4Q29sb3I7XCIsXHJcbiAgICAgICAgXCIgICNpZiBIQVNfRElGRlVTRVRFWFRVUkVcIixcclxuICAgICAgICBcIiAgICB2ZWMyIHRleENvb3JkID0gZnJhZ1RleENvb3JkICsgdGV4Q29vcmRPZmZzZXQgKyBnbF9Qb2ludENvb3JkKnRleENvb3JkU2l6ZTtcIixcclxuICAgICAgICBcIiAgICB0ZXhDb29yZC55ID0gMS4wIC0gdGV4Q29vcmQueTtcIixcclxuICAgICAgICBcIiAgICB2ZWM0IHRleERpZmZ1c2UgPSB0ZXh0dXJlMkQoZGlmZnVzZVRleHR1cmUsIHRleENvb3JkKTtcIixcclxuICAgICAgICBcIiAgICBhbHBoYSAqPSB0ZXhEaWZmdXNlLmE7XCIsXHJcbiAgICAgICAgXCIgICAgb2JqRGlmZnVzZSAqPSB0ZXhEaWZmdXNlLnJnYjtcIixcclxuICAgICAgICBcIiAgI2VuZGlmXCIsXHJcbiAgICAgICAgXCIgIGlmIChhbHBoYSA8IDAuMDUpIGRpc2NhcmQ7XCIsXHJcbiAgICAgICAgXCIgIGdsX0ZyYWdDb2xvciA9IHZlYzQob2JqRGlmZnVzZSwgYWxwaGEpO1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcbiAgICBhZGREaXJlY3RpdmVzOiBmdW5jdGlvbihkaXJlY3RpdmVzLCBsaWdodHMsIHBhcmFtcykge1xyXG4gICAgICAgIGRpcmVjdGl2ZXMucHVzaChcIkhBU19ESUZGVVNFVEVYVFVSRSBcIiArICgnZGlmZnVzZVRleHR1cmUnIGluIHBhcmFtcyA/IFwiMVwiIDogXCIwXCIpKTtcclxuICAgIH0sXHJcbiAgICBoYXNUcmFuc3BhcmVuY3k6IGZ1bmN0aW9uKHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiBwYXJhbXMudHJhbnNwYXJlbmN5ICYmIHBhcmFtcy50cmFuc3BhcmVuY3kuZ2V0VmFsdWUoKVswXSA+IDAuMDAxO1xyXG4gICAgfSxcclxuICAgIHVuaWZvcm1zOiB7XHJcbiAgICAgICAgZGlmZnVzZUNvbG9yOiBbMS4wLCAxLjAsIDEuMF0sXHJcbiAgICAgICAgdGV4Q29vcmRPZmZzZXQ6IFswLCAwXSxcclxuICAgICAgICB0ZXhDb29yZFNpemU6IFsxLCAxXSxcclxuICAgICAgICB0cmFuc3BhcmVuY3k6IDAuMCxcclxuICAgICAgICB1c2VWZXJ0ZXhDb2xvcjogZmFsc2UsXHJcbiAgICAgICAgcG9pbnRTaXplOiAxLjBcclxuICAgIH0sXHJcbiAgICBzYW1wbGVyczoge1xyXG4gICAgICAgIGRpZmZ1c2VUZXh0dXJlOiBudWxsXHJcbiAgICB9LFxyXG4gICAgYXR0cmlidXRlczoge1xyXG4gICAgICAgIHRleGNvb3JkOiBudWxsLFxyXG4gICAgICAgIGNvbG9yOiBudWxsXHJcbiAgICB9XHJcbn0pO1xyXG4iLCJ2YXIgU2hhZGVyRGVzY3JpcHRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMudW5pZm9ybXMgPSB7fTtcclxuICAgIHRoaXMuc2FtcGxlcnMgPSB7fTtcclxuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xyXG4gICAgdGhpcy5uYW1lID0gXCJcIjtcclxuICAgIHRoaXMuZnJhZ21lbnQgPSBcIlwiO1xyXG4gICAgdGhpcy52ZXJ0ZXggPSBcIlwiO1xyXG59O1xyXG5TaGFkZXJEZXNjcmlwdG9yLnByb3RvdHlwZS5hZGREaXJlY3RpdmVzID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5TaGFkZXJEZXNjcmlwdG9yLnByb3RvdHlwZS5oYXNUcmFuc3BhcmVuY3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNoYWRlckRlc2NyaXB0b3I7XHJcbiIsInZhciBjX2dsb2JhbFNjcmlwdHMgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAobmFtZSwgc2NyaXB0KSB7XHJcbiAgICAgICAgY19nbG9iYWxTY3JpcHRzW25hbWVdID0gc2NyaXB0O1xyXG4gICAgICAgIHNjcmlwdC5uYW1lID0gbmFtZTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U2NyaXB0OiBmdW5jdGlvbiAoc2NyaXB0KSB7XHJcbiAgICAgICAgcmV0dXJuIGNfZ2xvYmFsU2NyaXB0c1tzY3JpcHRdO1xyXG4gICAgfVxyXG59O1xyXG4iLCJ2YXIgQWJzdHJhY3RTaGFkZXJDbG9zdXJlID0gcmVxdWlyZShcIi4vLi4vYWJzdHJhY3RzaGFkZXJjbG9zdXJlLmpzXCIpO1xyXG52YXIgU3lzdGVtTm90aWZpZXIgPSByZXF1aXJlKFwiLi4vLi4vc3lzdGVtL3N5c3RlbS1ub3RpZmllci5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiBBIFNoYWRlckNsb3N1cmUgY29ubmVjdHMgYSBtZXNoLXNwZWNpZmljIEdMUHJvZ3JhbSB3aXRoIGl0J3MgWGZsb3cgZGF0YVxyXG4gKiBAcGFyYW0ge0dMQ29udGV4dH0gY29udGV4dFxyXG4gKiBAcGFyYW0gZGVzY3JpcHRvclxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBTaGFkZXJDbG9zdXJlID0gZnVuY3Rpb24gKGNvbnRleHQsIGRlc2NyaXB0b3IpIHtcclxuICAgIEFic3RyYWN0U2hhZGVyQ2xvc3VyZS5jYWxsKHRoaXMsIGNvbnRleHQpO1xyXG4gICAgdGhpcy5kZXNjcmlwdG9yID0gZGVzY3JpcHRvcjtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKFNoYWRlckNsb3N1cmUsIEFic3RyYWN0U2hhZGVyQ2xvc3VyZSk7XHJcblxyXG5YTUwzRC5leHRlbmQoU2hhZGVyQ2xvc3VyZS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBzZXREZWZhdWx0VW5pZm9ybXM6IGZ1bmN0aW9uIChkZXN0KSB7XHJcbiAgICAgICAgWE1MM0QuZXh0ZW5kKGRlc3QsIHRoaXMuZGVzY3JpcHRvci51bmlmb3Jtcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVNvdXJjZXM6IGZ1bmN0aW9uIChzY2VuZSwgc2hhZGVyRGF0YSwgdnNSZXF1ZXN0KSB7XHJcblxyXG4gICAgICAgIHZhciBvYmplY3REYXRhID0gdnNSZXF1ZXN0ICYmIHZzUmVxdWVzdC5nZXRSZXN1bHQoKTtcclxuICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgaW5wdXREYXRhID0ge307XHJcbiAgICAgICAgc2hhZGVyRGF0YSAmJiBYTUwzRC5leHRlbmQoaW5wdXREYXRhLCBzaGFkZXJEYXRhLmdldE91dHB1dE1hcCgpKTtcclxuICAgICAgICBvYmplY3REYXRhICYmIFhNTDNELmV4dGVuZChpbnB1dERhdGEsIG9iamVjdERhdGEuZ2V0T3V0cHV0TWFwKCkpO1xyXG5cclxuXHJcbiAgICAgICAgZm9yICh2YXIgYXR0ck5hbWUgaW4gdGhpcy5kZXNjcmlwdG9yLmF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5kZXNjcmlwdG9yLmF0dHJpYnV0ZXNbYXR0ck5hbWVdO1xyXG4gICAgICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkucmVxdWlyZWQgJiYgIWlucHV0RGF0YVthdHRyTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1lc2ggaXMgbWlzc2luZyAnXCIgKyBhdHRyTmFtZSArIFwiJyBhdHRyaWJ1dGUuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRlc2NyaXB0b3IuYWRkRGlyZWN0aXZlcyhkaXJlY3RpdmVzLCBzY2VuZS5saWdodHMgfHwge30sIGlucHV0RGF0YSk7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSB7XHJcbiAgICAgICAgICAgIGZyYWdtZW50OiB0aGlzLmFkZERpcmVjdGl2ZXNUb1NvdXJjZShkaXJlY3RpdmVzLCB0aGlzLmRlc2NyaXB0b3IuZnJhZ21lbnQpLFxyXG4gICAgICAgICAgICB2ZXJ0ZXg6IHRoaXMuYWRkRGlyZWN0aXZlc1RvU291cmNlKGRpcmVjdGl2ZXMsIHRoaXMuZGVzY3JpcHRvci52ZXJ0ZXgpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgU3lzdGVtTm90aWZpZXIuc2VuZEV2ZW50KCd1cm5zaGFkZXInLCB7XHJcbiAgICAgICAgICAgIHVybnNoYWRlclR5cGU6IFwiY29kZVwiLCB2ZXJ0ZXhTaGFkZXI6IHRoaXMuc291cmNlLnZlcnRleCwgZnJhZ21lbnRTaGFkZXI6IHRoaXMuc291cmNlLmZyYWdtZW50XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGREaXJlY3RpdmVzVG9Tb3VyY2U6IGZ1bmN0aW9uIChkaXJlY3RpdmVzLCBzb3VyY2UpIHtcclxuICAgICAgICB2YXIgaGVhZGVyID0gXCJcIjtcclxuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaGVhZGVyICs9IFwiI2RlZmluZSBcIiArIHYgKyBcIlxcblwiO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBoZWFkZXIgKyBcIlxcblwiICsgc291cmNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUcmFuc3BhcmVuY3lGcm9tSW5wdXREYXRhOiBmdW5jdGlvbiAoZGF0YU1hcCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0b3IuaGFzVHJhbnNwYXJlbmN5KGRhdGFNYXApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2hhZGVyQ2xvc3VyZTtcclxuXHJcbiIsInZhciBBYnN0cmFjdFNoYWRlckNvbXBvc2VyID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0c2hhZGVyY29tcG9zZXIuanNcIikuQWJzdHJhY3RTaGFkZXJDb21wb3NlcjtcclxudmFyIFVSTlNoYWRlckNsb3N1cmU9IHJlcXVpcmUoXCIuL3VybnNoYWRlcmNsb3N1cmUuanNcIik7XHJcbnZhciBTaGFkZXJEZXNjcmlwdG9yID0gcmVxdWlyZShcIi4vc2hhZGVyLWRlc2NyaXB0b3IuanNcIik7XHJcbnZhciBDb21wdXRlUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5Db21wdXRlUmVxdWVzdDtcclxudmFyIGFkZEZyYWdtZW50U2hhZGVySGVhZGVyID0gcmVxdWlyZShcIi4uLy4uL3NoYWRlci9zaGFkZXItdXRpbHMuanNcIikuYWRkRnJhZ21lbnRTaGFkZXJIZWFkZXI7XHJcbnJlcXVpcmUoXCIuL2RpZmZ1c2UuanNcIik7XHJcbnJlcXVpcmUoXCIuL3Bob25nLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9tYXR0ZS5qc1wiKTtcclxucmVxdWlyZShcIi4vcG9pbnQuanNcIik7XHJcbnJlcXVpcmUoXCIuL3V0aWxpdHkuanNcIik7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG52YXIgZ2V0U2hhZGVyRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICB2YXIgc2hhZGVyTmFtZSA9IHBhdGguc3Vic3RyaW5nKHBhdGgubGFzdEluZGV4T2YoJzonKSArIDEpO1xyXG4gICAgcmV0dXJuIFhNTDNELnNoYWRlcnMuZ2V0U2NyaXB0KHNoYWRlck5hbWUpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAaW1wbGVtZW50cyB7SVNoYWRlckNvbXBvc2VyfVxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFNoYWRlckNvbXBvc2VyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIFVSTlNoYWRlckNvbXBvc2VyID0gZnVuY3Rpb24gKGNvbnRleHQsIG1hdGVyaWFsQ29uZmlndXJhdGlvbikge1xyXG4gICAgQWJzdHJhY3RTaGFkZXJDb21wb3Nlci5jYWxsKHRoaXMsIGNvbnRleHQsIG1hdGVyaWFsQ29uZmlndXJhdGlvbik7XHJcbiAgICB0aGlzLmRlc2NyaXB0b3IgPSBudWxsO1xyXG4gICAgdGhpcy5zZXRNYXRlcmlhbENvbmZpZ3VyYXRpb24obWF0ZXJpYWxDb25maWd1cmF0aW9uKTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKFVSTlNoYWRlckNvbXBvc2VyLCBBYnN0cmFjdFNoYWRlckNvbXBvc2VyLCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge01hdGVyaWFsQ29uZmlndXJhdGlvbn0gbWF0ZXJpYWxDb25maWd1cmF0aW9uXHJcbiAgICAgKi9cclxuICAgIHNldE1hdGVyaWFsQ29uZmlndXJhdGlvbjogZnVuY3Rpb24gKG1hdGVyaWFsQ29uZmlndXJhdGlvbikge1xyXG4gICAgICAgIHZhciBzaGFkZXJTY3JpcHRVUkkgPSBtYXRlcmlhbENvbmZpZ3VyYXRpb24ubW9kZWwudXJuO1xyXG4gICAgICAgIHRoaXMuc2V0U2hhZGVyU2NyaXB0KHNoYWRlclNjcmlwdFVSSSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRlc2NyaXB0b3IpIHtcclxuICAgICAgICAgICAgbWF0ZXJpYWxDb25maWd1cmF0aW9uLmRhdGFOb2RlICYmIHRoaXMudXBkYXRlUmVxdWVzdChtYXRlcmlhbENvbmZpZ3VyYXRpb24uZGF0YU5vZGUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kZXNjcmlwdG9yLmZyYWdtZW50ID0gYWRkRnJhZ21lbnRTaGFkZXJIZWFkZXIodGhpcy5kZXNjcmlwdG9yLmZyYWdtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNoYWRlclNjcmlwdDogZnVuY3Rpb24gKHVyaSkge1xyXG5cclxuICAgICAgICBpZiAoIXVyaSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlNoYWRlciBoYXMgbm8gc2NyaXB0IGF0dGFjaGVkOiBcIiwgdGhpcy5hZGFwdGVyLm5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1cmkuc2NoZW1lICE9IFwidXJuXCIpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJTaGFkZXIgc2NyaXB0IHJlZmVyZW5jZSBzaG91bGQgc3RhcnQgd2l0aCBhbiBVUk46IFwiLCB0aGlzLmFkYXB0ZXIubm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRTaGFkZXJEZXNjcmlwdG9yKHVyaS5wYXRoKTtcclxuICAgICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBVUk46IFwiICsgdXJpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRvciA9IG5ldyBTaGFkZXJEZXNjcmlwdG9yKCk7XHJcbiAgICAgICAgWE1MM0QuZXh0ZW5kKHRoaXMuZGVzY3JpcHRvciwgZGVzY3JpcHRvcik7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFJlcXVlc3RGaWVsZHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kZXNjcmlwdG9yLnVuaWZvcm1zKS5jb25jYXQoT2JqZWN0LmtleXModGhpcy5kZXNjcmlwdG9yLnNhbXBsZXJzKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBhdHRyaWJ1dGVzIHJlcXVpcmVkIGJ5IHRoZSBzaGFkZXJcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3Q8c3RyaW5nLCAqPn1cclxuICAgICAqL1xyXG4gICAgZ2V0U2hhZGVyQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0b3IuYXR0cmlidXRlcztcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlU2hhZGVyQ2xvc3VyZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVVJOU2hhZGVyQ2xvc3VyZSh0aGlzLmNvbnRleHQsIHRoaXMuZGVzY3JpcHRvcik7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZU9iamVjdERhdGFSZXF1ZXN0OiBmdW5jdGlvbiAob2JqZWN0RGF0YU5vZGUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHJlcXVlc3ROYW1lcyA9IFtcInBvc2l0aW9uXCJdO1xyXG4gICAgICAgIHJlcXVlc3ROYW1lcy5wdXNoLmFwcGx5KHJlcXVlc3ROYW1lcywgT2JqZWN0LmtleXModGhpcy5kZXNjcmlwdG9yLmF0dHJpYnV0ZXMpKTtcclxuICAgICAgICByZXF1ZXN0TmFtZXMucHVzaC5hcHBseShyZXF1ZXN0TmFtZXMsIE9iamVjdC5rZXlzKHRoaXMuZGVzY3JpcHRvci51bmlmb3JtcykpO1xyXG4gICAgICAgIHJlcXVlc3ROYW1lcy5wdXNoLmFwcGx5KHJlcXVlc3ROYW1lcywgT2JqZWN0LmtleXModGhpcy5kZXNjcmlwdG9yLnNhbXBsZXJzKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wdXRlUmVxdWVzdChvYmplY3REYXRhTm9kZSwgcmVxdWVzdE5hbWVzLCBjYWxsYmFjayk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3RyaWJ1dGVPYmplY3RTaGFkZXJEYXRhOiBmdW5jdGlvbiAob2JqZWN0UmVxdWVzdCwgYXR0cmlidXRlQ2FsbGJhY2ssIHVuaWZvcm1DYWxsYmFjaykge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBvYmplY3RSZXF1ZXN0LmdldFJlc3VsdCgpO1xyXG5cclxuICAgICAgICB2YXIgZGF0YU1hcCA9IHJlc3VsdC5nZXRPdXRwdXRNYXAoKTtcclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGRhdGFNYXApIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwicG9zaXRpb25cIiB8fCB0aGlzLmRlc2NyaXB0b3IuYXR0cmlidXRlc1tuYW1lXSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlQ2FsbGJhY2sobmFtZSwgZGF0YU1hcFtuYW1lXSk7IGVsc2UgaWYgKHRoaXMuZGVzY3JpcHRvci51bmlmb3Jtc1tuYW1lXSAhPT0gdW5kZWZpbmVkIHx8IHRoaXMuZGVzY3JpcHRvci5zYW1wbGVyc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtQ2FsbGJhY2sobmFtZSwgZGF0YU1hcFtuYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVVJOU2hhZGVyQ29tcG9zZXI7XHJcblxyXG5cclxuIiwiWE1MM0Quc2hhZGVycy5yZWdpc3RlcihcInBpY2tvYmplY3RpZFwiLCB7XHJcbiAgICB2ZXJ0ZXggOiBbXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcIixcclxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4O1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICAgZ2xfUG9zaXRpb24gPSBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIGZyYWdtZW50IDogW1xyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGlkO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChpZCwgMC4wKTtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIHVuaWZvcm1zIDoge31cclxufSk7XHJcblxyXG5YTUwzRC5zaGFkZXJzLnJlZ2lzdGVyKFwicGlja2VkcG9zaXRpb25cIiwge1xyXG4gICAgdmVydGV4IDogW1xyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBiYm94WzJdO1wiLCAgLy8gbWluID0gYmJveFswXSwgbWF4ID0gYmJveFsxXVxyXG5cclxuICAgICAgICBcInZhcnlpbmcgdmVjMyB3b3JsZENvb3JkO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICAgd29ybGRDb29yZCA9IChtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCkpLnh5ejtcIixcclxuICAgICAgICBcIiAgICB2ZWMzIGRpZmYgPSBiYm94WzFdIC0gYmJveFswXTtcIixcclxuICAgICAgICBcIiAgICB3b3JsZENvb3JkID0gd29ybGRDb29yZCAtIGJib3hbMF07XCIsXHJcbiAgICAgICAgXCIgICAgd29ybGRDb29yZCA9IHdvcmxkQ29vcmQgLyBkaWZmO1wiLFxyXG4gICAgICAgIFwiICAgIGdsX1Bvc2l0aW9uID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICBmcmFnbWVudCA6IFtcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyB3b3JsZENvb3JkO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh3b3JsZENvb3JkLCAxLjApO1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgdW5pZm9ybXMgOiB7fVxyXG59KTtcclxuXHJcblxyXG5YTUwzRC5zaGFkZXJzLnJlZ2lzdGVyKFwicGlja2VkTm9ybWFsc1wiLCB7XHJcbiAgICB2ZXJ0ZXggOiBbXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcIixcclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcIixcclxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQzIG1vZGVsVmlld01hdHJpeE47XCIsXHJcblxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdOb3JtYWw7XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgICBmcmFnTm9ybWFsID0gbm9ybWFsaXplKG1vZGVsVmlld01hdHJpeE4gKiBub3JtYWwpO1wiLFxyXG4gICAgICAgIFwiICAgIGdsX1Bvc2l0aW9uID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICBmcmFnbWVudCA6IFtcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnTm9ybWFsO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgoZnJhZ05vcm1hbCsxLjApLzIuMCAqICgyNTQuMCAvIDI1NS4wKSwgMS4wKTtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIHVuaWZvcm1zIDoge31cclxufSk7XHJcblxyXG5YTUwzRC5zaGFkZXJzLnJlZ2lzdGVyKFwibGlnaHQtZGVwdGhcIiwge1xyXG5cclxuICAgIHZlcnRleDogW1xyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzQgd29ybGRQb3NpdGlvbjtcIixcclxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcIixcclxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4O1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1wiLFxyXG4gICAgICAgIFwiICAgZ2xfUG9zaXRpb24gICA9IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgZnJhZ21lbnQ6IFtcclxuICAgICAgICBcInZhcnlpbmcgdmVjNCB3b3JsZFBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIsXHJcblxyXG4gICAgICAgIFwidmVjNCBwYWNrX2RlcHRoKCBjb25zdCBpbiBmbG9hdCBkZXB0aCApIHtcIixcclxuICAgICAgICBcImNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wLCAyNTYuMCwgMS4wICk7XCIsXHJcbiAgICAgICAgXCJjb25zdCB2ZWM0IGJpdF9tYXNrICA9IHZlYzQoIDAuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCApO1wiLFxyXG4gICAgICAgIFwidmVjNCByZXMgPSBmcmFjdCggZGVwdGggKiBiaXRfc2hpZnQgKTtcIixcclxuICAgICAgICBcInJlcyAtPSByZXMueHh5eiAqIGJpdF9tYXNrO1wiLFxyXG4gICAgICAgIFwicmV0dXJuIHJlcztcIixcclxuICAgICAgICBcIn1cIixcclxuXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgICBnbF9GcmFnQ29sb3IgPSBwYWNrX2RlcHRoKCBnbF9GcmFnQ29vcmQueiApO1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgdW5pZm9ybXM6IHt9XHJcbn0pO1xyXG5cclxuWE1MM0Quc2hhZGVycy5yZWdpc3RlcihcInJlbmRlci1ub3JtYWxcIiwge1xyXG4gICAgdmVydGV4IDogW1xyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBub3JtYWw7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcIixcclxuICAgICAgICBcInVuaWZvcm0gbWF0MyBtb2RlbE1hdHJpeE47XCIsXHJcblxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdOb3JtYWw7XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgICBmcmFnTm9ybWFsID0gbW9kZWxNYXRyaXhOICogbm9ybWFsO1wiLFxyXG4gICAgICAgIFwiICAgIGdsX1Bvc2l0aW9uID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICBmcmFnbWVudCA6IFtcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnTm9ybWFsO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KChub3JtYWxpemUoZnJhZ05vcm1hbCkgKyAxLjApIC8gMi4wLCAxLjApO1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgdW5pZm9ybXMgOiB7fVxyXG59KTtcclxuXHJcblhNTDNELnNoYWRlcnMucmVnaXN0ZXIoXCJyZW5kZXItcG9zaXRpb25cIiwge1xyXG4gICAgdmVydGV4IDogW1xyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcIixcclxuXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgd29ybGRDb29yZDtcIixcclxuXHJcbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxyXG4gICAgICAgIFwiICAgIHdvcmxkQ29vcmQgPSAobW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApKS54eXo7XCIsXHJcbiAgICAgICAgXCIgICAgZ2xfUG9zaXRpb24gPSBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIGZyYWdtZW50IDogW1xyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIHdvcmxkQ29vcmQ7XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHdvcmxkQ29vcmQsIDEuMCk7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICB1bmlmb3JtcyA6IHt9XHJcbn0pO1xyXG5cclxuWE1MM0Quc2hhZGVycy5yZWdpc3RlcihcImJveGJsdXJcIiwge1xyXG4gICAgdmVydGV4OiBbXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcIixcclxuXHJcbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxyXG4gICAgICAgIFwiICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAxLjApO1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgZnJhZ21lbnQ6IFtcclxuICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIHNJblRleHR1cmU7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzIgY2FudmFzU2l6ZTtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMiBibHVyT2Zmc2V0O1wiLFxyXG5cclxuICAgICAgICBcImNvbnN0IGZsb2F0IGJsdXJTaXplID0gMS4wLzUxMi4wO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICB2ZWMyIHRleGNvb3JkID0gKGdsX0ZyYWdDb29yZC54eSAvIGNhbnZhc1NpemUueHkpO1wiLFxyXG4gICAgICAgIFwiICAgdmVjNCBzdW0gPSB2ZWM0KDAuMCk7XCIsXHJcbiAgICAgICAgXCIgICBmbG9hdCBibHVyU2l6ZVkgPSBibHVyT2Zmc2V0LnkgLyBjYW52YXNTaXplLnk7XCIsXHJcbiAgICAgICAgXCIgICBmbG9hdCBibHVyU2l6ZVggPSBibHVyT2Zmc2V0LnggLyBjYW52YXNTaXplLng7XCIsXHJcblxyXG4gICAgICAgIFwiICAgc3VtICs9IHRleHR1cmUyRChzSW5UZXh0dXJlLCB2ZWMyKHRleGNvb3JkLngsIHRleGNvb3JkLnkgLSAxLjUqYmx1clNpemVZKSk7XCIsXHJcbiAgICAgICAgXCIgICBzdW0gKz0gdGV4dHVyZTJEKHNJblRleHR1cmUsIHZlYzIodGV4Y29vcmQueCwgdGV4Y29vcmQueSAtIDIuMCpibHVyU2l6ZVkpKTtcIixcclxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54LCB0ZXhjb29yZC55IC0gYmx1clNpemVZKSk7XCIsXHJcbiAgICAgICAgXCIgICBzdW0gKz0gdGV4dHVyZTJEKHNJblRleHR1cmUsIHZlYzIodGV4Y29vcmQueCwgdGV4Y29vcmQueSArIGJsdXJTaXplWSkpO1wiLFxyXG4gICAgICAgIFwiICAgc3VtICs9IHRleHR1cmUyRChzSW5UZXh0dXJlLCB2ZWMyKHRleGNvb3JkLngsIHRleGNvb3JkLnkgKyAyLjAqYmx1clNpemVZKSk7XCIsXHJcbiAgICAgICAgXCIgICBzdW0gKz0gdGV4dHVyZTJEKHNJblRleHR1cmUsIHZlYzIodGV4Y29vcmQueCwgdGV4Y29vcmQueSArIDEuNSpibHVyU2l6ZVkpKTtcIixcclxuXHJcbiAgICAgICAgXCIgICBzdW0gKz0gdGV4dHVyZTJEKHNJblRleHR1cmUsIHZlYzIodGV4Y29vcmQueCAtIDEuNSpibHVyU2l6ZVgsIHRleGNvb3JkLnkpKTtcIixcclxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54IC0gMi4wKmJsdXJTaXplWCwgdGV4Y29vcmQueSkpO1wiLFxyXG4gICAgICAgIFwiICAgc3VtICs9IHRleHR1cmUyRChzSW5UZXh0dXJlLCB2ZWMyKHRleGNvb3JkLnggLSBibHVyU2l6ZVgsIHRleGNvb3JkLnkpKTtcIixcclxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54ICsgYmx1clNpemVYLCB0ZXhjb29yZC55KSk7XCIsXHJcbiAgICAgICAgXCIgICBzdW0gKz0gdGV4dHVyZTJEKHNJblRleHR1cmUsIHZlYzIodGV4Y29vcmQueCArIDIuMCpibHVyU2l6ZVgsIHRleGNvb3JkLnkpKTtcIixcclxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54ICsgMS41KmJsdXJTaXplWCwgdGV4Y29vcmQueSkpO1wiLFxyXG5cclxuICAgICAgICBcIiAgIGdsX0ZyYWdDb2xvciA9IHN1bSAvIDEyLjA7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICB1bmlmb3Jtczoge1xyXG4gICAgICAgIGNhbnZhc1NpemUgOiBbNTEyLCA1MTJdLFxyXG4gICAgICAgIGJsdXJPZmZzZXQgOiBbMS4wLCAxLjBdXHJcbiAgICB9LFxyXG5cclxuICAgIHNhbXBsZXJzOiB7XHJcbiAgICAgICAgc0luVGV4dHVyZSA6IG51bGxcclxuICAgIH1cclxufSk7XHJcblxyXG5YTUwzRC5zaGFkZXJzLnJlZ2lzdGVyKFwic3Nhb1wiLCB7XHJcbiAgICB2ZXJ0ZXggOiBbXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIixcclxuXHJcbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxyXG4gICAgICAgIFwiICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMC4wLCAxLjApO1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgZnJhZ21lbnQgOiBbXHJcbiAgICAgICAgXCIjaWZkZWYgR0xfRVNcIixcclxuICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcIixcclxuICAgICAgICBcIiNlbmRpZlwiLFxyXG5cclxuICAgICAgICBcInVuaWZvcm0gdmVjMiBjYW52YXNTaXplO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgc1Bvc2l0aW9uVGV4O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgc05vcm1hbFRleDtcIixcclxuICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIHNSYW5kb21Ob3JtYWxzO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMyIHVSYW5kb21UZXhTaXplO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCB1U2FtcGxlUmFkaXVzO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCB1U2NhbGU7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHVCaWFzO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCB1SW50ZW5zaXR5O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMyIHVDb25zdFZlY3RvcnNbNF07XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcIixcclxuXHJcbiAgICAgICAgXCJ2ZWMzIGdldFBvc2l0aW9uKHZlYzIgdXYpIHtcIixcclxuICAgICAgICBcInJldHVybiB0ZXh0dXJlMkQoc1Bvc2l0aW9uVGV4LCB1dikueHl6O1wiLFxyXG4gICAgICAgIFwifVwiLFxyXG5cclxuICAgICAgICBcImZsb2F0IGNhbGNBbWJpZW50T2NjbHVzaW9uKHZlYzIgc2NyZWVuVVYsIHZlYzIgdXZPZmZzZXQsIHZlYzMgb3JpZ2luLCB2ZWMzIGNub3JtKSB7XCIsXHJcbiAgICAgICAgXCIgICB2ZWMzIGRpZmYgPSBnZXRQb3NpdGlvbihzY3JlZW5VViArIHV2T2Zmc2V0KSAtIG9yaWdpbjtcIixcclxuICAgICAgICBcIiAgIHZlYzMgdiA9IG5vcm1hbGl6ZShkaWZmKTtcIixcclxuICAgICAgICBcIiAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoZGlmZikgKiB1U2NhbGU7XCIsXHJcbiAgICAgICAgXCIgICByZXR1cm4gbWF4KDAuMCwgZG90KGNub3JtLCB2KSAtIHVCaWFzKSAqICgxLjAvKDEuMCArIGRpc3QpKSAqIHVJbnRlbnNpdHk7XCIsXHJcbiAgICAgICAgXCJ9XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgIHZlYzIgc2NyZWVuVVYgPSBnbF9GcmFnQ29vcmQueHkgLyBjYW52YXNTaXplLnh5O1wiLFxyXG4gICAgICAgIFwiICAgdmVjMiByYW5kID0gbm9ybWFsaXplKHRleHR1cmUyRChzUmFuZG9tTm9ybWFscywgZ2xfRnJhZ0Nvb3JkLnh5IC8gdVJhbmRvbVRleFNpemUpLnh5ICogMi4wIC0gMS4wICk7XCIsXHJcbiAgICAgICAgXCIgICB2ZWMzIG5vcm0gPSBub3JtYWxpemUodGV4dHVyZTJEKHNOb3JtYWxUZXgsIHNjcmVlblVWKS54eXogKiAyLjAgLSAxLjAgKTtcIixcclxuICAgICAgICBcIiAgIHZlYzMgb3JpZ2luID0gZ2V0UG9zaXRpb24oc2NyZWVuVVYpO1wiLFxyXG4gICAgICAgIFwiICAgZmxvYXQgcmFkaXVzID0gdVNhbXBsZVJhZGl1cyAvICh2aWV3TWF0cml4ICogdmVjNChvcmlnaW4sIDEuMCkpLno7XCIsXHJcbiAgICAgICAgXCIgICBmbG9hdCBhbyA9IDAuMDtcIixcclxuXHJcbiAgICAgICAgXCIgICBjb25zdCBpbnQgaXRlcmF0aW9ucyA9IDQ7XCIsXHJcbiAgICAgICAgXCIgICBmb3IgKGludCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7ICsraSkge1wiLFxyXG4gICAgICAgIFwiICAgICAgIHZlYzIgY29vcmQxID0gcmVmbGVjdCh1Q29uc3RWZWN0b3JzW2ldLCByYW5kKSAqIHJhZGl1cztcIixcclxuICAgICAgICBcIiAgICAgICB2ZWMyIGNvb3JkMiA9IHZlYzIoY29vcmQxLngqMC43MDcgLSBjb29yZDEueSowLjcwNywgY29vcmQxLngqMC43MDcgKyBjb29yZDEueSowLjcwNyk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgYW8gKz0gY2FsY0FtYmllbnRPY2NsdXNpb24oc2NyZWVuVVYsIGNvb3JkMSowLjI1LCBvcmlnaW4sIG5vcm0pO1wiLFxyXG4gICAgICAgIFwiICAgICAgIGFvICs9IGNhbGNBbWJpZW50T2NjbHVzaW9uKHNjcmVlblVWLCBjb29yZDIqMC41LCBvcmlnaW4sIG5vcm0pO1wiLFxyXG4gICAgICAgIFwiICAgICAgIGFvICs9IGNhbGNBbWJpZW50T2NjbHVzaW9uKHNjcmVlblVWLCBjb29yZDEqMC43NSwgb3JpZ2luLCBub3JtKTtcIixcclxuICAgICAgICBcIiAgICAgICBhbyArPSBjYWxjQW1iaWVudE9jY2x1c2lvbihzY3JlZW5VViwgY29vcmQyLCBvcmlnaW4sIG5vcm0pO1wiLFxyXG4gICAgICAgIFwiICAgfVwiLFxyXG4gICAgICAgIFwiICAgYW8gLz0gKGZsb2F0KGl0ZXJhdGlvbnMpICogNC4wKTtcIixcclxuICAgICAgICBcIiAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoYW8sIGFvLCBhbywgMS4wKTtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIHVuaWZvcm1zOiB7XHJcbiAgICAgICAgY2FudmFzU2l6ZSAgICAgIDogWzUxMiwgNTEyXSxcclxuICAgICAgICB1Q29uc3RWZWN0b3JzICAgOiBbMSwwLCAtMSwwLCAwLDEsIDAsLTFdLFxyXG4gICAgICAgIHVSYW5kb21UZXhTaXplICA6IFs2NCw2NF0sXHJcbiAgICAgICAgdVNhbXBsZVJhZGl1cyAgIDogMC45LFxyXG4gICAgICAgIHVTY2FsZSAgICAgICAgICA6IDAuOSxcclxuICAgICAgICB1QmlhcyAgICAgICAgICAgOiAwLjIsXHJcbiAgICAgICAgdUludGVuc2l0eSAgICAgIDogMS4wXHJcbiAgICB9LFxyXG5cclxuICAgIHNhbXBsZXJzOiB7XHJcbiAgICAgICAgc1Bvc2l0aW9uVGV4ICAgOiBudWxsLFxyXG4gICAgICAgIHNOb3JtYWxUZXggICAgIDogbnVsbCxcclxuICAgICAgICBzUmFuZG9tTm9ybWFscyA6IG51bGxcclxuICAgIH0sXHJcblxyXG4gICAgYXR0cmlidXRlczoge1xyXG4gICAgfVxyXG59KTtcclxuIiwiLy8gTm90ZTogVGhpcyBjb250ZXh0IHNob3VsZCBvbmx5IGJlIHVzZWQgdG8gYWNjZXNzIEdMIGNvbnN0YW50c1xyXG52YXIgR0wgPSB3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xyXG52YXIgRm9yd2FyZFJlbmRlclRyZWUgPSByZXF1aXJlKFwiLi9yZW5kZXItdHJlZXMvZm9yd2FyZC5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge0dMQ29udGV4dH0gY29udGV4dFxyXG4gKiBAcGFyYW0ge1NjZW5lfSBzY2VuZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBHTFJlbmRlckludGVyZmFjZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBzY2VuZSkge1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgIHRoaXMub3B0aW9ucyA9IHtcclxuICAgICAgICBwaWNraW5nRW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICBtb3VzZU1vdmVQaWNraW5nRW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICBnbEJsZW5kRnVuY1NlcGFyYXRlOiBbR0wuU1JDX0FMUEhBLCBHTC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBHTC5PTkUsIEdMLk9ORV9NSU5VU19TUkNfQUxQSEFdXHJcbiAgICB9O1xyXG4gICAgdGhpcy5yZW5kZXJQaXBlbGluZSA9IG51bGw7XHJcbn07XHJcblxyXG5YTUwzRC5leHRlbmQoR0xSZW5kZXJJbnRlcmZhY2UucHJvdG90eXBlLCB7XHJcbiAgICBnZXRSZW5kZXJQaXBlbGluZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5yZW5kZXJQaXBlbGluZSA9IHRoaXMucmVuZGVyUGlwZWxpbmUgfHwgbmV3IEZvcndhcmRSZW5kZXJUcmVlKHRoaXMuY29udGV4dCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRSZW5kZXJQaXBlbGluZTogZnVuY3Rpb24gKHBpcGVsaW5lKSB7XHJcbiAgICAgICAgLy9UT0RPIGNsZWFudXAgb2xkIHBpcGVsaW5lXHJcbiAgICAgICAgdGhpcy5yZW5kZXJQaXBlbGluZSA9IHBpcGVsaW5lO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0UmVkcmF3KFwiUGlwZWxpbmUgY2hhbmdlZFwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UmVuZGVyT3B0aW9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHTFJlbmRlckludGVyZmFjZTtcclxuXHJcbiIsIi8qKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBCYXNlUmVuZGVyUGFzcyA9IGZ1bmN0aW9uIChyZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KSB7XHJcbiAgICB0aGlzLnJlbmRlckludGVyZmFjZSA9IHJlbmRlckludGVyZmFjZTtcclxuICAgIHRoaXMub3V0cHV0ID0gb3V0cHV0O1xyXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgdGhpcy5pbnB1dHMgPSBvcHQuaW5wdXRzIHx8IHt9O1xyXG4gICAgdGhpcy5pZCA9IG9wdC5pZCB8fCBcIlwiO1xyXG4gICAgdGhpcy5wcmVQYXNzZXMgPSBbXTtcclxuICAgIHRoaXMucG9zdFBhc3NlcyA9IFtdO1xyXG4gICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcclxufTtcclxuXHJcblhNTDNELmV4dGVuZChCYXNlUmVuZGVyUGFzcy5wcm90b3R5cGUsIHtcclxuICAgIGFkZFByZVBhc3M6IGZ1bmN0aW9uIChwYXNzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJlUGFzc2VzLmluZGV4T2YocGFzcykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlUGFzc2VzLnB1c2gocGFzcyk7XHJcbiAgICAgICAgICAgIHBhc3MucG9zdFBhc3Nlcy5wdXNoKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlUHJlUGFzczogZnVuY3Rpb24gKHBhc3MpIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5wcmVQYXNzZXMuaW5kZXhPZihwYXNzKTtcclxuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLnByZVBhc3Nlcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgcGFzcy5wb3N0UGFzc2VzLnNwbGljZShwYXNzLnBvc3RQYXNzZXMuaW5kZXhPZih0aGlzKSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhclByZVBhc3NlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5wcmVQYXNzZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUHJlUGFzcyh0aGlzLnByZVBhc3Nlc1tpXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFByb2Nlc3NlZDogZnVuY3Rpb24gKHByb2Nlc3NlZCkge1xyXG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NlZCAmJiAhcHJvY2Vzc2VkKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5wb3N0UGFzc2VzLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zdFBhc3Nlc1tpXS5zZXRQcm9jZXNzZWQoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHByb2Nlc3NlZDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyVHJlZTogZnVuY3Rpb24gKHNjZW5lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5wcmVQYXNzZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pXHJcbiAgICAgICAgICAgIHRoaXMucHJlUGFzc2VzW2ldLnJlbmRlclRyZWUoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyKHNjZW5lKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBwaXhlbHMgZnJvbSB0aGUgcGFzcydzIHRhcmdldFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnbFggT3BlbkdMIENvb3JkaW5hdGUgaW4gdGhlIHRhcmdldFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdsWSBPcGVuR0wgQ29vcmRpbmF0ZSBpbiB0aGUgdGFyZ2V0XHJcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gcGl4ZWwgZGF0YVxyXG4gICAgICovXHJcbiAgICByZWFkUGl4ZWxEYXRhRnJvbUJ1ZmZlcjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY19kYXRhID0gbmV3IFVpbnQ4QXJyYXkoOCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ2xYLCBnbFksIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0LmdsO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSB0YXJnZXQuZ2V0U2NhbGUoKTtcclxuICAgICAgICAgICAgdmFyIHggPSBnbFggKiBzY2FsZTtcclxuICAgICAgICAgICAgdmFyIHkgPSBnbFkgKiBzY2FsZTtcclxuXHJcbiAgICAgICAgICAgIHRhcmdldC5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBnbC5yZWFkUGl4ZWxzKHgsIHksIDEsIDEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGNfZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY19kYXRhO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFeGNlcHRpb24oZSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0oKSlcclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYXNlUmVuZGVyUGFzcztcclxuXHJcbiIsInZhciBCYXNlUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XHJcbnZhciBGdWxsc2NyZWVuUXVhZCA9IHJlcXVpcmUoXCIuLi9iYXNlL2Z1bGxzY3JlZW5xdWFkLmpzXCIpO1xyXG5cclxudmFyIEJveEJsdXJQYXNzID0gZnVuY3Rpb24gKHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBvcHQpIHtcclxuICAgIEJhc2VSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XHJcbiAgICB0aGlzLl9wcm9ncmFtID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5wcm9ncmFtRmFjdG9yeS5nZXRQcm9ncmFtQnlOYW1lKFwiYm94Ymx1clwiKTtcclxuICAgIHRoaXMuX3NjcmVlblF1YWQgPSBuZXcgRnVsbHNjcmVlblF1YWQodGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dCk7XHJcbiAgICB0aGlzLl91bmlmb3Jtc0RpcnR5ID0gdHJ1ZTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKEJveEJsdXJQYXNzLCBCYXNlUmVuZGVyUGFzcyk7XHJcblxyXG5YTUwzRC5leHRlbmQoQm94Qmx1clBhc3MucHJvdG90eXBlLCB7XHJcbiAgICByZW5kZXI6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbDtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMub3V0cHV0O1xyXG5cclxuICAgICAgICAgICAgdGFyZ2V0LmJpbmQoKTtcclxuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLmJpbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Tm9uVm9sYXRpbGVTaGFkZXJVbmlmb3JtcygpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fc2NyZWVuUXVhZC5kcmF3KHRoaXMuX3Byb2dyYW0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbS51bmJpbmQoKTtcclxuICAgICAgICAgICAgdGFyZ2V0LnVuYmluZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0oKSksXHJcblxyXG4gICAgX3NldE5vblZvbGF0aWxlU2hhZGVyVW5pZm9ybXM6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHVuaWZvcm1zID0ge307XHJcbiAgICAgICAgdmFyIHVuaWZvcm1OYW1lcyA9IFtcImNhbnZhc1NpemVcIiwgXCJzSW5UZXh0dXJlXCIsIFwiYmx1ck9mZnNldFwiXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl91bmlmb3Jtc0RpcnR5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLl9wcm9ncmFtO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5vdXRwdXQ7XHJcblxyXG4gICAgICAgICAgICB1bmlmb3Jtc1tcImNhbnZhc1NpemVcIl0gPSBbdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0XTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbXCJzSW5UZXh0dXJlXCJdID0gW3RoaXMuaW5wdXRzLmJ1ZmZlci5jb2xvclRhcmdldC5oYW5kbGVdO1xyXG4gICAgICAgICAgICB1bmlmb3Jtc1tcImJsdXJPZmZzZXRcIl0gPSBbMS4wLCAxLjBdO1xyXG4gICAgICAgICAgICBwcm9ncmFtLnNldFN5c3RlbVVuaWZvcm1WYXJpYWJsZXModW5pZm9ybU5hbWVzLCB1bmlmb3Jtcyk7XHJcblxyXG4vLyAgICAgICAgICAgICAgICB0aGlzLl91bmlmb3Jtc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSkoKVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm94Qmx1clBhc3M7XHJcblxyXG4iLCJ2YXIgU2NlbmVSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vc2NlbmUtcGFzcy5qc1wiKTtcclxudmFyIE9iamVjdFNvcnRlciA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJlci90b29scy9vYmplY3Rzb3J0ZXIuanNcIik7XHJcblxyXG52YXIgRm9yd2FyZFJlbmRlclBhc3MgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCkge1xyXG4gICAgU2NlbmVSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XHJcbiAgICB0aGlzLnNvcnRlciA9IG5ldyBPYmplY3RTb3J0ZXIoKTtcclxuICAgIHRoaXMubGFzdFJlbmRlclN0YXRzID0ge307XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhGb3J3YXJkUmVuZGVyUGFzcywgU2NlbmVSZW5kZXJQYXNzKTtcclxuXHJcblhNTDNELmV4dGVuZChGb3J3YXJkUmVuZGVyUGFzcy5wcm90b3R5cGUsIHtcclxuXHJcblxyXG4gICAgcmVuZGVyOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIEZsb2F0MzJBcnJheVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBjX3dvcmxkVG9WaWV3TWF0cml4ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX3ZpZXdUb1dvcmxkTWF0cml4ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX3Byb2plY3Rpb25NYXRyaXggPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfcHJvZ3JhbVN5c3RlbVVuaWZvcm1zID0gW1widmlld01hdHJpeFwiLCBcInZpZXdJbnZlcnNlTWF0cml4XCIsIFwicHJvamVjdGlvbk1hdHJpeFwiLCBcImNhbWVyYVBvc2l0aW9uXCIsIFwiY29vcmRzXCIsIFwic3Nhb01hcFwiLCBcIndpZHRoXCJdO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNjZW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQuZ2wsIGNvdW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdHM6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbWl0aXZlczogMFxyXG4gICAgICAgICAgICAgICAgfSwgdGFyZ2V0ID0gdGhpcy5vdXRwdXQsIHN5c3RlbVVuaWZvcm1zID0gc2NlbmUuc3lzdGVtVW5pZm9ybXMsIHdpZHRoID0gdGFyZ2V0LmdldFdpZHRoKCksIGhlaWdodCA9IHRhcmdldC5nZXRIZWlnaHQoKSwgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICB0YXJnZXQuYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEdMU3RhdGVzKCk7XHJcbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgc2NlbmUudXBkYXRlUmVhZHlPYmplY3RzRnJvbUFjdGl2ZVZpZXcoYXNwZWN0KTtcclxuICAgICAgICAgICAgc2NlbmUuZ2V0QWN0aXZlVmlldygpLmdldFdvcmxkVG9WaWV3TWF0cml4KGNfd29ybGRUb1ZpZXdNYXRyaXgpO1xyXG4gICAgICAgICAgICBzY2VuZS5nZXRBY3RpdmVWaWV3KCkuZ2V0Vmlld1RvV29ybGRNYXRyaXgoY192aWV3VG9Xb3JsZE1hdHJpeCk7XHJcbiAgICAgICAgICAgIHNjZW5lLmdldEFjdGl2ZVZpZXcoKS5nZXRQcm9qZWN0aW9uTWF0cml4KGNfcHJvamVjdGlvbk1hdHJpeCwgYXNwZWN0KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzb3J0ZWQgPSB0aGlzLnNvcnRlci5zb3J0U2NlbmUoc2NlbmUsIGNfd29ybGRUb1ZpZXdNYXRyaXgpO1xyXG5cclxuICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJ2aWV3TWF0cml4XCJdID0gY193b3JsZFRvVmlld01hdHJpeDtcclxuICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJ2aWV3SW52ZXJzZU1hdHJpeFwiXSA9IGNfdmlld1RvV29ybGRNYXRyaXg7XHJcbiAgICAgICAgICAgIHN5c3RlbVVuaWZvcm1zW1wicHJvamVjdGlvbk1hdHJpeFwiXSA9IGNfcHJvamVjdGlvbk1hdHJpeDtcclxuICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJjYW1lcmFQb3NpdGlvblwiXSA9IHNjZW5lLmdldEFjdGl2ZVZpZXcoKS5nZXRXb3JsZFNwYWNlUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJjb29yZHNcIl0gPSBbdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0LCAxXTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0cy5zc2FvTWFwKVxyXG4gICAgICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJzc2FvTWFwXCJdID0gW3RoaXMuaW5wdXRzLnNzYW9NYXAuY29sb3JUYXJnZXQuaGFuZGxlXTtcclxuXHJcbiAgICAgICAgICAgIC8vUmVuZGVyIG9wYXF1ZSBvYmplY3RzXHJcbiAgICAgICAgICAgIGZvciAodmFyIHByb2dyYW0gaW4gc29ydGVkLm9wYXF1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJPYmplY3RzVG9BY3RpdmVCdWZmZXIoc29ydGVkLm9wYXF1ZVtwcm9ncmFtXSwgc2NlbmUsIHRhcmdldCwgc3lzdGVtVW5pZm9ybXMsIGNfcHJvZ3JhbVN5c3RlbVVuaWZvcm1zLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRzOiBjb3VudFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vUmVuZGVyIHRyYW5zcGFyZW50IG9iamVjdHNcclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzb3J0ZWQudHJhbnNwYXJlbnQubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYmplY3RBcnJheSA9IFtzb3J0ZWQudHJhbnNwYXJlbnRba11dO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJPYmplY3RzVG9BY3RpdmVCdWZmZXIob2JqZWN0QXJyYXksIHNjZW5lLCB0YXJnZXQsIHN5c3RlbVVuaWZvcm1zLCBjX3Byb2dyYW1TeXN0ZW1Vbmlmb3Jtcywge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRzOiBjb3VudFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2NlbmUubGlnaHRzLmNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGFyZ2V0LnVuYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RSZW5kZXJTdGF0cy5jb3VudCA9IGNvdW50O1xyXG4gICAgICAgIH1cclxuICAgIH0oKSksXHJcblxyXG4gICAgZ2V0UmVuZGVyU3RhdHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0UmVuZGVyU3RhdHM7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZvcndhcmRSZW5kZXJQYXNzO1xyXG5cclxuIiwidmFyIFNjZW5lUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCIuL3NjZW5lLXBhc3MuanNcIik7XHJcbnZhciBPYmplY3RTb3J0ZXIgPSByZXF1aXJlKFwiLi4vLi4vcmVuZGVyZXIvdG9vbHMvb2JqZWN0c29ydGVyLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7R0xSZW5kZXJJbnRlcmZhY2V9IHJlbmRlckludGVyZmFjZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3V0cHV0XHJcbiAqIEBwYXJhbSB7UmVuZGVyTGlnaHR9IGxpZ2h0XHJcbiAqIEBwYXJhbSB7Kn0gb3B0XHJcbiAqIEBleHRlbmRzIHtTY2VuZVJlbmRlclBhc3N9XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIExpZ2h0UGFzcyA9IGZ1bmN0aW9uIChyZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgbGlnaHQsIG9wdCkge1xyXG4gICAgU2NlbmVSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XHJcbiAgICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoTGlnaHRQYXNzLCBTY2VuZVJlbmRlclBhc3MsIHtcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuc29ydGVyID0gbmV3IE9iamVjdFNvcnRlcigpO1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IGNvbnRleHQucHJvZ3JhbUZhY3RvcnkuZ2V0UHJvZ3JhbUJ5TmFtZShcImxpZ2h0LWRlcHRoXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXJTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5saWdodC5zY2VuZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbmRlcjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY192aWV3TWF0X3RtcCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY19wcm9qTWF0X3RtcCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY19wcm9ncmFtU3lzdGVtVW5pZm9ybXMgPSBbXCJ2aWV3TWF0cml4XCIsIFwicHJvamVjdGlvbk1hdHJpeFwiXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzY2VuZSkge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0LmdsLCB0YXJnZXQgPSB0aGlzLm91dHB1dCwgd2lkdGggPSB0YXJnZXQuZ2V0V2lkdGgoKSwgaGVpZ2h0ID0gdGFyZ2V0LmdldEhlaWdodCgpLCBhc3BlY3QgPSB3aWR0aCAvIGhlaWdodCwgZnJ1c3R1bSA9IHRoaXMubGlnaHQuZ2V0RnJ1c3R1bShhc3BlY3QpLCBwcm9ncmFtID0gdGhpcy5wcm9ncmFtO1xyXG5cclxuICAgICAgICAgICAgdGFyZ2V0LmJpbmQoKTtcclxuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvdW50ID0ge29iamVjdHM6IDAsIHByaW1pdGl2ZXM6IDB9O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5saWdodC5tb2RlbC5nZXRMaWdodFZpZXdNYXRyaXgoY192aWV3TWF0X3RtcCk7XHJcbiAgICAgICAgICAgIGZydXN0dW0uZ2V0UHJvamVjdGlvbk1hdHJpeChjX3Byb2pNYXRfdG1wLCBhc3BlY3QpO1xyXG5cclxuICAgICAgICAgICAgc2NlbmUudXBkYXRlUmVhZHlPYmplY3RzRnJvbU1hdHJpY2VzKGNfdmlld01hdF90bXAsIGNfcHJvak1hdF90bXApO1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuc29ydGVyLnNvcnRTY2VuZShzY2VuZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHt9O1xyXG4gICAgICAgICAgICBwYXJhbWV0ZXJzW1widmlld01hdHJpeFwiXSA9IGNfdmlld01hdF90bXA7XHJcbiAgICAgICAgICAgIHBhcmFtZXRlcnNbXCJwcm9qZWN0aW9uTWF0cml4XCJdID0gY19wcm9qTWF0X3RtcDtcclxuXHJcbiAgICAgICAgICAgIC8vUmVuZGVyIG9wYXF1ZSBvYmplY3RzXHJcbiAgICAgICAgICAgIGZvciAodmFyIHNoYWRlciBpbiBvYmplY3RzLm9wYXF1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJPYmplY3RzVG9BY3RpdmVCdWZmZXIob2JqZWN0cy5vcGFxdWVbc2hhZGVyXSwgc2NlbmUsIHRhcmdldCwgcGFyYW1ldGVycywgY19wcm9ncmFtU3lzdGVtVW5pZm9ybXMsIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsIHN0YXRzOiBjb3VudCwgcHJvZ3JhbTogcHJvZ3JhbVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERvIG5vdCByZW5kZXIgdHJhbnNwYXJlbnQgb2JqZWN0cyAoY29uc2lkZXJlZCB0byBub3QgdGhyb3cgc2hhZG93c1xyXG4gICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7Y291bnQ6IGNvdW50fTtcclxuICAgICAgICB9XHJcbiAgICB9KCkpXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaWdodFBhc3M7XHJcblxyXG4iLCJ2YXIgQmFzZVJlbmRlclBhc3MgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xyXG5cclxudmFyIFBpY2tOb3JtYWxSZW5kZXJQYXNzID0gZnVuY3Rpb24gKHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBvcHQpIHtcclxuICAgIEJhc2VSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhQaWNrTm9ybWFsUmVuZGVyUGFzcywgQmFzZVJlbmRlclBhc3MsIHtcclxuICAgIHJlbmRlcjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY19tb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX3dvcmxkTWF0cml4ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX25vcm1hbE1hdHJpeDMgPSBYTUwzRC5tYXRoLm1hdDMuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfdW5pZm9ybUNvbGxlY3Rpb24gPSB7XHJcbiAgICAgICAgICAgICAgICBlbnZCYXNlOiB7fSxcclxuICAgICAgICAgICAgICAgIGVudk92ZXJyaWRlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgc3lzQmFzZToge31cclxuICAgICAgICAgICAgfSwgY19zeXN0ZW1Vbmlmb3JtTmFtZXMgPSBbXCJtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4XCIsIFwibW9kZWxWaWV3TWF0cml4TlwiXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QsIHZpZXdNYXRyaXgsIHByb2pNYXRyaXgpIHtcclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbCwgdGFyZ2V0ID0gdGhpcy5vdXRwdXQ7XHJcblxyXG4gICAgICAgICAgICB0YXJnZXQuYmluZCgpO1xyXG4gICAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2aWV3TWF0cml4ICYmIHByb2pNYXRyaXgpIHtcclxuICAgICAgICAgICAgICAgIG9iamVjdC51cGRhdGVNb2RlbFZpZXdNYXRyaXgodmlld01hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QudXBkYXRlTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeChwcm9qTWF0cml4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb2JqZWN0LmdldE1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgoY19tb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4KTtcclxuXHJcbiAgICAgICAgICAgIG9iamVjdC5nZXRXb3JsZE1hdHJpeChjX3dvcmxkTWF0cml4KTtcclxuICAgICAgICAgICAgaWYgKCFYTUwzRC5tYXRoLm1hdDMubm9ybWFsRnJvbU1hdDQoY19ub3JtYWxNYXRyaXgzLCBjX3dvcmxkTWF0cml4KSkge1xyXG4gICAgICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQzLmlkZW50aXR5KGNfbm9ybWFsTWF0cml4Myk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG5cclxuICAgICAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0LnByb2dyYW1GYWN0b3J5LmdldFBpY2tpbmdOb3JtYWxQcm9ncmFtKCk7XHJcbiAgICAgICAgICAgIHByb2dyYW0uYmluZCgpO1xyXG5cclxuICAgICAgICAgICAgY191bmlmb3JtQ29sbGVjdGlvbi5zeXNCYXNlW1wibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFwiXSA9IGNfbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcclxuICAgICAgICAgICAgY191bmlmb3JtQ29sbGVjdGlvbi5zeXNCYXNlW1wibW9kZWxWaWV3TWF0cml4TlwiXSA9IGNfbm9ybWFsTWF0cml4MztcclxuXHJcbiAgICAgICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybVZhcmlhYmxlcyhudWxsLCBjX3N5c3RlbVVuaWZvcm1OYW1lcywgY191bmlmb3JtQ29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgIG9iamVjdC5tZXNoLmRyYXcocHJvZ3JhbSk7XHJcblxyXG4gICAgICAgICAgICBwcm9ncmFtLnVuYmluZCgpO1xyXG4gICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSgpKSwgLyoqXHJcbiAgICAgKiBSZWFkIG5vcm1hbCBmcm9tIHBpY2tpbmcgYnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2xYIE9wZW5HTCBDb29yZGluYXRlIG9mIGNvbG9yIGJ1ZmZlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdsWSBPcGVuR0wgQ29vcmRpbmF0ZSBvZiBjb2xvciBidWZmZXJcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFZlY3RvciB3aXRoIG5vcm1hbCBkYXRhXHJcbiAgICAgKi9cclxuICAgIHJlYWROb3JtYWxGcm9tUGlja2luZ0J1ZmZlcjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY19waWNrVmVjdG9yID0gWE1MM0QubWF0aC52ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX29uZSA9IFhNTDNELm1hdGgudmVjMy5mcm9tVmFsdWVzKDEsIDEsIDEpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdsWCwgZ2xZKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5yZWFkUGl4ZWxEYXRhRnJvbUJ1ZmZlcihnbFgsIGdsWSwgdGhpcy5vdXRwdXQpO1xyXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNfcGlja1ZlY3RvclswXSA9IGRhdGFbMF0gLyAyNTQ7XHJcbiAgICAgICAgICAgIGNfcGlja1ZlY3RvclsxXSA9IGRhdGFbMV0gLyAyNTQ7XHJcbiAgICAgICAgICAgIGNfcGlja1ZlY3RvclsyXSA9IGRhdGFbMl0gLyAyNTQ7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBPcHRpbWl6ZSAoMiBGbG9hdCBhcnJheXMgY3JlYXRlZClcclxuICAgICAgICAgICAgcmV0dXJuIFhNTDNELm1hdGgudmVjMy5zdWJ0cmFjdChYTUwzRC5tYXRoLnZlYzMuY3JlYXRlKCksIFhNTDNELm1hdGgudmVjMy5zY2FsZShYTUwzRC5tYXRoLnZlYzMuY3JlYXRlKCksIGNfcGlja1ZlY3RvciwgMi4wKSwgY19vbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH0oKSlcclxufSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQaWNrTm9ybWFsUmVuZGVyUGFzcztcclxuXHJcbiIsInZhciBCYXNlUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XHJcblxyXG52YXIgUGlja09iamVjdFJlbmRlclBhc3MgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCkge1xyXG4gICAgQmFzZVJlbmRlclBhc3MuY2FsbCh0aGlzLCByZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoUGlja09iamVjdFJlbmRlclBhc3MsIEJhc2VSZW5kZXJQYXNzKTtcclxuXHJcblhNTDNELmV4dGVuZChQaWNrT2JqZWN0UmVuZGVyUGFzcy5wcm90b3R5cGUsIHtcclxuICAgIHJlbmRlcjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY19tdnAgPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCksIGNfdW5pZm9ybUNvbGxlY3Rpb24gPSB7XHJcbiAgICAgICAgICAgICAgICBlbnZCYXNlOiB7fSxcclxuICAgICAgICAgICAgICAgIGVudk92ZXJyaWRlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgc3lzQmFzZToge31cclxuICAgICAgICAgICAgfSwgY19zeXN0ZW1Vbmlmb3JtTmFtZXMgPSBbXCJpZFwiLCBcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIl07XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqZWN0cywgdmlld01hdHJpeCwgcHJvak1hdHJpeCkge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0LmdsLCB0YXJnZXQgPSB0aGlzLm91dHB1dDtcclxuICAgICAgICAgICAgdGFyZ2V0LmJpbmQoKTtcclxuXHJcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdGFyZ2V0LmdldFdpZHRoKCksIHRhcmdldC5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwcm9ncmFtID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5wcm9ncmFtRmFjdG9yeS5nZXRQaWNraW5nT2JqZWN0SWRQcm9ncmFtKCk7XHJcbiAgICAgICAgICAgIHByb2dyYW0uYmluZCgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbiA9IG9iamVjdHMubGVuZ3RoOyBqIDwgbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gb2JqZWN0c1tqXTtcclxuICAgICAgICAgICAgICAgIHZhciBtZXNoID0gb2JqLm1lc2g7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFvYmouaXNWaXNpYmxlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHZpZXdNYXRyaXggJiYgcHJvak1hdHJpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iai51cGRhdGVNb2RlbFZpZXdNYXRyaXgodmlld01hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqLnVwZGF0ZU1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgocHJvak1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgb2JqLmdldE1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgoY19tdnApO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBvYmpJZCA9IGogKyAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMxID0gb2JqSWQgJiAyNTU7XHJcbiAgICAgICAgICAgICAgICBvYmpJZCA9IG9iaklkID4+IDg7XHJcbiAgICAgICAgICAgICAgICB2YXIgYzIgPSBvYmpJZCAmIDI1NTtcclxuICAgICAgICAgICAgICAgIG9iaklkID0gb2JqSWQgPj4gODtcclxuICAgICAgICAgICAgICAgIHZhciBjMyA9IG9iaklkICYgMjU1O1xyXG5cclxuICAgICAgICAgICAgICAgIGNfdW5pZm9ybUNvbGxlY3Rpb24uc3lzQmFzZVtcImlkXCJdID0gW2MzIC8gMjU1LjAsIGMyIC8gMjU1LjAsIGMxIC8gMjU1LjBdO1xyXG4gICAgICAgICAgICAgICAgY191bmlmb3JtQ29sbGVjdGlvbi5zeXNCYXNlW1wibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFwiXSA9IGNfbXZwO1xyXG5cclxuICAgICAgICAgICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybVZhcmlhYmxlcyhudWxsLCBjX3N5c3RlbVVuaWZvcm1OYW1lcywgY191bmlmb3JtQ29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBtZXNoLmRyYXcocHJvZ3JhbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvZ3JhbS51bmJpbmQoKTtcclxuICAgICAgICAgICAgdGFyZ2V0LnVuYmluZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICB9KCkpLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgcGl4ZWxzIGZyb20gdGhlIHNjcmVlbmJ1ZmZlciB0byBkZXRlcm1pbmUgcGlja2VkIG9iamVjdCBvciBub3JtYWxzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFNjcmVlbiBDb29yZGluYXRlIG9mIGNvbG9yIGJ1ZmZlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgU2NyZWVuIENvb3JkaW5hdGUgb2YgY29sb3IgYnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIExpc3Qgb2Ygb2JqZWN0cyB0aGF0IHdlcmUgcmVuZGVyZWQgaW4gdGhlIHByZXZpb3VzIHBpY2tpbmcgcGFzc1xyXG4gICAgICogQHJldHVybnMge1JlbmRlck9iamVjdHxudWxsfSBQaWNrZWQgT2JqZWN0XHJcbiAgICAgKi9cclxuICAgIGdldFJlbmRlck9iamVjdEZyb21QaWNraW5nQnVmZmVyOiBmdW5jdGlvbiAoeCwgeSwgb2JqZWN0cykge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5yZWFkUGl4ZWxEYXRhRnJvbUJ1ZmZlcih4LCB5LCB0aGlzLm91dHB1dCk7XHJcblxyXG4gICAgICAgIGlmICghZGF0YSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xyXG4gICAgICAgIHZhciBvYmpJZCA9IGRhdGFbMF0gKiA2NTUzNiArIGRhdGFbMV0gKiAyNTYgKyBkYXRhWzJdO1xyXG5cclxuICAgICAgICBpZiAob2JqSWQgPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBwaWNrZWRPYmogPSBvYmplY3RzW29iaklkIC0gMV07XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHBpY2tlZE9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBpY2tPYmplY3RSZW5kZXJQYXNzO1xyXG5cclxuIiwidmFyIEJhc2VSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vYmFzZS5qc1wiKTtcclxuXHJcbnZhciBQaWNrUG9zaXRpb25SZW5kZXJQYXNzID0gZnVuY3Rpb24gKHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBvcHQpIHtcclxuICAgIEJhc2VSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XHJcbiAgICB0aGlzLm9iamVjdEJvdW5kaW5nQm94ID0gWE1MM0QubWF0aC5iYm94LmNyZWF0ZSgpO1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhQaWNrUG9zaXRpb25SZW5kZXJQYXNzLCBCYXNlUmVuZGVyUGFzcywge1xyXG4gICAgcmVuZGVyOiAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgY19tb2RlbE1hdHJpeCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY19tb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpLCBjX3VuaWZvcm1Db2xsZWN0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgZW52QmFzZToge30sXHJcbiAgICAgICAgICAgICAgICBlbnZPdmVycmlkZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIHN5c0Jhc2U6IHt9XHJcbiAgICAgICAgICAgIH0sIGNfc3lzdGVtVW5pZm9ybU5hbWVzID0gW1wiYmJveFwiLCBcIm1vZGVsTWF0cml4XCIsIFwibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFwiXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIHZpZXdNYXRyaXgsIHByb2pNYXRyaXgpIHtcclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbCwgdGFyZ2V0ID0gdGhpcy5vdXRwdXQ7XHJcblxyXG4gICAgICAgICAgICB0YXJnZXQuYmluZCgpO1xyXG4gICAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2aWV3TWF0cml4ICYmIHByb2pNYXRyaXgpIHtcclxuICAgICAgICAgICAgICAgIG9iai51cGRhdGVNb2RlbFZpZXdNYXRyaXgodmlld01hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICBvYmoudXBkYXRlTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeChwcm9qTWF0cml4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYmouZ2V0V29ybGRNYXRyaXgoY19tb2RlbE1hdHJpeCk7XHJcblxyXG4gICAgICAgICAgICBvYmouZ2V0T2JqZWN0U3BhY2VCb3VuZGluZ0JveCh0aGlzLm9iamVjdEJvdW5kaW5nQm94KTtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC5iYm94LnRyYW5zZm9ybSh0aGlzLm9iamVjdEJvdW5kaW5nQm94LCBjX21vZGVsTWF0cml4LCB0aGlzLm9iamVjdEJvdW5kaW5nQm94KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwcm9ncmFtID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5wcm9ncmFtRmFjdG9yeS5nZXRQaWNraW5nUG9zaXRpb25Qcm9ncmFtKCk7XHJcbiAgICAgICAgICAgIHByb2dyYW0uYmluZCgpO1xyXG4gICAgICAgICAgICBvYmouZ2V0TW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeChjX21vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgpO1xyXG5cclxuICAgICAgICAgICAgY191bmlmb3JtQ29sbGVjdGlvbi5zeXNCYXNlW1wiYmJveFwiXSA9IHRoaXMub2JqZWN0Qm91bmRpbmdCb3g7XHJcbiAgICAgICAgICAgIGNfdW5pZm9ybUNvbGxlY3Rpb24uc3lzQmFzZVtcIm1vZGVsTWF0cml4XCJdID0gY19tb2RlbE1hdHJpeDtcclxuICAgICAgICAgICAgY191bmlmb3JtQ29sbGVjdGlvbi5zeXNCYXNlW1wibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFwiXSA9IGNfbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcclxuXHJcbiAgICAgICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybVZhcmlhYmxlcyhudWxsLCBjX3N5c3RlbVVuaWZvcm1OYW1lcywgY191bmlmb3JtQ29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgIG9iai5tZXNoLmRyYXcocHJvZ3JhbSk7XHJcblxyXG4gICAgICAgICAgICBwcm9ncmFtLnVuYmluZCgpO1xyXG4gICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0oKSksXHJcblxyXG4gICAgcmVhZFBvc2l0aW9uRnJvbVBpY2tpbmdCdWZmZXI6IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBjX3ZlYzMgPSBYTUwzRC5tYXRoLnZlYzMuY3JlYXRlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMucmVhZFBpeGVsRGF0YUZyb21CdWZmZXIoeCwgeSwgdGhpcy5vdXRwdXQpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNfdmVjM1swXSA9IGRhdGFbMF0gLyAyNTU7XHJcbiAgICAgICAgICAgICAgICBjX3ZlYzNbMV0gPSBkYXRhWzFdIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgY192ZWMzWzJdID0gZGF0YVsyXSAvIDI1NTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IFhNTDNELm1hdGguYmJveC5zaXplKFhNTDNELm1hdGgudmVjMy5jcmVhdGUoKSwgdGhpcy5vYmplY3RCb3VuZGluZ0JveCk7XHJcbiAgICAgICAgICAgICAgICBzaXplID0gWE1MM0QubWF0aC52ZWMzLm11bChzaXplLCBjX3ZlYzMsIHNpemUpO1xyXG4gICAgICAgICAgICAgICAgWE1MM0QubWF0aC52ZWMzLmFkZChzaXplLCB0aGlzLm9iamVjdEJvdW5kaW5nQm94LCBzaXplKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KCkpXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQaWNrUG9zaXRpb25SZW5kZXJQYXNzO1xyXG5cclxuIiwidmFyIFNjZW5lUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCIuL3NjZW5lLXBhc3MuanNcIik7XHJcbnZhciBPYmplY3RTb3J0ZXIgPSByZXF1aXJlKFwiLi4vLi4vcmVuZGVyZXIvdG9vbHMvb2JqZWN0c29ydGVyLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7R0xSZW5kZXJJbnRlcmZhY2V9IHJlbmRlckludGVyZmFjZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3V0cHV0XHJcbiAqIEBwYXJhbSB7UmVuZGVyTGlnaHR9IGxpZ2h0XHJcbiAqIEBwYXJhbSB7Kn0gb3B0XHJcbiAqIEBleHRlbmRzIHtTY2VuZVJlbmRlclBhc3N9XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIFBvaW50TGlnaHRQYXNzID0gZnVuY3Rpb24gKHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBsaWdodCwgb3B0KSB7XHJcbiAgICBTY2VuZVJlbmRlclBhc3MuY2FsbCh0aGlzLCByZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KTtcclxuICAgIHRoaXMubGlnaHQgPSBsaWdodDtcclxuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhQb2ludExpZ2h0UGFzcywgU2NlbmVSZW5kZXJQYXNzLCB7XHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnNvcnRlciA9IG5ldyBPYmplY3RTb3J0ZXIoKTtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBjb250ZXh0LnByb2dyYW1GYWN0b3J5LmdldFByb2dyYW1CeU5hbWUoXCJsaWdodC1kZXB0aFwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyKHRoaXMubGlnaHQuc2NlbmUpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXI6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNfdmlld01hdF90bXAgPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfcHJvak1hdF90bXAgPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfcHJvZ3JhbVN5c3RlbVVuaWZvcm1zID0gW1widmlld01hdHJpeFwiLCBcInByb2plY3Rpb25NYXRyaXhcIl07XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc2NlbmUpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQuZ2wsIHRhcmdldCA9IHRoaXMub3V0cHV0LCB3aWR0aCA9IHRhcmdldC5nZXRXaWR0aCgpLCBoZWlnaHQgPSB0YXJnZXQuZ2V0SGVpZ2h0KCksIGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0LCBmcnVzdHVtID0gdGhpcy5saWdodC5nZXRGcnVzdHVtKGFzcGVjdCksIHByb2dyYW0gPSB0aGlzLnByb2dyYW07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHNpZGUgPSAwOyBzaWRlIDwgdGFyZ2V0LmdsU2lkZXMubGVuZ3RoOyBzaWRlKyspIHtcclxuICAgICAgICAgICAgICAgIC8vY2FsY3VsYXRlIHJvdGF0aW9ubWF0cml4IGZvciB0aGF0IGZhY2VcclxuICAgICAgICAgICAgICAgIHZhciBtYXRfcm90ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0LmlkZW50aXR5KG1hdF9yb3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzaWRlID09IDApIHsgLy9sb29rIGludG8gK3ggb1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbMF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbMl0gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzRdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzVdID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdFs2XSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdFs4XSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbOV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbMTBdID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpZGUgPT0gMSkgeyAvL2xvb2sgaW50byAteFxyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbMF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbMl0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbNF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbNV0gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzZdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzhdID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzldID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzEwXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaWRlID09IDIpIHsgLy9sb29rIGludG8gK3lcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzBdID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzFdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzJdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzRdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzVdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzZdID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdFs4XSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdFs5XSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdFsxMF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2lkZSA9PSAzKSB7IC8vbG9vayBpbnRvIC15XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdFswXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdFsxXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdFsyXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdFs0XSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdFs1XSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdFs2XSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdFs4XSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdFs5XSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbMTBdID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpZGUgPT0gNCkgeyAvL2xvb2sgaW50byArelxyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbMl0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbNF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbNV0gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzZdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzhdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzldID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzEwXSA9IC0xO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2lkZSA9PSA1KSB7IC8vbG9vayBpbnRvIC16XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdFswXSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbMl0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbNF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3RbNV0gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzZdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzhdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzldID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90WzEwXSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmJpbmQoc2lkZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgICAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0ge29iamVjdHM6IDAsIHByaW1pdGl2ZXM6IDB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMubGlnaHQubW9kZWwuZ2V0TGlnaHRWaWV3TWF0cml4KGNfdmlld01hdF90bXApO1xyXG4gICAgICAgICAgICAgICAgLy9yb3RhdGUgZm9yIHRoZSBhcHJvcHJpYXRlIHNpZGUgb2YgdGhlIGN1YmVtYXBcclxuICAgICAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5tdWwoY192aWV3TWF0X3RtcCwgbWF0X3JvdCwgY192aWV3TWF0X3RtcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnJ1c3R1bS5nZXRQcm9qZWN0aW9uTWF0cml4KGNfcHJvak1hdF90bXAsIGFzcGVjdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2NlbmUudXBkYXRlUmVhZHlPYmplY3RzRnJvbU1hdHJpY2VzKGNfdmlld01hdF90bXAsIGNfcHJvak1hdF90bXApO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLnNvcnRlci5zb3J0U2NlbmUoc2NlbmUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzW1widmlld01hdHJpeFwiXSA9IGNfdmlld01hdF90bXA7XHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzW1wicHJvamVjdGlvbk1hdHJpeFwiXSA9IGNfcHJvak1hdF90bXA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9SZW5kZXIgb3BhcXVlIG9iamVjdHNcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHNoYWRlciBpbiBvYmplY3RzLm9wYXF1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyT2JqZWN0c1RvQWN0aXZlQnVmZmVyKG9iamVjdHMub3BhcXVlW3NoYWRlcl0sIHNjZW5lLCB0YXJnZXQsIHBhcmFtZXRlcnMsIGNfcHJvZ3JhbVN5c3RlbVVuaWZvcm1zLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHM6IGNvdW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmFtOiBwcm9ncmFtXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHJlbmRlciB0cmFuc3BhcmVudCBvYmplY3RzIChjb25zaWRlcmVkIHRvIG5vdCB0aHJvdyBzaGFkb3dzXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtjb3VudDogY291bnR9O1xyXG4gICAgICAgIH1cclxuICAgIH0oKSlcclxufSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2ludExpZ2h0UGFzcztcclxuXHJcbiIsInZhciBCYXNlUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XHJcbnZhciBPcHRpb25zID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL29wdGlvbnMuanNcIik7XHJcblxyXG52YXIgT1BUSU9OX0ZBQ0VDVUxMSU5HID0gXCJyZW5kZXJlci1mYWNlY3VsbGluZ1wiO1xyXG52YXIgT1BUSU9OX0ZST05URkFDRSA9IFwicmVuZGVyZXItZnJvbnRmYWNlXCI7XHJcblxyXG5PcHRpb25zLnJlZ2lzdGVyKE9QVElPTl9GQUNFQ1VMTElORywgXCJub25lXCIpO1xyXG5PcHRpb25zLnJlZ2lzdGVyKE9QVElPTl9GUk9OVEZBQ0UsIFwiY2N3XCIpO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIFNjZW5lUmVuZGVyUGFzcyA9IGZ1bmN0aW9uIChyZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KSB7XHJcbiAgICBCYXNlUmVuZGVyUGFzcy5jYWxsKHRoaXMsIHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBvcHQpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBnZXRHbG9iYWxGYWNlQ3VsbGluZ1NldHRlcihPcHRpb25zLmdldFZhbHVlKE9QVElPTl9GQUNFQ1VMTElORykpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2V0RnJvbnRGYWNlID0gZ2V0R2xvYmFsRnJvbnRGYWNlU2V0dGVyKE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX0ZST05URkFDRSkpO1xyXG5cclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIE9wdGlvbnMuYWRkT2JzZXJ2ZXIoT1BUSU9OX0ZBQ0VDVUxMSU5HLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoYXQuc2V0RmFjZUN1bGxpbmcgPSBnZXRHbG9iYWxGYWNlQ3VsbGluZ1NldHRlcih2YWx1ZSk7XHJcbiAgICB9KTtcclxuICAgIE9wdGlvbnMuYWRkT2JzZXJ2ZXIoT1BUSU9OX0ZST05URkFDRSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICB0aGF0LnNldEZyb250RmFjZSA9IGdldEdsb2JhbEZyb250RmFjZVNldHRlcih2YWx1ZSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKFNjZW5lUmVuZGVyUGFzcywgQmFzZVJlbmRlclBhc3MsIHtcclxuICAgIHNldEdMU3RhdGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbDtcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgdGhpcy5zZXRGYWNlQ3VsbGluZyhnbCk7XHJcbiAgICAgICAgdGhpcy5zZXRGcm9udEZhY2UoZ2wpO1xyXG4gICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgIH0sIC8qKlxyXG4gICAgICogQHBhcmFtIEFycmF5XHJcbiAgICAgKi9cclxuICAgIHJlbmRlck9iamVjdHNUb0FjdGl2ZUJ1ZmZlcjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdG1wTW9kZWxNYXRyaXggPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIHRtcE1vZGVsTWF0cml4TiA9IFhNTDNELm1hdGgubWF0My5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgdG1wTW9kZWxWaWV3ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciB0bXBNb2RlbFZpZXdQcm9qZWN0aW9uID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciB0bXBNb2RlbFZpZXdOID0gWE1MM0QubWF0aC5tYXQzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX29iamVjdFN5c3RlbVVuaWZvcm1zID0gW1wibW9kZWxNYXRyaXhcIiwgXCJtb2RlbE1hdHJpeE5cIiwgXCJtb2RlbFZpZXdNYXRyaXhcIiwgXCJtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4XCIsIFwibW9kZWxWaWV3TWF0cml4TlwiXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3RBcnJheSwgc2NlbmUsIHRhcmdldCwgc3lzdGVtVW5pZm9ybXMsIHNjZW5lUGFyYW1ldGVyRmlsdGVyLCBvcHQpIHtcclxuICAgICAgICAgICAgdmFyIG9iakNvdW50ID0gMDtcclxuICAgICAgICAgICAgdmFyIHByaW1pdGl2ZUNvdW50ID0gMDtcclxuICAgICAgICAgICAgdmFyIHN0YXRzID0gb3B0LnN0YXRzIHx8IHt9O1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNwYXJlbnQgPSBvcHQudHJhbnNwYXJlbnQgPT09IHRydWUgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgICAgIHZhciBwcm9ncmFtID0gb3B0LnByb2dyYW0gfHwgb2JqZWN0QXJyYXlbMF0uZ2V0UHJvZ3JhbSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9iamVjdEFycmF5Lmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdHM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0cmFuc3BhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgZ3VhcmFudGVlIHRoYXQgdGhlIFJlbmRlck9iamVjdCBoYXMgYSB2YWxpZCBzaGFkZXJcclxuICAgICAgICAgICAgcHJvZ3JhbS5iaW5kKCk7XHJcblxyXG4gICAgICAgICAgICAvL1NldCBnbG9iYWwgZGF0YSB0aGF0IGlzIHNoYXJlZCBiZXR3ZWVuIGFsbCBvYmplY3RzIHVzaW5nIHRoaXMgc2hhZGVyXHJcbiAgICAgICAgICAgIHByb2dyYW0uc2V0U3lzdGVtVW5pZm9ybVZhcmlhYmxlcyhzY2VuZVBhcmFtZXRlckZpbHRlciwgc3lzdGVtVW5pZm9ybXMpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHByZXZPdmVycmlkZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IG9iamVjdEFycmF5Lmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IG9iamVjdEFycmF5W2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvYmouaXNWaXNpYmxlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG1lc2ggPSBvYmoubWVzaDtcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmFzc2VydChtZXNoLCBcIldlIG5lZWQgYSBtZXNoIGF0IHRoaXMgcG9pbnQuXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIG9iai5nZXRXb3JsZE1hdHJpeCh0bXBNb2RlbE1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1Vbmlmb3Jtc1tcIm1vZGVsTWF0cml4XCJdID0gdG1wTW9kZWxNYXRyaXg7XHJcblxyXG4gICAgICAgICAgICAgICAgb2JqLmdldE1vZGVsTWF0cml4Tih0bXBNb2RlbE1hdHJpeE4pO1xyXG4gICAgICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJtb2RlbE1hdHJpeE5cIl0gPSB0bXBNb2RlbE1hdHJpeE47XHJcblxyXG4gICAgICAgICAgICAgICAgb2JqLmdldE1vZGVsVmlld01hdHJpeCh0bXBNb2RlbFZpZXcpO1xyXG4gICAgICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJtb2RlbFZpZXdNYXRyaXhcIl0gPSB0bXBNb2RlbFZpZXc7XHJcblxyXG4gICAgICAgICAgICAgICAgb2JqLmdldE1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgodG1wTW9kZWxWaWV3UHJvamVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1Vbmlmb3Jtc1tcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIl0gPSB0bXBNb2RlbFZpZXdQcm9qZWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgIG9iai5nZXRNb2RlbFZpZXdNYXRyaXhOKHRtcE1vZGVsVmlld04pO1xyXG4gICAgICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJtb2RlbFZpZXdNYXRyaXhOXCJdID0gdG1wTW9kZWxWaWV3TjtcclxuXHJcbiAgICAgICAgICAgICAgICBwcm9ncmFtLnNldFN5c3RlbVVuaWZvcm1WYXJpYWJsZXMoY19vYmplY3RTeXN0ZW1Vbmlmb3Jtcywgc3lzdGVtVW5pZm9ybXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHByb2dyYW0uY2hhbmdlVW5pZm9ybVZhcmlhYmxlT3ZlcnJpZGUocHJldk92ZXJyaWRlLCBtZXNoLnVuaWZvcm1PdmVycmlkZSk7XHJcbiAgICAgICAgICAgICAgICBwcmV2T3ZlcnJpZGUgPSBtZXNoLnVuaWZvcm1PdmVycmlkZTtcclxuXHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmVDb3VudCArPSBtZXNoLmRyYXcocHJvZ3JhbSk7XHJcbiAgICAgICAgICAgICAgICBvYmpDb3VudCsrO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9ncmFtLmNoYW5nZVVuaWZvcm1WYXJpYWJsZU92ZXJyaWRlKHByZXZPdmVycmlkZSwgbnVsbCk7XHJcblxyXG4gICAgICAgICAgICBwcm9ncmFtLnVuYmluZCgpO1xyXG4gICAgICAgICAgICBzdGF0cy5vYmplY3RzICs9IG9iakNvdW50O1xyXG4gICAgICAgICAgICBzdGF0cy5wcmltaXRpdmVzICs9IHByaW1pdGl2ZUNvdW50O1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdHM7XHJcbiAgICAgICAgfVxyXG4gICAgfSgpKVxyXG5cclxuXHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gZ2V0R2xvYmFsRnJvbnRGYWNlU2V0dGVyKG1vZGUpIHtcclxuICAgIGlmIChtb2RlLnRvTG93ZXJDYXNlKCkgPT0gXCJjd1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnbCkge1xyXG4gICAgICAgICAgICBnbC5mcm9udEZhY2UoZ2wuQ1cpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGdsKSB7XHJcbiAgICAgICAgZ2wuZnJvbnRGYWNlKGdsLkNDVyk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRHbG9iYWxGYWNlQ3VsbGluZ1NldHRlcihtb2RlKSB7XHJcbiAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcclxuICAgIHN3aXRjaCAobW9kZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgY2FzZSBcImJhY2tcIjpcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnbCkge1xyXG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XHJcbiAgICAgICAgICAgICAgICBnbC5jdWxsRmFjZShnbC5CQUNLKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImZyb250XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ2wpIHtcclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xyXG4gICAgICAgICAgICAgICAgZ2wuY3VsbEZhY2UoZ2wuRlJPTlQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiYm90aFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdsKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcclxuICAgICAgICAgICAgICAgIGdsLmN1bGxGYWNlKGdsLkZST05UX0FORF9CQUNLKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIm5vbmVcIjpcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdsKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NlbmVSZW5kZXJQYXNzO1xyXG4iLCJ2YXIgQmFzZVJlbmRlclBhc3MgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xyXG52YXIgVmVydGV4QXR0cmlidXRlUGFzcyA9IHJlcXVpcmUoXCIuL3ZlcnRleGF0dHJpYnV0ZS1wYXNzLmpzXCIpO1xyXG52YXIgR0xSZW5kZXJUYXJnZXQgPSByZXF1aXJlKFwiLi4vYmFzZS9yZW5kZXJ0YXJnZXQuanNcIikuR0xSZW5kZXJUYXJnZXQ7XHJcbnZhciBGdWxsc2NyZWVuUXVhZCA9IHJlcXVpcmUoXCIuLi9iYXNlL2Z1bGxzY3JlZW5xdWFkLmpzXCIpO1xyXG52YXIgT3B0aW9ucyA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9vcHRpb25zLmpzXCIpO1xyXG5cclxudmFyIGJhc2U2NFJhbmRvbU5vcm1hbHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSUFBQUFDQUNBSUFBQUJNWFBhY0FBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFBQWdZMGhTVFFBQWVpVUFBSUNEQUFENS93QUFnT2tBQUhVd0FBRHFZQUFBT3BnQUFCZHZrbC9GUmdBQW5SeEpSRUZVZU5vRTRYZU1wbm1DR09iOTBwdkRsM045bGF1NnFyczZUM2RQM3RtZDNiM2JTN3lqanFJWVpKS3dMTUtXTGN1Q1NkaXdETWcyTEVBMkRRTUdCRml3cVQ4cytjUjRQcEczNU9hWjJjblR1YXRENWZqbC9MMDUvSUtmQi83RC96WC9BZlpjVS9wL0xydFhzMXFocjExdzl2ZjcwNzFjN3I4S0puZTk4dDhPUmwreWt2ZHVyTnJKbDlNMGUyaC8yT0NONWY3UHVLWHRacjFqSGpySlg3OUtENWo1N2FwZjdPdW5NUGd3Tk1nSVdCTG5DTEM2MkZPRm1PTGxDSDU3SHRYcWFsYUhzSm1rajZSM2kvNC9pOVdkcTNUMVdQdzNjLzQvcmZNeFY1NHRVUVpBMTNMam52cDNqK1MycSt6ZVRlNGVTdjlkTXQvY2svLzRKK3k0Yi92TGFlTTUvSXVGOUdPb3JOUW5uOVVGb3JnbXdEZXZqZFlyN3g4ZXBiU28vNk5TY3VPZWRjdkJueHJKMzNIb0VLcS9NYmcrVk01eDhMZXB0S0VQUDhmVnA0VW9VMGlBSFI1ZlNpdHV0akVuaFhvb1FoeWtXRGc0bjRralJ4ck55R3MvZVo3dC9OWFpzaDZKUlp4K1owc3JFRXdwM012RS8rRXcvTWV1cGhIMEgxWW01MWVVLzFzcjJrR0Z4VVB5d29qL1FXM1dpVFAvOVVWeTVXbHNtS3BiMXd3ZEl3UWNuOTJSQllRZ1YyS2tRb202SnZvbGdFQ2FVNUViZ1EyWldTZlNrQmppQXQ0YkZjeVhnOGNMOXB0YnJHUW5wYUdTcHhJVlF1bmlybFJtR0t4Vm85T2VtcG1UUFU4ZGEvRHF3QWlmTVNib2NVTmNWMEdkQmQvRTVreW5pd3ltQ2poTkFiNE5MU2lzQzVDT0pEeWtsMlZ0cHNWRTUyNFRWUmZSUU9mVmt4Z0M4dEwxdC9KWUNVeW5TbE1GNmd5WkhyM1cwY0hBK2ZxcmZMUU55dm00VkFMTEE3TTdGb3RkL1R6aFZTUlpCUi9xdkh4TlQ2NkFpWVV6aUpmNlNta3ZLTGRGVjhPakF1bS83YTVscEpLR3gzTzhaQUszRWlMTzhxNTZPWlh6WjNMVGxTOW56TEdVMjBsQ0xiQkhSTk9JZ2h6cmJORkdMQTNPczVYZDJLSGd4WUlNTVVoVzAvSmpmSnBEQjZaZFhlZEJDQ1pZZFNSb1YzRXVBV29GTnJ1U3d6UXdZV1ZEbXl3UzNWUnJvOFFicDIyRjQ2WUNGS1Ntdkp1UlFRN2lQMHorMHpmVVBOUlJaYXF2L0J5cEw5UFJTQ1RYWkYwUmQ3dnVHZEJmR1NLNUpzZzMydFd2L2ZscjVIZ01SdkpoQytvRytVRTBTVk45aUhEWW9hMk0wT2ZZMklCVEdWRmJiR3VpcklhSEUvVXNvYlV6VXM2eWFBOUlYT3J2SjI0UmIvWFN5b0x3dmdtUFIwbjBRbDZMc0JFb3c5OEFvQ210UG1FSHNQRlRGSjd4YkVVR21qaHF3K2F5QURlZyt5RkpCN0pHVU54Um1vVTQzNFZmS0N5VmREb2h4YmJNTGpXaWtMc3hSaGg4b25DUW9zWkFydmY5aGU3OGVFUy9rdE5STmRrcUtsbFh5dmJnd3FtL2QxVG9QQmVGNzFCN044bUZ5ajBuZUJWQjlFMThveFd3enlQM2k0aCtLN29YK3RrQ3N6QTJZL1crbTNoYytpTHZyMDRWVVlBT3hVMktVQWhBRy9VUTk2R1dJS3lsNnNLQWhER3NjQ0I2WEdHc2RVV2pWd0c1eWdaRnFYSUhPVFVpMjZoc1FHQ0NORUhwUGlhanFpN2UrT3BVclUwVHRTNjNCbUpoWFhvemdiVTE5bGFsMStUcnZ6cWZTT2Y0ZTVuaTRsYnkzOGR5QW5qbEJ1MkgwTU1zMkZmcHF2Q3ZoWnNKMW82VXVTYUNlcnlpUytjdGRuNGtxaC9DNmd6MmZCSU9LRk53cndSQ1FYUEx5ZzJiZWJmSnF5ejdReitabk9oL1FkcnZuRmZWQ200cGFHVWxuY2JRWHNMMW5QcEVGVThvK0VISzFoZnhaOW4wUmptNjcrSEx1dDUrSGdPUGduVVVYNEZLSTNDejdwV0RuTkZsKzgvVGJnSWxKaGRWbWJqcy9oZ3ZaZUw1MnpyNjkybGl3UG5jVVhwRzVVQVdyeE16amc4WGk1Y3l1N1d1a2dUR0NsVVF6RnhRSEt0K0xER2I5K29XNERCZUJnY2dTbWVvME5GMkloNCtFT0NBWkpEaVR0THNyNEIzRFpXcGVMWEk5QzU1aTVESkRNSkxnb1c0eklCbEtJcUxxYmNqeGVVMGV3Q1R4eWdOeE5vU1NYM2d6dUxsbG1ocnVGQW1UUmJOUjRDTTNnWjhxTHRSbW9OeTVuNGEybXdjQTNFZ2VTMTV2cUZpTFNndVJkcEJTU242cm91MVhHVE4xUEc1akM3VHBYWXlYVmYyWmJBNFU2NjIvWC96bkxHUTBsOG5vYVZrbHpXcmdLS25VcmdJVnZwWXMrQ2JTNnJka3NHVjBCK0s1SkNZNTJHd3BGbmw2Q01xL3RsWjlBb2p0bzZrYmE4ejBQUSsrcjdQT2h5MlhPL2RjNlV3Ni84eVVHWW9PU3JrcXdYMTZtcWNYNU4zeC9pRlJLcDkyanpJUGgvUGRpQlROdEhaVytKbW90b1o3bVJZSExHY0R6c2phYjlKZjBLU0dpVGd3aXcrMGRXKzE3ZFY2NlllWFV2cVFxZ0o5SGVWWmx1ZVRieFFwVVlPakxieGFGR2FYZXRadHRzbFNXNW1YZjE4OGFURjljc0VhOW9zRDVaME1xOXlPU0xHQktxQ1YwNms1QXFOZG5GZjU0Q0kyeGFZZVZDNmpJK2JTbitCZnovTGJTeW05OFhVNWFVQXJEMXlRVCtaWkpUVExGNnZxQi9PSmtGZUlvUGQrRTdlMURqYTNVakhoN0xlRUxkUHcxOGgrYUtYdUoyQ2RFM1RxV3pOWk84WjJyMnVFeTBvYXRBVTRvNEM1VHo2S2xYT1hvWTNVaWxOaFA1QTExVXhPQk9VQ0JkeEtRZmlQWER1aXJjTVBya0dEM21pNStMNnZyWFFGcnJCNVJMdTBPaEZyclI1NDNJdHFsMU1RUnBGVzRHVVM0VzZUTWx6Z0FXQUhKQjNaU20yOHQxc09vMmtBUG9TN0JZSUFyeFNSdkFOSDNkQkdpVmxxQ2lHbU13eFhZNTh5UGdwbGg2eFVnenpadGdybWVSbnZNM3lCeUZyWEpGM05FbGJTeDFDd3Mya084Ty8wNGZtQysrL1YxakRWdFVkZXlSVFU0ZEgyRCtEZXVZWHRTNnJ5YnRKSVVNNDV6VUowZnZxeXdtNG1tZnNIUDRMTlh5M1lOWXBQd3VRdE8raDF4QW43RnBlL3E2R0JwZTQ1SVFYRXVuSE5BV2lmWm05V3A1QmJqNGRRZFhtc3orUm9ZSFZvVko5Q2VkNzdLQld0SDQ0STB0L3pJMFRwbjVKa3pFYlJmRTdoL0pVeDdhYmhDWDhCR2U4TWN4N1pNZURacHgrZVlhRHRsU3ZTeXNpU21YMHpUVzFtNG5La3FSbXcrd3c4dkt5dnFmOUx2TCswU2hLd3ZoUGcxeHdqL1Jtc1dvaEpTYkFRMXV2ZGZyYU9Wc3pJcE9zZmhpQUJCelhrMFVvMXBlYzlpaEpkcTNpVThQUkFHOG0yYmRuU1dDaFUyUVBRZEtBNFZKY2RlVDJDZlBDY1AzWGtHY0l4VWdVRVZ1QlZvUDF0S1R2NkZFYlpWL0lEUW1La0o1ZHgyYUxzRVZ4TUVpL0x3SFRELzlpQ2RsWFlaMExlb25IZzFSOERwY0RWTXA2Qit2WllsVmtEZDdxSXpnRG8zTXdLMUFRU3pJVDJlT0VDeUFQRTN4Tm5lZUFVbVNyWFJnTXdCN25OOGNrZ05GUUkxc050ditCR2J0aWNDdkJZeWtLa3dJbDVZd1k1VVQra2JUWEQ4K0lWRmIwWUNJM3psbFVSbE1UVlN1enNCQms1SXh5S0YxV1lTYUxDSDFweEZsdzlWYjZQTkxTTjdGZmswZUxvRmhJKzVqMnRhUWtVRTNpL2tBUnRtQWRZZldKOUVoNENHcDFBVENnbUcvdnEzeklEa0pKSjZRdzk4S01VREVwMkhvM2tZTnZ4V3FXak0vWTUwVzZNMUJXMnRPdmRDbXdPS3N6blVnNUpxcS9VWHNIS0lieWxZSThpRm5neHRPaUZCeURaTXZ3Z0xLVElPMnA4K1p6NWw2RjlpYTZWNEhISTlJdEFyNklCQU1MeFdndlZBN0hmR1dXdGVxeEhuTjFDNzg0WVE5dVFJd0Uzd0lZTUZEQTlXdkJpYW5NKzA3OXlBUXpIaTBpZEp1WGVqSWJpVkZXQzdhVGdSeXR2TWxjZjUyYzZGSlk0UmxEc1VLeEJvUGRodDY2d3JZdnBKTUVLRjlHOVRDWlFCemZOR21kM2d6SWR5MThVRWl1MjF5WHlMR1ZWaEJmTHNYeVdQRW1NRGlXWHF0Z2pjQjFWejBRM29kVHZOaWdKNXM0bUlDamgybjZ0RlJiQnJXR0Q0dmk1MTJJdnJOSTV1YytYVFE2NzhpSkdSbWJhS1dYL054RFVDTXJFVHc2WjQyUkdOcnlkQVg4N3BRcVIrUTNUbkFzcVN1ci9HUkJ2aHpIZDc5UlM0ZjlVNml3SCtlYUpsdFcyWFBabU9UUHQrU1NOd0RUZ1ZUS01lQmlFd0R0SnBkTjZGcGUyS08zdXBuWjErbzhqcmJ4ekNuSlIwcTZNNFltaHdjNkxNd1l5YUpYejVUc1hWRGFwT1lOYUY2YTRnUzhpSUtyR1kyOEZRbVpVNVV1OU5UNFRIcEpvMlpScnJwaS9GSzJRMTR0b000R0UxZ29MeEF0b3BHdjJqWElUbVMzcU9rMC9uZ3ZrS2IrTHk0VXNtMnRKMVIwNDE4UXBYOFcvVTFKazRMa3VLR2dGVGFJQTROSmpYSDRobWduYXl5cmltSXRzYzd3TDJxb29WblpWZjV2eTZQTmViWmNtWGw2THExNzRrSlhzQWg5Rmo5VnRTbVRKc2tnQlZ3azl3VVJpQjJiWWxhT3hscStiMElRZ1cxT3hTV1lCL1B6VjVBc21OZUNhVTNKdmlReDRiOXJqUytGOFJqekRZQTM0L3dFMW52YS9uUDNBMWxiemhESFQzZ09kMmZKeUZDdW90bXJURFlleFIyaDdlK0oyM1VsVXhmOGVyNkp3Yjh5M0JxUmQyem5XQUxLVkw5RHBVc1B5L1UwNHJDMzRGWE9UTHNMam5nMnl2bWxRSlhHc05hSm93bWRGTWpGVFNOWjZWTVZxQkV1OVZVNlJURkw0eXZrTElRR0U3SE9jOXV6aWxZNnVYQXppWkZxOGlGTVB6alM4bEhhU21FOXJ5Um5JalJoYW9Ed0RoMk9zY3FRZGM0MENRNmdVQ21UUXVuUzA0cm42VUtxR25MeTZ2dTF3V3oySUNhQTB2YTJFUmJqOVhOOXdzUjBHUldhd1RHRXBaZmFTaHQ1TWk4UzF0MUhiaSttQmRScVNOSURMOHZTOWxRTFBrTWIvZlJzcmRETyt1KytLVTBET2xDeFdVUE5DYkxOTkVuQWVFbDl2VWdTamE0TnlidGZzZmt4YUxGNHRLSENobGcyM2ZQdDNQZ1Njb3NjS0hEckkwSlVCaWdqZDBUeXBxdzhQWTBXZjgxT2ZwT2UzOHJldnBFY1J3cDVBNlVObUdYRWljWHMyU2g5VUl2ZVJyckV6QzgxdUJ1bUNlMjVScjZFa2h4L0lVR3RwWlFVeWZXeXNpa2JoOWp4WkNEZ3JDNEpTV1NRZXMxTittTTVldTVuYkJocXFiVUY0RDFNSXZXVkxrS2Q1eVBEMVZCZVluRGJ5VTFVTjBCNkd5QUtUaCtLYk4yV3EzSGoraVMzeUNadmhQRTFWQU9nS1NrcGNvQ2h1WitPMC9TMHFteGRRZW1wMGp5aThqeDUybFMwRGJFMUJ5Y2xtVnd3OUE3dE1BSk1LcG14YlV6elV3aW0vSkNobFlhelB5UytSaklOZXU3SWFraWt0bVRuK2VKTUVDcWV6UkRqYkMzbTBaQkZJWjUzUVJ0clN5TnYxVU1PVDF1bmtOUlFjeDRISEVZb1RRSzRPQXdOa1Q3Q1Jyc1kzVWdrWEV1aWNnQnVNL0phTlUrMStXVWFUNEdmazlPN2lmUU92ZjlHdW56R3Z2NjVPVjNIdWdGSTlxRXJMRExlVEQ1WU1GdWVmQnpEKzBCVVVxVjdGMWpmc21ZdGVYMElwemRRY3NLb3AyQlBVajlLT2hOMWZZNzBOL1JYdy9BR01sWVdLYlRnaFJLWFBiMGFnUlVnQzFVNFk4NGtPSm14aGFFMHdrSmFZWnNWWlhBSjI1NTd4clhpUXJqSkVpK1VmblBDTTVlU091ZUhrcnhldzVMTFhnazJBS2hRSWRrY29TK1Q4Vmp4UHlPbERRZ3hNTmJSMGxETlRkMXZFcXU3bGI1L20zNnA4ZTdVWDhWNjA2SGRWV21HU1ZTZ2ljcDNFcTVnOGtaSGc0R1NuWFA5TnZ4MW1BR0MvdTZGT2lQd3pTbGZPRGZoS0duZUI4ZWg3TW44d1M5amtZaVVDeVVMMnBJc3JhS05QSjNZNmxQRS9ZVGZ2REFoRVh4WmF6VEJKUmRrS21rTzRBYXhJaGFrRUIxR2RoWjI4c2I1aldDSnEvbGQ4T3d2WVFOcDlUOUV1WHl5cGpzajF6cU8vZU1sUTI2am5FRkszMHdHeFBvc25WYW4rVVdoRVA1QUtiU2drOGJRTkZZcitMdVhyblZ1M3hQcG5KTlhSWGg3S1ViWDlNSllYN3dNanIraUVFYXhheWZMNkc0WS9tVkZtYWRwTHNPLzY0cE1EcjUzSUFVNndxL1RuRUdmVU1pcmVPMFppOXhFNzAzbU4wdm5MdnI0Qi9PTVpRdkFnNUhvOUpYcUxLM3V1UzlIeEFpWktsZ0E0TmtsdjFaVzhyNEl0K1I0d0VhMzJSV1p4QXhHUFZIN011SXFoa3pFWmFYdkV3Vnk4UUx1dnlPSktUWWdEY1pFclBrVk9lcm93T3ZJbXgyMTJodWR6VElhNUxNNWQ2Ykp4aGZCTGhIckdkUFlZdDlPeFBWaG1zVk02cmp6Y2E0ZlJ6dDNjM1pOdUs3VWhVbjd1cFRKeGJpckRBNnhxNERnUFZjdEJRc3IrSEp1ZGhLSXNrbEVra1hMWUFGUzk3aFVFdFlsY3JlMFZ6V3lLQ1V3d3FOdjJNZk51SmZYZkF5Zi9STXZycEtzbmE0VHZyc0FMNDdBeGl4K1BrdVREOHpGNWNSQWtuL0dCQVBrSWpTQURobm51MzI0MHhDTmQ2WFNJWjlsOFBtUnFMMVA2UW1aSUdFZXlndWxzVThLLzNvbFhlaUkwa3lrR3NyZm9oMFgrbHdBSkN3Rk5DWmU3ekdkaktMcDNlcXdRYXNQb3V5dWFpbTZseGpUVUZBbXZOOVlWaE9iVkp1NmZPc1ZMd2dIQXVFMXphQ00zNUlZcDlJNEo2d3dOaFR0cTliMDFtcE9qMEM2d29waEVtOWl0Mi9TNTVSQ3VIUSt6MitwL3l4MVFSbnArMmJlSTRZbFMrYzA3YXZSQlpWVmdxUFVNaWdGc0JGRXJhTGVyOUhmTDJKNm5EMVBIVFNIQ3dWVU5hWHlYYnJMakpVTEMwellOMnkydzhCOG5laTVwS0pTZUM0cm4yRWMwNDZFdTR0MGZBU0t4L21hRk1PWi9MUWtHZzhWZVltNUliYWJTYnhCc3c3OXdJdi83VkRhZStMWERTSjdDYXdadms3cWExQjArUk1vV29yL1pxT0ExZ0k5WnZudjBHWWhlSjYxLzdJUjMrYlN1L3ZtbytOd0ltSVNYbzJ5Wm5DdG5TbGRvSU8yYU12SlR4UjRpR1Y2aXhHSFhGUmd0a3RxdnhOTVV0eGRtbFE1SzRzZzYyZ3Y3V2grYmwvTEtmZ2g4dkp4NWpIV204emZ6Q2xiWWRBSDJUMkMvMXQrdm9aWFE1Nld4S1RMdkd1ME85TTRCZGxJTGlLTWwxQ3ZZRGZOK2ExRStvUUdUNVpRdGpKUFl1SjM1Q3lscThJZVpPSmd3cmRqdVhMZ2orenN1UkFmdkUyL3cvSXN6RmNYb215S3RyZzYveFprajN4dkhqbEN2SmpyemJwNmc2Zi9MQ3VtS3NFM2txNm15aVN3T3NvY3djeUgvcUt2RUROOU5JYzNlUXoxcER0RmYrT3QyYU5XMmVrbFVpTDJPL3BKeHErNjB1cGhuRVJpVXREa05UNlhRdFRHelVCdWMxd2Z1T284ODh5TDNqbFNaaE42c01lWDdwRW9uMGkveitTcGZob21jbDI4MWMwZHh1RDhpNmhXU1NlV0RIOW9HVUZ3TWtBTGdia3dCYms4RjZkaVdFejduN2dmRzdteWNML0lrNm1Sa2w0cE1HZnlDcFhVQkZ4Q3BqeEUrcjA0OXhTZlpWQzRIMnYzWkVkbG5SN28xTFZTWDBndGczU1Vjai85Sm1PdEhhY2xTVngwWmpBdmhnVjVYcEpRM1IvWlNYNm9MSzNEVXlJYkJrQXhTRjhMclU3bVE0YWJWQlVnRE9qT0FWZG1TV2NmVCs4VXV4WkFHUjVkYUF2bjZyZ0xvOFUwSmFpdW9yUFhuS2FwUFFkelZZVyt1UFhHQzNVY2RpYVp2NU0vblVoK2MxcjkydHdZaDI0WVJ5bHJyWnR4RTVzUGtyclB6UUFiei9uc1lhYXpyRnF5eUJ5Z1N3Uk9GNjI3V0h5M3grY2VhOXJwYVd6cGw2bWVoZEVvTFJiTVFjVGNtU2llS1NxQjBtWVVmSnkrMGtJRndwVytqcmlTN2RPMmdxeXIydm81UTBEdUg0VXNMMnNUOXZBcjlJTWxyWDZ0WHhlWjFsSWFQTTk2NjdTL3g2LytvVFN4YVdwN09abWZuSEg5R0ZaL014Q1R0Q2RKOGs0Mm15TGYxbytoWExQQ0Q4L2tSNzhkNHQ5dC8rL3pUN25haHJORnFhUFFtcVo1WjdJSnhlb3dmZzNCUllKa0RXZGJzdjVZZ3Era3lZeklCRFVzMWtwUnJpNVhpdnowbHE1anRjSGhxeFlCejBudXBUcjFzSExIaTI5Tk53T2xNa21QTS9KRlBzSVIydnFTMGtOeE5JcmZpMmdBeWVjUWJFSlVDM25yakF3dW8veWVXRTc0cUU5T0lMaVNZeHpLWFpMY1BHSmtGUjJyOHVKTjVtSnRiMXRtQXpRNXAyYmIzRnhtNUg0Yy9nRk5mMFFHTjZNa2x2TWpiYUhONlVqZDNPMzFUNUpmbjQ0K25CczZGV2N4bHc5b3VRKzhQcC95dEdycS9RWWtIOFJYMVhCY3Mzc0tSRGFoUlZqZ0dFMnBaNnJ6bVNyUDFYUmZtd2VnWWFETklKMVBSQm9UcENNKzVmT0tSRlJFYnhQN2hKRXViZThacGFQWSt5VkZUeWVsRnhSTXlYbEZ2bENZa1U5RFg4NG81RVl4Z2RlVTZJRk5sNng0RzdRTVdqRlZSWVBkQlh5MUVobW9RT1l5R2k4WnFRTDlGRlE3MktoQUdqSjREMFJFNGhhdFhjcnNaZG9UZERyaHlYMDlXSW9maEJUNjRNSUthOWZBVEkwVmhSdEw1cmd2RzZla21tSE9QcCtZUFBxdmlWNnNLQ3hsR1FoQ1VYa0RmSVYzbHJSSWd6VWk4V0pvYzU2L1FrZWZhUGxCeXM3bjhycFpYRk9nNE81NXFvelk0VWhyUmhURTZpN2lxQzJyVjFtdTVMeTg1V1NsdEhwUmxNL2wvbmthUHNKZzAzak95VjA3S1o0VlJoYzgwNmNYdHF4Z1Vmc1RkQ1lWYVR5MVd1SzBUT1FEdHFxaTUwTGdETGt0eWQrY3hJcW0xRDNTSzhsNTZpOGZtb05oa21aQWJvMmdkZnhzeXQ0NkZ0bUUvOG9ORmt6REtvUFJvZ3pXNEtRUEd4VzZlQ045YWFZNVQxMlpTK3FLakIwK1pQQktnNFo2cm4xRmh4eTFlRnI3QnZHZUpQWTFUUVdleWh3RmFEZkhEY3FMbHY3cnIvUlpPYjBPbEVFQS9JVGdyUmovTDN2NHcvLzQveVRyTUNlNDh5bzkwaE11NGNvTzdNckFGa0RYNFBRU2J3ZFVUUGhzU3h0ajRBMUZmVWdtQm1sWmFkM1J0WE8xMDljMlExZ3NSV2dxWlJNYURzVnpPWVlBYnpzc0tTbnBGWEM4SFdtYmVCMHF3SUMrSXVRSmpJVVM5Y2xGS2pVVjJMZy8zZnNCQkNXOEFDUVZDQ1ZMUklyUGhxNXFLNWtDSHQ4RGxFQ1I1OUs1RWMrTStYTzdncEhoNDBCR0tNSCtGQTR1MGVLdWtwM2dXcGVWQis1WEV1eXVpOXBIdzlGaXdLdjBmUTg4ZC9XVlJKU1crRDlmR20zY2srOWk2aDdDczcweC9USlpsdTBvVkRLMk1NL1Ivc3pOSFpHdElOM3JjTTJXcXhaL3ZvbWNyRmoza2UyeElDR2JRZmo1Rk8vcG9Kd0Z3a3h2dllMd0N1dHIwdlI3ZnBYaWFETmxwL3ExUGppWWtZdUdWeW5KdFRkc01HVEdjUm9weXNtZWRtTW9pcS9qNTJVOTdyQVBIWTYvbW4vbGVFNHJYMDV5WkdrT3dFbmFIMUIrUTBkWjdsc0prQ1U1Z1dNZkx6MUp4QktjUGlCTGMveXJZVG9iUmU5eEsxdE1PeGV5SWN1elRxcHdVRldSR3pMcWltM1VQMkQ2NFhYai9UazUyd1N6S1FZS2FIVkIwekhraGFTbmdlSVJUd2FSWVVvT0k3VXlNNmJrOVgxM0xSVElWL1E5TGF1elFZWVloU1IzRFpDK1BzeFRWWVlrZ3RvTStSZmlmQVZ0UGt0QWpGdFBVL3R0dk83aXBVenliUmVkRmQyL1FuVWE4U01GMDdmeVhoSlZldVRvLzdFOHM5SHZPNkZUQWVkcGRIZUhweVBKcDJFOEx0dVdzLzJ1OWRMSlhBYXNsNU1wQWxjaXp5cG82Z253dmZpNWJlU3ljTXVPbndXS1ozaFhjL2JhUFBqV005NTR3Y1kxc09pVHg5TlVHNmsxRTdOcTVETnN5aUk5TTBhUUYzOEtsU052M0IxZmJwRE5YUG1leWZleWttZnh1aU5kSkx3VkJ1d21aVmRTcGVDb0o2b3lFSXRYTllzSnNEOUZYODFJYmpHSWQ1alFBVEFIb0NVRFY1Nk04STEyb3NSczlzWS9JSmxJaUwrOTRlVWFodE5IVjcyNHV3dE9FbGZWSkxpdENnVndBSnZIaVVpb2g3WHVEYXRiODYrbVdub21MblgyVms3TTV2ajRQR21la3VKVnNmQWd5dlRVNXpHSVkzWWxCRktQNzNWNEgyYSs1N0R6SkQyVEVNbUw0akgwWmFuSndQU3I4RGxKNzZZS1hTRUhjcUliU3IwUm5CalpUb2V1ZG9UdzJTdUFSUjFWSmFPVEpkVXdmVXNKcGxONUVyaktYRGFZcExkWldrUWRiS3hZY0ZEMUpnbStuaTZrL3paOXZwTmZlSDlRc3FqYXlsVStqVjkyNERBcnorNGc2VjFJVEs3UDBqa1FvNjVVbW9LMExTWWh5eGJEY00wd1pPeXR6bnRUWU1pUjlLWFMzRXVTT25raWdaVmJVWDVQWXhtd2tFL20vMk04TVl0YUdMU1BrL0hJTEs3eWN5bmhlZEE0ME9aQzJkODMxaHVlMWpFMmZLVGtuRWZ2Y0F6RG02K0xWNzZqK0Y3dS8zaHBxSDR4bVo0YnRZbSsySkxEcmxoa3RKM1grQitoVVFWME11Ni91eC8ybk1LTDA5bkhIZ3FybWxkVm14Qy9HUVUwSW11eVNKZFFvU0xPUHBTL3cyRStoOTRac0ZhVkhCUm1iOWxvNDVMT0ovaXBHc1JWVktta0tNZXFMVEk3WTFHSzh5WTgxV2t1bzE4ciswK3VhaTVEOTdUMENNaTlsTnVib09aaHl3RTlJTVlMdUk0a2NNQ2hVR3hMbkt6SG0rZEVMa0tCMERqTFIyZmh6cFJrSm9rVThVOTc2TEtSM24wN3ErNWdXMWZGVmZ5Rm5Wd0RPRHFXMHg1cytxVHRKRkpQOU4zczlFd3JNbmxKVU5XVUpuWEpUZEVzbjRZeFFnRFZIR25MOXc5dGVkam50MFpTTGdHL1FrSlFXSHhzK2E1VVNOWDFPVmkrR1AvTFZzcFRmTVZRWmdLdXVtbFVoRzgwUWhRK09kTk1LSzJXd0RPTjZpM2xib3UzaHFqRlV5SklpUUVaNERtRUtTR3lLd1BIeUcvTWs5OFprMjlDMy81T3Z0Yk5vRUNZV1poNkF1c1FGcUN0MDZndlNaY29EdUN4VnVRYTJGak5pemp1TG5NYThiSVB5VVMwY0hBOU1TU0xTMHE2ZFFnKzJ4Tjhtam9sWldpbWFRMXFiYmljREw2OXNESHk1NGZCcTJiaGUxY3Bxa2V5ck04SktDUkFyYUE5UC8wOTRWazBjMWlOZVlrT0M2a29lWlpBeFIzb0R6S3NTOWdSZ3lsSUxiUzdJVllsc2VqcDJvMjBZOE5Ud0d0ZHRXVGJqc3Zra0ZUdmN1VnZoaXNUR2J6QTUvdmhXK3RvZm81OU9jN2I5SkxJQ3VPYUF0Y1dERFJsbit5MXk1WDh0VHhIVFRwWm9EMktNaGY2em4vRnA0TlpSb0M5SzBWWXRUWVc2UnRkRmpVeUdNajhPSkZYZEZrR3FnZmJCOUU3U2JoUTlEcSt6aTErNzB0N2NlTDdLdjY4b2NzTHVLU1NrczBDeUYwZjNmc0dYcWIwY0p4a2E3ZzVRVjZKK3c3U29wVG01VjBHVEliTVB1SjdlU2x2RU9kM1UyT2cxNS81enlDbzlrajl1dHpOc0pBajdTVjlQWUZRaGl0TG1iRE9pWjJtYWpoTXlTU0VUWTB2UHBoU0ZjY1Jsd0o1SDJEVEpNdER6MTRyeENONitRRXFEa2ppYUpDTCtUc2ErR3ZJY2kzNFZGdjZ3cHMrZGNPRnZQczJINjQ3T1VWcE9rUUx5WmlhL1lpdFdMTFBRS2RQTjRMODRrOFR2NkNXWXpoZlJEMFJ2V1dSZ3h4OFRlZFhrTFY2QVgxRjduWGdTcFdiWE95WGhMNE1SNnRVeUFrL3pwV2VJRFpLdEpvc0tRTEdVR0J3WmhPN0dZVjFmem95U2lHRUhxWmNvb2dmOTdXU0toWEhqSE5TVGhpOVo3N0FXam9tWmhaSkNqaFZKSDBqV1JKSjhKYW92REJhSW5SaVl6WEQrSXluSytycjdUcGFHSlZpVFc5aE5UWWloR1lTcXhxUUVCN05vWUx4NWxQdnlEWVA3T1NQZnl6UkM5aCt3bm96NytWaTl2WTFZRStndUFBcllYcTJKSDhyK08yaFFwYTUxVlNJWEtDZ2pIR1h6QlBvUDZPTDFFbGRQcmhXbUMrSFZsNk1udGxlQzJZRHBGb1VZTndqT01nYUpwZVZjeTZOdU9TdzAzdFc4ZTdranU1OEJhUGhicTJPQURzaEwzWklzY0xxU3F4TCtObFdsR3NZa21QK0FuRzdubXpQN1JBQTBFZDN6c1B6UlNzTTJWM0JmdllhdVJwckNsMHUwYjZHOTVmQmRVamxxOXErQzZZT3RXZHFtT0psRXZmNk9BeVk5RzFxcElrRkpjK1FTRjRicTRZRlFQNHRDbUxrSk9Ec3VTZ1ZnUnJqeVZPUkUyUzRtazhWc2JybTlsUkZ3YXp4UkxlQjZNcnc1b1JSSXIydzhNZnZYMTQzMUNNcDFJL0w4MEFLaGhnQWtUQ2NPamh6aGFlWGFtRVlrWUd3bVRnVjJ0TTB2VG90c3dtNWFLT1AxMmFmS3RseEVLeWxXZHJES3hmY2ZqTkpSSndXU0g4ci9GWXkzMThQdDdaeGIyUklIbUtZeityTWhIaVk0UGdzdWJZcVp5eEtLakswVENiZlN5UlhvMW5CT3lCcFFxQ1R2Qit4UHA4ZEJRdHhKcmtPa3F4Z3l4eGVnS3dIWEFEU0RpdzZRaGxFYzROY212RHFLWDBDRmlNRDNFemc3R21zS0doQngyY3VULzVNK2Q3RStUZU83R3lKdFhkbmIrNFNONHEzWHRTaUEwcVBaNnVHN0JUbGIzeFJoS1J4TVpvSURTb3daOURwQ2hnWkVTbTVZYzljT2xIUEEzeE9vbFdvR2FQMElLc1liN01zbDh5SXVGQy95RWRyTTZXMHk4T0E1VFZ4OGtJYU8ya0Q0M0NSdEV1OE5KR3pHTDJKdUhIRXkxbDAxc2xraU5odUZ5aFBoam9SZlpDbkhpMm94MGI0M2hlbFZxeU1jZlN4UWlZNU9Edmh5d2ZTWkpaMnJpcnlldm8yUWZHT01qa1dpOTlMdnB2QkV6ci80eThLaUlsOVF2ZG51V1VveGw2dUg3TzhRWnJyUE0zbldaMGVCaGo1Y2Y1VEl1VzRjeDlPcktDY2g5RWJxWktEeWtaQ2JVclB0Y3V4bUhxWWxQN2Z2c2JvYnRhWVZ1TjdSY054ZWZVTVhONjB3SVpTZnhCclB5dnlDWHZvSi9lQXZQT1lqeDIrWDByMFZaekkyQUprcTYrNkV6UWxDUXZnaTJtYXplRGZJZUdiMzFjdWgvZzY1NjhIZkdFY041cXg5RXFPKzg1Zi9MUWlyNmx2UjJEblpQZ2wxTXlLT2Frclp6VmdtM3g1Q2djVk0vS29sU0hzV3hvZmtuMUZvRXIrZG8wVmFmRGFNbGdzQ2hUV1VUeHRpOE1ocUt3cUJrdTdGUXptUkZxTTJJS1ljRFFNc0RrQU8xa1lVSENSOTBXS2FrVzBQdVBuQkJsVFdRM0I2V21xVktSY1RncHRnSVppVmdhUWswSS9IVXptSWM1ZHE0TTNVaXlQVUFMSXNFamZqK2tqVlQxTmdrWlBWWE0wSzhjdjErVEhtUVNScUJHaVFpVjJRemtRMUZWeDhZU3ZUZEduN1hublNsNWY0N1ViMDFNRFp5ZmFoMjl5QjJtQVRuSDVoQlVOTlp1VmczVnhsdkFWaHlUbnNsVmhSUXQ1R1VETWRTTldjTXNFV2kzVmZENFZwTklITHc5UTNqWGVXWE0vZVlzcGUzSndIbWx2T2xJYTdKcVpGS2xycmpiTVMxSUNwbmZoWVJITHRsZ2QwOU9ZUk4rbHVwbnNGaFcxUWJmTzUrMERjM2pGOE90aDdub3g2S2ZIa25nckQ0Z2s4STZxY3QzVDJMVjk5ck9BVlI3eEpUTjlySnNaT2JuNkN2WDlGRU9Xa3lIYmQ0NXJWdnlXbGl1eXBkZGFia1poeUdaNVFvOGNQRTU4d1E2cnlsblIrMmlZUnlYbVlwS3UrRVloT2pGUzQ5d3VUdFhUQ1cwZ1lwMEYyWDB1Q2lCTmVmU08xTkxZVzFiU09kS2VhM0ZXazJZckFLNkxITkpHQkpLK01PZHl6MVRVU0JUV3dKU2hvcHlTUXpUc0pBdG40UnVVdWNRZ3U2ajBwSFRIbFltWHpsSmlRY1JHWEpJVFZsUGk2M2hLNG40b2xWdW1BSXJrb3cwMVNXNXBrMXJNQVM1ZnlPckRlSDdPY1ZNWjJIQlRadG9yTm0vSGVqOGcyYjg1R21HcEd6REpWd2dnaEV2VkQ4SVhJK08zM0YyY2FqZkwvS1F1TEZPcEwrZWp0ZHd3SCtiM2plcFh3Wk96aEZpSzFqQlFsYTNvcE10d2VSY3RUWkp2NXVvbGRINmN5NnRxeWplMXMydnpNMGx2cnJYdW5oUjdyMFgvczdCMlJYLzFBQnM0M0RvakIxelJYVkZmazQ4WGxVc2plV3VxRkRoOWZFMTdONU1lcDJUVWg0b2hHU0ZvblBCY2g4YmpaTEJvV0hVTWI5blJCUjRXUkpvSmxReUZQVDRNcFBSVWlKZm1KUkNWRExvNWRuN0RqUjV6Y3BxWk5DUlJVZ29DZWhId2t6aEJrQTJsb3NGc1V5cStGc08yR1Zad1E3ZjJVcmlUZ0hlcGNWcmdtNjhaSStRaEZYOGtCNGRFdnhqTkJ3WERXVUhyZlREdUFPOHN3QllxeG03YlVVdzN6bkg2ZUt2Z1lyQVdXczRCN1U2VG5Tb1NBQmxWR0dUaDJJNXlqcndjc3pNRkRQNDlJWThVanJnNXhJNEJjWXhLTzNod1BVL21uMWRjaElxWTFZOWdaQWtuUnRZMXFYU09aZzNqQkpFSUo1bG0yS0RnYkdrYU0xeWZhN2s2NC84amdCUnBxeWMvUFJMNysrNGZveXl0Q0xNSnlqK01Ya1ZXOWxnamZYQ1FLZVovZitUT3c0dUNXdk9VSW9FTlRXdGZZZk1KMDMramNRR1VjbUxlVERJOXNrRFMzaU0wTFRBWkNPYzJHTGd4a09HSHUvRmZWcVZYbnZQK0dZaTd3VzR4czNUSE9MMmFkdDM0ZWoxMUc5QlJLT2tUZHF4SUZPZ21EKytMNGlVS0lYSlBxR1J4T09GUlUwQWRhVEMxcTNJNGdkMW1jdXVmSjFadmNwZ3daNmRtMnRKUzErM3RoZ2Q1K1hvTVU0eGVaS1NyT1dWeXlHR2NjZ3BtTk1FTm51dnp5MlZaVGpscnc2TUthdzZ3ZXQ4dzVuaWVNOFpaWEk0MUE2UVhFZWNwdi9NTXVPMzRqU0ZlVUZ1OUl1UUFXTS9aVWtzY0txR1c0dVdDbUgwRkExVmNzQ1RTeFRzNXJGV1pLWklvUldUaUlteUNMTUpFQjE3QUl5amNBYlk1eHgzVWR0bG1JUGV3ckhBZ2Y2a2RLU0N2b05WNmxQZ0sxMFdRWUswQ3Nrd3B6dFBwYTJTUDQvaTUvcndRMWtzbXlJTHpNZ3BPc3FXSjZSNG9SaUp1THZ0K0ZSd3FiUHVoUnMrajl0QVBiOW03YzNCYmcrUXNmWmpIMllCa0Z2bm9DVFp0S0hmaVVWSHJwbTRXS2VVN3daaG5ZYXBxcnVnOGhMRUtsRlA5ZFY2SURGdjBKQnpJc3hTN0VnSSt6OWpVaFNoM0Y3Rm1tRWlvMnRhU1BuSmZnNHNxMzRSd0Vjcko5MlFyMXM1cUtRelFEMU93ZUEzdW82ckhveUtUejMweThrTmRRMFNSMmlzUVJLQWFxcGNLbFhOa3BTUitjNG1YcWRpUlFJUkVLU1NuVTg1WE1LeUhKVG5XZTlJMGxHd1RGOTRYcFluNnFpK212YVQ0V3BxWEFObVNqVFc0NU1PcXg3c0k3V25KajBieFJKSXY0M2pDakhRZ0dRRmxpY0IvNCs3L3J1OUEveXhaM3NDdENySnRSSHpoWXhRVVJjYkhhWS8zT2ttNVRGSUIvUkpZamtVZmtPNFpYbW1qUE9GZEdmVXkvazFYdGhFTFBiaXZLRFBJMzY2cDhnRlhIa2JwdisyUER3TjZ5ZVV4QW9IYWkrV05iMFdWMEZOSjZ2eElja3FreGlXclFRdW1HSDRVZVRZa213a1pxbHRNVEh3MGVsdWtaYkFVYUNVZ1hpOUtuYXZUR2xBZ2tFYVU0aktSNXpBZkU5Z0NoZzlKai9hNktaeWphaXg2Z0ZCWjVCTUo3aHVGRjNoMHlkWDdNbDBSblkxQVM2VzNWa2ZPMVhDM1BMTnkwQzRKVytaK2cvVkN1SlNGNVVpOEtDYU9ScGFiS1l4eGJ3RFhCUFpISkxSNTR4bWNHcWlFd0dVQ3MrZFViYVZITmdlT3BIMkg4NDh4MkJOVG9xY3RMaGRrdVo3TWw3Z050ZUpwSEo4bk9wYVZQTytvSUFXb3lXbW1Rc0p0ZEtaQ2Y0SExXRkpXMldyWnNjc3BmcEQ3QjRkNXVLektwVTcwNUR5V2tWd2hnc2VnNWJNSGswVEU0aW56Ym5vU1YvRnVrRlE4VXVtbHJrbjhCcGh5ckhXaCtReHBwcVFXdWZJVHQzdWRYeXg1M05XYmViZ05ncUJVYUhPWXBXaG9ZNjFQb3lXSkZrajhZMjk4TTJtdU9TRFFvZ0s5Y2lhbU52bjJWNnpxRzVXdnNiRUdJb3phSDRWZEQ4b0N2VFVDUjBCSlczaUx5ZDE2QXVzeGJGSXUwQnBIclptWUtQeDlRVE5lZW5ucEc4UFlkZUFMR3QwOGhKVnZKeThQWXpPajZvdlNmZzVJNXlURldKM2hVZ2RmL29Xcy9ndktuc3ZzUUYxbThMQmxzaEN0VExIbjQ3bkFBb0dBWVQxR20zMm9uTkJPaHdhWUtFMklRNGdka0crbHRTVnhWRk9PcTk0YTBFb1FjSnVrZC9IcFFxclpSTzlpRkpCWUE5bmw4SVpNTDRGeCtHeUl4bEtwTDh3aU9qUlF6NlptTFYyU2tCRXByVTV5NTFraUV2bVRKRVBFMzFVU0hPVXh4V2RTTWtTWlBFeFNNTnFpRDM1SzdSejdja0tOcThic2RUcnlnU3h6NmFZWUNna0JZZmRBcUFPTDg1bUJud2Y4VDdzQmZ5VzlISWIxYkxaUnhxTUYwUGlUZ0ZvUllNdytydWhIOG1YRWk2OVM4aDUrL3RMRW0zNzJOL1dGRWJkN2NYTHVxQmlhUXJ3cDhtMmhPeEdlQTZCU0pCSllFcVJZOTRlS2ZqQVY0SkI0SFMybndwSUF5UkV0emVZbkphdWx4V0taWklRbzV3cnVvZHRyeUloSEN6bWhCWkRtTTI4YVlEVUxKMjJtWWR3NHdKZUU1MEMwZVZVOVhTdTNlYUJGeE0yQmtad3F5eEZMSURJcEhzdkFKWXV2cFdnSk9CV1EyUllyTDhnVGhSOEl2bk0vU1VJU2NUQ1ZHSURSUjU5bTdYNTBxS0xHRFdsa2lqUUZWeHVwQ1BIcENJQUxyQllNV25NelB3NjF1NFVPNW1SWFh1cEhGNWM4VTFOYUw1VktFZWN1NmVzQ0w0N0dJNlgwU0ozaHpOLzhYL2x6OEQwa1JJNHF3QURmSmtlOXVEaVJhNHZ3YkVWUkNtcGNGM1JKMGUreFhwTWFDbWxneGhYWWlhQ2lneFdhMGhVeTZyTHJNSjMweGVkWG9WcFNTb2JrSGZNRTJEeVZGMk0xeThBUmdNVVZkbVVNRHA4a3dWZkR6TGNrMXhQclNYam1ZUEZPcHYrdUp1NHBQZ1B5b25vbFRoL1BtWGlDN0VpMnprVHVJQm05Z2dISGpTTHFCRHpBWUxITjFEWHNycXVLd015Rlk0ZVVQb3pKQTIvMkErWlhFTWhLNytBMHU4eCtyYW90N202Rk9tdUEwZ3psVzNGdzZGc09PR2lZMlVVUVlEeVhtZERsYnNWZmRqWEZKMUZYeS9YbDlCSWFQVXBlUjYwUXFUVnNib1hlWEhIMkVtbWtyYllFRitTb0t4a1IrZDdoNE5MQm44THh0cDF4MjZnZnBIZU9aVW1HRXh0bUJWSjZETHI0bENoZ3hZOEJVTmFUKzVIN3FKQjVsazRmTU4yVWhHTERLRWNhUDRJblc5SnVZVUlXLzR0d3BxQW45ZHdHb3MxcUdnVHg4M1Y1NW9YWEhrVFppOHg0STgzL0NvTXE3RitRYW9DbE1RdmJNOTFReWpFTExmWExKVFVzOGZvdHdpb0pNM0ZHZGVFSWI3MUdqN2FrdzRkSmNVbk45YWhXZ1BmbS9DaUVYR1ozRVB0cFNSOUhYQk5nbURHcU5UQ3RpQ2tBeGJGMGVaREVhUXBISGw4M1RuUEp6aFdraHNpS1Fhb3JvQVZTQkZVSy9ReDNxNmhveFRNQzF3ZGduSkVQKzQ3aW1Ca1NONnk0OGR4NDdyQTlVN2xaVFBKTmNCa25jU1pDYzVLdWNITURWQ2FabWNaNmpGMmR3ZVUyZVlTOXdrdHV5OUpsZDZaZUxmZ2EzSUNwandqY2xFc3hPaDd3NTcrTmZuQkRiVlJwcXdobUY0SUxTQWVRY1ZFZGl1TE5lTHFRbnlHL09rallwVFI2a3JZekVnOUFJUXVYRHh6U2M3NE53SnQ5K1BaU3pjeWllSVZGVGZlTzRjK0hSanNXYVlabVZiRitxQnpyeERpUWYrUXU0Zy8rdC85WG1ERnovVFFwS3RFNnp2NGtIQ05Od3RMRnZocnErSjA0ZmxPUXJENEVrVWg5Vm0vS3RRTDJiZFhGeE12Sis4dFJ2Z2JYcTZHRHBUNUJ5VWtPSGloWFk2NWRBSGxDd2VQQlZGRWlpV2dHakFXYWJ4THREM3oyUGVEZmtCYWF1bEVRY1lnZXBlTGtJbmovQ2pOVVkxS0dOMVRSeVdoZEdpNmVxYzNEVUFMb1VSOXJCV1MzZUlyUVlKUlFRallPK0dDZjJEWkk2ckM5d0pOekhNMmxtd2RRMC9nZWhwdTZXTzdPSGgvYng1Rmowa3d4d2NWQ01zK3phc1huRmo5K2p1dFZPTlNnc3gwOUdPRGE3dUExVDJrM0ppWERpQVhFeUhXRW1vRXh3Y3FJOVY5SHpGSFdmS25ET011UkpUdWRXTmhqYUFmTnZnU1p3OEhzbzR5TkFVcE4xUzJpWVpXdlNXQlQ4WktDRlZoMjVMQ3o0WlRPaGQxRzFSRnVYeHBuVTdZMGxJSSt5bEJwY3hKOTlWSXF2a3h1angwaUpWREpnNHNmeTZpVU5pREtNUHpXTVdqMTJiUGhKQ05WdWswRnJJVjNWZlJWb29ZT2ptcmN5YlBLbkYyVzRLVStCNkZRanNyemw3TGhjYjJJbHRvOHpxT0RDcEdXZVhZNW1iVXJReW05MVFhWlp2aE1nUldUdFNFR2pGZXl6QlVKU2VIOTBEMDFzaGZWOUtKQjAwcTZCY1FaaGNvWkwxeHFTWTlLbEowalU1blRxM1hZVGdDd0FQSEJySk5FV1hKTGlmZnoyaTVQRnBmZ3lodDRjUkIzR05kL2hHY0ZEMDZNYVVVZHgybFZXRGUrWVBiNThGTUpKYmIwdDI0cVU2ZzNhekRLSkxISzc1NWttdGJ3OVE4V2pwYTcrcVNJSkFBOHJHcWlIY0lTQU5VS1NFM3REWk84RHNNRVd4U1JnU0RqZENIa2s1RHZiVlRnUGkxYjJja0JGamNnK01qSExiWFNJN2x1MUw5aVRMZWlTc0o2Ky9ramYxTHl6UTJIZmVPb3N4M3d2U1k2aTZuelN0UmEwcndvWFhXZy9oN3VTeEsrRi8wdlZ0NjR5bEI2OG5JcWhMM3prSldLaVlmVXB6c3A3S1ByZlRiN0ZjODR1SHNtWnBCbjkrQ1lhN290M0VMU1BWTTJEM09icjlNOUFOWUZneEMyQTZIYStNUmo1V1ZtQytHc3pkV0o0WnVpbDBwSkp0azgwbWVQdE00Ym5JdU5uQ1JzeE1HYWZ3U2wramRtNXMrQ1p5K0JvZWMwUXhRMFpwUlJVc09yMTlKWHkwQ3A0MHdNbnpUVCt3VnhXWWZXT2JvVEJLTkQrdDJRS2Z1cGVhbXVYRG9Sa1hvUm5UTDFlQjc5VHlZajBnUC9oRlBiMHhaeVdwZzNuRzA5cVVpYkVBNDFNdDBLeHd3MEJ2TGlJTzFyUnZvSDR4blhyMnZ5L0JsdlY2RlZGOWM0alZ2ZytYbGliK1BWS2F4ZHhJTVhrN1lYaDVpc3FwQVk2TnlVNnFwd3M4cEJ4YTJPakp3bnh0K2hKRUFiZTJHZ3k3dEFGalZSMDczTWl2K3k1cW8xL0dFbU9iMkRYbGl6UlVQYXVZUUJWVUFNaUlKS2lLb1h0UDBvSnZRL2g5Yy9rMS85d3BrcS9kcFROYjVqRHE5d21BMFdPR3FtNnNqaHZJamRMUktrSUxjWnk0K0lwd2oyRk9lZm1PUmt5bkx5cEttc1J4d2t2TjNqL0RyWmV1eHFaOEdqbjgzTmJHNmpubDhGYkZKUW5pbDBaNnFYVWZRRklrWkpibndXOUZ3NkJDQzdrMjlLOG1nVkpMakE3UWcrcEwyK1hwUUViL0lvQW1vRTRDc2xqNkhOazFrcFZmckt4bGhxKzNFM3dmRXRLMlBBZ1IxZi8wMnliYzgvd2VyUlc4a2ZwYWgrSkYrb3VUaUJFRVViZlhLcjZUelpOb2M4bGxMVUdpc0RRN0E5N2VvcHZYbTAvempJZmJxcGd5ZW1CdkNWVm5xWWt4WmFzUGdrbWlVaU1VRldrZmJPNlphUXIvMUVmREhNU3dMVUxFbUtZenROQ3hQcDV5Yk9WT2dheWlRZkFud0tXUWpObVNnMzRXNlZ2RkRuSHgvWnN5cEVZMUpNTW1rQ3BaSTNDYUd4Wjk1dVI2MkoxRjJBWkFIYkNDMm5UamRXdW5XVmxMb211TjBuNzVzRUt2R0Jxb1RzdUs5U1ZWenA2alhNSWh1dUdVUjBCWGt5U2IrV1g1Y0VLSkZjU1Y0TmtzMzFBbzU0TzJRRkNSbnJhUGxBSE16aHFhNVpmOFZNWjdZaHFTNkRiSTNCRU9JVUdnRzBWRnFaS0lQektCV3dJS085ak5SNkU4TWNFSGxaL1RqSWpVblhnWnZQUGFSaThIbkVWczB4azdRNkhKaEN5YVBxcGNhSjhGVlkvU05NVGRZcmoyZ0tOOGZtMVFmYzhYT0hxYS9XVUtPYnpJRXl6b0Q4UXF5djBQMXgrSk5UMEg3SzF3K2pLaGVuZWRhdG9jeWFmSFUreW1lVEp5RTdLSXovNEp0NnVVTG1rQzBJM01LVVE5TDRtN3hkRE0xTVNINWRUVmJpVVRtcWZuekplc1hnZGE1UDVab1dwU1dlTjNrU3dzeUZjdVU4YVZzS3ZTOGNSUXdnVVZ5ZVNyVHloc3B2d0lYTDFRTEs5dGxad1hZUWY1K29rUk5Dem1ORmtCWXY1TVhqUm03aG85R09FUkQ1WjlCL1A4TzJZeldWckFXcVBVYVovWFR3R1V1ME5Mc3VUaS93M01ZMEFkcnZGYk5IWEVZQ2ZoVVBmb3pKUXBxenZNSy9zcnI3d2F5b2tRVnBweExaeDNDd2c4Q0hQVU1LY3VlMXlhVXlKMnk3a3J5M0t5dDU4U3F4Snh0OGVhNG5WK2gweVUrSlczQVV4d05QTzg2UHY3WFhaTWcyZUVPV2p4eWNCRFJLMmFXbDVDMFJLQ0JwNGQ5N01mVlQrRGhMYmFieFNGSmZGa0FrSU1QbVl0Zk5BdzU5WlZqYzZJOGtLZlAvQW5SVE1kNDVOWVl4RDdKUmJWTk0zckdkQ1dZRGdhS0VUa1QyRHAzZlE1R2VGbWxVK3BrRUwrbVhuQzJWU1cwTEZlK0FZRXE4TDZTRnhKd1I4V1VReS8vY3JLaVpicEF1VzhMZFFpV0E2cFg0WDUzemtxcjgwS1B0aHZyQ2pqYXp5R0J3UXNUNmVYcDMzNHhQUmxJU3Z0Z3Fvekc0WVVyRFBXOWFvUEhkY3ZCOXpCU0F1MXo2TGNpMTNQTkM5aEFWekMyWEVBbCs5YTMrNmcwcHFkYjNFcXdMTnl6cDV3dnBQYVpnUFJnM0pYUE56UnVScWFhemU5WjhUeU5IY3Y2bjRjU1VTRm5mdWp1L1Y3S2VQa3RtLzkveDdJTVNYc1VES1JuL2w2WldMbVlyWko3bm93RllPcVZvRnZ3cm9GZDN0STFyOGFYcUoyUE42T28zSHBxemJSRHV3b1VkMk9xSy9CcW5BNHplaWdXVXBWVi84WG1KcHlENlBPVUdHcnFzOHJFNVUzQ3FUcFNCaktDME5LY1hGUGs1b0l6QTU3bU1jYUpmTTB3M0M4VWRVT2lvVUJYdGlHWTBQRlhKbk1MSytsejNwV1JkR3A1RHNjYzVRZjM5NVU1NVZwNHRMR3dFd3kwUzJwRWx4NWNCbmlUNDdxV3NGL0VZd0hkaXp6dlR1a2xjWmlKb3lndEpjdkFkZmNpNFhWYlhjNUFqa05nOHVSRzZreWh6bmkxK09uOWUwR0JXdXQ1Z1JkdVk0L3pKeG5ReHpUWks0WnRiMlhxYmEyK1NWOCsxK3JzRXhiejQxK040cmx6TXVOMlN6RkVPdi85LytOL1FMVlkwbEVnQnNpTlY2blM4QXdlTDNvcFF5aDQ5OU9WTHlQRmVOdmZJRXNkYXFTSHlaWWloZWhoR1FRYmR5TkljaWZmTHhzV21STjlONUhYL1prenNQZnpNbS91S1Vxb2dlMENXMHNTNXFicFg1SDQ1N2wyUXJJcHVQWVhCSXhHOW5xWVRhYVFpeWNKaWdlZlBTTUhsZmxjV1hRTDNMUGlDdVF4SEJmSzJISi9WbFl0cjRjYnl1RzJJK1hOeUpaWnhMRm9tWEhxU21IUDR5M1A1V2xlenh6alY1U2J5di9HazZjTnd5OU1VaHM0Z1Jnd3VQRkw2UjJyc1NqVkc0aW93Sk0yWlNwMnArdTVYS05IVlp5R3NDVGw4cmdlSGFET1N5VllrTjFOdnkzTk10YTdpWll3T0VRNWllbjBldlVvd2Jhb2xDNTBTaGwxUVQ4VHVHY3ErZ0NzejRSb0t5aEFsaC9ETnhQMitPL2hnM01Md2FvTllrWXdMVERYSVE1MldaY1dVUVRERmhWZ21NZktXa200bFFvbE1aa2ZxcEJybFRWb2Z5cVU2UDZySlo0QXZmVkdzamVLQkxBK05WSjdKTzdOSXNjQVRKc0VoK1BpRWVodmdxWWx5REwzNlhGOHAwK2JIL3NoMDNIWisrWW1SOCtQa0k2TDM3TFBJemU5bUY3UEN5Tkp2SktNYnNHYWluUFpZOWxET1VXZXFHNWYvVVc3T2hGWDMyYUhoVXQ1a2lTZndZdzdXWTBCa29KYXd0c3duTVVwTTRSM3d3MDlTbTlWLzdLYzlqb2M5SHkxcWxUNFBGNVFRaU1ZWTB4dzhuU1ZKUTduejdXeXBrSDFVOTdHRTdLUG9rcWE0cUtBc29qbG9KOERSUlFSNHRCbUZtYVRRTVVoTzdweWg0a3dzZVBRYzhxQUdsY1BVZndwN2sxZ3hWWE5MVW01RmcwMlFCckIwb1lLRmVOMVZ2czJGM1Q3K1hTbzl6Nk9YSERaZFNGV3BiNExrZ2RNY3lRZm55dlFYVXZtZDBra3RhRUt4OGNhWVhpSTNoVnY1bEtuYTlIWThvVEJwOExYZjhyTXBZbi9KcnkyWXJnVHd2ZHAvVnZ3eUxmUmtkOHduTmVRTnBZckE5UmhJUmVCa01LdERlWVJFWGs0UXpqTGs3Q2ZOZWZxbXFKM0UzdmNsbGNSQVVjSFBleUQrV3ZyUlN6dzhwZkdTbG1tR3Jpa05HVjI0eEZkQTZuWEJiK2ZDMHFRR0JtcEE4SXk1MjVwK0x6cXdZNWFpNGtUMVUzajNHMTdpeVJNcWoyN0g3eTNHNHpWeFdtTkxsMWc4U2dKWE9WK2g2OFFzaE1BSmdiR01veFFQZFJSbFVmN3R4RnVBZUJPa1RlNDJlVzRsM21yNGo2N0puWnovNzBJMFY5UkxCaVFPTnhsdFVmS0d4ZGNqUE82SzBZblN2RkJocEpnbWd3REpGTTRNZkhxRjJTdGlPWTh3SmxaUmRTbjQyazVNcUYzSmVtMFZzWFduWUxJSVkrblVpQU9vSVR6VGhLS0M3WVFtRXY3YTh4b3ZqZTk5ZmZHa3E3eFNnc1daUnY0aVpBY3luT0FtVG1tR2RNK0FOK1hlS3lwYzhrNGY2V1grcEtsSVM0clpvcmdUa053Zk1uQnB1bytvamVEa0daTmlHdWRKcjRacWk0bURoTmFTeWhvZ01UOXBnckxLdE51NG93RVArMHVlc2pnTFRqdzljbm4rU1pBYUpNemg4ZS9nbmtZclFyNC9GaUcxeGprK2hSSjRWMW9ma2t1WXRnL3crMUlRQ1BETEp5TGYwUktMQVFDV1VoREhpQzlJYUJaTGljajlXZHpINkJUSDlaS3g3QXhUWlA5cjdBSkQvTDFwOU1sSVQzeHFlYWovSGpjTUJsWHFkTFJseHRkbjhYOWp3b1R4RDdzcUZ2ajZMNlZQelBpenFubnZCMzJMSzRVWEdlMVZkQkRUYXROQUNuQmxzZHdINXdESkxnL254SkhoeHUzZ3l3d3RoRkxwVUhNMXJ0Mk9aMWxXUHRQOFMrbjVRVWpuK2V1dFpEb2pqMVAyN2c1R0NuODBDcTdVcld3UFN3akVYYXJSbEJkRU9LSEdLc3Fmb2Fvcm9jTkpRbG56VWZ1eW1KdVViZlE5eFhvUFZ2TUo3YWo2cm1EUCsyYzN5dE1TdmZGK1Vzcko4OGdrUzNOUXROeUg5NjBPNSt0UHhjVEVSMUc4bVdqS0N6SXFvQ3V4c0dycHB5T2ljbEJCZEtTQXM0b3JkZTBQeHNSNWtpaHhyRzdpeXdYcFBzNE1BM0RZOXQ4WGhrTkFKeWNXQ2dKQ1NVZ3NIcUhhZ0xYYndYbVJ2TFZCbk9zb0hRbEE0V1lQYStQMGFjSnphWks5VCtJWkR0ZFJYMWEycnlvSWlubVdHeDVNVjFONEROQ1UrQ3BxL0ZINk1rRmdBTWlBRExNSkFxU0dSZlVndXBCMTJ2ZVhGZ3huRElhRnpOVmtWSTB6WDdjSE53Nno1UXdraHNBL29ZVytkU3JjTzQ2NVhwWE82NnlTNFN4Q3BRbFR1dWpGb1hhWjhUNllhNGJQL2RkVUtVclpSTXJxL0xuSFhKUDZ0bGdyK0x2Q3ZBeGlFR01Mc2FLdVRVNjRZR0tXUitwSFlJM0ZtWjdNTnZCb1ZVZ2l6ZTZiU2M4aWQ4T1ZvZjMxVkFRNC9mczhQcHNvWDUyQnY1SXdGS1dUWm00d1NWdVNWLzVwWHYyQXFqbVg2R01JQjFpejRGWWJ6TGVsSUJHU1Rkd1Riclc5K2Fua3F2S0NsaXhOUVl2Uy8yRUJaWFB5MWU5S2JFZ2pTVWpYSkZEbmU5V3dwTHRaa013N1Z1MUE1UkZ3VXE0Ym91S0JpU1hpNXh3N3NTR1lWdEdIT0hnTjlHd3BlTCtadmpreko1Zndyc3FmRjNBMXdoMFh6VGFrVzdXZ3VrcDJXZEpKNDNmTHFGdEFzY3pXdUoxMHdMbU1vbk5ZeWJOcGlPWkpVbnNtcFl5N0JaelRvM1pUblU2VFVrRXhBY2JsUlB3TkpnTHE3Q2Y4Q3lZUzNDeW1zN3JsKytJR3N3OGNuanJpL1ZINlpRUTFGVzdsMlZtQTJTaHRkdFBNWW5wa1kvc2pyTHptZmdxSERCZnZDZ2VqOFpEcG1jUjRPeDVRdDVVWDlsaHVZTFQ2QlR6bnVGZU1ZNFV0MitIZHVmNW16Si8wVm1wdk9mSkhsMm1nMVUvdHpmRllHeGVmMmtjWDZuV2FGVXpoVjhKcFVKUS9XWlNYUE1XV3BQWkZXcUFZaERMcGZaYWFOelFHQUY5RzFPUVRMZG1jS1UyUk9rMERNQkRhMHBRQjFwU1dEdkU4VE5JZ3JYaHNGNUR1am55dEdRNFcvVkhIRURQYmR0Vm1HM0NHWnc3M2l6dzZJZGx6TnpTMVNZNnNmRVFYMzlCSEVYSmJic3VUdXkvSW5ieGFWdkY2Smk3eHVEZmh4V1p1YmNZNVF1UFAxSE1MRHBPb2tyVzhjM3haWXN0ZDJyVDRNd2VOT1hjUGszaE52VldqbXBEMkxXWjBPSFRqYVY1Sng0QVkwRGlBblNXYzNiZnFNOUNJY25tUEJUbHlJTE9iSVQwOVUyVEFHcGI0dWtTTHNaVHVTSVVYZ0tWQzdZUTNSUFNiT1Q3TlU1cUhVb05YTWt5OW4yeFB4S3VKOVUxbnVwRmtxaEVPWXFrVG04d0ljS0tQeXBHSlJPMUhzLzB3TTk5THRqK3hocElxdHNTbWhQRitlblp1ZEs4WWF5VmdPb0pQb2FVVDNkZnlXZHExQmNxbWFqdWV6dlN6UVhUSGtsU0lQU3V4dmpQOTg1VElOYVdMOGRqbWF6Vi8vTndLZEpEcDhjN2JNSnVLbXlGK3pTaklnZEpHTi9pZUZGNFFmS3liRlpwTnBjY3dOQTkxMHRmcUk2ak4rUnNJL25veUVKNzEveHVGSkRWREc1dTNvQWh3cjBsWEE2elZZbkVPNG5leEpHVE9BT1NRMTJsZkVacUhsN3RXd1lWRGhnN2E4ZTBiOGp0SzhxeXZIZldEOVVNeFd0TzluTEpSOHUrTXlHU0tIdGRaSmNmUEZTUWtzRm9IMll3MG1NRFpqQytOSnRtWUg0SWVNT3RnQ2ZpZUFpSmdtU1N0STBNUlZreDlXUnRLc2E2Qitwa1NZekd3WU8xSGRJTGh5WGVaMjJJcTJ4YlBNYUxEOFNBRlhXbWxBTExDT2NHbTBQazJ3QUNDWTI2REdKaUJtdndVTUt6TmlqaWJvN2F0NmxOT2RIUWkrTlVUZ1Vyc2ZGT2VBWjc1T2xwVm1heUN6dThyRTIyYW4rckhqNG4vUy85MkRMMGlhbWNWZXd6UGlnUzcwbDFOelY2NllTU0ljK3dmNzhkQldXMlhMS1VDU0F5RFRiaDFSRnVPQW5xcFpLQUxLUFRmbFBKNVVES2hwTUw1R0UxQ3lCQjBiYjQyaG90dDkrVngrdVVpZ0RhUU52RzBMdFVCcnZkb0tNaWhKbEFiVy9zdVg4ZEtGV1ZUWXo2Z01rSVhWZUllb3NKTnJtVEN6RWJpdk1xdFVPNTZ5b21XVUZjcEF0alNpYlZCTXVkaCsxak05dkNDSFY5VTdTbWRXWllVKzhwdE5UazVWeTVrY0YxSko5ZVZLWkh6NVhnYzBzcHZSZmdHRktiZU1wSmY0R2l2YW5kcjhYQUw1S0pra2Fyc0JjRUE0RWowRDJuUmdrV0NrblV3WFFHVHhSWVo0TzN2TW1jSDRzTHlaNEZldVFHenVhUXkwbUVMakhzcytoRkhTYnFhcU5LTURFTXh3a3owdWRRVHFra1dNZjNFRXVOanFHVXdyYkpLUGRRc2ZYSXN6bE5ZaXhYZDVYZGdaaW5IVzl1R2g4RzRTZ3laSVlNN1E3NGlWS05GVmN3YmRZVjRML2RQTnl3M2F6NW8ycHMwMmRYRTBVaXNqWVhGYUd0WjBST3hjSkc0QS9jODBNSkZWS1V5T28ycWtMUjFNSFRwZ2lIbHlvbmF5RS85UVZxUndpV3FLc2xpeTdMTzR1RXJPcXF3VFZzWDkrUTNpbDRMZ0hpdStnZkRBb09PcVFBRVh3d3MyemV2bHFRWE5jZ1RCSHpRZnhuY3orRXRkZjdZVVY5dWt1MTExWldGdjRkWFVmZjhYTkg2d2NLbjRubVJscWkxamQyblB1N1dqR2tGYWp2T0NvZFJTM0tLV1BVU0xRdkNGQjlYNXZsRjgvZk9OTHdmdVljdUtXcUhFcit5SUxVZzNpdUxzcTJ3bkhBWFkxRVFaRzVlVjJHekdVd3NYVDJHWFlJcnIvVnVoV3g5SjdReUc4YjAybS9JSkFZYi9TaTZJODhSTThzWTlVQnNvTDRVV0ZPVkJ5aTVvbHpyZXAvM2NmRlg1RS9mY2g0LzBJZFZoNm5DSEdrL2ZDcE9CdkxVRU5rVk1BZ1ZIME5BNG93QkxKM25Vd2p1S0NOZklmUlhWYVdGZ3hFZmRVRnhCczBEVVo5Ri9EWnhDNFRXNCtLK2d0NlJHWmVSeHVFbGt3VHdieW9oUkd3aTlDNEhBRWcydHkybWpzbTNjcTdmQjQwR3ZIY1VtdlhrbjBDclZaOThyQ21GV2ZoenkxempZdlB2K0dkZk5KYVBva2N2dTFoVnpudEo5a2IxUmpZaEVkQjl2cUJqdjJDZGNNUW1WbFBIWitOazlZcDBzKzRDYU1Ubnl1NmlSRGJ6dGI3UjJaK1VKSFpVemI1YVN0L0xrY1FCOHo4M0t6TlJVTUg5NVZneFJiK1VvVFdhaFNqN2lvUzk1Q0JFMFlQaWRWTzhySWhIVkpRYjhUS0h2aEpBaXVRWXViOHRGZy9TMUdlOU8vS2F4R1oxK2NCTHJ5SDg0SkJIR2ZJcWc5d3JJTk1COFhGNmJkNTcrT2VEbzN5NjBHd2UvOERtZXJyaldwWGVOTlBTaGtkeEVucEJUZTJwVXVJU2R5YmJ2OGcwTGozVTZZYUVuOGhHZnp2amNHMk5pTEFCb3oyOG1nSCtDRTdxTUdqd1VYNUtxbG9vbUFXZnkwVXVoc3RZdXNtdVhaQzl1WEk2b1gvU3BnOHpTZ0lBdWVGVWY1c3BucktPNHl4WmVDY0l2c2FpdDRqeWRZV0dpTTJSa1ZmTU1mQVBVemNuejRsd1BtSjZ4QlpqWTNCRWFyNFNDeFN0cDRuQ0YvK2dYVTRvOHpKRUlIck9wM1duY0M1MnV2QjREQWNWWGltUVhDaTZtOUlXNTY5cCt0Vy9qZjVhV1hjczR0OFdxNVZwa0owNlFDNlBMZHBTK3lGY3RaRXhFTUYrS3N0NGRCZW45Zmc4SVJYRVJEM1FaNWF4bDVYMjZhMjE2R1JCZjZsUXAwdTZaOG4xdVZSN0NENmZCcktFWVZYZG1Rc2dKV01DbXcxNTBBRitobVN1cENPUkZyMG9UcTBEaTh4WmloU1F1eDd3TlkxbENzNVpyanBNRW8vL0xBS2JSVm95UVFxd2ZWV1BlakNiNWN0ZGV4VEUzM1RrL2RYb3hrZmt5bGZJeTVlRmdsTmJ1V3hPN2w1bzZnMzY1UlJsR3Jnd3A4ZTZuSVVBSG1pQnBlRC9mUEFQU2crekIvMGdJNWx5UjR3OXRLakN3eUlZMUlPN3k0bGJGNTBVa0w3MkIrYzlMWVkvcDE1YXpGelBzMzNiYk1uekRaaTVwbm5QRjlUK3NyZVFJOGlVVTRib0hhSElqTTRVL0pTc1A1L0ZPOGF2d0d6YjFDci9XSnpNaTRHdG9DdGRVd1llSS9HUmRtMkVyaWI5UFpaNUhibzNGK1ZoQWV4YndkVUFTMk5kampDaU9LMGl2Y2hPdnl5Y0hNamxUL0lmeUd3K1Y3K0tRdU5TTFZJSXIyRHBUaEwzaWZHR1pBZkkwU1Y1S2pjLzRSZFRqQmVsV2c0Y3ZTQ3ROOUdpS2tkVnREQVFqZjMycE9WMllPcHE2TWFhdGhVNjdVQitqQ0pSSkdVVFRrY282c0VGUXZSR0VwYmhMdlFOS0pVbHNoWjdxaFh0clFpeEZWMUNPcCttN3h3WWkwTVJ5SkxmWU9LYWw1UmdvRWtWWHhraGtVQ3duUmZ3WGdoK1BHOTlrSGdsbVRuSzVzTllPMHdmWHN5a3VsRWpVclRJUENnZ2hGSVhFME5QeHk2ODNBbXJXUTZycVBBR0cyRlV2VkJlbDRYRHJXQ0JBTW9WQjgwL0pGVW4xTGdkWTk2OTdnczhMKzlhOER2V3pWcHpHZG1ubVZXUXpnRHJxUGpnYThFRzBuWFpleVlaczlYTU9NU004dXdKcm1qcDdvdmdrMzMvdzhLR1FYa3dTbXJUa0V2eHBLQjRCYWozZ1Bobm8xaVZxRTViUHpBVUJPUS9ZUEJ6NGd4QTd3dmNXS1BmMkd6Y2hIQVhtb3hlSFJGL1VVd2hodG1rKzBvdWo2QVdpNWVZWDMwRnF4UFhMUnBtalBoSlNwMm9tWVZQM2dQSEdsMktjSG1IaWc4THZBejhGZzA3ZkY2QTlpelNwam81Y0lvek1oZkE5YUswTEYwc3FtcWVaM0N5MkxmU2lVaDhQS2dZZm1CWFcraUd4TUpCMnNsRThPa29adWxqVlRjeHJ1YlVDUVYzaXNuWkJuNTY0bGRIOHY1WDRkWkdaaUdqUmlVREYybmU0cm4vQU9XKzRocVQ1dDlPTzQwcUNyR1Nnb3pCcDJWQlhwc0w3b2VrYmh2OFJJQVVMbVhGSzFzWmROZ1NOZmFPV2RVUmN4TjdKVDR6Y0Z3UE5naDZjNTY4dUNoY1U3Z3hVVHNXZktob2laR3UrRkxVb3M4dGZOdEowL1BRNnpxdlY0dVByOFovOUhZOE9yTkZ5bGJPdmZvMTd4WENQUllBWGxycUJOT2NGakl3WExMY3VtZzBxQlJhYUI5ZUpFbHhEcWN2MmZvd3JMK0N2NUc5NXBiVnVFT2VMa0g1RmRJWHhabWxLY3VCT2REUHdzUStWUmQrQ2FVVEI5L0toZ2pRUlRIc2svVVA0Y2lnaURCcnJBMDF4Y3RFMmhSNmM3NXl3S3dpM2NXbXR6WmNLUnBPVEFiZlVPTmF2TEVFLzZtU2dCSDh1MTc2ZVdwN0xUZitwL09Ubk5KWU03TExvbnhDcmRad3BDaWR0N09yQzZ5WFNPRTAvdDZaTWwyekZNTER1OWoxUUNZRHlRVFRPTDFrb25aVEsrUzUyc3M2WGJEUGlVK0FZckkxRGtzODFXK21JUWVUSlo0YUF2a2d4MEV5ZzBORllQdi8vSi8yRjRZNUd5Skh0OC9sWlpnS0dUWk4wRUZ3WEFHWkFvNUNZSnlMMStlS2lhekdYQjVKWkhLQ3FtM3Q0emRuM1hQeWI5Z29DOHpiQ3duS3c4TXJTV0dMTHV5azg1dkZ5N28wTktORWt1L080VFRTaTd1aXh2eFh4K2FjMG5YUHNIVXdMRXJHTlZ3MjZkZnI5SVFrZnd6OUJvbit1UjNvNjBxaElLZXkzUERpczZ5aURMbHhCejJjQ3JNZ2JlNmhNNEhXcHlCZG9PZWUyRjVBcW94Yjc4cHpDMndQMk95SU83TlVXdFFLbjhPTnArRDFkM1JvYUE1QitaYXhNQ0xVUWhqQ001Y2NQT0Z2RGMzY21NUnpacFgxYms2ZWJZZGFHVlJ1QjZBb0ZhZkduTUpESmJTYVd0MkI5aFVnMXZXeks1cEh4UjB0aVBQSXJaTmJERDVkeHZQcmdDOEVvcHplVGxpcXcrNENQeS81NVdaeTliVTZESEJLNFBSQkVCZmpZa2N6ZnkyODc3aW5taFNwSWd2dE56SWVnK3NYenJUTjl5OGR2UEwzL3lQVXlieDNtZGNsbk8vQnpEejk3cEQ3VlRrL2dVSWczUUd1QVJRTEFSTkdZNndENkovTGNvcU1FQ3h0SjdWcDhsa29uTDNSTlpyVE9tejNDT0hJV0MxNi92YjhwWlZVWG1mV1BoVm5iU1FvdnJiRHhETDh4VzJhRi9aeUR6WmNYOW9QZDAvVDZabVkrTEk1VkdzYXhERTg5VTJyUlhnZVhOME1semJjUDh0SHBqQS9hQWRmT2JDVWxhOE9rLzNMZE5hQmZLcXFZd0pUSEJTRXVleVhqdFYxeGY5TTRNdWRxT1lZVnl3LzBKWGZsdGhhU3dKN1FGQ1U0V0MreXBkaGpDdmd4U1RPMk9vcVphVTZ1dXpJcjR0Y3ZOWnBWMnErc2NzSmFGYWk5ZzNsekVwMzJnci9aaktHR3F3Z2RTMDhvUUpXaVI0RE44OUxUVHFBWklLcHZtY0FpczJ1MHB5bXlaRjhkQzZzeDNxam04SUVIZVo0eUpEZDFSWkR2c0Y5NTdyeFRBTGp1ZzhuMG9JaTJ4ck1sOEdzcmcwV0pmeW5XLy8zdForSk45OTZ3UjcvS0hGZUJmcElGdGNiNEFSQmt5REhGUm1Bekl6d1R6bUlBVzF4a2NQNlNOaWhNRFdvYnllL1hpT2hKcTBhTmpHd0JhWHhYamdlMk5LcFZRdjFmQi9tengxL1JvODlIOTQydzhYVUtqRzdBSXVTNG16SW8ydXEvQmEyN2tPZXlNTXdyUkU1dmVlRVZTaE0zRCtnVGFIa0EvNENhTlZicVdFb0oyVnVqdVdmakM4T1FPNjNqZGtIQlczUlkxK01vd21IV3llS1BtYlJHbTR2UXJzSTFlZGs0VmJvWEVsUDN1NWx0M0N4cEJoalVwaW1qMDVUcjZtVjlkUmZoU1NWUUFuRUd4SEpJKzRSZkN3eVUzZ1JjVlNRTnZQVGc3RWx2MEhYenQxdXlkeURNZmVKMlpVclk0Sjk0ayt3TGNOV2xpMUgyUGRJL3pSZUJFcFpZYk5sVU93emVNajM1N01iMTQzRHQvaWU2aXpIeHVZWVJCYUVXeFFaL1BVVVdxZnkwbGkrc3p1ZVBITytrVFY2UzVDdGdLeThDQzJkUHE0WXFJejFmSmlWMERpbTdVT2tFNGh0a0Y1bmpnTklncXAxcktlOEpSTXdZTGlJbGZPNC9SckRGV045VFg3NVZyY2YwRlVReGFGMlZGQ3FiZERIS1BkVlpIMk0vYnVXV3d2RW1kb05BRDZ6czEyVWVKQ1h1RjZOcFhvUUNuZ1JZR1VSM20yZzd4eCs1WFhwbmhZK1ZvVnBTdmFZN1Jmc0pET0RvVzRVd3F1QjRSZ2dXZFd5R2NJSHdwMmdadURHR0ErSFRwbm9hb24vaFZEY05MMjliMWpqOE1sbjJaNG1ya2k1bFhrS0V1SDAzZDJzRERqaklXejc2bktXRHp3WU95anJhMUV0NVJxeTM0UEtHWkZTY2VweXFaNnZiWG1sZFNRQUlZaWFQaHk3U1FsSk1vWGVPVjRZSlB0VGN2RWMzV3RTMTlPbVdZeDcvSTJCZi9ES0thdmVJNTY3dUVkL2FjUGJMaHAyc3FFUGZBM09VcGdmeWJtRWJpTDVqUmY2R3Z2cnZLczY4Yi81N25Uamkrd0hxa3d5VFpoQm5GenlZODBkam8yTXhEUUhla1U0VzAzMUFzVVQrVDVPOTJmSzRVWnlqMEhaQU40eE1YUENLaUNxb2s4a09mc0Mzb3diUjNOL3AyRmtDbHhwZ0hBRnBBeVdsMEV3UWhPTjc3d3d6cXo0OU1RdnlwbHlpWFd5U0pSVCtVQTl1SkR6RHZuUVR2WnNQQTJRbmFYZUh2S0tTcldGQ2dUdVlxd01ZQk5sQmsvWkhGbHIvZmdpRWYzN05uZlJkbEFZVDJqdmlsbFlTa1l6eGdTY0VUTHBzWnFtNWswMitsdkNEV2pWd3hzL2R5NG5QRTU1NFkreS9rSlM1b3IyYzlyckI3aWdrZzJaUXpEZjQyRmV3V3Vpa0tOTnpoNjMwYTR5YmtyVnQzbjQyalEreXlUMURGaWsrQ1RoalYxZURzTmYrUElxRVpDaEMzVTZMeFJ3bVM2RVpLVWIvMVlpL3BTUC9zU3F2amJmRzJ1dnY3bUVjdjVxUmh1UGc3NHVWU1Q0MHBidVlsWmE0bU5Ea1RFTS9uWldxOGJCaFZ6Njd6SldyMDNhVGNreHdNcWlORzhCaitPOG5nUVZQTXVuSlZmcU9EQTN3ZVdSc3l1SSs3TlEzZEY5Ukl3YVY4NVJ1NFp6Q2sxWDU5bUN4b2VTY3FKcG5KOGtpdHROcjJmaDVKd01WbEhtZ3NldlFMdy91SldJRGt0YTFUUTE5VnNsK09na050VmtHZU9qYkhvR2lBdTVEY1FrQTBzcndrT0lMY01xb0hOS29BZjhDMWIyc0UzU1dVNmh5M2lYeWtxV3J5d0FMMEpSREhMUE5HZ0VqaU9WamJnOFVjNHlvWnpYbHlGbkNjcE5ZWGxUK0lyOXk1Vm9DM0xtSUgrQ3I5NFJFOE5JS01oM0lMRkFZUUcxSU93OVMyUmJ0aUluZTl1bWZUQkc0cXluSndMbVJvcGNCWXZIZEloSmp3Szdxb1JWQW0zS3NDaE9MRzlQa21kOEs0cngwRmRtYVhJcit6TWdxWDlsOHJmK0JmMmZGOFVsVHYrOUNud0UxSzhTQjJkelcxaytaN0k3aDJzeitobUpQdzNxOTNNdjNscFFGMjZDYk5mRVAvelQvMHpOSkd6Ujc5bzh2d0hzREdORUg3N2s2WDVTN0tFb0ZadEwvTHloRGh2QVNCUWNRcFFnQkdGMndOdWhCRDhsMlNKSkloeHZ4bGN2UUNzaEoxNjRPcGM1QjNNSEZlN0ZpOHRNZmFBT2k4V3pHNXFVU21sUnRoeEEzeldURFJtdlNhTXNXTTlqdG9RSFd3eGFFQmVZZ2NBR0MzMUhlblBCMWlYb1RFSEY0WVZwOENvbEV3MlZPSnpJMEppamlJQWpoVllWZk9NWjhUdkpDNWVVcmt2bEV6UTlqYzhmczBxczVuSU0zQTdxYWJ6cjZwT2ZoOHVoTmpCWmJvMGExYWc5eHVXRTFOK0VMVk9XaitMUXd2bW5zNXUyODkvMlliY3crdzlhU2xxU3ZsTFpNaUxwUHB1NW9BeGd4Ukt6UmJ4dkpLVm0wbnl1d0pkby9uVGt4NkptSS9XRzBpOWt6dTZEWnozM1R5eFFYeHA4dW1NNWxmVDdJMFdxU2w5WDArS2lsa0ZvdEF6bUFEYmZEcnFMNkFURXBWY0w1Zk9DbEU4dUZqMHlHWkxxVnlRL0VQZmFmbENSLzN4VnYxdEhlbDd4NXBUTE1QRGprYXZHTGpEWDRjUmdSQkgzWHFZWGN5bnN4MzVXZ3JOazlMbmloVW0xb1hNcHFzMHBZYUtqQS95QVVnYU5EcmJHNmU2eVZsdE00Nko0S21ocFZWUTYyTXV6NzFEd2dTN2ZtK0g0Q3lvR2tSNmxGemtnbUpTMzFZa2xEWXZrVmxsQUlHSWtOcko4a0ZxWGRiNDhBOTRDYkllcHJwSDNuL2k3bnRJMTZHMUpQSHBMZHlSYTJBaXNtV0ZlZ3EvOGFJREVraTh1WGhUalFtUm9Rdmw3K09xVDlOVmMrUDhYcHdpNElVWFJsVUozVFl1S2ZLMEM4ek4wdVpiNWVpbkhaUDg2WElpQk9OcE5zMGdzSk1Iamt1SGRBejhPNlhHZ3ZONkxsNkVhN0duQVpUOHNoZCtZcFpPYXFDNExiOTBwU3M1RmpCaEkyU2pqS05taWJKZ3BSa1UyTFlGQ1Iwc3ZRQlNMc0FLV0lhY3orYkRsN0t4Wnhwd2ZLL0xrdTVKZHorRy9CLzlqenRHeElIYlRkRDI2WjBaYmk3S3lIbm9GQ1Znb01CQW9rYUhPbXpPSm5JTENzVEE4K3NhV0YydTR3TURCdXVRU1lGK1RseDk3VVZhOUpIaDJuUytPaUhNQnd5NnNSR0JTa1FkVm1zdkVVVjh6b1Z6OEJyays4YitOemdEYk9sRlhUMzBYUzN1TDBrSlpsNkE4UnF4aUtlWXlITmFCYUZCSkJxb2lnYnNzcU9QNVZ1Q1V4WFVFK0JueFpDRHAwc1VHaWtOdzY4ZnVtd1VXSytMT1R6SE9vNndobnE3VDVKeHRqY1Z4UXZJVlViTFlNeTFzQW5YSmtUQ1Rwamw5c0tyVllwZ1FPQm1KWUlkTENWNzQ0ZXh5aVFZU3VyR25PUWwwdDVXRkhDbjd5V1BPQjE1eTIwVTI1OTlsVXpzalZ5REkxRVhkOUhkMTgza3lscEcrOWxxMXYxYThQMmRudzhUU0NyVkFDTjkyRG1GMGszQkZLSXRVa1Vpd3hwSUp1ZDN5UjQvQmNTZmNQRE0wVC9RdGNoTEhzaXVUL0Z2cVlKbE1xdkhHY2p2MmJQODBsYjZ5OHI5T1I3TFVyWUhwZXJ5WWxXVElwUW1VSEpqcHhjbTJQR3lrcUI3Vm54TFJJL0tNcXlGV1pOaWFjRWNUT1U4K1dHRVBudko5SGI5ZUpnOFdaODhkRTJwS1lkbTdOTU9yc0dDQjlOZGJpb0k1bkNDa285NnRFR1huQlFUcW45WmFFL2xiUDFsdkVyMkh5Z0VjYzF6SzBOWk0xc2ZvMm43bXR6QThMaFA3QnNzK1EydVdsNHl0ejJ2MFh6bW04VVo2V3hMSE1iMm9wUGNiNmMxRW1jdEVtZEpTREw5NmdSZmFmSVhyczIycHZKU0VmemlQRTBrVkxHcG40a05TSFVEM1N5bmRCTkt4c1RzVm0wUDFnZW44ZnlvNktzWi9OSFYzUDhpZXpxYTMwNEtTUmllUkxES0pHY0tveGk4QXJCdDRtOFVIc1RZYk1KNWdFek41eTlZRUg3WnBVSllYTHFJTGdJTi9ISWViNW53RDNjREEzTVhkcDE3N0xmMzh4eUNYMFRPZjRqUm04RGhORmxnb09Ka2krZGRwNnZMZzZtbTF4dm43M2RMVUJHTEI4cmFBZFlsNFY0MStsV0FEMHl5dzE4UnlOdjFWWXV4ZjlQODBNUE5aWCtQRlhqMXE5R0h0eC93WlE4ZklYNStiOXdkSVh4WDdJTHp6U25PZktha1hqYTRiWldIVnFwWnVSWk9NbU16b1gvMFZBczdzejNPcTNWWGxzZWJHNGpadC84cXV2RUtEMjdORlJlRXpock45ampQZ2JFSnZiR0laUStHQnF5Y0pWOUF6R1ZvOWRkSVA1QUtjbTJCTGs2VUNtOTdrTlU5eWhxVDBDTWdOUExnVWN4TWtEV0MralZPSzZCSHNlbkt3VytRcU4rWjRGZE9USzBucmVsbzQxWjBSZENiU2JRMkRwdGpONjZMa1ZZNHpwaHZsaHl6TlVpUUJGSW1KRFdPSGFTcVFqcUdobyttcWVyUVVMbloxNGtwakc1alh2WXpteVNkNGNFbDVBTXBYVWhRcVk2SXh5SHFENkdPbzVJZkJaZGw0dmlEMEROdXljUG9PanlTaDc4dkwrMHc2SDVQQm8xQ1YrRFFublpXTjdTWnRaQ200NFVNNWxWV2VGRExMajFTbklpY0JEUXdJMmdCVnVXc3lDRG1SMmRrQ01jdjlHd3lqTVg4RllTWk1OelFRbkRFMGg2R0ZrcFJkclhMVDRYTWQ2eEkvdXdCYUI5QXNjU3VrU01WT3NmY1E1QjR0alA0ZDJMeWxpQzlUOGRiM3JXeU54MDY0OEZWYUdEaGYrUEw1RmFPMEJkWnNZZ0krc3VCZHBKK00rVWt2dXZVeGVERHBmMzY5OFp2Wk5JYzBmNG41Q0V5MTZPNFRLWDRUZW02NjhpcDFNYUZGM1VIaVdRN2ZUeUdvc0YrNXljMVg2cVlpRHM3U21RU0lnSHhEWFlyNVhNRXZxdkEyWUU4NGlGNlNIdzdVazFGd2tNOTJ5eExpS0ZRNFdhS05rTDg2eFhORkZBTzJCMkg2UWpOOWRZRUxzNWQrNmNLellmNTJHZHppeUtXaUI0QldBMHR6RUw0WGZIWEp0VWhlZnpXWkZvd0VTZTJESUxlWGJCSUpaNFMvb1ZpeVNIZlVzem9tNlg4Q3dpNnBmS2ZXZHQxWEY3SzJwZ3BzM3YrRlgzN1QrNWR5UEw1ZXVmTU9tcitXWjBmUkpHTGpRQzBCQ0hMb0diY0xTaHlGNm8wbmtzZnd3NGhkeXhHakowK1BYUG1CL21zTzg3YXlxWTQvc1dxVDRuVGpXRGUyaE9pQVhnYk9qMWl1Z2QzM3NidmthVUdRVFIzQ1dLQ3dTeUxNS2JwK3VLTDJnc2tvblM4WW5WeThNTldxTG44Nmc4Tks4b2QxWVZYVG5pb2R6TUgzWFppb01KNm5qVnpPL1VxTVMwQk5yUjExMUcrYTM0bE10ZXYxU3NadTRnbU9LMStnUk9iNUZZQjFtRmtSYVlEOEd5aG4wV2NVcGxPZTF6anJpOUVDODRGY3NUZytCODNMemtPai9PZjNwWGUvZDdrMVY4S3hiNXhTVS9ES0NIdFYvbVFKTHQ4SWVWdXpQNk91UllBdjhDWVp0RU5UeUpVNU9DTEpIVTZVeCtnZ0swcGZaRmJuTEppbEE5TjBDaktPd2NaRVdVdWpQU3plUU8rR21jdGw2YjBveWhPVDJQOWNWVXNBbXFDV2dZZDk3emh3ZnZ4UUxtYmQ5bUw1ZkkzbHJ5U0Z0aExXZ0I0b2lnVmZFdGlSMkU5ZVp6S2o4U2RmUkdvOVc2eEdZODBjTjVMVk9ic29LQlBKaXBod0w1THJZK3pLaFBRZGVBZDNrblNkUzJiTTNBUkhPbFIwOFNncXlKMjAyTmNtQTlNc3BiSWl6aVNrai9COUJISjNrcWhvK1Rwb3pTWnBwMUhJSjlFR3lSRWNFc1phT2lYUS9pWkY3ekNtOFVwVlp4MlJFdkRPRS8veExIaGxLOFo3VXFwRDc2OXd3MGtLR01yZmFyV1V2Z1lNRFlteURpRVJCdWMzR09xZlMvTmFkQnRweXR3L0lwSWZ4dUVDQ1FOVS9sR2cvcDZJY3U1NHd1d3ZhbzFMZVcvcUg5Vk5lVDE2N3lQcHN5bnYwZkRXUXpNU0VCYkpySUh5TlZIR2RLWklyQVBxWjlPc3BmODhtLzRrS3k4b3VEOWt4RVRiaVV4dDBZN2xOVXpiVGJLL2swMTFwc2tjdE1Ga1JoWmY4TnhvVGtnL2duMFdiMnZyMi83ejdlcmVmbGVIYVBwT1Bya2FxNnB6dG84eWFqRlA0My94dHB4UFNGbG5LMmV5dEl3Q0prS2IrRHFuTjhSWW9sb0tjbkY0aU5YNWRneDZwREdYODJHMGIrZmFQOEJtRWtFYjVoenU3OEFnRnNxTmxGektGME8wL0ZqWlJzQXhCSDNDY3hJWldIQzdKaFlXdldsTEhTUms1eGVSNStQVUd4NWZ5UjJWbmZjbVdlWFNWWklFVlRLVGE5TFJpbmtacHo4TXRPY0pJSG5Vc01tL2ppd3RKYjJNMUM0R1Z5am9hUnk1eExoTmM1dElHcERMUGxlK1p1ZmJjcWloSlQxdWFXb2NzMVUxcFNFeUlGeHJ5KzAzU1lZQ2VLeE5OcXN6Q1VubmpKeW5LN05RU3NBekRBeHEzSDR3THZmeTUwRXFId1JTWFcyL0xUampmWXlVaDFLNUJpWU5rTG1sTE96cFgyZWRjVVpKNmdFTDRSS0dFd2hPRXJ6d0p0RTk5cEJEY2pNc3VmSnBKTndXdXhzbGRleUFnazJxUDhScjN5bi9jdHorWldQNXhzcHNuQyt4S2Z3TmdhSXJMOFZXOXBETmw2RTNJaHlrT1JmcE1UaDJ4UThXL1BaOUZIdDg3WlgxM2Fjc0JXQUhLb2RaeFZkQlBsQ3B4dGNMSUhoYkhzZHd0ZWtjdHVFNFlRcFIyNmFnREJkbUpQTTZMWXpUQXhPUDFtSGxxc2llZzdLSEQvZURlWmNJcEd6RGVVL0pHVUxrVmd2OUkrL094YnowMnVGWk1pL284ZjNjQUlSdkN4ei95Z2dWc2huNGo1SDJ1aGg4Ny90ZTNRWW5BSlBkd3RZclEvNnF2NytoU0dXeWRUTzFackFkd1puS3BKTGt6dG5PSEd6Tis1L3pXc2VhMmxaQktkRDVrU1J6a0puRVBHR3ZSODVCMjd5WmxUVWRqZGJnZkkzTnJOVGZFK1UybjMrZU5XejR3emlmR01tTGlNOWVpUTg4RXVsb1lzS2JQbVdudEhmRkdHMm1IS1p0Rjc3ekNTSnY1cCtmdTBlTE92MlRpdkx4RE10QnZWZHNQOUdWbDhuMUFNK1hRTTlVbFR1WmJra1FLUkhTOXpEMVFYOHBXQTdKd3UzNWVLeVRrWnlQc2ZsVUpCYjQ1Z2pkdjVZMlowcG5KdklVM01yUjhBVjRlQzRYcHFDV2hXMEZLQVRWS3VnaUJ5U0Y1MzA0RzhGeWpxVWRFblY0L3hmS0FtZU9qWlN4bThocUYwYk5yQ29aVUFNNElzZ2Z4NDAvdzFWMWNuQXVqY3NFVmUyN1ZSeHNrek0xZWFjNGEzRHRIQ1lUcWpMZlRoSzVFTFA5eGl3WVVKbmpDWks0eWxpV0xRMGtHb01uUHpPZFRGcGRZMXFibldjUXVKZHpWc01ZaHRxRk5XRzQyVXl2ak9FWEsrRDgxRit1MlUyY2tSVzAwaXRpaiswNlZ2V2pkSFBNdnZ2UTVDNnEyUHhVaVJiMnlmSW8vTzdyZUJnWVY0dHFKOGVqQU8xYm91cUtaajc1UnBHM1crbmdVZlFDY1d2TlZoWmdOeUNWVmRDYklTNkJPMm1oTCtnMHdMY2JTVkpxVHRMaDhCVzd2bWVyeTJwSGtSbzJOSDlJc3QraE44TjBSRUZtU1R2UHBpUVk0S2dzZENTMUgyTndrRloxNjV1cjBNcHhVYUhXanJKTzhQNmNoaDFwcFozTUJUNWN3TzljeEhYSk94b0ZLNHY1ZDdEemp6VFVLR3FXWUtjOW5IUEJsYm56aUdvUENmOFlvUHdEWGp5V1J3WHU5cEt5amJaZWVMRVRoK0h3K0wzRjNGMjVvdkhENDJSeGorbnU2S1ZTNmQ3bXhXMGFPSkxQcE95cHBuYjUrYTRVdjYzVUZiRm1TTk1KZnVtcjdvRldvTFJXNGUzbGVIRWlteTNRZGJrTDBwUkl0U1BRN2l2WGVIamxDbjE1RDlNa3piZE5SaUFzTVU3QkdaWElrL1I2ckZkT3d0RmR2VjhKR3A0eDFka2hZWXUxd0p3alRHWE1ZTzBDN1Q2UG9TeExPdVhYN01ubGJMZXZiaGMxdE03REVDcVdtR1F3dSswREFISkRRejhrVVpjZVBReDNkc3pNN1RuRjZ1V1plR3RpRmhHT3Z4OWJ5c1J1eU5Fek1EdEp2NW5JRHliS1JoRlZjdUhMSExELy9YaHpMbDhlNlJlUDB2aHpRSTcrMk90TmxELzRiaUVjc21NWmI4YVIvck1VR2JKR0VGb0J1NUJPYXJHbUthZ0FvQ25pbVREckNWWlRxa014NEdJRWpDNXlBZ3BIWXBHemx3YTREOWhxRVg1K09RZFhTdm9NUDkrT0xJM2ZGRWF3RTFka1Rja1gydy9ENDhWWVJmQnZ5RFNGZWZmZm9VRWhBZXRoMmt0enA0VnltbjQyMUs4aG9YQVJyUXRJK09pcHVUU2dpVWZ0SlVtWWFKUVRaeE0xSElLTmk0Qk5BOGpJYXRQQUdlaldzT2FDd1k0U1JYZ3dZZHVQczBLRlozMHE1NldDWUxXYnFjS2tnUkNEYjJQakx4MUM0OUt5T3R5UytvWGcxcit4OHNxUUR3M3VKcElNakp3K2VBODJOWFJIZFFjSFZwaXlTUVJpd2plZk0yc1ovN3pEa0lidkxmaHlKWDdZSk5NemRYTm1GTC8wMy94YUdtWmg4MjFWQVNEMTRNa3pwV1V2Tno0MVA2Q0FIN3J0dC9DRnFyb1duVHZhemMrQzlzMk1QMGFWZDEySFcyVWlrY0toZFVrQXI0amxMRGpCUkdDcE9MQU8zc3dyVTZydnBpS0hyQjdRcy9Rc3IwMWRkcS9GUndWOVlCZ1ZLelVUY3I2c0xGNFh1ZWRxSHdubkNpL0xZdGJncHp6U1VoRjJoUFlOdDFlMVV5ZjZhM29hOUl6SkE3YXgyanI0STJwL1U1MjV0SGR1cnBvQ0RkRlJNWXUvaytvdlUzcm9qY3RLMHdTMERsc2xoV1NqdEM5Vjg0bS9DVHlIaEhPWVBVbTFoRjVtOFlLTVN1dVVsWXdoeHd0OUZBMTV2TUlyTlR6QUtFdkI5Z3hkY3RFemhWZkcyNHNNSXpZWUtKYkNseDNZKy92SXhrcnhNTDh2SjFiSWJ5VjZ4bzJPamJ5MmppdFozb0VvWFJ5RG1kMlA1T1lGMlVta0x6cFI2RUh6R0laTHNoSXdib0xTVDBIUFY1Q0tpM2YwOUlhZk04SFZhdkJudmoxRnllMFRLQis3aUlPSnlxTlZYTFRvc3hMbUpiTjJ4TUQ1T0U5WjJyQnBtbmIrZFNKRnREN0lSZXVpYUZMOFA5UCtrOEViYWE2U0d6dzZsQWoyU1AydW95d1prL2ZoN0Q0cVo0M1M4K1RzTW5xdWc4S2lkRHNmSDJRVlB3UHV0REcvZ0FlWFVBS3lXV2ZEMVpUb1BCVmc5UkszSXkySlNkMFU3am9RS2NZOXVKR20rMUI5dlI0c0gyZHlBMHY1SmJydzA2SWp2NlU1bjgzVjF5ZmdxaU9ic2p4L0cxY053bXc0bVlKSlNzSUE1UkpwTTZaQktLVW42TjdSdUgva0h0SWdsckZWVkRORk1XaEFhcUVIcVRoaCtCQTQ3NFF5T2hUQnE5Qm9KM01KejN5cVVreTY1SXpqc2lsMlBPK0ZvcDcyK0llQ0NpQjk2YzlOcnJ6dlVwdW43VkNaVVVTWDJLVUxvaFF0ZjZOS0dIdDVjTlZ5eDZZNXhOeFlrc0cxSkYybnJNbXFpbTRDZ3VyU1JZdWVYdEtkdnJMMFFiL2Z5UGt1TVo0NXBveE90NHpJUXNzV09WRVZYdUxhWmdTclVtWkRONFU2bTZWck5lamt6Y3Y3NmdYa2FWVnN5U2taM2JVbktTS2V3QjFHaVhpK1JSK2NtZVZDZXViQVpxQ3NndlRsNzVnWnpVaVNvQ05GaXBWUW5jaVhjbFlQdnlncjhneWF4eUtLeUdnbHFRNjFCOFBrZktxYzZMUVJxNDJaMzZxWWVpc0dPdm5LVkZVTDRLZG1aNFJXVWJMMk52ZzZnVk9CUnFwaVdyektjU0k0QWFJcit5dFpmVHVNZjFxWFM0NjgwU0c3Y25wWVZwbyt0YTRSMVpDTFA4N0dneURNOEhIS3VDSUc1OFpDRjFUVDJabVFmRFV1S2FGV2tiKytyb01pdGZPUmVhWkdweUNLUlhZS0V3TzJGaFRGamhhZUtaTkh3QW9TczY3MHBaQ3ZFWUhwV0tIemhKb0oycVo0OTZrU1c0amJmSkJKSHJoaDJURGJHZEdZZ2ZZLzVUTkxxbE93bUU4T3E4cWhtZFN1b0IvL25Fd2wvdTNueStzNks4ZW9uZGU4TFcwS1k1Ymx3NXgwWG5VMUNCZU9kQTBKV1dMV1hUcDBqRWNDWkxLTWFHeFlpYmFIR2YwMEppN0VsZzFrR3pDQ2l4N0tmcExBN3RSQnFOZEFiaDFjM1JEWm14NGQ2RGQrcHUwZjk3OHNGYTVJMURYUlNVNnJmT2h6QnAwQXh5L2tPLzlDRk1hOWx4SGdkOG9Xd09rQ2RJbDJ4UGpXTldYVG9MOUJyTzZnZWhkNkZSaFVVWUdseE1WVHdTeE9KMVJKWXBUM29UTmlkaVRIWlRuVXdIWWt0VnpleTRwYkhZUjljQzVMMG1ZOHV1TkNFQlRuY3ZoYmpZZkNmUTQxbWM1TVBOdVdWMUkxdjB0bS9lRFZtcWtVZ0RyR2U2OE50TWdxVjBYTW1EZkExYWNNTFpCcGhCcnJYTXFCVTAyeGZBaEhnUCtTenE0YnBpOE5iMFJ2anRESDViU1dWL3I1MUJvUlphckp2bE1DSUpiWkRNUEZaZVVScEFDU2pUb2RHbWsyeTY2SExQaEk2cmZ4RUlIM0Z3UFRUcDdZdURnaWtpTWdBTVlVekdLcGZxa2FOajg3QlVzYWdoZ3U1UGc1UXYwV05oR0tSZXh6SURjQUp0ZitJWnppOXdySkdDc1hxN1NNVmVrZHJiVm8rTnZncXFIQ0NmN05Ibjgza0RldDVMZHJlS2VQS3pwN1lpdXRUVHBLeE8yUXdFRFNFR293MFY3SUdMZk1maFU0SVNzSmtsMWwvclcwWWpFVzRvTkx0ajZHU1FiM1l4cll1RFlUMDR3OE5wUDNkZ04zcXI4YUJVdlg4QnJoTDZFWUFmWng3RWNEOUZSaTYxQldpK2o0UEZFdGtyNUdIZFZBZmFOSjBQb0xBdDU0ZkJTMkM1cXpBK1VGNmdOY28zSlVVb2M1VUJrRDVXR1lkT2hsSXFpTVZ4TlNjbUdHc2ZOekhzenBrZ005U0xwVmxydVE1UVJwNS9FNTFHWUtYRDFFUVlvcVBhZ1lzSGZNSEllKys5TFBPY0ZmdGxDT3Eyb2RkNjVGeW0wL1h3V0d6WHBkeGQ0bDlOUFl0T1ZteFBSTCt0MHg2cXBXb2N6VWdNUUlSaU9vVUhuZTRkZm5MSkVRVUxGOGxaK3VDNk9laEF1Sm4rVndLUzRGeGp0dVJLYU1ORGNWMjhYelEyQUtxbytWNUYwZlZCeERZaHNQYStsdm80dUVXUXBOTjZIWFJIV2l6dCtUZTVnTVNvR0I0ZnFwTWZHQUo0T1N4dVUvbmxjaTVVU0IrRlByMmh3UEQ0TFArc2pNeU1BQ0V4VXQzT0c1bEtvSHNKT0EwOHZrZzQzMDZsQWFId29vUXdkQmptRHVYN3E5bko1bUthNUs1Q3l4cW5vcjhhNU41UUxseDB2eTJXcXljYW5rZngxZjVLVU5GOGwzd1d3bG0xNFBwQm1JeHFEOXduZ3dEbWYzNmErdHNLQkNRMERqSFNnMFFKOUJNQWJMWjU0N1lhYzVIYXdyM25iSUhzSjhPM3I4TE4wbVVqc25KUjltb0FRbXVYaHJRQWI1K0hLbUxTdnBEc2VqQVhOU0VKcUd2NkZ4alR0S1RHZml3VkVlT2VCb3dLNkxsTVJzZDEzdkFmU2VrbVpKL0QvWVlqR1V0RVBEQnZ6NkMvNHdZVTZPVnlXSlgyZTdaN3h5bStrUmJPTzBZYVpyTStsekxTVUJXU3ZUbGlLVG1VS1NEU2MvTUNRRkRZR2tEOEhwYjVWQ3QxRE9FWE1ZNjV2a0JWSzFsQjZtYUR5VjdzV3dVUXIvY2l4akltMS9oMDZUV0NhNGpJV2M4Ry8yODZTTTM0TEpvUXhoQXdkclNtNElOODdpeXcxTmMwVzh5RWQ5cGJ5V3VKZ2FBMFY3RStXZWoxYW42Y3RyUlNienpJWXltRW1UdHdtSHNXV0QyWWFjY3dLRFlHbUFuUXdZNHZENjFEQXpQRmhYbEwzWXpSUDlBdW8vY2k5UXZCemp0K2JvNEREWks2ak9CYkQ2NUVkOXJ6VUZuOTNWYTNXMG5PT1RxVkFOQVJ2cXF4eS9ZL09pcTB3M1FCTXoyRFVJeEtrcWRndnh0VWh1UHBGa21LSWVGRFhncXpCNVYxU25paUpKVVJMTnJFQ1g4ZFZYMXNzNDdCMzZDL2NNL3pheU1uRit5bjRKVVlvNFdReDRaUzVUTkp2UkgzNW5VUmYySTVBdTRkWTgvcjJSQVB0SnkyYnFXZDVJSVdpcG9xOUdCblFrdXVKTGQ4THBZU1g3NWs2TS82cnlYNVM2WUpiRFFaazJzaWx6WmUweVVSa1kzRkx0cTlHRkRXSVoyRFU0eUVYcmRkN0gwcVZKZis4ckRoUHhRbVh5SGZtdG5wYzVIbjU2TnA1bnROdFZBQXdJUnFCbkN4ekNUUy85WkJxME5iNmM2RmdDNzA2R0QrZld1QnYrb0pqNjZ6YjhYZU5aRFhxTC9HYUZUMy9naFFTbUF1YWVLSmtxaGk3dVFEV3llU09FUXdYb3IyQkdoeXdycWxkRWR4R2VVZ0QzMWVxZjgrVnZRcW1YSHFvNDNTRDJBRmd4akQzd2VsbFZNQ3FONE1ycnhFM3djcHBjN0dqZjhObUdxWWxISUZlRUtnVnlIV0lmUFpyNXRiRmFuNHFwamFHQjB3Nm5MamdLeE9wR3VxRTRqd3RvbG9jRkxJOERzWG1PdFFpSE9VbFcwQ2xPVnhoZU9aOE92NUdmdDRaVXIxb0dHZm42K3NEZTdJUm5HUTFzb01rdGIxYWlQMXltc1dwTU84Zzc5LzBCYlFBWjkyTEp3SzJBWnl4U2NkUHpGdkErQzhoWWgycVppQW1vSE1CWWt4SkYxUDZJN0Fad1ZuRWFUTHBHUk1zazh6WTBSdi8vZ3VBcnh0THNRQXp6U2YvNTgzOXpxbHQxSzhmTzNkUGRFem5rY0VrdXRkcGRhU0VJa21GNTllUW4rMlVCQXdKc1dJOEcvR1kvNmNtQURSbGVZQUhMMUZLN1MzTEo0UXduZFpqdXJ1N3FDbDI1NnVaOC81ek9PZjQrU2ppSXFsSkpJdXAybUV5a2hDVGhIZ09yUlB3d0J3VHVkZ0kzeUVnQXRQTW9jOGczV0NwdFNIM0YzMmhRMGhJVGcwLzdXbkdDSUphN2x0Uzc1MUlHcklHdW5TanRFOUYramg0NjJQRmpFaVh0WHdoNWg2eEc5RzBsc29ja1Y1SEFmVEF6R0drVFdrcjlVM1Y1bmtWam9KVVZQUWJIVUE3ZUE2ekhzaGd2U1F6OENMc1ZYM0pvNU5GQ053cGw2V2t4ay9QRi9jTmNta1g5Q3FjV1Y3clNSaWQ4cTBpK2xvQUdpME5zNVdJTE1McUoxU0htWitMaWx4QVpkRjJEelJYUTk4UXRUODdQcGZzcW5CYUQrUk9qdGdjdU10SkRFcTNlVnY3YUQ1UFhpZGMwR1V0TEdZaXFZamFmZEtvMjdla2JETS9VQUg1bzErOFlUNFo0b1d0dWpxS0RkZTFDaUpKTVpRRjdINnZ5UXNodERmODNmL0x2czJleC8yTFdkOEZoRHRkWDRBcUwzbkRVbW9Uck9XbXB4ZlpUNGczNVF3bURWblI0RWFZT21Mc0ozTG9ZWldGK1JMT0wzRnNPTFNqYjEzSzZMd3AxcEttOHR3eUdDNURkOWtXZ3A4ZEV2SWtMSGludUpISmVPbGdMMlpuQmdGdzhvNnZING1BQ1czcjgwSkhXUVBCbXlrYVBVWGxaU1d0Q1RWRFBGMFREOTQ2akN4ZjczOFRyR0w1bzBiUUVWZ0IzVkhSdjBldmNwZWVyRUNkbzhRektDdXhBUlBybzNiZCs1WW91cGtoOW4zZW9iRCt5RjA4a3JZSjN6NzFrSFQ3dVFYT1FER1g1ZUlITFdieDZMYmNkTUlpZ3djamFTQlQyNHVHcjhjQU5POHZxWEFOa2RnVitHYzFtNG5xQm1BTFZoeklLeEtpRzBqemN1T0VPSHdkdmFtblp6SytleEtLVmtxdGd4STJMUGdwOFdlNUloWkNFVTFrTmlMRTJzVk90UXBEUjRXYzVMQ2x3RHNCOUk4VlQyZ0JpVEREK05QcnZKakh5dHpLNW4rR3VETFErS1Qzem5hY2hlK00xRCtBZFQ4U0tkb2FUUnhrK1c1VVpvTFJDWHAzeU5abHNIb011d3J1WC9NeFJIMDJoV3FBTE0wQ2VUb2RmVDZTOTVEVUY2SjMrVVZzNDcrSWg1V1JCOWx3bHI2WGRLZFVrdFBXVmg5cnBFVkM2LzhUQnErRm4rVml5MGJjTVNqYXlLV2k0MklTOEhTRkg4TnRKTXUyQVV5MnRyOG5EbXBBMXNkVlBwMVBTS2tuR0dNZlZGRDBsalUzUXV1UTVGYTEwN1dOSkd1TzA0QkpteW1rSGpzNXg5WnJWRnRrckUzQWJiRnh5T1FNdThuU1dDakZCcVE4VFdkUUZydmZUd1FCbEMySitTOTFmVnp0amIxTlM2bWwwVnRYaldHUjZ3cjJJK1hrWUV4d1dZTjVEbE5MVGk1eUh5SDFBVFEzWmRSWEw5TEFLVnNlZzhDYmE3OW1mN2RuMnRmamRSWlFHNVkwei9QN0w5ckFMZm9VOHJ5SHVONFNYU0lrTDBEczRhQ05TL1VzTGFlekwrZkhKVkZwRm1nN0YrTCtTcWpKT0R2UFRwMzVMbDhNQk53RWFqTkRWSXpiL2cxUjZJWWRIL3RrcFhzWThVell1UUZxWnF0Tk53U2pqL3pTSUpoWXZxcWluUkFPM3VzZm5zLzZ2dDFVandkWkpFamZkb0tZT2pKQytwOUdQaVoyRGtETGMwdkxmQW9tNnJvbnBRemkraW5jdUNDWHBLQ2RsWTBGOW9JT0lMK3FESmVmSWxLSENOMTlKWFplNktxeU1vWHFaT0JORkxVSTY3OG1lbmlQc09wdWhaanAzaVpzVXRJN1k2bU40TllYcFI3eVR3SWNqTFRxTHo3eDA3Z1BwbXFWNWh1a1VUdStIWGlKS0hUcEpzYjBOcSt0dXN4eUNybG8vTnFOM2dpM0Q2bEw0d2dXYlgrQU1Cd09LMnhuUjZkay9IU1B2dFhncmdwdXk1dk4wVUtmeXcwVFpZS1VyK1hwWnJHUzFqWFBjVnBNWlFtQ2RPcWRSYlk3bkpmczRVMWJPZW8rT3lmY2s2UmZqclllbUtXQTVRcmc0OXo4M0wvQjFCK3A5OVZPU2pDemsySFE5U2NaWjJMUFFLc0tqb2NBeVNsVjhlaFV2V3RLQ0ZKR0djVndsN0llUzlRUEh6YWllQzl3TG5CM2pCY1RZWEhqU0dHbHpycFNWOUdXczFrRjNIbGhGUkcycFBDK2ZLMlJnc0txUTlZVVV6bm1EamhZZVFqT0M2Q2RvZURzdVZoT3NxQUJJbG9GWkNLd0V1QjRQZEJXcHFOMWgwdmU4dW9jMGlweHRWSkNFN2FOWmlmVG40NjA4VjQvSkNZVEY3ZWhxeHluVTRtVUZueGpjd05MamEvOXNYN1F1c1JQUjBoS2JLNFBla256ZUJ4VWQxWVR3UnZCNlArRm40SzRFM0ZVNGRaRjhyUVRQckl5dldSb2tHUGRVMGd4UXRaNVVIam1qaDBCYWx1c3ZnSC9teXlsVk5IeFZWWXhPeklyeVhpSE5wblNqbDB4UFlLZkdhenVKZVovaEQzbi9IZ29xN09hcE5BdXg5U25HUDRtZWIwSUZGZFNLNmk2aFJaZm9TTXg4U0ZRT1Z5emtNYmxMZ3ZoTVJnbWF6dGlGb1cyTHBGYW1wd09nTlhBcWdiYzUzNGdrZjRhN2RWU2E3NkpZYVVKK2QwOVBDSDZKR054RWdjcDNZMVhkMWNoM1dVSGdScGt4ZzUyWm9qS2xGY2k5SGU2dDIwNE1GN29hZUNhK1BBZC9HaXFmbU83dkFzMytrWGpGNFVKQTg2L2w4d0RjOUVDMTZmeVdVVnFqeTNjeHpyTHVFSkV5VklvYVk2Z1loZWhMOGIyS3lzc3llalJSeG5MalFGek5GQVBDMHlsOU4yWWYxZUZhNmh3TUMyT2NvbW5pbDJXSEowVkdjNGlwS2RBMFVYemk5U0hjaDd6OE1FTVVTVTVnYUlsM0UxUlBZWEVRSFlXazBCY3FCS002MnVvbU5pTjdlMkRqVnFhb0lBZkM3Vko0blJoSEd0cDZLQ1YxbS94Y0tqcHN0QzkxVHhKaldWbitOSGdhc3VkOSttK3ovaGVTQlE3cG81R3dTNmdFMk5PcTJnZkpaM2NjYTdOMU1URzhBZWkrbGVibUU3S0ZTUFpmQk82cDdqMEpXWjQxYy9JOGlja3FpWHgwb3FHMmthN2NTMkk5RlJPNTBWZHFiZWlPMmN0cjhDK0wrWi92Ujc4NjhiNkRpZjZqV3JvWVN4UnZQay9TVWZKRW9yNGtLanE5dmhTa0tza2xhV3VTaGlFK1NLRTF5L3BHOHBNcEdCQndDZGlvb1NtNVVBK2xpOSs1cXMyWnBsUnk0Y01CdklEWWpJRzFKaDlsZzB5T3JwMkQrVDYveEtnb1FKZ1Z4NWZvZGpDYkRPbnh1YzErRDdaN016TVhmRnVxKzh2U3psdkZFNmwwbFpYVnNENEdpUXV6Q3luYlRucnA3R2RueXZrdldDMUpsU1VKM1RhekVqeG0vbnBHRkJQU2l1TlRSOTRjcGlVY1I2TzBwQktYaWI0R0JlRW1TeVdHUjdINzhxUjBrL0ljNWZoV3V2QUpQanpCbDMxSWp6UjBDN09Yb0Q1T1RreHhubUNWNEhsYkdVYko2WFYrbTdCK255R2ZWUWx3QXZINmY0K1VyRnBQYWdHRThqVGM0YUtXQzN0Zmg4T01US3ovRFRnYkVOMG5oZzZra1VnSmRCeGt0ZGtjaUR0QWVuSVQvUE5yWlJpUXcvMVowUTFhcXRLcWh4TlJXcTd4UXFIdUxBT2pKVWdYdXgxdXB1Rlk0R3NwS3EzcUlnZlNBRkVKNENIRVNPU2RLRERvWU1EcURqVlF3QkFrQnZFRE9OWXBLL0ZNVHA1S3ljYVZNRHZCUlFmMEZ3Myt4MW93WjZNMlZwdWtBTjFwUlhjN2tUeEd2b2ZqZTdSVUQ2KzRGYjFRbDZkSVdjcnlWYmN2UUdFOXpmUkV3ZGFtcitQcHFsTEtzbVlCN3dkNVp6L1dkYVB1QnU3SGVsY1RTaVV1WkR3T1NCeUUvR3MxUCtHWGxJMFdlYTBPZklhMU1XcE14YTh5UU1vQnpXVGVnelJEV1Q2UWxnNmdiNk8yUVc2TVV6eFRDZ21jZXN4T1krVUxxbFJ3NDdiNG52QnV6L25oZC9SSUFhSEtZSmtVVGdOVHc3dGQrTVVPL2xOQ2JzTEMzdzBITjBSK013NWVWeTE0NWdkMkxPd3dQdzNJNUwrV3B3WGJvZ2s2eWpnenVON3g0NUNlRkdUaWs1Q2w1Zi9Ia1VUTUZJT1ZaT05ucXFOZ3BZV0lCay92a054OFZ4d1hMcTZoUDQ2WEtrYWR1dU5xcVluN1pWM2lBa2VDM3o4aTA2TzBhWkZHQVh2TFNUcUZEUmRFQVdhKzJPYlNyaC9jNmhOem0weGphREd5UHhaYmQ0enRqNEx6UkhwMUdhejJ6VGxWSkFDNE9WTG5vVjZWVWtBOXlKS0VhYnVpVUtMOWo2ZW96RDBwM2FleE5jT3BLOWRIOGkyWHBuRjRacXZ5ak85VWVTY2x2dUdYWENXWVl5TkZ3R3JrdmxGRFhXWXByR2JWN2FMbmpkSGZjZHZhQmV2bCtEczVTMi9HOHhrSEIxSms0M3dzSngxVkgySWFKKzJ4MklHcEhVdDlJRk5GeUdXd0pLTkpFWjRHOE1GODBFdFFaVmN4b1hyV2p3ZWJxUWtrSDBDeGdHSWQreCtpT1NNV2NjdzBrR25UMFlLNzNCTmV4amRtZEFNR1gxa21WRk9TNktuMHJjV09RaHJHK1NXRUVvWVJJQ2Vlc1NUclJCbzh5UFJ1a2FuQjFhb3JycWgxSW1NZkhvMmhHK3ZWSithak1MaXNLTjhOK1JDeEU3MDRTVWxqV0pUZTRXc0U2b0NvY3VKbHBYNGU1dzJZc2NFVjhET1VBQUtHU3lTUnhMMUk4V2JvWFpLc0JCSWZwM1VEakUzVVhBSVpQNncyRlhpV1NoeUFOWHdKNUVJMnpoRUFBNkhhSkhaRXl2RjRMSHhibXZQVlM0cXB6MWNzZEpxR2wyWHBzZVIwbDlUL0RPTE5aZVVIaVRNT0xQa2ExQ2I4MVp3eThkSTdKdTNQV0RGS1hRYjhwdE5aTjBPZGFDVWw1TkRyZ1ptY3BseGFYbEJ1SENqZjhlQThEUmJYTlN6Zyt6TkpMWUZ6U3NlRmRJbkVuaUJ2RGYrVzBFb1FqUzFmYnFtU3l1NVB1QjJBZ3hMU3VxSVFBZWZ6U2Z1RHpIZzlrVEloMmpmRkJWTmN4T2ZEeVpVNlhJb0xnaW01Q0xoaUpyalFQTUtmcTdVVTJOdXFPUlo5RmFxZjZWYk42UkNVY3dpVmtoME9wU0E1aVlSNXFmc1J2TXRaS1RiSExWOTY3U0dKN043T2NSZENBK252a3ZRbTZoSjByeVBIcW5qaHpwYnoyV1YvL0k3VW5wdTJzcWJJTGxwMHRNMlhyVm1mbjNsU3JwSTlXSmFUTlhhdlNRekNMaUg4dk1xeXIvRGRyZ1dLWU90aGxIZnA4M2JjT29rTEh5cEtKYjU3cWluWGdEK2RPTXZtY00wRWpTUnFwZzdDRTUzcGRaanhBQVFBbEJLN3daamhGTVpxb2dRRHd2TmtsdWxMZC84QWRtZnBrZXI4T1NaRDA0eW1MT2FRRy9TS1NvdFozaENHclNaYURuWkx2Q2U3ZjlRam0rWG8xVFZVQXhSZWd0NHRudHRPSEkvTUhRb2FrMTFNOHZOcG8ydFJUVXhHSU9NWmlwMTJFN3BXaUZSRS9sTjE5dGd1MWhHWU1Lcy9nNitlb2pVamM4ZE1nanNpR2FHaUxNV0hQT09CeXl1cE5VOXUrTGFCOUl2emtGaUxQSy9GSFoxbnJsVERCWWNPdlNWclMzbnVLcXgrcGcwOTlQVkpXS3Nxall2RXZrc3kxUlF1UUF5MFpZc2tMZS93ZklZS3l1SUhzcDhIVnhmUWkwRjFVeEFCMXA0WjVkM0J1NEM5cmM5SURCU2JRaUVhVjRuaU9OOUw5VmVQd2o5WHRHVW4vZnZ2QTByVXluRDJHNHhOemFpVThHQWdXZ05lSFd1NXV5NzhHUEZMb3MxdzlBdHRlZXhNaU54ZU4vdzEwUWRLNllLcVU1cDFZaTlod3kxRjFUbFdPZmdOeWNyaTBzZ0JqYXVYM0djb3AzRTRMMUdEcFRMeG93UmxpRHdGM3AvVGNzaHpSZkg2VytGT2tKd3lWaFNIODNvR2dLeHQyV3A2ZVNPcDMwSmdRRjhmcHNZNWZzQ2hNMFVVczFrVERETmlUa0kzWHNkZlMyS0NnaDhYckJraE5CSkpBUTdybUFCQUYxS1ZKdTJmUktVajA1K21FYU41RXA4TjFmbCtzdStCaTR5dmQ3aWhHN3V4UDMxTU1waVROWU5jL1BXMG0xTk5TZHJNK3NPejVNQ05SbTU4WERkTHVub1gyeGNGRTc4SFMzcXFZSEo2SkhoZTJsNzBuLzhVVGZPQmhVUnZFallpK2Y3ZkJXODkwaE9pcDBLckNHc3VMUDBZa1l1Y3ZCeEhaaFNFU2ZuYkZGMG5NNVdFZjJsTjN1dHRoMmk1RHpyL0lWdnFSWUhySG4xU20yNU1NejJFSjZKeDVjUU9lTnBLRnU1bE5xdmljNUhRNTVHY3NIQmVuZDRoNmRhd01EYW1DUkp0b1JaRmRFS1NoUGViOFgwa21TMlVnUFFwdEVZWnNBa1J2UWYzSS9KVDI2dk55TW43ZkE1RkJnVGpjOW00RjUxbmtwQ0FXd09ZVzRiamNwQ1RZQ0pIZHBkcU1kVGIwTEh3NEN1cE1jOURBcSsyMDhvNVBYb3VHT0EvdXU5K3Q2bUZORmwrQ3FjTjJsY2kzZ0JMSGU4bHkxeVh1RFF2ZWxxd1BUWnBod3hQVWRsUzYwT25Qc1hIWUZ6S1puSXlreVZHVXlJTVFUN2dCU1VWSjZqWlVhRWhxanNlVWRjelhoVVlnc3pxSEs3Smp5TkxQNGphVnFRUVVyZ1p0U2V5WXlmM2htYTRFNUdiSUdKd2VLbk04Z2xzRzluMXdhcVEzY1MzZHVUVkNmNS8xVmlqaEwraUJUY3NaZUhSaDJtbk9xMk85WjFPR1ZsY3IxSzdRUDQycWI1OU8vM2txakQzZGhUZXhibFMvcklTVU1scEpQaU9CMDk5Z1grcTV6Um1YQ3F0QStGK3p6N2lrTS9SczNtWTNQU0t1MWo1US9acWF0OWV5YVVONE5lalVzUGZFTXIrYTV6ZkRiVHI0VGVHcFdKdHFJcVpDVDdXVWpQUE95U1ZnL0FjcFFzZGZUVnJOVlZKWm1uOTkwWkk0WGd1elc0NkhaQUdUV3RuVDIwTmt1dzBhV3pMMzQvZ09KOHNYeFBGRlZaTThtNlVLT2k4Z2MrUVlmaEk2a21XTjc3Y3BwM3A5Q2ZYODhubDlCd242Z1BVdE9YYU1kSTllT29tN3hXSWNSRzZGbTNFVEFieTNzVC93Wm9HYmpDN2owQUNKcGQ2WkVpTER1Z1BoWGZsMy94YlFLSS85Y1M1V2ovbnMxTTZ1Y0Z1eWZib0pwNjlEa25KOEE3Vm5KQ1NRZHd1QWt1WHBXTEtaZTdjQ0hpRVFpQmFieXFGSnJrYk1NT2FuanpFMDVsVEMvTzFJVGV1cHRmZkpVKytnMkFuODM3ZFhENEpHQWZUT2ZWNDBmZW4vT1BQY3cvbTdldDZ4bm5nRnptNjFOeWtyZTEwclBXMjJ3bjBaQTlKcTVEUjJQNGgwUUphY2Ztd0I5dlhZWnVRZjV1R3F4WDlhSkhZT2N3MDRaMVRYOGVyZTBKck1XVTg2N3kvY0dDNU53VWx4MGtpQXhsQXo1ZFpWc2tWMFd2WnZ4RkN4MUZVWDRSVEtkVGh3alI5NXNEeXI2eXlBWTNqT0svRWx3dVVMOUZJWTJrZTVvb1FBUlo0V0xPbHBDRG9ETW85MFQza0dUZHFWMmhVcHYwWllTSGZtS2FaVEZ3OG83Mi9DU2NJMUFBc1pPUVR6THVQeWNZU0N1WkNUd0ZiMStxdkw5bmVBRDZZMGd6Q2lVUm5MdEZpL2g0VXIvTUUyTFR1QkNUK0c3b3hTRWlHdngxSGxUUEZtZFBiSDRpSDg0cnA0Mk5xM0NtQWJ5cHFxeFVISFVrL3c4dUpTTGpNUjBtV0EyVnNYMWExbVVVcWtncStWOWZHWkxHYlJpSmhONnpvTHlUWHRhdXZTV1V2bkpYb3lWM09xdlltUjFjelpOWlJEMmpSRENYL3hmd0doUitjV0pHTTMxRi83czlJWXZtTlhZMzh4c21ha3JPSlJvdkpCeVJvd1d3WCtCLzE4K3E2YTFJcFNlTFpPY3djOFN1VXVBR2FYK0pKVWU0K3lIYXRXUzA3TGJzSk9jMjg2OFJEV1ZrSTREaUZnNm5Za3ZRVWljRWtMUmFKU29YYWlIU1gyd2tncW54VDUyR09FRGt4ajRHM3hFL2JxRlFBelRmQW1ZQ3RiR0QzcGQwNXNKeWg1UzArV3BPcUNsNXY0N0VtNUdkeEtXZTRDYmpZeU5wYnFEYldacGRza2ZpLzRmTHAzTGpPZEMwUXM3ZkdUQU0zUy81RzFyaGFDSHBINnZJTzAzK0RXUTFjbkFINlE3ajRndWZuSVd4VGNxMzRqZmNMK1VWdktpTURnSXRDNEE2VVRWazR4K2pzVG5nbkZKc0RoYjl6eHpCNld4SjNaR3BlMmpNaVpRR2RuMU9PRUlncUFsWVlHQUptb1lhYjdwWlZwY2FYcUZzYUdkVm1OQjU2UVZPcHZZYmZtdXljODF0bVJ0bm1yeGZRSXk4cVJ1RHJhNlRkVnE0WUdPayttcEw4UUo0dnVtZC9hbHpPUEN1S2kyM0tDNkcrN2hkajdNdGkwRFNEc2JUalpxdnRxZStuSW91YWVYT09nenlJanc3VnIyUHZ0dDNJYTZBZHdYcE56cHlsRGlGOHhsSUl0SFpvcEduUGlET1ZZbDBWelFoc0Izd1pxazRDd1RVR092VDdoS1pBLzBOOHRrcHV2R0JGTGc0WjE3R1VYWlRDYVRBL0VGcFRYSHVndXkwTERxaUMxK2JaNlVqN0xmWi9udFUyVnh5cFF2VEEvSjFwTkd2T1JnM1NsNkRYcDlUbFRnNWNFTDFSRGR0NlhHdEx5UzQ0WmVtWTBOazlWaStHL0NmQ25ER2xEUERkZi8zdjRSd1hZMFdvWU9ORWVqbkc2RVM2eTlPMEJmdEQ0bHhMSDNabXVZVHZOU2R0TlY1YUtkUS9qbCs4ajZYSCtPR1NmKzFacDZjakd1WE1CYlpRRXQ0YUh1bGdTQVYrSlc4N3dMbWhqWDh1ODQ4d01VeHppR3NoUW4zdkZTRVREajRyVDY1TXJXbVRPK3ZSTGdYUlVsRDZYaHUzeEsyUm4yZnNiVSt5ZVpKdFFpMm5ITGFvRmN2ckk4QlUxTG5KYWxsSmZvanNodG03Sjh3ODNXb0ZzeDU4ZXVFclFIbmM0dkY1aU50eGRCSmZBd3dLMGcwcnZLWjBMaEJ6Y3ZvNTlrZWplQTZaTjE2bDJsRjQranp1aG55MW1SbzI5MXZwb3N3NkVkcU5aM2NxUnJKQTNqd0lQODRCMUdEUGVacWQxK0tVTUozRVkxNnlVRWxPMVdyaWFOcFVjT2tWdUhnS3MyZXl2aVphRzE3QVJPRXk4K0JiVndMd09DWE9acUkzSlZXQ0IrZmdNek1rTnRoZGwzQ0Q4eGk1aHhSRWRMRXlhNjhscE9ZcVYwNncwQ1RtaXR5OFpJOTc4WUR5NTBOcGF4N2NlKzc4b2d3ZkZHVHJuNC9SK1h5Y2pwNEhhYVdSbWdFeFJ6SS9aZm9DVU9xYUkvT0ZVRFExT003R2QxekpENUZmUXVpZUQrT1V4MUNOY2VHajBlZ3g2YnBvcVpYMy9UZ2RwTkZNTVlkdzdTYi9nMDBwRVk4T0NqQUQ0by9ERXd1TEFDM0dxSE90UkNVVU1hZ3BRQUE0ellHZE1CN3NLY09DcUhyQXJ5WGVqQTNOSlBrc3lhQjRaNVk3L1NJNVhKSmhUdFlYMlBvTG5HS3c3Nlg1YlZrbFhIekliQUx3V0NwZFovaFJHaWNpcVNvb1M4czVsQlRBTUlNcUNldGtrRnRPdDN1RmtRR1VHTVFrbldnSzZjRnFUSW9yY1pyRlpOMU8zbHIrQ0l4ZXdqemgwWklZRlVPd25DbHpDU3dFSUlMaGtRYVBZaDBBK1k3VU1hVzJFdWVtZERGaDdjK1pDdEo4eHJGeC9wMC9McndwMzU0a2J5SndkczNxdENEeEFQL2xYLzBQTjk0cXZCMmZIYzVxaTdwWW92dHpvRVNsVWlVcEZNRTNGWkVzS3FWOHhOYjlJVUNlQjZxamJHWmZYanRKeGt5K1hFdlpocjErYnBJRDVsekFVdzUrMm5SS2YraitjdCsvYm1uRmxsSjZ4dnBmT002aHNYVXRGMnpsc0J4RERHNjFaYnFYN0RKVlVVZ3lSdlUybnJraUhiUGNQcndlYVVaRnFQUE9GQkZnTUFrUUpBTnpoRVFFNjhOd2VwcDY3NkpKR3c4Q1NiS0pBdkc5WVFJQzZhdVpaSzVoZFo3blNxd3N4R1NSSDFxY0ptU2Q4NnN4em1TRk5pWWpJRnRkV3Vna3hweFV3SEdycko2ZHpYQkRDUlpUODQ0VHJ0azRwdHNCZVBlVTdZWFI3YmRhbnVPdWk5TmI2ZGtaS2lYRWVxZnlJZnJ3ZXVwTXhJdDV3eXV5N0ZaS2kwa1dRN2lyREgrVjVLOTRRa20vTHRhcWdpc2diRkxVRkw2RmE0dXduNU5xVkJZWmZLaGdtT0RHUXhHVkpSbEs0eVB4YmtaSmU5ZTR3MFBsaHZSdXl2TTE4Q1BvN2NyMHRCZ1pCV0d0T1orY2xyOGVlOGJ6MHIybDBQK0RlS3RIN3h4M2J0dFVsc0JaQ1I3UG92ZStLeisyZTc4Mnl3ZFNsRTJwUDArMUR6VEZVcVl0c1lKandzVjVrZzBpY080VEJFQjhnajY0QWhhSzNzWEUzWUF6eEJka1ZOWlp6ME1MT1RTOWpGdW5mbW1mUk5sc1VnSm1DU3NBNWFmTTlqaHZoZllHZGY0TXVhVmdjNFFLQS9pZHc3S242TlJWeEFwZDNXR2k0dmQzTGZzTWdoRW5kNlhGV3NvZmU2ZGRsWWRjZjAydUVhNDJreHRTOG5aUmJ0YUVrY2czKzFGdndmQXYwa2tzU3FlNTBpdzVqYkhzQmFVTjNlK2hvSUJmcW1CRkJwc24wb3Nwand0d2tPZXFDaXFsOExtYU9hbU95eHJ4WFpSN1lheTV3U0JOUyt2U0lDOGQwRWxaVWMzZGREYUJaT1RNcWZpSlJOeVM5RjZWalNrWUs5d1E2ZlkxOFRwZ2lQbW5LUDFIQzExRkx1bS85Y3Yzb3ZZV1pIR3dkczB2anBXeEhINFVhNUNBbnArLzZjeitvSW9uT1crMWh1di9WRzVIbERXUldoZEhCU3d3cTNNbDd6S2x3a2V4RUtzQzJHRC9IdHZTM1dKaDVvSEN6TmZOQU41bTRva0wxWW1vNWZuQk1CbVhORnJDdVViNjNkU3BKZHFhR1IwczR0RG1EUkhuYy9JM0JBNTcya3JDV2tQbWpSbnpJVGZnekpTcWQ1V0U4djRRcmpxNjdhTitqOThkb212QUIzY1VhU21hRGFXNVg2alcyTG5ZTlBraUdRZmk2UHZvVnNPNDU4WnZGUG1vSUI2QmNHRFJKd2ttUzdFcUNicytMZGhJR053OXpNb01KVzJRVTFKdEhmZm1VSjRIM0ZOeEozMk9vbXhPLyt4RjU3dFkrVmJuSDI4VnEybmF5NXZUYWdUR2RQMzNlcmNUNFRRb1NKTjlyZnkwZ2VibjJNN2J6R1FXbnh1NjhZaHRVK1hhbDg3Y1FZVVZJeGVyQ0ZRdTRaS3JYR0ZHQUZ6bHNNRW1NelV6VkYzaVlQNS9SMWJqRE0xbFNaekErYTNJVENXN0QxZmVlVDVFZy9lc25KS0dadElLWk9OZVgrVVE3U2hnTHpPOEpEdk4xRmF3V0lYZGRVVzZRRmxiOXMvanQ5UlFPK2E4aWd3QjJUeEQxNktRUzJlSm1HM0E0aFRVdDFRem0vWTUwbWVrTXRBVGwvZnI4blFHMWxVZVFpaFM4T25JakZyeFpZYk1LS3Y2V0VhZ05VZHpNdzVLNG5jVDhQNGVLKzVkL1FFbzhFYlpmeUJGT0IwbUFyOVZicllqUEFjUDcyUkdOTWxQa2RrWE5VZHlwcW1iOER5UERoZkJ1a3JGWm54alR6NzlUdXIxZkt0UWZ1QmRQejZXLzE0ZjA2dzJ1Q21aU2h5ZktwZW4wbWVYWHFrSS9nYW1UaEJ0VFJDNXBZd01DUmhDdmhEUlZGeElXdm9VUEo3UXVPbU5WYkM5b0kveitYY2xucXZ4c29mREplTDBTWUdrK2lCNUVtbmpCamZtaVRTR3VBbHluUUI0YWROaC9INW1mUnVYVzV6MU1HaEdoazZJQXRGMEhHOGY0WWFwOWcxWXNnaVR1YmZBaXcvU281Sm9KVWsraGVnclkzQVFudjAyczZoVFVjU2hKMG9ZSkFUYWtDZDFVU0xTK2cxM2VHcThtZ2Q4eUhNV3NFUEFSb0IxUklBRTFWR1VqVkNGaC9OOHlaWFN0NHB6RXBzVk1zbEZOK2JVdmcybE15NHIrSGxaKzhIbVRCNHF2eXpqQnNJUGkvUk55dkkrRGMwME9pT0Y0MFJqTUhkVEdCK1daZ1BOSTZ3K2hnWWp2SlVTSW5nZHM1VTBjWGtNbVpFaFNsYTBUbEQ1TXZJb1JKd1B4OEgrWEdHYmcvSE51SDVPdFZnMXIvenJiRmFhSjNHZE9WNnlwY0FoVXRiZEJIUkFmOEZjVk1ONlVXOVAvS21rVkJwQmdtTWxrZklxa3pYeGRRWm9IVmhiNWE5K1RFbkJxMTlISkdTOGlVODhWaitSMXU3d1NZUU9BTTVNOE1wV092RndZODlZYVRuUE1Wd280Ym1sVUdQRjc3VU9QYW44bVR3YXJ1bFdLbGN1SWY2TC8vWGZ1Uk5aOHRHVXNXNkJQd3JpY2FLbUZ6eVgwT2FsM25OUnBxOSs1b2VCb3B4TVhJdVRVdE4zT2ZRZ2xHNGlaWVJHUFRGNWpzcEZ5WEpBSnlQaW9kaFNvSEFoQjhqbndMdUZ4elVSY21RZHE4WGY4c1lMcjNNUzkycFVtaU5qTTVVcHFnZFFuZ21QdzNiTXJTV3hndXplTGZaYWNWY2thVzVJMnlub09lejJIVjlGcU9tUWlneG5heW5mQ0N2SDV0bDVnR3krWStGUndDTksybzQwTndMNkpUNUttV2JpL01NSXJjaXpUMU82VFdZTkpQVWxla3BXQWg0dDhGZ2xLeFFjL0pqd3YranI3L25YRmxCR1duVStwUXVKL1Q1THF3QXZ4eS9VV0txQXp6Qi9BWTBqei85TXltUXdUMVI0RmNGeUZiREYrQVgzVjJmbSttVjYwZEw0WmFyM0lWZUlOb2JqZ0M5cXlQczR1bXI0MkFRcnJueHZPb3pQd3RkVW02NWtwM2NDMjRXWlFGN2VZb1BWUkx3WFZXOVQvSy8rMmY5SURTeldHZDlpT2lGenN0aGpLTW1CY2grMkNaajN5TkpCTkpQcHNJaURSMkRCbElzWVhxaWthM0lGRTV3SFlRUnZqZVBPT1F6RzRMMkQ0TTNBSDdsMDdnWUNkNk9rZ3J0V0lubGtyVTBtTHJER3lmd2Q4ZXltTmZwa2VuTWt1eGNZZlI4Mmh2RzRvUndhaVZ5QW9LbEFUWXBjSlJ6TDc3L2o4bEh5dmM4OU55MVU1YXlhNUZlUzd6QzZUdEdqVkdSTFNXc0xTanRDdnh1RTg0UmtZS2lLalhJRWZISUVFeXJJK2dCbHgrTDVNYkVYaytKVUxTREV6dElSbC9BNXZPVjQwd3I5YXpEU1JQWUhMNDNUdm80bnFERW1BbUE0a0xWemZKWEtvMHhvNVhnRDRud0xuWVI0NlFrZ0VkN0RSS3drajl2cDRGdHk4c3k1czRmVnZOUytEYlEvOHFPU01xcXhpa3FXWmRDODVnZmYrWlVUU3huTHR5c2VhRWhQYnhWeGpVNWtvVkNveHdxT0VHeHAxVGRBN2h1dHRrTHE1OENyZ0JkeHV0aFg1dzk1VzVaNWh0OXE4SFlWbFhyNDFwZjlkdFA3cm01TlAxRHVaQkNQZVZWRXExZjQ5Y3haUEZHM3N1S2RTZllmYVVzRE1VMWhwVDliczVYWnU3UGt0ZXludkdWcDdUeU95dG5TdXJ5VE12Umpzb3RsZDNuS09yS2hzSStaK0oyRlBZK0hnWmhhOGNPdTNuWDVTMEZYczJLOWg4VFpWR044VUlDRVEvcTVjcEEzYXZmQ09VdGNSR0k0VStjV1IrVisvaVNKOGNSWWJ6Z0xWM1QvYS9RaVE1UzdNSjlGNEpXd1h2ZUdQZ3hob24yamdEbWlMc2orUnhoSWZINC9IWmJVTHkxZUErYks3elRIUzVRU0FrczhicEtwTDJXdVVtT2RYdzJSNzB0M1RxeWtKcHdZRjJVVWw3QlhCMkUxZ1Fra2xiUVNTRlV0NzJBNkhLYm03MEUwbHFjTmtFcXdvaWYrT1o4V0pHYklzWTdrWGhwMmdYWlRMT3o0YjNIc3RtaXVyMVE0emtXZ05VaFh4NkY4Nk5zT0k4TVM4bDNjbU9qMUFYUFhjTCtTWURuT3ZGSGxNYmgyVXZ5QlVWclJvaFp4bUQvOXBabC9Yd3lXa2JFV3JoL25vQUhmQnNJclJQVnlxcytsWWtiRkF5M0Noc05WOHFWU0hFUm5FdmJNNEQ2aXN3RDJNaVNmaWE4WVc5alAwVlBoV0tCUVMrcnY0eU9HbU04S3JoeEdzRXhFNnpSQkY3Tk1SVC9heU41Y3RtL3VHMmVkU1hRMXBCaS9lZ0pycXJ6SmVOOXhIRlhCVmFCa3FBc0ZlVzRTTlRBMjFPTUN2ejBDVE5DelVuemp4LzV6ZGZHSWQvNDRLWk5yY1JxemFwdVV4aWtEWWhMaTgrTGs1clRRSU5IQWc1YkxoK2N4bGdYMmFIK0psR0VRNWpsc2dad0srak84b0NRNVhicTQ1VlVWRUxudzRlZXl0QUM0QmU2cHRIbWErZzViWWVrZzRGRTdOWE5xTzhRN1ZjOWg5RzBteWlPNWVBUDdsdlNXS2xkdTlBTkhQNFI0eXFGSmdNZ0R1Z1hEQ2dnTnpsUkc3SCtBbzd5SUYvbE9qdGNPd3VnL1JWMFduaXpKZVEwdGJjRFdDdXd0dTQ5STdzdG44bmptNzN5aHRKZDBzSk84Tng4ckFmNDhpMnc5WkY5YmVqdTRNdkczLzFJdlpZTmlmUkRlUlVUMXdEaGYzcytITCtCSnkxMTZyQW1iWkFWWWZ4T05lK21laHN2M1ZBa2tyQmd1WGhueUFNNUNrZTJGbTA3Y1ptQU1vYk1aM296QlpnVWNDNXJlSytTSDdMcVhLRTIvRE5ORHpzZUFXVExTSVJpd3VJK1V3aDJBTjN2TWtmaVRBcmdDc0E2YTkvRjF2bjlucE4zb0I1K0hOSkw0UW92cmlQdExwSm1DWEZPdlR3QXFBcjVGdFd2aG9MQlpsS1VhOTgwVVhZR2NJakVGS0t1TXZBT2RtRVN2NDNFUDNUZ0ZPWUpHWHVnaW5VaGdxUjdhRWczZko4REU2WU5oY0t5dTI1aDc4TmtHVXFNNE81WUtwMmdsNWdlUXpudkNKTnF6RVM5QTlONDdkNWNCbUtQM0ZSQkcya1ZCWVhkalloOE9FME5PeGtaclhhMlZBYzdxMmlTWlV4QlM0SnNwS1A2OWhLYVpOU3Q2M1ZDREJXUU8ySk0zZHJtcDNkZjl0bXc0MSs2R0RSZkcxL3VGUWxNVDlLVWNSMUlKWk5Vc1dKZ0xMRUp1RGJHOXhZa2p0WXd3N2lrL2FYbUk4SU5WeTVsUFFTYlplRXRTVmU4SmVHY3B1ZUQ0WVZFQUpMMnRHRjA1bkV4VHJwTGkzZEVjSkFGd0xBY1lCa0F0S3hQR0hDcWRnazBPY1JiQWpwZk1OdmhicGlZdjlUOStsK1NMenY4aDZEQUtuZU15MStXTWtxYlgwbllXejJ3aVI2azNSNzYwb2oreFJlTUEvVWFNTTFOcmM4M3BxVlpvQ21YTTFZdTBNd29ITy9wWVMvRUNoMDJTSTZtd0pFL0NNZ1NTQ2tJVmIwckpMb0hUbUcxWVNXbGVmaUV4dDB2b2Jxa1NncUlIdnNYeDhwVFc2N01HMUdnSVRsb29uQUlsRUxPSm1FOEYwSVZ6Mzhnd09PQ01YeVhOZ25MSmtzd2JpWGovVTFFK2xNT0xKSHpsazU4ajU5NEVtazc0ZXQ2YlN2TXR0QzM3WDJPeVJ6U2lBVnBGK2h5M3FIa3lpQVlOdFdBNDkrYnlMd1pSZTJsQjNKNE1RL3ZETjNPZVM4N0djUWJSNktXa1V3a3NwMDJEU2JsazlZaytJNEFiV0srbnNnUEhVVlQvQjV4RElXODd2Y2NGeDVRZUlPWWF4TlpSditTQ0ZEUUdSaS9IK2lPNXpzSDY3OVBkZ3VLWHhPckdwSU5rWDNLeWtPZTI0dklZUDB0ajdhV01KSmpidDhrUzZSMXp1QUh4bFhnNTB1R0ViZHlVcnh0cEpXVlpWN3Fza0VnSG1TYjFEU2g5QmhWZG5nbG9uRVZhRVlyenhMVWdoSEJISjZjeGpMMWszdERPVS9URG1oc05FSW1oajRYNElRR0s4Rm9xNm9PT25zd3VGYmpNOEJCTmw4S1Yxd290UUZzUjcxOUo3MTZuWC9uS3pRVmxKN1QvUVRmZnlkN1BOaEp0cXYrRGdEc09ZUnZoT0FRVmpzMDg1Q3RoSU1KeXJKRnNQckEyQkp2S1p6UCsvMzBSYVUrdFJyNVVXNG12VERhOEhXZmRvQ1p5VnlHTXoxbDVRbmtZRHZJSnJZQm1sVnRNTGo4Y0xERGEwV2RoeTF6eExKMExNaEptaW82dTR2d0tWaEp4aGlBZmtpMlpyRi9iMy9uNFNWblp2c0VEemEvMTZOMWxFVmJVNlpESUN2Uis1ZVp3Mml5YnJWVkNGWG5sdFZMc3grT1QyYVdLUDVRUm1sUGVwcTdGYWVXcGFBcjlPR1AvNlltMUdMai9lUUpSZ1MxRndmTVUzc3JTakJhNUhIQ2Z6N2l2V0RtUUllL0dmT0VJNXpKcGp3TmppMDA2YUtJbDB4VjR4d2x5dnQ1OUJkazhLZ3pUV3pPZDlmM2VzanI1WjZsOUlsYlBWUEJybXdzd3JhR1RETmJLTUQ5QzNTZDhhcUlQR3VQclJuRWlCYkdxOStyUm1xeGNJZHlaNDhaaUFsMHlqNFZlazZZam9KUUJHT0hZNVd2ZkF2ZnorR2xPRmU4UlZtVG5VM1QvRGFxRzRTODFKVG1GbTNwT2F5ZjRqMjcvTHdXVUxvdWcrNTU4b0VYWlZiazR3WW9EMlo1d09SVjFpS3EraGxIdW5WUjhPZTZPeEN2c3dTck9UL1ZDQWlnR3h4NTFydFhHaVdxTk1UZUZXZUFhSWJ6TFM4Y1JIZkx2ejd6OGlWQjZLRlBCd2FiMnVoZ3RKN0tjVDJGUHFXd0ZwNzdpdm05TFRONm95TnVXOTMyZ3RYaEtUK0JjQkVBS3VqZE1kNHRtSDh2a1lkaWFFNWxBWHViZ0lFdjdOZjlqaXNrODdFUGRTcVNWTk5remNQZ0RLaTBqOFdkT2lxenJhckRSMFlVQm82bW96eElQa0tHS0hRS05GS281ZERCaGM3NXNUb21YUmVYVldDNXkrejQ1S3NOZ2diMFhZTU1oQ29EWFplSXR5eHVMc0w4T2c1VXdyUURTZ0lZZ3EzRTR2Skk3SndsSmpkTSszTFJBOWl2b1RhSDBIUnM1ZUNVdkNqSFl5NmJnTFNwOUVuT2lGS0Jrak1ObkRXcUw1QzZVd2wyVWxFalZqNFJEMEZYbzlVT2ZDYncyL1cvWnVhUTl4aStJb0l2eDFsaVhVM1Fsd1VYSWV5bDZhZlA3Q09OOEdOWFI4a2NNNnRaWDFhbDZLdDBPbFN1YjVKK0N5a3R4MFJUQ0l1VWxkdTVDYmN0cmNEYWVsM0FYUldYS0V5eFZaVStDTzZ0UlI1YmVFZS9ETCtNM2J5aTdUa3NOL0wzQzdqZU4zQ1dPQ3BBdlFaeWx2UUF3ajIzY3dkRU9HSDA4eERsZ2xjUHpucDRMNk1ZdTZDMUozVndxUTN5WEo0cWFQSnZIdUl5V0lPb0FRbllUclUzT3k3S21DSkFvb1l0ekRHNTRzV3JBdjgveTRHR3dWR1o1U1Z3T1lQM3pxRkZENXhQTVAvQzdUWE03UDhtRjZPdXNMMG5vd1ZjZ25LRkxBcE1Qd2gyTlJCaDlPUXMxS0gxZ3d4U2hBeis5bTRsOVNYRXNwVE9KRWlqdVpFUi9IVTAyNHNWUUxYcmlZamNLbWFUM0VhcVRuazl2Z0dpelBQdjJjZlpOWlZKSDV0YWJaQm9JcjB6bXRsS1lKMmRWeXN1eTlSRW1SMHVJWUdtNWpZZHhmRHN0a0NHN3l2RDZGcS9iL2d2UEduVjgvVnB5dVQ2NUk3Rk5aL3JEaWI1SEc4UmdsN0ZESVM3akVrak1WanBwdXV3TEhDM3E3NzdCQzUraWJKN0QvMzdJVTZ5RjB0YSs4YzBWZkxhblNpcklZNlcrNFBqSUdOVGpPejdtQmlNMmtEay9PNFdLSml2djljdXA1RHRVZTBGMlBkejZTdnNURzErNHFKdUozbHZUVnpYM3E1Y2FQTEkzRVBvdk9YbnRodm12c2YxTHczcTlDWDQ0Uy85ZUp2NVpOUHRXK2xrTURZdCtrWG8vY25IdHN2c2ZTYkcxNUgzY0xRZm5zQXJUckE5cmRYWDYrOWtzWXNHSkV0OUtZYUNNRkMxMStJMmVPVjhiZnFlb2svbWd1bWNFUFM0bkxHL1JlSVRhS2M3MDQ0K21pWk1qKzZ2STJvbGhYeHFkSjVQZmlPQ0dKR29RL1hUR3IzUmxvaGRpY1VFQU4yTmxTSEpPWk0vSjR6NzYwS21tVituUnZCcHZKblljbnhONTljYXdsSUdnYTlXK2xrbjBMMkp0SWlXL2o1U0JDOUw0Zk10QU5kVHY0OHdnV09xcmV5eUpRemhNMGR1M2tUd3AzZHllUFV4elJZbzhBOXBKREVwRXlVRCt5QngwZzFLUG5pWndqR05ubC9nQURTOHJKa2J6MVVRYUFyV0dhZ29JRlpBN2hGSW1uYmpSQkVUam1lVWJhWFk1SlZWMktUUHp3dGhwWnJrbkI0dXA1UEdzTGcxMHlXeWd6SkFZRWV1UHhBWUdsZ3luWlUzVlNYZVJhemZpOVJDWVhSZ2Q0TmtHZjNTUFh6d20rd2Z1cUpnclhiSE5nVHdlQk1yOXltd1pBQ0drMThDSU9WRjRpU05sRmVxaFVzaXFYODRHNVFHUmVXSVRqQlk1MWtDWWhUWkw1RDR0ZFZtd2lNK3JMRGFEK1ZQTHN0aEtHaDRaeG04OXJnWHc1bGZnN05nL0s4ZUhDemszbTVnbmVQMFFweFAvdDF2VytaUnY1ZkRwb1Fnc25xeUNLMG1HVWxvZ3FLL2c2VUswM1pFT09iZ2VRdzNtYzE5S1pzekhIVVkrZmRkWXVrN1lNTnFTOUpNNjdFck9uREEybWhDVkJCQmtJY3pxcnRkc3FPMTg5M1pCdmU2YUsxTm9adG5YT3RSV2tYMklhUU9YRE03S1NKMm0vcFZNaVRvZDRXYk1Lc2NRTWVhZW9zcU5kS2VOeHhURno4Tk5BbzVwZGlLSDVhcm1WVWdXZ1d1QXFjQ2Z0bUhxOFRkdlUzV0pkcTg0dVJkSkhNVTdmbUVFcjJyV3RNUExmVHhlbG9PNXBMZzlnbDByYmNMcS93bVZKZDdpY2ExRzIwTUtBVkNYby9XdUtXV0FOeGJWaHRUZWxnWS83bFJ0Ulh0WGNDallNbm16TFBWNzBLZ2wrU3dUYytHazcvLzBvcEplT3krNUh5Y2l1NVhhZmEza1VUb1JCUmIzRDNoL040cXFFbHNVL0FyeFBDTHp6REQ1eEJiWEEzbXhqbzY0SWxKUVBNRjB5czU2Ykxab2FsZGlRNEhwRjg1Vk9WMDVvN0Vrbll6SnZaSUlxRGladDNXQ2hVdzJ4K2c2QlVkN3BKRUhsZHQydnlyd3YvbXJ2MW91QnEzMzFlNC84Y3RadlI4Si9DYmRzWWhGMlZGUkZRMVFtc01IQW1aUHFmazBiWS9BZ3pCTWN2aEZPN3A1TFpNSis5YkFRUXpuUWlvekJMT29GcEFJUUpCRGNSVUppTEpjOU1jNElOQW9DN0NGeVEvRDBRZSt1NW1VYWh4T2xKMTl6bDk0cDIrQzFhdEE3NGY3RzBacks5Wk1yTXpVY0lxaFN6ZDJrMkdpekdUd3dPVHZzSFFRSmx1RFRQVUFEMTlMYXhpODBZMXBCZndzNXo5OXd3SENhMjlZdDBGR2I5STdlUmJYMFQvVSs0V0w4Z2VmdytRNU82ZHNMaUxGWG5KcDRUWUMyazNQWlBCQ29FYU5iQlc4TnpkMXB5dE1YOHRJUU5OQWtJSEN4SU41MUMweks1YXNDTXNhVk81NmZrQkxCNFI4dzY2MkFMM3JyblhWNHhmdXNHdi9SSWZLc3ZMTkxZNGFZRUVWTlR2WkZ6aFF3TTVycCszaDZDQm9NU2s4WU5tZVdzcWlOQ1BNRkFZek1NbEJxT0h6QUJQcGMyM1NTTS9tUWhhUWhWdzBtV2dYaXo1QVVIYVNwTWNWQlVrRkFLYkNWUm5iMU8xeTRoWHhPSUh5dk5oOEVyeGQwKzFPZUtzdWl3bnNGUUJIZ2k4bTZpVVpxaUxmUlhDWnV6Nk9USzdNKzRDbVBvU3JiK2wzekppTzNYc2piWm93UWVINHgyYnVTaXdXWjY4N1pxOFJrd3RZUVVRZXBsME11QTdMZWU4UHNYV3N6SDVlVWExcnlZMVRlMG8vRFpyOFdOcXRGcjlablpnM3c4SVYzRnliK3hyNmR5ZjQ0VUI4Q2RocFdUMkRURGt6N3AzSGlZTG90aUxCeEtaRURzQllTN01ubUlmNXZvOU1LaVVXcFRqZGZpMjNUOTFlTWpPMk16dlo0RXhWRkFsVWwvMWpFTWlSbGh3VEFNSG9WWFlnbzN0VmQxalZabWVwL1NiejJlelNpSEwvVitLOU5JdVRMVGJ4b2c5aUZXU1Q2YjlKUDNtVy84ZkVHeGRLK1FhZVlMRndDV2RVRGc4bTQyTzVRQUNycVgwVGhFUCsvdE5RR3lmazJVdDcwYzhxVTJVOFRISU5Ya0tJTlpUQkpaN2x0YXFCZGlmcCtaQStBdUxKQnIxTXcwVWlud1NFV2F3MEY2TS9pOTBFaElPMDJLV1RubEQyNHFtR0I3ZlEvY1VvQ3FUUlJCVEh5RlhGekV4RVh6STlOZXREMGdta1ZHUmNsSytBbm9iRmRpaFpBWHJBN0E0a0d5azZnU2tRcFJuSGpPZHNNWmd5dDBMbnVpR2s4YXRKM3JxVkx0Z3FyU0FlS09SUi9nV0kxQ3ZwajE1YkI0VDNQazR5MVlEZVJPYVI0bGFnMHVaQkRrUnBxdDJGTUJhMnpvMHpMRHQ4c0lCdE5jZzFxUFF0eW1PdzBjZURPTGlrMW53bVhOek9YM0xmaXZsWWxoS2RBUUt1VDlYRjUrUk9FTDkwWjVlcTlIam14clhzRng5bzlSMTdMYXQzVG9XeHlIaGViZmNucW94bURpQlpBY2FRN2lGM2tOVk1Wa1JTZDR2RmVqU3p2TnFDOGVrSi9WNHJ2STJpUHdsUmI1VjRkclJha29NUVRSY0k0ZjhPWHNSdXJxK3ROT0RSa0M1M21kRVN6d3JCeWhhdVphZkhXUElEcVpTd3EwbFF1ZFFmRFAxZlNFald5RTAxcDdvenc2WHpTRElkZDYrZzNpTmlHdkZ2WHZaM0dqVzVBdFdLMFBwZzdJTGlFNEh0aUlaeHoxVGRUeW5JaWRoSXZaQkhncjkxeWZxdkpiMEszNW5JV3ZjZlZaVTltYldyNk1kUjNBek03dGdtU09CRkdrTGdkNUw2TXlRTGNKTGo3OTBtZkt1bGsrakdyM2RFTS81MUFWU0pNSDFGZU1CY2NqUXF0K2Vrd2dTckE4dS9URVVyTVJUd0xodXZCZW1yWjdRblQ5YnZ6WU5Qd2pFVGFsZktET2xFcDJRaFhwMkNzNzdvc0hpSlNwbFRiQm84NnZHZFBDR3RpTHF4RGxDdmFGMFFjTlIwTmwrb1MzZlRQUU9jM2xiV3A3MGJEZVBOVjVFTGtrSkhxYU53ajZtRHJ2alp2SC91bU0rRy9yS21MaXVxWEl4MUxTbmVKUU1YUkJrKzhuampVcXEvOVU4Mk5QSWpqL0QvcUUyeVhOR3d1c1hxWFZZWSs2TVpjclQwSHdmR1R3T1lyWXVvUmZPeWwrdG9jaDBydXVBQU9URXJYeVVqbGFhelJGNVVyZzFqYmhIcEVvZXVyTFExNzEyVU5Ja3VRYUJDdVpja0ZFMnFDbG14S2dOMlBjUFNrM0JweWVydHVSVlRTa2FoUnNUaFZCbHZTdTg3SktsRTg1aFdMb0YyNFhzVlkxYUxoemRoSW5zVnlrcW5tUDQrRms1S2Zmbk1LWXkrTGRVNjBZZno3dHYzakF1MXA3V0tXODl4b29pamxXSkJocFgxOEkwcjBBYlBmZW1iT0h6ZDV0Y2xMN3lSeVVoRTNsZEhMNk4rVDF1cHhEN2dnSUhSQUIwNDh2dXl1SjBhVFR1OGVzNUxnR2ZDTUVuUktnNHVOM0o3NzhNN0t4STNrN3dBdVpiVXVMQXYvbDY2bXB0TnpNckNidWZ1dnZRTkd0aWZxTVlTVXB6MFJoSThINnBmRGt5RVFLVW1EUy9UUjcxMEw4UmduYTRQMkxkSk1tMWJXazRzNVZncTBiMit2ZlMzQnNtOTd2ZEt1RmZOS0xHMk5CMW5yUGdmazBLaUpaMUxmMUl5bEFocUFRQXpKQ0toTzlqWGhKWGlLVXdLRnJPM1pXOUt4YTF3SktDYW9DQUVGY2hLRFExd011dEdlUm5EQkZvbWNkWklaOG5SbCt6TkRtbDFMYTFKb00xREFxdHBlc2lZbktjVEU3Nkx4emV1eTFMQVRRQ1d2VURuNGY1MEZxZ3g5TFVUVzlFZ3V1ZjRXaVA1L1V4end1RERKcGlFU0hFanY2aDlmeEVabXJyU0JaYmdTU0NlOWRQRkdNZUJPcDU2bnp5Z2xlVWdnRFRDaWdlR3IzT0ZoOFprVThwY0hQcTBoM1pHeWN5WHpKRXZ5YVNkVGZtbXRVcjUxUkFrYnFyWFpNcHh5Z25zK2U5UzVGZytMY2lYRWI4VHFQZjZhcjNRdXdpS0l6dzUzbS84Uk9yZXl4di9ZV21vUS9PT1pnQVdwNWRvb1JVZHFHUlNCNVlFclJBWDFHQ3FTRkVLUHhGcFdhZ25JY3RpdUprZnYxakx1V2RpYmdqK2Y2OFd5MXlnVjVHRUFBQUFBRWxGVGtTdVFtQ0NcIlxyXG5cclxudmFyIE9QVElPTl9TU0FPX1NDQUxFID0gXCJyZW5kZXJlci1zc2FvLXNjYWxlXCI7XHJcbnZhciBPUFRJT05fU1NBT19JTlRFTlNJVFkgPSBcInJlbmRlcmVyLXNzYW8taW50ZW5zaXR5XCI7XHJcbnZhciBPUFRJT05fU1NBT19CSUFTID0gXCJyZW5kZXJlci1zc2FvLWJpYXNcIjtcclxudmFyIE9QVElPTl9TU0FPX1JBRElVUyA9IFwicmVuZGVyZXItc3Nhby1yYWRpdXNcIjtcclxudmFyIEZMQUdTID0ge307XHJcbkZMQUdTW09QVElPTl9TU0FPX1NDQUxFXSA9IHtkZWZhdWx0VmFsdWU6IDF9O1xyXG5GTEFHU1tPUFRJT05fU1NBT19JTlRFTlNJVFldID0ge2RlZmF1bHRWYWx1ZTogNX07XHJcbkZMQUdTW09QVElPTl9TU0FPX0JJQVNdID0ge2RlZmF1bHRWYWx1ZTogMC4yfTtcclxuRkxBR1NbT1BUSU9OX1NTQU9fUkFESVVTXSA9IHtkZWZhdWx0VmFsdWU6IDF9O1xyXG5mb3IgKHZhciBmbGFnIGluIEZMQUdTKSB7XHJcbiAgICBPcHRpb25zLnJlZ2lzdGVyKGZsYWcsIEZMQUdTW2ZsYWddLmRlZmF1bHRWYWx1ZSk7XHJcbn1cclxuXHJcbnZhciBTU0FPUGFzcyA9IGZ1bmN0aW9uIChyZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KSB7XHJcbiAgICBCYXNlUmVuZGVyUGFzcy5jYWxsKHRoaXMsIHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBvcHQpO1xyXG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0O1xyXG4gICAgdGhpcy5fcHJvZ3JhbSA9IGNvbnRleHQucHJvZ3JhbUZhY3RvcnkuZ2V0UHJvZ3JhbUJ5TmFtZShcInNzYW9cIik7XHJcbiAgICB0aGlzLnJhbmRvbVZlY3RvclRleHR1cmUgPSB0aGlzLmNyZWF0ZVJhbmRvbVZlY3RvclRleHR1cmUoY29udGV4dCk7XHJcbiAgICB0aGlzLmxvYWRSYW5kb21WZWN0b3JJbWFnZSgpO1xyXG4gICAgdGhpcy5fc2NyZWVuUXVhZCA9IG5ldyBGdWxsc2NyZWVuUXVhZChjb250ZXh0KTtcclxuICAgIHRoaXMuX3VuaWZvcm1zRGlydHkgPSB0cnVlO1xyXG4vL1x0XHRpZiAoIXRoaXMuaW5wdXRzLnBvc2l0aW9uQnVmZmVyKVxyXG4vL1x0XHRcdHRoaXMuX3Bvc2l0aW9uUGFzcyA9IHRoaXMuY3JlYXRlVmVydGV4QXR0cmlidXRlUGFzcyhcInJlbmRlci1wb3NpdGlvblwiKTtcclxuLy9cdFx0aWYgKCF0aGlzLmlucHV0cy5ub3JtYWxCdWZmZXIpXHJcbi8vXHRcdFx0dGhpcy5fbm9ybWFsUGFzcyA9IHRoaXMuY3JlYXRlVmVydGV4QXR0cmlidXRlUGFzcyhcInJlbmRlci1ub3JtYWxcIik7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhTU0FPUGFzcywgQmFzZVJlbmRlclBhc3MpO1xyXG5cclxuWE1MM0QuZXh0ZW5kKFNTQU9QYXNzLnByb3RvdHlwZSwge1xyXG4gICAgY3JlYXRlUmFuZG9tVmVjdG9yVGV4dHVyZTogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgZ2wgPSBjb250ZXh0LmdsO1xyXG4gICAgICAgIHZhciB0ZXggPSBjb250ZXh0LmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICB0ZXguY3JlYXRlVGV4MkRGcm9tRGF0YShnbC5SR0JBLCA2NCwgNjQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHtcclxuICAgICAgICAgICAgd3JhcFM6IGdsLlJFUEVBVCwgd3JhcFQ6IGdsLlJFUEVBVCwgbWluRmlsdGVyOiBnbC5MSU5FQVIsIG1hZ0ZpbHRlcjogZ2wuTElORUFSXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGV4LmlzVGV4dHVyZSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRleDtcclxuICAgIH0sXHJcblxyXG4gICAgbG9hZFJhbmRvbVZlY3RvckltYWdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIGltZy5zcmMgPSBiYXNlNjRSYW5kb21Ob3JtYWxzO1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgdmFyIHRleGhhbmRsZSA9IHRoaXMucmFuZG9tVmVjdG9yVGV4dHVyZS5oYW5kbGU7XHJcblxyXG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleGhhbmRsZSk7XHJcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1nKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVZlcnRleEF0dHJpYnV0ZVBhc3M6IGZ1bmN0aW9uIChwcm9ncmFtTmFtZSkge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dDtcclxuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEdMUmVuZGVyVGFyZ2V0KGNvbnRleHQsIHtcclxuICAgICAgICAgICAgd2lkdGg6IGNvbnRleHQuY2FudmFzVGFyZ2V0LndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGNvbnRleHQuY2FudmFzVGFyZ2V0LmhlaWdodCxcclxuICAgICAgICAgICAgY29sb3JGb3JtYXQ6IGNvbnRleHQuZ2wuUkdCQSxcclxuICAgICAgICAgICAgY29sb3JUeXBlOiBjb250ZXh0LmdsLkZMT0FULFxyXG4gICAgICAgICAgICBkZXB0aEZvcm1hdDogY29udGV4dC5nbC5ERVBUSF9DT01QT05FTlQxNixcclxuICAgICAgICAgICAgc3RlbmNpbEZvcm1hdDogbnVsbCxcclxuICAgICAgICAgICAgZGVwdGhBc1JlbmRlcmJ1ZmZlcjogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVydGV4QXR0cmlidXRlUGFzcyh0aGlzLnJlbmRlckludGVyZmFjZSwgYnVmZmVyLCB7XHJcbiAgICAgICAgICAgIHByb2dyYW1OYW1lOiBwcm9ncmFtTmFtZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXI6IChmdW5jdGlvbiAoKSB7XHJcbi8vXHRcdFx0aWYgKHRoaXMuX3Bvc2l0aW9uUGFzcylcclxuLy9cdFx0XHRcdHRoaXMuX3Bvc2l0aW9uUGFzcy5zZXRQcm9jZXNzZWQoZmFsc2UpO1xyXG5cclxuICAgICAgICB2YXIgdmlld01hdHJpeCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgdW5pZm9ybU5hbWVzID0gW1widmlld01hdHJpeFwiXTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNjZW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLm91dHB1dDtcclxuXHJcbiAgICAgICAgICAgIHRhcmdldC5iaW5kKCk7XHJcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcclxuICAgICAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdGFyZ2V0LmdldFdpZHRoKCksIHRhcmdldC5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLmJpbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Tm9uVm9sYXRpbGVTaGFkZXJVbmlmb3JtcygpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHVuaWZvcm1zID0ge307XHJcbiAgICAgICAgICAgIHNjZW5lLmdldEFjdGl2ZVZpZXcoKS5nZXRXb3JsZFRvVmlld01hdHJpeCh2aWV3TWF0cml4KTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbXCJ2aWV3TWF0cml4XCJdID0gdmlld01hdHJpeDtcclxuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbS5zZXRTeXN0ZW1Vbmlmb3JtVmFyaWFibGVzKHVuaWZvcm1OYW1lcywgdW5pZm9ybXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9zY3JlZW5RdWFkLmRyYXcodGhpcy5fcHJvZ3JhbSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLnVuYmluZCgpO1xyXG4gICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSgpKSxcclxuXHJcbiAgICBfc2V0Tm9uVm9sYXRpbGVTaGFkZXJVbmlmb3JtczogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdW5pZm9ybU5hbWVzID0gW1wiY2FudmFzU2l6ZVwiLCBcInNQb3NpdGlvblRleFwiLCBcInNOb3JtYWxUZXhcIiwgXCJzUmFuZG9tTm9ybWFsc1wiLCBcInVSYW5kb21UZXhTaXplXCIsIFwidVNjYWxlXCIsIFwidUJpYXNcIiwgXCJ1SW50ZW5zaXR5XCIsIFwidVNhbXBsZVJhZGl1c1wiLCBcInVDb25zdFZlY3RvcnNcIl07XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdW5pZm9ybXNEaXJ0eSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIHZhciB1bmlmb3JtcyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgcHJvZ3JhbSA9IHRoaXMuX3Byb2dyYW07XHJcbiAgICAgICAgICAgIHByb2dyYW0uYmluZCgpO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5vdXRwdXQ7XHJcblxyXG4gICAgICAgICAgICB1bmlmb3Jtc1tcImNhbnZhc1NpemVcIl0gPSBbdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0XTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbXCJzUG9zaXRpb25UZXhcIl0gPSBbdGhpcy5pbnB1dHMucG9zaXRpb25CdWZmZXIuY29sb3JUYXJnZXQuaGFuZGxlXTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbXCJzTm9ybWFsVGV4XCJdID0gW3RoaXMuaW5wdXRzLm5vcm1hbEJ1ZmZlci5jb2xvclRhcmdldC5oYW5kbGVdO1xyXG4gICAgICAgICAgICB1bmlmb3Jtc1tcInNSYW5kb21Ob3JtYWxzXCJdID0gW3RoaXMucmFuZG9tVmVjdG9yVGV4dHVyZV07XHJcbiAgICAgICAgICAgIHVuaWZvcm1zW1widVJhbmRvbVRleFNpemVcIl0gPSBbNjQsIDY0XTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbXCJ1U2NhbGVcIl0gPSBPcHRpb25zLmdldFZhbHVlKE9QVElPTl9TU0FPX1NDQUxFKTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbXCJ1Qmlhc1wiXSA9IE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX1NTQU9fQklBUyk7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zW1widUludGVuc2l0eVwiXSA9IE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX1NTQU9fSU5URU5TSVRZKTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbXCJ1U2FtcGxlUmFkaXVzXCJdID0gT3B0aW9ucy5nZXRWYWx1ZShPUFRJT05fU1NBT19SQURJVVMpO1xyXG4gICAgICAgICAgICB1bmlmb3Jtc1tcInVDb25zdFZlY3RvcnNcIl0gPSBbMSwgMCwgLTEsIDAsIDAsIDEsIDAsIC0xXTtcclxuXHJcbiAgICAgICAgICAgIHByb2dyYW0uc2V0U3lzdGVtVW5pZm9ybVZhcmlhYmxlcyh1bmlmb3JtTmFtZXMsIHVuaWZvcm1zKTtcclxuICAgICAgICAgICAgcHJvZ3JhbS51bmJpbmQoKTtcclxuXHJcbi8vICAgICAgICAgICAgICAgIHRoaXMuX3VuaWZvcm1zRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KSgpXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTU0FPUGFzcztcclxuXHJcbiIsInZhciBTY2VuZVJlbmRlclBhc3MgPSByZXF1aXJlKFwiLi9zY2VuZS1wYXNzLmpzXCIpO1xyXG5cclxudmFyIFZlcnRleEF0dHJpYnV0ZVBhc3MgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCkge1xyXG4gICAgU2NlbmVSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XHJcbiAgICB0aGlzLl9wcm9ncmFtID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5wcm9ncmFtRmFjdG9yeS5nZXRQcm9ncmFtQnlOYW1lKG9wdC5wcm9ncmFtTmFtZSk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhWZXJ0ZXhBdHRyaWJ1dGVQYXNzLCBTY2VuZVJlbmRlclBhc3MpO1xyXG5cclxuWE1MM0QuZXh0ZW5kKFZlcnRleEF0dHJpYnV0ZVBhc3MucHJvdG90eXBlLCB7XHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChzY2VuZSkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMub3V0cHV0O1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRhcmdldC5nZXRXaWR0aCgpO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0YXJnZXQuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgdmFyIGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xyXG5cclxuICAgICAgICB0YXJnZXQuYmluZCgpO1xyXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcclxuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0YXJnZXQuZ2V0V2lkdGgoKSwgdGFyZ2V0LmdldEhlaWdodCgpKTtcclxuICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XHJcblxyXG4gICAgICAgIHNjZW5lLnVwZGF0ZVJlYWR5T2JqZWN0c0Zyb21BY3RpdmVWaWV3KGFzcGVjdCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyT2JqZWN0c1RvQWN0aXZlQnVmZmVyKHNjZW5lLnJlYWR5LCBzY2VuZSwgdGFyZ2V0LCBzY2VuZS5zeXN0ZW1Vbmlmb3JtcywgW10sIHtcclxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBwcm9ncmFtOiB0aGlzLl9wcm9ncmFtXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRhcmdldC51bmJpbmQoKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnRleEF0dHJpYnV0ZVBhc3M7XHJcblxyXG4iLCJ2YXIgQmFzZVJlbmRlclRyZWUgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlKSB7XHJcbiAgICB0aGlzLm1haW5SZW5kZXJQYXNzID0gbnVsbDtcclxuICAgIHRoaXMucmVuZGVySW50ZXJmYWNlID0gcmVuZGVySW50ZXJmYWNlO1xyXG59O1xyXG5cclxuWE1MM0QuZXh0ZW5kKEJhc2VSZW5kZXJUcmVlLnByb3RvdHlwZSwge1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoc2NlbmUpIHtcclxuICAgICAgICB0aGlzLm1haW5SZW5kZXJQYXNzLnJlbmRlclRyZWUoc2NlbmUpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFzZVJlbmRlclRyZWU7XHJcblxyXG4iLCJ2YXIgQmFzZVJlbmRlclRyZWUgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xyXG52YXIgR0xSZW5kZXJUYXJnZXQgPSByZXF1aXJlKFwiLi4vYmFzZS9yZW5kZXJ0YXJnZXQuanNcIikuR0xSZW5kZXJUYXJnZXQ7XHJcbnZhciBHTEN1YmVNYXBSZW5kZXJUYXJnZXQgPSByZXF1aXJlKFwiLi4vYmFzZS9yZW5kZXJ0YXJnZXQuanNcIikuR0xDdWJlTWFwUmVuZGVyVGFyZ2V0O1xyXG52YXIgRm9yd2FyZFJlbmRlclBhc3MgPSByZXF1aXJlKFwiLi4vcmVuZGVyLXBhc3Nlcy9mb3J3YXJkLmpzXCIpO1xyXG52YXIgQm94Qmx1clBhc3M9IHJlcXVpcmUoXCIuLi9yZW5kZXItcGFzc2VzL2JveGJsdXIuanNcIik7XHJcbnZhciBMaWdodFBhc3M9IHJlcXVpcmUoXCIuLi9yZW5kZXItcGFzc2VzL2xpZ2h0LXBhc3MuanNcIik7XHJcbnZhciBQb2ludExpZ2h0UGFzcz0gcmVxdWlyZShcIi4uL3JlbmRlci1wYXNzZXMvcG9pbnRsaWdodC1wYXNzLmpzXCIpO1xyXG52YXIgVmVydGV4QXR0cmlidXRlUGFzcyA9IHJlcXVpcmUoXCIuLi9yZW5kZXItcGFzc2VzL3ZlcnRleGF0dHJpYnV0ZS1wYXNzLmpzXCIpO1xyXG52YXIgU1NBT1Bhc3MgPSByZXF1aXJlKFwiLi4vcmVuZGVyLXBhc3Nlcy9zc2FvLXBhc3MuanNcIik7XHJcbnZhciBFVkVOVF9UWVBFID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmVyL3NjZW5lL2NvbnN0YW50cy5qc1wiKS5FVkVOVF9UWVBFO1xyXG52YXIgTWF0ZXJpYWxFdmVudHMgPSByZXF1aXJlKFwiLi4vbWF0ZXJpYWxzL2V2ZW50cy5qc1wiKTtcclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7R0xSZW5kZXJJbnRlcmZhY2V9IHJlbmRlckludGVyZmFjZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZVNTQU9cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgRm9yd2FyZFJlbmRlclRyZWUgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlLCBlbmFibGVTU0FPKSB7XHJcbiAgICBCYXNlUmVuZGVyVHJlZS5jYWxsKHRoaXMsIHJlbmRlckludGVyZmFjZSk7XHJcbiAgICB2YXIgc2NlbmUgPSByZW5kZXJJbnRlcmZhY2Uuc2NlbmU7XHJcbiAgICB0aGlzLl9lbmFibGVTU0FPID0gZW5hYmxlU1NBTztcclxuICAgIHRoaXMubWFpblBhc3MgPSBudWxsO1xyXG4gICAgdGhpcy5jcmVhdGVNYWluUGFzcygpO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoRm9yd2FyZFJlbmRlclRyZWUsIEJhc2VSZW5kZXJUcmVlKTtcclxuXHJcblhNTDNELmV4dGVuZChGb3J3YXJkUmVuZGVyVHJlZS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBjcmVhdGVNYWluUGFzczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvdXRwdXRUYXJnZXQgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0LmNhbnZhc1RhcmdldDtcclxuICAgICAgICBpZiAodGhpcy5fZW5hYmxlU1NBTykge1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25QYXNzID0gdGhpcy5jcmVhdGVWZXJ0ZXhBdHRyaWJ1dGVQYXNzKFwicmVuZGVyLXBvc2l0aW9uXCIpO1xyXG4gICAgICAgICAgICB2YXIgbm9ybWFsUGFzcyA9IHRoaXMuY3JlYXRlVmVydGV4QXR0cmlidXRlUGFzcyhcInJlbmRlci1ub3JtYWxcIik7XHJcbiAgICAgICAgICAgIHZhciBzc2FvUGFzcyA9IHRoaXMuY3JlYXRlU1NBT1Bhc3MocG9zaXRpb25QYXNzLm91dHB1dCwgbm9ybWFsUGFzcy5vdXRwdXQpO1xyXG4gICAgICAgICAgICBzc2FvUGFzcy5hZGRQcmVQYXNzKHBvc2l0aW9uUGFzcyk7XHJcbiAgICAgICAgICAgIHNzYW9QYXNzLmFkZFByZVBhc3Mobm9ybWFsUGFzcyk7XHJcbiAgICAgICAgICAgIHZhciBibHVyUGFzcyA9IHRoaXMuY3JlYXRlQmx1clBhc3Moc3Nhb1Bhc3Mub3V0cHV0KTtcclxuICAgICAgICAgICAgYmx1clBhc3MuYWRkUHJlUGFzcyhzc2FvUGFzcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JsdXJQYXNzID0gYmx1clBhc3M7XHJcbiAgICAgICAgICAgIHRoaXMuX3NzYW9QYXNzID0gc3Nhb1Bhc3M7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uUGFzcyA9IHBvc2l0aW9uUGFzcztcclxuICAgICAgICAgICAgdGhpcy5fbm9ybWFsUGFzcyA9IG5vcm1hbFBhc3M7XHJcbiAgICAgICAgICAgIHRoaXMubWFpblBhc3MgPSBuZXcgRm9yd2FyZFJlbmRlclBhc3ModGhpcy5yZW5kZXJJbnRlcmZhY2UsIG91dHB1dFRhcmdldCwge1xyXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Nhb01hcDogYmx1clBhc3Mub3V0cHV0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLm1haW5QYXNzLmFkZFByZVBhc3MoYmx1clBhc3MpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFpblBhc3MgPSBuZXcgRm9yd2FyZFJlbmRlclBhc3ModGhpcy5yZW5kZXJJbnRlcmZhY2UsIG91dHB1dFRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFpblJlbmRlclBhc3MgPSB0aGlzLm1haW5QYXNzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVWZXJ0ZXhBdHRyaWJ1dGVQYXNzOiBmdW5jdGlvbiAocHJvZ3JhbU5hbWUpIHtcclxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQ7XHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBHTFJlbmRlclRhcmdldChjb250ZXh0LCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBjb250ZXh0LmNhbnZhc1RhcmdldC53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBjb250ZXh0LmNhbnZhc1RhcmdldC5oZWlnaHQsXHJcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0OiBjb250ZXh0LmdsLlJHQkEsXHJcbiAgICAgICAgICAgIGNvbG9yVHlwZTogY29udGV4dC5nbC5GTE9BVCxcclxuICAgICAgICAgICAgZGVwdGhGb3JtYXQ6IGNvbnRleHQuZ2wuREVQVEhfQ09NUE9ORU5UMTYsXHJcbiAgICAgICAgICAgIHN0ZW5jaWxGb3JtYXQ6IG51bGwsXHJcbiAgICAgICAgICAgIGRlcHRoQXNSZW5kZXJidWZmZXI6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlcnRleEF0dHJpYnV0ZVBhc3ModGhpcy5yZW5kZXJJbnRlcmZhY2UsIGJ1ZmZlciwge1xyXG4gICAgICAgICAgICBwcm9ncmFtTmFtZTogcHJvZ3JhbU5hbWVcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlU1NBT1Bhc3M6IGZ1bmN0aW9uIChwb3NpdGlvbkJ1ZmZlciwgbm9ybWFsQnVmZmVyKSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0O1xyXG4gICAgICAgIHZhciBzc2FvQnVmZmVyID0gbmV3IEdMUmVuZGVyVGFyZ2V0KGNvbnRleHQsIHtcclxuICAgICAgICAgICAgd2lkdGg6IGNvbnRleHQuY2FudmFzVGFyZ2V0LndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGNvbnRleHQuY2FudmFzVGFyZ2V0LmhlaWdodCxcclxuICAgICAgICAgICAgY29sb3JGb3JtYXQ6IGNvbnRleHQuZ2wuUkdCQSxcclxuICAgICAgICAgICAgZGVwdGhGb3JtYXQ6IGNvbnRleHQuZ2wuREVQVEhfQ09NUE9ORU5UMTYsXHJcbiAgICAgICAgICAgIHN0ZW5jaWxGb3JtYXQ6IG51bGwsXHJcbiAgICAgICAgICAgIGRlcHRoQXNSZW5kZXJidWZmZXI6IHRydWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBTU0FPUGFzcyh0aGlzLnJlbmRlckludGVyZmFjZSwgc3Nhb0J1ZmZlciwge1xyXG4gICAgICAgICAgICBpbnB1dHM6IHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uQnVmZmVyOiBwb3NpdGlvbkJ1ZmZlciwgbm9ybWFsQnVmZmVyOiBub3JtYWxCdWZmZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVCbHVyUGFzczogZnVuY3Rpb24gKGlucHV0QnVmZmVyKSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0O1xyXG4gICAgICAgIHZhciBibHVyQnVmZmVyID0gbmV3IEdMUmVuZGVyVGFyZ2V0KGNvbnRleHQsIHtcclxuICAgICAgICAgICAgd2lkdGg6IGlucHV0QnVmZmVyLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGlucHV0QnVmZmVyLmhlaWdodCxcclxuICAgICAgICAgICAgY29sb3JGb3JtYXQ6IGNvbnRleHQuZ2wuUkdCQSxcclxuICAgICAgICAgICAgZGVwdGhGb3JtYXQ6IGNvbnRleHQuZ2wuREVQVEhfQ09NUE9ORU5UMTYsXHJcbiAgICAgICAgICAgIHN0ZW5jaWxGb3JtYXQ6IG51bGwsXHJcbiAgICAgICAgICAgIGRlcHRoQXNSZW5kZXJidWZmZXI6IHRydWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3hCbHVyUGFzcyh0aGlzLnJlbmRlckludGVyZmFjZSwgYmx1ckJ1ZmZlciwge1xyXG4gICAgICAgICAgICBpbnB1dHM6IHtcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcjogaW5wdXRCdWZmZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChzY2VuZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9lbmFibGVTU0FPKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uUGFzcy5zZXRQcm9jZXNzZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxQYXNzLnNldFByb2Nlc3NlZChmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NzYW9QYXNzLnNldFByb2Nlc3NlZChmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JsdXJQYXNzLnNldFByb2Nlc3NlZChmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFpblJlbmRlclBhc3Muc2V0UHJvY2Vzc2VkKGZhbHNlKTtcclxuICAgICAgICBCYXNlUmVuZGVyVHJlZS5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcywgc2NlbmUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRSZW5kZXJTdGF0czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1haW5QYXNzLmdldFJlbmRlclN0YXRzKCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGb3J3YXJkUmVuZGVyVHJlZTtcclxuXHJcbiIsInZhciBHTENvbnRleHQgPSByZXF1aXJlKFwiLi9iYXNlL2NvbnRleHQuanNcIik7XHJcbnZhciBHTFNjZW5lID0gcmVxdWlyZShcIi4vc2NlbmUvZ2xzY2VuZS5qc1wiKTtcclxudmFyIEdMU2NhbGVkUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZShcIi4vYmFzZS9yZW5kZXJ0YXJnZXQuanNcIikuR0xTY2FsZWRSZW5kZXJUYXJnZXQ7XHJcbnZhciBEYXRhQ2hhbmdlTGlzdGVuZXIgPSByZXF1aXJlKFwiLi4vcmVuZGVyZXIvdG9vbHMvZGF0YWNoYW5nZWxpc3RlbmVyLmpzXCIpO1xyXG52YXIgUmVuZGVySW50ZXJmYWNlID0gcmVxdWlyZShcIi4vcmVuZGVyLWludGVyZmFjZS5qc1wiKTtcclxudmFyIFBpY2tPYmplY3RSZW5kZXJQYXNzPSByZXF1aXJlKFwiLi9yZW5kZXItcGFzc2VzL3BpY2stb2JqZWN0LmpzXCIpO1xyXG52YXIgUGlja1Bvc2l0aW9uUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCIuL3JlbmRlci1wYXNzZXMvcGljay1wb3NpdGlvbi5qc1wiKTtcclxudmFyIFBpY2tOb3JtYWxSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vcmVuZGVyLXBhc3Nlcy9waWNrLW5vcm1hbC5qc1wiKTtcclxudmFyIEZvcndhcmRSZW5kZXJUcmVlID0gcmVxdWlyZShcIi4vcmVuZGVyLXRyZWVzL2ZvcndhcmQuanNcIik7XHJcbnZhciBHTFUgPSByZXF1aXJlKFwiLi4vLi4vY29udHJpYi9nbHUuanNcIik7XHJcbnZhciBPcHRpb25zID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL29wdGlvbnMuanNcIik7XHJcbnZhciB4bWwzZEZvcm1hdEhhbmRsZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9mb3JtYXRoYW5kbGVyLmpzXCIpLnhtbDNkRm9ybWF0SGFuZGxlcjtcclxudmFyIE1BWF9QSUNLX0JVRkZFUl9ESU1FTlNJT04gPSA1MTI7XHJcblxyXG52YXIgT1BUSU9OX1NTQU8gPSBcInJlbmRlcmVyLXNzYW9cIjtcclxudmFyIEZMQUdTID0ge307XHJcbkZMQUdTW09QVElPTl9TU0FPXSA9IHtkZWZhdWx0VmFsdWU6IGZhbHNlLCByZWNvbXBpbGVPbkNoYW5nZTogdHJ1ZX07XHJcbmZvciAodmFyIGZsYWcgaW4gRkxBR1MpIHtcclxuICAgIE9wdGlvbnMucmVnaXN0ZXIoZmxhZywgRkxBR1NbZmxhZ10uZGVmYXVsdFZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgdGhlIGdpdmVuIHktY29vcmRpbmF0ZSBvbiB0aGUgY2FudmFzIHRvIGEgeS1jb29yZGluYXRlIGFwcHJvcHJpYXRlIGluXHJcbiAqIHRoZSBHTCBjb250ZXh0LiBUaGUgeS1jb29yZGluYXRlIGdldHMgdHVybmVkIHVwc2lkZS1kb3duLiBUaGUgbG93ZXN0IHBvc3NpYmxlXHJcbiAqIGNhbnZhcyBjb29yZGluYXRlIGlzIDAsIHNvIHdlIG5lZWQgdG8gc3VidHJhY3QgMSBmcm9tIHRoZSBoZWlnaHQsIHRvby5cclxuICpcclxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGNvbnZlcnRlZCB5LWNvb3JkaW5hdGVcclxuICovXHJcbnZhciBjYW52YXNUb0dsWSA9IGZ1bmN0aW9uIChjYW52YXMsIHkpIHtcclxuICAgIHJldHVybiBjYW52YXMuaGVpZ2h0IC0geSAtIDE7XHJcbn07XHJcbi8qKlxyXG4gKiBAaW50ZXJmYWNlXHJcbiAqL1xyXG52YXIgSVJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuSVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUb0NhbnZhcyA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuSVJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVSZXNpemVFdmVudCA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbn07XHJcbklSZW5kZXJlci5wcm90b3R5cGUucmVxdWVzdFJlZHJhdyA9IGZ1bmN0aW9uIChyZWFzb24pIHtcclxufTtcclxuSVJlbmRlcmVyLnByb3RvdHlwZS5uZWVkc1JlZHJhdyA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuSVJlbmRlcmVyLnByb3RvdHlwZS5nZXRXb3JsZFNwYWNlTm9ybWFsQnlQb2ludCA9IGZ1bmN0aW9uIChvYmosIHgsIHkpIHtcclxufTtcclxuSVJlbmRlcmVyLnByb3RvdHlwZS5nZXRXb3JsZFNwYWNlUG9zaXRpb25CeVBvaW50ID0gZnVuY3Rpb24gKG9iaiwgeCwgeSkge1xyXG59O1xyXG5JUmVuZGVyZXIucHJvdG90eXBlLmdldFJlbmRlck9iamVjdEZyb21QaWNraW5nQnVmZmVyID0gZnVuY3Rpb24gKHgsIHkpIHtcclxufTtcclxuSVJlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZVJheSA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbn07XHJcbklSZW5kZXJlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIDx4bWwzZD4gRWxlbWVudFxyXG4gKiBAaW1wbGVtZW50cyB7SVJlbmRlcmVyfVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBHTFJlbmRlcmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNhbnZhc0hhbmRsZXIpIHtcclxuXHJcbiAgICB0aGlzLl9jYW52YXNIYW5kbGVyID0gY2FudmFzSGFuZGxlcjtcclxuICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXNIYW5kbGVyLmdldENhbnZhcygpO1xyXG4gICAgdGhpcy53aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcclxuXHJcbiAgICB0aGlzLmNvbnRleHQgPSBuZXcgR0xDb250ZXh0KGNhbnZhcywgdGhpcy5fY2FudmFzSGFuZGxlci5pZCk7XHJcbiAgICB0aGlzLnNjZW5lID0gbmV3IEdMU2NlbmUodGhpcy5jb250ZXh0KTtcclxuXHJcbiAgICB2YXIgZmFjdG9yeSA9IHhtbDNkRm9ybWF0SGFuZGxlci5nZXRGYWN0b3J5KFwid2ViZ2xcIiwgdGhpcy5fY2FudmFzSGFuZGxlci5pZCk7XHJcbiAgICBmYWN0b3J5LnNldFNjZW5lKHRoaXMuc2NlbmUpO1xyXG4gICAgZmFjdG9yeS5zZXRSZW5kZXJlcih0aGlzKTtcclxuXHJcbiAgICB2YXIgeG1sM2RBZGFwdGVyID0gZmFjdG9yeS5nZXRBZGFwdGVyKGVsZW1lbnQpO1xyXG4gICAgeG1sM2RBZGFwdGVyLnRyYXZlcnNlKGZ1bmN0aW9uICgpIHtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc2NlbmUucm9vdE5vZGUuc2V0VmlzaWJsZSh0cnVlKTtcclxuXHJcblxyXG4gICAgLyoqIEB0eXBlIHtSZW5kZXJPYmplY3R9ICovXHJcbiAgICB0aGlzLnBpY2tlZE9iamVjdCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5uZWVkc0RyYXcgPSB0cnVlO1xyXG4gICAgdGhpcy5uZWVkc1BpY2tpbmdEcmF3ID0gdHJ1ZTtcclxuICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0UmVkcmF3ID0gdGhpcy5yZXF1ZXN0UmVkcmF3LmJpbmQodGhpcyk7XHJcblxyXG4gICAgLy9DdXJyZW50bHkgdXNlZCBhcyBhIGhlbHBlciB0byBjYWxjdWxhdGUgdmlldyBhbmQgcHJvamVjdGlvbiBtYXRyaWNlcyBmb3IgcmF5IGNhc3RpbmcsIHNpbmNlIHRoZSBzY2VuZVxyXG4gICAgLy9tdXN0IGJlIHJlbmRlcmVkIGZyb20gdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhlIHJheVxyXG4gICAgdGhpcy5yYXlDYW1lcmEgPSB0aGlzLnNjZW5lLmNyZWF0ZVJlbmRlclZpZXcoKTtcclxuXHJcbiAgICB0aGlzLmluaXRHTCgpO1xyXG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IG5ldyBEYXRhQ2hhbmdlTGlzdGVuZXIodGhpcyk7XHJcblxyXG4gICAgdGhpcy5yZW5kZXJJbnRlcmZhY2UgPSB0aGlzLmNyZWF0ZVJlbmRlckludGVyZmFjZSgpO1xyXG4gICAgdGhpcy5jcmVhdGVEZWZhdWx0UGlwZWxpbmVzKCk7XHJcbiAgICBPcHRpb25zLmFkZE9ic2VydmVyKHRoaXMub25GbGFnc0NoYW5nZS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbi8vIEp1c3QgdG8gc2F0aXNmeSBqc2xpbnRcclxuR0xSZW5kZXJlci5wcm90b3R5cGUuZ2VuZXJhdGVSYXkgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcblxyXG5YTUwzRC5leHRlbmQoR0xSZW5kZXJlci5wcm90b3R5cGUsIHtcclxuICAgIGluaXRHTDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcclxuXHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcclxuICAgICAgICBnbC5jbGVhckRlcHRoKDEpO1xyXG4gICAgICAgIGdsLmNsZWFyU3RlbmNpbCgwKTtcclxuXHJcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgIGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpO1xyXG5cclxuICAgICAgICBnbC5mcm9udEZhY2UoZ2wuQ0NXKTtcclxuICAgICAgICBnbC5jdWxsRmFjZShnbC5CQUNLKTtcclxuICAgICAgICBnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XHJcblxyXG4gICAgICAgIGdsLmJsZW5kRXF1YXRpb24oZ2wuRlVOQ19BREQpO1xyXG4gICAgICAgIGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xyXG5cclxuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcblxyXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlBBQ0tfQUxJR05NRU5ULCAxKTtcclxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfQUxJR05NRU5ULCAxKTtcclxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcclxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGZhbHNlKTtcclxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCBnbC5CUk9XU0VSX0RFRkFVTFRfV0VCR0wpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaGFuZGxlUmVzaXplRXZlbnQ6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5oYW5kbGVSZXNpemVFdmVudCh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmNyZWF0ZURlZmF1bHRQaXBlbGluZXMoKTtcclxuICAgICAgICB0aGlzLnNjZW5lLmhhbmRsZVJlc2l6ZUV2ZW50KHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMubmVlZHNEcmF3ID0gdGhpcy5uZWVkc1BpY2tpbmdEcmF3ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlRGVmYXVsdFBpcGVsaW5lczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwaXBlbGluZSA9IG5ldyBGb3J3YXJkUmVuZGVyVHJlZSh0aGlzLnJlbmRlckludGVyZmFjZSwgT3B0aW9ucy5nZXRWYWx1ZShPUFRJT05fU1NBTykpO1xyXG4gICAgICAgIHRoaXMucmVuZGVySW50ZXJmYWNlLnNldFJlbmRlclBpcGVsaW5lKHBpcGVsaW5lKTtcclxuXHJcbiAgICAgICAgdmFyIHBpY2tUYXJnZXQgPSBuZXcgR0xTY2FsZWRSZW5kZXJUYXJnZXQodGhpcy5jb250ZXh0LCBNQVhfUElDS19CVUZGRVJfRElNRU5TSU9OLCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLmNvbnRleHQuY2FudmFzVGFyZ2V0LndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuY29udGV4dC5jYW52YXNUYXJnZXQuaGVpZ2h0LFxyXG4gICAgICAgICAgICBjb2xvckZvcm1hdDogdGhpcy5jb250ZXh0LmdsLlJHQkEsXHJcbiAgICAgICAgICAgIGRlcHRoRm9ybWF0OiB0aGlzLmNvbnRleHQuZ2wuREVQVEhfQ09NUE9ORU5UMTYsXHJcbiAgICAgICAgICAgIHN0ZW5jaWxGb3JtYXQ6IG51bGwsXHJcbiAgICAgICAgICAgIGRlcHRoQXNSZW5kZXJidWZmZXI6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnBpY2tPYmplY3RQYXNzID0gbmV3IFBpY2tPYmplY3RSZW5kZXJQYXNzKHRoaXMucmVuZGVySW50ZXJmYWNlLCBwaWNrVGFyZ2V0KTtcclxuICAgICAgICB0aGlzLnBpY2tQb3NpdGlvblBhc3MgPSBuZXcgUGlja1Bvc2l0aW9uUmVuZGVyUGFzcyh0aGlzLnJlbmRlckludGVyZmFjZSwgcGlja1RhcmdldCk7XHJcbiAgICAgICAgdGhpcy5waWNrTm9ybWFsUGFzcyA9IG5ldyBQaWNrTm9ybWFsUmVuZGVyUGFzcyh0aGlzLnJlbmRlckludGVyZmFjZSwgcGlja1RhcmdldCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVJlbmRlckludGVyZmFjZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVuZGVySW50ZXJmYWNlKHRoaXMuY29udGV4dCwgdGhpcy5zY2VuZSk7XHJcbiAgICAgICAgLy9UT0RPIG5lZWQgdG8gcHJvdmlkZSBhbiBpbnRlcmZhY2UgZm9yIGNyZWF0aW5nIHNoYWRlcnMsIGJ1ZmZlcnMgYW5kIHNvIG9uXHJcbiAgICB9LFxyXG5cclxuICAgIHJlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChyZWFzb24pIHtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIlJlcXVlc3QgcmVkcmF3IGJlY2F1c2U6XCIsIHJlYXNvbik7XHJcbiAgICAgICAgdGhpcy5uZWVkc0RyYXcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubmVlZHNQaWNraW5nRHJhdyA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFdvcmxkU3BhY2VOb3JtYWxCeVBvaW50OiBmdW5jdGlvbiAoeCwgeSwgb2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IG9iamVjdCB8fCB0aGlzLnBpY2tlZE9iamVjdDtcclxuICAgICAgICBpZiAoIW9iailcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgeSA9IGNhbnZhc1RvR2xZKHRoaXMuX2NhbnZhc0hhbmRsZXIuZ2V0Q2FudmFzKCksIHkpO1xyXG4gICAgICAgIHRoaXMucGlja05vcm1hbFBhc3MucmVuZGVyKG9iaik7XHJcbiAgICAgICAgdGhpcy5uZWVkc1BpY2tpbmdEcmF3ID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5waWNrTm9ybWFsUGFzcy5yZWFkTm9ybWFsRnJvbVBpY2tpbmdCdWZmZXIoeCwgeSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFdvcmxkU3BhY2VQb3NpdGlvbkJ5UG9pbnQ6IGZ1bmN0aW9uICh4LCB5LCBvYmplY3QpIHtcclxuICAgICAgICB2YXIgb2JqID0gb2JqZWN0IHx8IHRoaXMucGlja2VkT2JqZWN0O1xyXG4gICAgICAgIGlmICghb2JqKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB5ID0gY2FudmFzVG9HbFkodGhpcy5fY2FudmFzSGFuZGxlci5nZXRDYW52YXMoKSwgeSk7XHJcbiAgICAgICAgdGhpcy5waWNrUG9zaXRpb25QYXNzLnJlbmRlcihvYmopO1xyXG4gICAgICAgIHRoaXMubmVlZHNQaWNraW5nRHJhdyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja1Bvc2l0aW9uUGFzcy5yZWFkUG9zaXRpb25Gcm9tUGlja2luZ0J1ZmZlcih4LCB5KTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UmVuZGVyT2JqZWN0QnlSYXk6IGZ1bmN0aW9uICh4bWwzZFJheSwgdmlld01hdCwgcHJvak1hdCkge1xyXG4gICAgICAgIHZhciBpbnRlcnNlY3RlZE9iamVjdHMgPSB0aGlzLnNjZW5lLmZpbmRSYXlJbnRlcnNlY3Rpb25zKHhtbDNkUmF5KTtcclxuICAgICAgICB0aGlzLnBpY2tPYmplY3RQYXNzLnJlbmRlcihpbnRlcnNlY3RlZE9iamVjdHMsIHZpZXdNYXQsIHByb2pNYXQpO1xyXG4gICAgICAgIC8vVGFyZ2V0IHRoZSBtaWRkbGUgb2YgdGhlIGJ1ZmZlclxyXG4gICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcih0aGlzLnBpY2tPYmplY3RQYXNzLm91dHB1dC5nZXRXaWR0aCgpIC8gMiAvIHRoaXMucGlja09iamVjdFBhc3Mub3V0cHV0LmdldFNjYWxlKCkpO1xyXG4gICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcih0aGlzLnBpY2tPYmplY3RQYXNzLm91dHB1dC5nZXRIZWlnaHQoKSAvIDIgLyB0aGlzLnBpY2tPYmplY3RQYXNzLm91dHB1dC5nZXRTY2FsZSgpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5waWNrT2JqZWN0UGFzcy5nZXRSZW5kZXJPYmplY3RGcm9tUGlja2luZ0J1ZmZlcih4LCB5LCBpbnRlcnNlY3RlZE9iamVjdHMpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0V29ybGRTcGFjZU5vcm1hbEJ5UmF5OiBmdW5jdGlvbiAocmF5LCBpbnRlcnNlY3RlZE9iamVjdCwgdmlld01hdCwgcHJvak1hdCkge1xyXG4gICAgICAgIGlmICghaW50ZXJzZWN0ZWRPYmplY3QpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIHRoaXMucGlja05vcm1hbFBhc3MucmVuZGVyKGludGVyc2VjdGVkT2JqZWN0LCB2aWV3TWF0LCBwcm9qTWF0KTtcclxuICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IodGhpcy5waWNrTm9ybWFsUGFzcy5vdXRwdXQuZ2V0V2lkdGgoKSAvIDIgLyB0aGlzLnBpY2tOb3JtYWxQYXNzLm91dHB1dC5nZXRTY2FsZSgpKTtcclxuICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IodGhpcy5waWNrTm9ybWFsUGFzcy5vdXRwdXQuZ2V0SGVpZ2h0KCkgLyAyIC8gdGhpcy5waWNrTm9ybWFsUGFzcy5vdXRwdXQuZ2V0U2NhbGUoKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja05vcm1hbFBhc3MucmVhZE5vcm1hbEZyb21QaWNraW5nQnVmZmVyKHgsIHkpO1xyXG5cclxuICAgIH0sIGdldFdvcmxkU3BhY2VQb3NpdGlvbkJ5UmF5OiBmdW5jdGlvbiAocmF5LCBpbnRlcnNlY3RlZE9iamVjdCwgdmlld01hdCwgcHJvak1hdCkge1xyXG4gICAgICAgIGlmICghaW50ZXJzZWN0ZWRPYmplY3QpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIHRoaXMucGlja1Bvc2l0aW9uUGFzcy5yZW5kZXIoaW50ZXJzZWN0ZWRPYmplY3QsIHZpZXdNYXQsIHByb2pNYXQpO1xyXG4gICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcih0aGlzLnBpY2tQb3NpdGlvblBhc3Mub3V0cHV0LmdldFdpZHRoKCkgLyAyIC8gdGhpcy5waWNrUG9zaXRpb25QYXNzLm91dHB1dC5nZXRTY2FsZSgpKTtcclxuICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IodGhpcy5waWNrUG9zaXRpb25QYXNzLm91dHB1dC5nZXRIZWlnaHQoKSAvIDIgLyB0aGlzLnBpY2tQb3NpdGlvblBhc3Mub3V0cHV0LmdldFNjYWxlKCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tQb3NpdGlvblBhc3MucmVhZFBvc2l0aW9uRnJvbVBpY2tpbmdCdWZmZXIoeCwgeSk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjYWxjdWxhdGVNYXRyaWNlc0ZvclJheTogZnVuY3Rpb24gKHJheSwgdmlld01hdCwgcHJvak1hdCkge1xyXG4gICAgICAgIHRoaXMucmF5Q2FtZXJhLnVwZGF0ZVBvc2l0aW9uKHJheS5vcmlnaW4uX2RhdGEpO1xyXG4gICAgICAgIHRoaXMucmF5Q2FtZXJhLnVwZGF0ZU9yaWVudGF0aW9uKHRoaXMuY2FsY3VsYXRlT3JpZW50YXRpb25Gb3JSYXlEaXJlY3Rpb24ocmF5KSk7XHJcbiAgICAgICAgdGhpcy5yYXlDYW1lcmEuZ2V0V29ybGRUb1ZpZXdNYXRyaXgodmlld01hdCk7XHJcbiAgICAgICAgdmFyIGFzcGVjdCA9IHRoaXMucGlja09iamVjdFBhc3Mub3V0cHV0LmdldFdpZHRoKCkgLyB0aGlzLnBpY2tPYmplY3RQYXNzLm91dHB1dC5nZXRIZWlnaHQoKTtcclxuICAgICAgICB0aGlzLnJheUNhbWVyYS5nZXRQcm9qZWN0aW9uTWF0cml4KHByb2pNYXQsIGFzcGVjdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNhbGN1bGF0ZU9yaWVudGF0aW9uRm9yUmF5RGlyZWN0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0bXBYID0gWE1MM0QubWF0aC52ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciB0bXBZID0gWE1MM0QubWF0aC52ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciB0bXBaID0gWE1MM0QubWF0aC52ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciB1cCA9IFhNTDNELm1hdGgudmVjMy5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgcSA9IFhNTDNELm1hdGgucXVhdC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgbSA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyYXkpIHtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC52ZWMzLnNldCh1cCwgMCwgMSwgMCk7XHJcbiAgICAgICAgICAgIFhNTDNELm1hdGgudmVjMy5jcm9zcyh0bXBYLCByYXkuZGlyZWN0aW9uLl9kYXRhLCB1cCk7XHJcbiAgICAgICAgICAgIGlmICghWE1MM0QubWF0aC52ZWMzLmxlbmd0aCh0bXBYKSkge1xyXG4gICAgICAgICAgICAgICAgWE1MM0QubWF0aC52ZWMzLnNldCh0bXBYLCAxLCAwLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLnZlYzMuY3Jvc3ModG1wWSwgdG1wWCwgcmF5LmRpcmVjdGlvbi5fZGF0YSk7XHJcbiAgICAgICAgICAgIFhNTDNELm1hdGgudmVjMy5uZWdhdGUodG1wWiwgcmF5LmRpcmVjdGlvbi5fZGF0YSk7XHJcblxyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLnF1YXQuc2V0RnJvbUJhc2lzKHRtcFgsIHRtcFksIHRtcFosIHEpO1xyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24obSwgcSwgWzAsIDAsIDBdKTtcclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG4gICAgfSkoKSxcclxuXHJcbiAgICBuZWVkc1JlZHJhdzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5lZWRzRHJhdztcclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyVG9DYW52YXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm5lZWRzRHJhdyA9IGZhbHNlOyAvL1NldCB0aGlzIGVhcmx5IHRvIGF2b2lkIGVuZGxlc3MgcmVuZGVyaW5nIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZHVyaW5nIHJlbmRlcmluZ1xyXG4gICAgICAgIHRoaXMucHJlcGFyZVJlbmRlcmluZygpO1xyXG4gICAgICAgIHRoaXMucmVuZGVySW50ZXJmYWNlLmdldFJlbmRlclBpcGVsaW5lKCkucmVuZGVyKHRoaXMuc2NlbmUpO1xyXG4gICAgICAgIHZhciBzdGF0cyA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmdldFJlbmRlclBpcGVsaW5lKCkuZ2V0UmVuZGVyU3RhdHMoKTtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIlJlbmRlcmVkIHRvIENhbnZhc1wiKTtcclxuICAgICAgICByZXR1cm4gc3RhdHM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFJlbmRlck9iamVjdEZyb21QaWNraW5nQnVmZmVyOiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgIHkgPSBjYW52YXNUb0dsWSh0aGlzLl9jYW52YXNIYW5kbGVyLmdldENhbnZhcygpLCB5KTtcclxuICAgICAgICBpZiAodGhpcy5uZWVkc1BpY2tpbmdEcmF3KSB7XHJcbiAgICAgICAgICAgIHRoaXMubmVlZHNQaWNraW5nRHJhdyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnByZXBhcmVSZW5kZXJpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS51cGRhdGVSZWFkeU9iamVjdHNGcm9tQWN0aXZlVmlldyh0aGlzLnBpY2tPYmplY3RQYXNzLm91dHB1dC5nZXRXaWR0aCgpIC8gdGhpcy5waWNrT2JqZWN0UGFzcy5vdXRwdXQuZ2V0SGVpZ2h0KCkpO1xyXG4gICAgICAgICAgICB0aGlzLnBpY2tPYmplY3RQYXNzLnJlbmRlcih0aGlzLnNjZW5lLnJlYWR5KTtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJSZW5kZXJlZCBQaWNraW5nIEJ1ZmZlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5waWNrZWRPYmplY3QgPSB0aGlzLnBpY2tPYmplY3RQYXNzLmdldFJlbmRlck9iamVjdEZyb21QaWNraW5nQnVmZmVyKHgsIHksIHRoaXMuc2NlbmUucmVhZHkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tlZE9iamVjdDtcclxuICAgIH0sXHJcblxyXG4gICAgcHJlcGFyZVJlbmRlcmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2NlbmUudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlcyBnbHVVblByb2plY3QoKSB0byB0cmFuc2Zvcm0gdGhlIDJEIHNjcmVlbiBwb2ludCB0byBhIDNEIHJheS5cclxuICAgICAqIE5vdCB0ZXN0ZWQhIVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNYXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2FudmFzWVxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZVJheTogKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGNfdmlld01hdHJpeCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY19wcm9qZWN0aW9uTWF0cml4ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNhbnZhc1gsIGNhbnZhc1kpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBnbFkgPSBjYW52YXNUb0dsWSh0aGlzLl9jYW52YXNIYW5kbGVyLmdldENhbnZhcygpLCBjYW52YXNZKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNldHVwIGlucHV0IHRvIHVucHJvamVjdFxyXG4gICAgICAgICAgICB2YXIgdmlld3BvcnQgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgdmlld3BvcnRbMF0gPSAwO1xyXG4gICAgICAgICAgICB2aWV3cG9ydFsxXSA9IDA7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0WzJdID0gdGhpcy53aWR0aDtcclxuICAgICAgICAgICAgdmlld3BvcnRbM10gPSB0aGlzLmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIC8vIGdldCB2aWV3IGFuZCBwcm9qZWN0aW9uIG1hdHJpeCBhcnJheXNcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnNjZW5lLmdldEFjdGl2ZVZpZXcoKTtcclxuICAgICAgICAgICAgdmlldy5nZXRXb3JsZFRvVmlld01hdHJpeChjX3ZpZXdNYXRyaXgpO1xyXG4gICAgICAgICAgICB2aWV3LmdldFByb2plY3Rpb25NYXRyaXgoY19wcm9qZWN0aW9uTWF0cml4LCB2aWV3cG9ydFsyXSAvIHZpZXdwb3J0WzNdKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByYXkgPSBuZXcgd2luZG93LlhNTDNEUmF5KCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmVhckhpdCA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICB2YXIgZmFySGl0ID0gbmV3IEFycmF5KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBkbyB1bnByb2plY3Rpb25zXHJcbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gR0xVLnVuUHJvamVjdChjYW52YXNYLCBnbFksIDAsIGNfdmlld01hdHJpeCwgY19wcm9qZWN0aW9uTWF0cml4LCB2aWV3cG9ydCwgbmVhckhpdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gR0xVLnVuUHJvamVjdChjYW52YXNYLCBnbFksIDEsIGNfdmlld01hdHJpeCwgY19wcm9qZWN0aW9uTWF0cml4LCB2aWV3cG9ydCwgZmFySGl0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJheTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJheVxyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQuaW52ZXJ0KGNfdmlld01hdHJpeCwgY192aWV3TWF0cml4KTtcclxuICAgICAgICAgICAgdmFyIHZpZXdQb3MgPSBuZXcgd2luZG93LlhNTDNEVmVjMyhjX3ZpZXdNYXRyaXhbMTJdLCBjX3ZpZXdNYXRyaXhbMTNdLCBjX3ZpZXdNYXRyaXhbMTRdKTtcclxuXHJcbiAgICAgICAgICAgIHJheS5vcmlnaW4uc2V0KHZpZXdQb3MpO1xyXG4gICAgICAgICAgICByYXkuZGlyZWN0aW9uLnNldChmYXJIaXRbMF0gLSBuZWFySGl0WzBdLCBmYXJIaXRbMV0gLSBuZWFySGl0WzFdLCBmYXJIaXRbMl0gLSBuZWFySGl0WzJdKTtcclxuICAgICAgICAgICAgcmF5LmRpcmVjdGlvbi5zZXQocmF5LmRpcmVjdGlvbi5ub3JtYWxpemUoKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmF5O1xyXG4gICAgICAgIH1cclxuICAgIH0oKSksXHJcblxyXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2NlbmUuY2xlYXIoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UmVuZGVySW50ZXJmYWNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVySW50ZXJmYWNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkZsYWdzQ2hhbmdlOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgaWYgKGtleSA9PSBPUFRJT05fU1NBTykge1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLnNoYWRlckZhY3Rvcnkuc2V0U2hhZGVyUmVjb21waWxlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRGVmYXVsdFBpcGVsaW5lcygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdMUmVuZGVyZXI7XHJcbiIsInZhciBYZmxvd01lc2ggPSByZXF1aXJlKFwiLi4veGZsb3cveGZsb3ctbWVzaC5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBEcmF3YWJsZUZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcblhNTDNELmV4dGVuZChEcmF3YWJsZUZhY3RvcnkucHJvdG90eXBlLCB7XHJcbiAgICBjcmVhdGVEcmF3YWJsZTogZnVuY3Rpb24gKG9iaiwgY29udGV4dCkge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiRHJhd2FibGVGYWN0b3J5OjpjcmVhdGVEcmF3YWJsZVwiLCBvYmopO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgWGZsb3dNZXNoKGNvbnRleHQsIG9iai5nZXREYXRhTm9kZSgpLCBvYmouZ2V0VHlwZSgpLCB7Ym91bmRpbmdCb3hDaGFuZ2VkOiBvYmouc2V0T2JqZWN0U3BhY2VCb3VuZGluZ0JveC5iaW5kKG9iail9KTtcclxuICAgICAgICAgICAgb2JqLm1lc2ggPSByZXN1bHQuZ2V0TWVzaCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoZSwgb2JqLm5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEcmF3YWJsZUZhY3Rvcnk7XHJcblxyXG5cclxuIiwidmFyIGxpZ2h0TW9kZWxzID0ge1xyXG4gICAgcG9pbnQ6IHtcclxuICAgICAgICBwYXJhbWV0ZXJzOiBbIFwicG9pbnRMaWdodFBvc2l0aW9uXCIsIFwicG9pbnRMaWdodEF0dGVudWF0aW9uXCIsIFwicG9pbnRMaWdodEludGVuc2l0eVwiLCBcInBvaW50TGlnaHRPblwiLCBcInBvaW50TGlnaHRDYXN0U2hhZG93XCIsIFwicG9pbnRMaWdodE1hdHJpeFwiLCBcInBvaW50TGlnaHRTaGFkb3dCaWFzXCIsIFwicG9pbnRMaWdodE5lYXJGYXJcIiwgXCJwb2ludExpZ2h0U2hhZG93TWFwXCJdXHJcbiAgICB9LFxyXG4gICAgZGlyZWN0aW9uYWw6IHtcclxuICAgICAgICBwYXJhbWV0ZXJzOiBbXCJkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uXCIsIFwiZGlyZWN0aW9uYWxMaWdodEludGVuc2l0eVwiLCBcImRpcmVjdGlvbmFsTGlnaHRPblwiLCBcImRpcmVjdGlvbmFsTGlnaHRDYXN0U2hhZG93XCIsIFwiZGlyZWN0aW9uYWxMaWdodE1hdHJpeFwiLCBcImRpcmVjdGlvbmFsTGlnaHRTaGFkb3dCaWFzXCIsIFwiZGlyZWN0aW9uYWxMaWdodFNoYWRvd01hcFwiXVxyXG4gICAgfSxcclxuICAgIHNwb3Q6IHtcclxuICAgICAgICBwYXJhbWV0ZXJzOiBbXCJzcG90TGlnaHRBdHRlbnVhdGlvblwiLCBcInNwb3RMaWdodFBvc2l0aW9uXCIsIFwic3BvdExpZ2h0SW50ZW5zaXR5XCIsIFwic3BvdExpZ2h0RGlyZWN0aW9uXCIsIFwic3BvdExpZ2h0T25cIiwgXCJzcG90TGlnaHRTb2Z0bmVzc1wiLCBcInNwb3RMaWdodENvc0ZhbGxvZmZBbmdsZVwiLCBcInNwb3RMaWdodENvc1NvZnRGYWxsb2ZmQW5nbGVcIiwgXCJzcG90TGlnaHRDYXN0U2hhZG93XCIsIFwic3BvdExpZ2h0TWF0cml4XCIsIFwic3BvdExpZ2h0U2hhZG93Qmlhc1wiLCBcInNwb3RMaWdodFNoYWRvd01hcFwiXVxyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIEFMTF9QQVJBTUVURVJTID0gbGlnaHRNb2RlbHMucG9pbnQucGFyYW1ldGVycy5jb25jYXQobGlnaHRNb2RlbHMuZGlyZWN0aW9uYWwucGFyYW1ldGVycykuY29uY2F0KGxpZ2h0TW9kZWxzLnNwb3QucGFyYW1ldGVycyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEFMTF9QQVJBTUVURVJTOiBBTExfUEFSQU1FVEVSU1xyXG59O1xyXG4iLCJ2YXIgU2NlbmUgPSByZXF1aXJlKFwiLi8uLi8uLi9yZW5kZXJlci9zY2VuZS9zY2VuZS5qc1wiKTtcclxudmFyIERyYXdhYmxlRmFjdG9yeSA9IHJlcXVpcmUoXCIuL2RyYXdhYmxlLWZhY3RvcnkuanNcIik7XHJcbnZhciBDID0gcmVxdWlyZShcIi4vLi4vLi4vcmVuZGVyZXIvc2NlbmUvY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgRnJ1c3R1bVRlc3QgPSByZXF1aXJlKFwiLi8uLi8uLi9yZW5kZXJlci90b29scy9mcnVzdHVtLmpzXCIpLkZydXN0dW1UZXN0O1xyXG52YXIgU2hhZGVyQ29tcG9zZXJGYWN0b3J5ID0gcmVxdWlyZShcIi4uL21hdGVyaWFscy9zaGFkZXJjb21wb3NlcmZhY3RvcnkuanNcIik7XHJcbnZhciBPcHRpb25zID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL29wdGlvbnMuanNcIik7XHJcbnZhciBTaGFkb3dNYXBTZXJ2aWNlID0gcmVxdWlyZShcIi4uL21hdGVyaWFscy9zaGFkb3dtYXAtc2VydmljZVwiKTtcclxuXHJcbnZhciBPUFRJT05fRlJVU1RVTV9DVUxMSU5HID0gXCJyZW5kZXJlci1mcnVzdHVtQ3VsbGluZ1wiO1xyXG52YXIgT1BUSU9OX1NIQURFSlNfRVhUUkFDVF9VTklGT1JNUyA9IFwic2hhZGVqcy1leHRyYWN0VW5pZm9ybUV4cHJlc3Npb25zXCI7XHJcbnZhciBPUFRJT05fU0hBREVKU19UUkFOU0ZPUk1fU1BBQ0VTID0gXCJzaGFkZWpzLXRyYW5zZm9ybVNwYWNlc1wiO1xyXG52YXIgT1BUSU9OX1NIQURFSlNfQ0FDSEUgPSBcInNoYWRlanMtY2FjaGVcIjtcclxuXHJcblxyXG4vLyBBbGwgdGhlIHNoYWRlciBmbGFnc1xyXG52YXIgRkxBR1MgPSB7fTtcclxuRkxBR1NbT1BUSU9OX1NIQURFSlNfRVhUUkFDVF9VTklGT1JNU10gPSB7ZGVmYXVsdFZhbHVlOiBmYWxzZSwgcmVjb21waWxlT25DaGFuZ2U6IHRydWV9O1xyXG5GTEFHU1tPUFRJT05fU0hBREVKU19UUkFOU0ZPUk1fU1BBQ0VTXSA9IHtkZWZhdWx0VmFsdWU6IHRydWUsIHJlY29tcGlsZU9uQ2hhbmdlOiB0cnVlfTtcclxuRkxBR1NbT1BUSU9OX0ZSVVNUVU1fQ1VMTElOR10gPSB7ZGVmYXVsdFZhbHVlOiB0cnVlLCByZWNvbXBpbGVPbkNoYW5nZTogZmFsc2V9O1xyXG5GTEFHU1tPUFRJT05fU0hBREVKU19DQUNIRV0gPSB7ZGVmYXVsdFZhbHVlOiB0cnVlLCByZWNvbXBpbGVPbkNoYW5nZTogZmFsc2V9O1xyXG5cclxuZm9yICh2YXIgZmxhZyBpbiBGTEFHUykge1xyXG4gICAgT3B0aW9ucy5yZWdpc3RlcihmbGFnLCBGTEFHU1tmbGFnXS5kZWZhdWx0VmFsdWUpO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XHJcbiAqIEBleHRlbmRzIHtTY2VuZX1cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgR0xTY2VuZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICBTY2VuZS5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIHRoaXMuc2hhZGVyRmFjdG9yeSA9IG5ldyBTaGFkZXJDb21wb3NlckZhY3RvcnkoY29udGV4dCk7XHJcbiAgICB0aGlzLmRyYXdhYmxlRmFjdG9yeSA9IG5ldyBEcmF3YWJsZUZhY3RvcnkoKTtcclxuXHJcbiAgICB0aGlzLnNoYWRvd01hcFNlcnZpY2UgPSBuZXcgU2hhZG93TWFwU2VydmljZShjb250ZXh0LCB0aGlzKTtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0FycmF5LjxSZW5kZXJPYmplY3Q+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlYWR5ID0gW107XHJcbiAgICB0aGlzLnF1ZXVlID0gW107XHJcbiAgICB0aGlzLmxpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xyXG4gICAgdGhpcy5zeXN0ZW1Vbmlmb3JtcyA9IHt9O1xyXG4gICAgdGhpcy5kZWZlcnJlZCA9IHdpbmRvd1snWE1MM0RfREVGRVJSRUQnXSB8fCBmYWxzZTtcclxuICAgIHRoaXMuY29sb3JDbG9zdXJlU2lnbmF0dXJlcyA9IFtdO1xyXG4gICAgdGhpcy5kb0ZydXN0dW1DdWxsaW5nID0gISFPcHRpb25zLmdldFZhbHVlKE9QVElPTl9GUlVTVFVNX0NVTExJTkcpO1xyXG4gICAgdGhpcy5hZGRMaXN0ZW5lcnMoKTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKEdMU2NlbmUsIFNjZW5lKTtcclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVNhZmUoYXJyLCBvYmopIHtcclxuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKG9iaik7XHJcbiAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuWE1MM0QuZXh0ZW5kKEdMU2NlbmUucHJvdG90eXBlLCB7XHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZW1vdmVTYWZlKHRoaXMucXVldWUsIG9iaik7XHJcbiAgICAgICAgcmVtb3ZlU2FmZSh0aGlzLnJlYWR5LCBvYmopO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVhZHkgPSBbXTtcclxuICAgICAgICB0aGlzLnF1ZXVlID0gW107XHJcbiAgICB9LFxyXG5cclxuICAgIG1vdmVGcm9tUXVldWVUb1JlYWR5OiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgaWYgKHJlbW92ZVNhZmUodGhpcy5xdWV1ZSwgb2JqKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWR5LnB1c2gob2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1vdmVGcm9tUmVhZHlUb1F1ZXVlOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgaWYgKHJlbW92ZVNhZmUodGhpcy5yZWFkeSwgb2JqKSkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gob2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxpZ2h0c05lZWRVcGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5saWdodHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGlnaHRQYXJhbWV0ZXJzKCk7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHRzLmxpZ2h0VmFsdWVDaGFuZ2VkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlT2JqZWN0c0ZvclJlbmRlcmluZygpO1xyXG5cclxuICAgICAgICAvLyBSZW5kZXIgc2hhZG93IG1hcHMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgdGhpcy5zaGFkb3dNYXBTZXJ2aWNlLnVwZGF0ZUZvclJlbmRlcmluZygpO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBzaGFkZXJzIGFyZSB1cGRhdGVzIEFGVEVSIG9iamVjdHNcclxuICAgICAgICAvLyBCZWNhdXNlIHVudXNlZCBzaGFkZXIgY2xvc3VyZXMgYXJlIGNsZWFyZWQgb24gdXBkYXRlXHJcbiAgICAgICAgdGhpcy51cGRhdGVTaGFkZXJzKCk7XHJcbiAgICB9LCB1cGRhdGVMaWdodFBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMuc3lzdGVtVW5pZm9ybXM7XHJcblxyXG4gICAgICAgIHRoaXMubGlnaHRzLmZpbGxHbG9iYWxQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuc2hhZG93TWFwU2VydmljZS5maWxsR2xvYmFsUGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcclxuXHJcbiAgICAgICAgLy8gRGVyaXZlZCBwYXJhbWV0ZXJzIHRoYXQgYXJlIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLlxyXG4gICAgICAgIC8vIFRPRE86IFB1dCB0aG9zZSB0byBhbiBhcHByb3ByaWF0ZSBwbGFjZVxyXG4gICAgICAgIHZhciBzcG90TGlnaHRGYWxsb2ZmQW5nbGUgPSBwYXJhbWV0ZXJzW1wic3BvdExpZ2h0RmFsbG9mZkFuZ2xlXCJdO1xyXG4gICAgICAgIHZhciBzcG90TGlnaHRTb2Z0bmVzcyA9IHBhcmFtZXRlcnNbXCJzcG90TGlnaHRTb2Z0bmVzc1wiXTtcclxuICAgICAgICBpZihzcG90TGlnaHRGYWxsb2ZmQW5nbGUpIHtcclxuICAgICAgICAgICAgLy8gTWFwIGJvdGggcGFyYW1ldGVycyBpbnRvIGNvc2ludXMgc3BhY2VcclxuICAgICAgICAgICAgdmFyIHNwb3RMaWdodENvc1NvZnRGYWxsb2ZmQW5nbGUgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHNwb3RMaWdodENvc0ZhbGxvZmZBbmdsZSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwb3RMaWdodEZhbGxvZmZBbmdsZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3BvdExpZ2h0Q29zRmFsbG9mZkFuZ2xlW2ldID0gTWF0aC5jb3Moc3BvdExpZ2h0RmFsbG9mZkFuZ2xlW2ldKTtcclxuICAgICAgICAgICAgICAgIHNwb3RMaWdodENvc1NvZnRGYWxsb2ZmQW5nbGVbaV0gPSBNYXRoLmNvcyhzcG90TGlnaHRGYWxsb2ZmQW5nbGVbaV0gKiAoMS4wIC0gc3BvdExpZ2h0U29mdG5lc3NbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJhbWV0ZXJzW1wic3BvdExpZ2h0Q29zRmFsbG9mZkFuZ2xlXCJdID0gc3BvdExpZ2h0Q29zRmFsbG9mZkFuZ2xlO1xyXG4gICAgICAgICAgICBwYXJhbWV0ZXJzW1wic3BvdExpZ2h0Q29zU29mdEZhbGxvZmZBbmdsZVwiXSA9IHNwb3RMaWdodENvc1NvZnRGYWxsb2ZmQW5nbGU7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVN5c3RlbVVuaWZvcm1zOiBmdW5jdGlvbiAobmFtZXMpIHtcclxuICAgICAgICB0aGlzLnNoYWRlckZhY3RvcnkudXBkYXRlU3lzdGVtVW5pZm9ybXMobmFtZXMsIHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVTaGFkZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zaGFkZXJGYWN0b3J5LnVwZGF0ZSh0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlT2JqZWN0c0ZvclJlbmRlcmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIG9iai51cGRhdGVGb3JSZW5kZXJpbmcoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gKGZ1bmMsIHRoYXQpIHtcclxuICAgICAgICB0aGlzLnF1ZXVlLnNsaWNlKCkuZm9yRWFjaChmdW5jLCB0aGF0KTtcclxuICAgICAgICB0aGlzLnJlYWR5LnNsaWNlKCkuZm9yRWFjaChmdW5jLCB0aGF0KTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlUmVhZHlPYmplY3RzRnJvbUFjdGl2ZVZpZXc6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNfd29ybGRUb1ZpZXdNYXRyaXggPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfdmlld1RvV29ybGRNYXRyaXggPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfcHJvak1hdF90bXAgPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfYmJveCA9IFhNTDNELm1hdGguYmJveC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY19mcnVzdHVtVGVzdCA9IG5ldyBGcnVzdHVtVGVzdCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFzcGVjdFJhdGlvKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3RpdmVWaWV3ID0gdGhpcy5nZXRBY3RpdmVWaWV3KCksIHJlYWR5T2JqZWN0cyA9IHRoaXMucmVhZHk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxsIE1WIG1hdHJpY2VzXHJcbiAgICAgICAgICAgIGFjdGl2ZVZpZXcuZ2V0V29ybGRUb1ZpZXdNYXRyaXgoY193b3JsZFRvVmlld01hdHJpeCk7XHJcbiAgICAgICAgICAgIHJlYWR5T2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgIG9iai51cGRhdGVNb2RlbFZpZXdNYXRyaXgoY193b3JsZFRvVmlld01hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICBvYmoudXBkYXRlTW9kZWxNYXRyaXhOKCk7XHJcbiAgICAgICAgICAgICAgICBvYmoudXBkYXRlTW9kZWxWaWV3TWF0cml4TigpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goKTtcclxuXHJcblxyXG4gICAgICAgICAgICBhY3RpdmVWaWV3LmdldFByb2plY3Rpb25NYXRyaXgoY19wcm9qTWF0X3RtcCwgYXNwZWN0UmF0aW8pO1xyXG4gICAgICAgICAgICBhY3RpdmVWaWV3LmdldFZpZXdUb1dvcmxkTWF0cml4KGNfdmlld1RvV29ybGRNYXRyaXgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGZydXN0dW0gPSBhY3RpdmVWaWV3LmdldEZydXN0dW0oKTtcclxuICAgICAgICAgICAgY19mcnVzdHVtVGVzdC5zZXQoZnJ1c3R1bSwgY192aWV3VG9Xb3JsZE1hdHJpeCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlYWR5T2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYmogPSByZWFkeU9iamVjdHNbaV07XHJcbiAgICAgICAgICAgICAgICBvYmoudXBkYXRlTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeChjX3Byb2pNYXRfdG1wKTtcclxuICAgICAgICAgICAgICAgIG9iai5nZXRXb3JsZFNwYWNlQm91bmRpbmdCb3goY19iYm94KTtcclxuICAgICAgICAgICAgICAgIG9iai5pbkZydXN0dW0gPSB0aGlzLmRvRnJ1c3R1bUN1bGxpbmcgPyBjX2ZydXN0dW1UZXN0LmlzQm94VmlzaWJsZShjX2Jib3gpIDogdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0oKSksXHJcbiAgICB1cGRhdGVSZWFkeU9iamVjdHNGcm9tTWF0cmljZXM6IGZ1bmN0aW9uICh3b3JsZFRvVmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeCkge1xyXG4gICAgICAgIHZhciByZWFkeU9iamVjdHMgPSB0aGlzLnJlYWR5O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVhZHlPYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gcmVhZHlPYmplY3RzW2ldO1xyXG4gICAgICAgICAgICBvYmoudXBkYXRlTW9kZWxWaWV3TWF0cml4KHdvcmxkVG9WaWV3TWF0cml4KTtcclxuICAgICAgICAgICAgb2JqLnVwZGF0ZU1vZGVsTWF0cml4TigpO1xyXG4gICAgICAgICAgICBvYmoudXBkYXRlTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeChwcm9qZWN0aW9uTWF0cml4KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgYWRkTGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEMuRVZFTlRfVFlQRS5TQ0VORV9TVFJVQ1RVUkVfQ0hBTkdFRCwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5uZXdDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkRXZlbnQoZXZlbnQubmV3Q2hpbGQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnJlbW92ZWRDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkRXZlbnQoZXZlbnQucmVtb3ZlZENoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihDLkVWRU5UX1RZUEUuVklFV19DSEFOR0VELCBmdW5jdGlvbiAoLypldmVudCovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0UmVkcmF3KFwiQWN0aXZlIHZpZXcgY2hhbmdlZC5cIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEMuRVZFTlRfVFlQRS5MSUdIVF9TVFJVQ1RVUkVfQ0hBTkdFRCwgZnVuY3Rpb24gKC8qZXZlbnQqLykge1xyXG4gICAgICAgICAgICB0aGlzLmxpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlckZhY3Rvcnkuc2V0TGlnaHRTdHJ1Y3R1cmVEaXJ0eSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyhcIkxpZ2h0IHN0cnVjdHVyZSBjaGFuZ2VkLlwiKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoQy5FVkVOVF9UWVBFLkxJR0hUX1ZBTFVFX0NIQU5HRUQsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmxpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlckZhY3Rvcnkuc2V0TGlnaHRWYWx1ZUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgdGhpcy5saWdodHMubGlnaHRWYWx1ZUNoYW5nZWQoZXZlbnQubGlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyhcIkxpZ2h0IHZhbHVlIGNoYW5nZWQuXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoQy5FVkVOVF9UWVBFLlNDRU5FX1NIQVBFX0NIQU5HRUQsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAvLyBOZWVkIHRvIHVwZGF0ZSBsaWdodCBmcnVzdHVtLiBEZWZlciB0aGlzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBwaGFzZVxyXG4gICAgICAgICAgICAgdGhpcy5saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgT3B0aW9ucy5hZGRPYnNlcnZlcih0aGlzLm9uRmxhZ3NDaGFuZ2UuYmluZCh0aGlzKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZENoaWxkRXZlbnQ6IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09IEMuTk9ERV9UWVBFLk9CSkVDVCkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyhcIk9iamVjdCB3YXMgYWRkZWQgdG8gc2NlbmUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlQ2hpbGRFdmVudDogZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT0gQy5OT0RFX1RZUEUuT0JKRUNUKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGNoaWxkKTtcclxuICAgICAgICAgICAgY2hpbGQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyhcIk9iamVjdCB3YXMgcmVtb3ZlZCBmcm9tIHNjZW5lLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGhhbmRsZVJlc2l6ZUV2ZW50OiBmdW5jdGlvbiAoLyp3aWR0aCwgaGVpZ2h0Ki8pIHtcclxuICAgICAgICB0aGlzLmdldEFjdGl2ZVZpZXcoKS5zZXRQcm9qZWN0aW9uRGlydHkoKTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlRHJhd2FibGU6IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmF3YWJsZUZhY3RvcnkuY3JlYXRlRHJhd2FibGUob2JqLCB0aGlzLmNvbnRleHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXF1ZXN0UmVkcmF3OiBmdW5jdGlvbiAocmVhc29uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5yZXF1ZXN0UmVkcmF3KHJlYXNvbik7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uRmxhZ3NDaGFuZ2U6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKEZMQUdTW2tleV0gJiYgRkxBR1Nba2V5XS5yZWNvbXBpbGVPbkNoYW5nZSlcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXJGYWN0b3J5LnNldFNoYWRlclJlY29tcGlsZSgpO1xyXG4gICAgICAgIGlmIChrZXkgPT0gT1BUSU9OX0ZSVVNUVU1fQ1VMTElORykge1xyXG4gICAgICAgICAgICB0aGlzLmRvRnJ1c3R1bUN1bGxpbmcgPSAhIXZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gR0xTY2VuZTtcclxuXHJcbiIsInZhciBTaGFkZXJVdGlscyA9IHJlcXVpcmUoXCIuL3NoYWRlci11dGlscy5qc1wiKTtcclxudmFyIFNoYWRlckRlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi4vbWF0ZXJpYWxzL3Vybi9zaGFkZXItZGVzY3JpcHRvci5qc1wiKTtcclxudmFyIFVSTlNoYWRlckNsb3N1cmUgPSByZXF1aXJlKFwiLi4vbWF0ZXJpYWxzL3Vybi91cm5zaGFkZXJjbG9zdXJlLmpzXCIpO1xyXG5cclxudmFyIFByb2dyYW1GYWN0b3J5ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB0aGlzLnByb2dyYW1zID0ge1xyXG4gICAgICAgIGZhbGxiYWNrOiBudWxsLCBwaWNraW5nOiB7XHJcbiAgICAgICAgICAgIGlkOiBudWxsLCBub3JtYWw6IG51bGwsIHBvc2l0aW9uOiBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5YTUwzRC5leHRlbmQoUHJvZ3JhbUZhY3RvcnkucHJvdG90eXBlLCB7XHJcblxyXG4gICAgZ2V0UHJvZ3JhbUJ5TmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgc2NyaXB0RGVzY3JpcHRvciA9IFhNTDNELnNoYWRlcnMuZ2V0U2NyaXB0KG5hbWUpO1xyXG4gICAgICAgIGlmICghc2NyaXB0RGVzY3JpcHRvciB8fCAhc2NyaXB0RGVzY3JpcHRvci52ZXJ0ZXgpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJVbmtub3duIHNoYWRlcjogXCIsIG5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBuZXcgU2hhZGVyRGVzY3JpcHRvcigpO1xyXG4gICAgICAgIFhNTDNELmV4dGVuZChkZXNjcmlwdG9yLCBzY3JpcHREZXNjcmlwdG9yKTtcclxuICAgICAgICBkZXNjcmlwdG9yLmZyYWdtZW50ID0gU2hhZGVyVXRpbHMuYWRkRnJhZ21lbnRTaGFkZXJIZWFkZXIoZGVzY3JpcHRvci5mcmFnbWVudCk7XHJcbiAgICAgICAgdmFyIHNoYWRlciA9IG5ldyBVUk5TaGFkZXJDbG9zdXJlKHRoaXMuY29udGV4dCwgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgc2hhZGVyLmNyZWF0ZVNvdXJjZXMoe30sIG51bGwsIG51bGwpO1xyXG4gICAgICAgIHNoYWRlci5jb21waWxlKCk7XHJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RmFsbGJhY2tQcm9ncmFtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnByb2dyYW1zLmZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gbmV3IFNoYWRlckRlc2NyaXB0b3IoKTtcclxuICAgICAgICAgICAgWE1MM0QuZXh0ZW5kKGRlc2NyaXB0b3IsIFhNTDNELnNoYWRlcnMuZ2V0U2NyaXB0KFwibWF0dGVcIikpO1xyXG4gICAgICAgICAgICBkZXNjcmlwdG9yLmZyYWdtZW50ID0gU2hhZGVyVXRpbHMuYWRkRnJhZ21lbnRTaGFkZXJIZWFkZXIoZGVzY3JpcHRvci5mcmFnbWVudCk7XHJcbiAgICAgICAgICAgIHZhciBzaGFkZXIgPSBuZXcgVVJOU2hhZGVyQ2xvc3VyZSh0aGlzLmNvbnRleHQsIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgICAgICBzaGFkZXIudW5pZm9ybUNvbGxlY3Rpb24uZW52QmFzZS5kaWZmdXNlQ29sb3IgPSBbMSwgMCwgMF07XHJcbiAgICAgICAgICAgIHNoYWRlci5jcmVhdGVTb3VyY2VzKHt9LCBudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgc2hhZGVyLmNvbXBpbGUoKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9ncmFtcy5mYWxsYmFjayA9IHNoYWRlcjtcclxuICAgICAgICAgICAgdGhpcy5wcm9ncmFtcy5mYWxsYmFjay5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbXMuZmFsbGJhY2suc2V0VW5pZm9ybVZhcmlhYmxlcyhbXCJkaWZmdXNlQ29sb3JcIl0sIG51bGwsIHtlbnZCYXNlOiB7ZGlmZnVzZUNvbG9yOiBbMSwgMCwgMF19fSk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbXMuZmFsbGJhY2sudW5iaW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnByb2dyYW1zLmZhbGxiYWNrO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRQaWNraW5nT2JqZWN0SWRQcm9ncmFtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBpY2tpbmcgPSB0aGlzLnByb2dyYW1zLnBpY2tpbmc7XHJcbiAgICAgICAgaWYgKCFwaWNraW5nLmlkKSB7XHJcbiAgICAgICAgICAgIHBpY2tpbmcuaWQgPSB0aGlzLmdldFByb2dyYW1CeU5hbWUoXCJwaWNrb2JqZWN0aWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwaWNraW5nLmlkO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRQaWNraW5nUG9zaXRpb25Qcm9ncmFtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBpY2tpbmcgPSB0aGlzLnByb2dyYW1zLnBpY2tpbmc7XHJcbiAgICAgICAgaWYgKCFwaWNraW5nLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHBpY2tpbmcucG9zaXRpb24gPSB0aGlzLmdldFByb2dyYW1CeU5hbWUoXCJwaWNrZWRwb3NpdGlvblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBpY2tpbmcucG9zaXRpb247XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBpY2tpbmdOb3JtYWxQcm9ncmFtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBpY2tpbmcgPSB0aGlzLnByb2dyYW1zLnBpY2tpbmc7XHJcbiAgICAgICAgaWYgKCFwaWNraW5nLm5vcm1hbCkge1xyXG4gICAgICAgICAgICBwaWNraW5nLm5vcm1hbCA9IHRoaXMuZ2V0UHJvZ3JhbUJ5TmFtZShcInBpY2tlZE5vcm1hbHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwaWNraW5nLm5vcm1hbDtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQcm9ncmFtRmFjdG9yeTtcclxuXHJcbiIsInZhciBGUkFHTUVOVF9IRUFERVIgPSBbXCIjaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcIiwgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XCIsIFwiI2Vsc2VcIiwgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcIiwgXCIjZW5kaWYgLy8gR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcIiwgXCJcXG5cIl0uam9pbihcIlxcblwiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgYWRkRnJhZ21lbnRTaGFkZXJIZWFkZXI6IGZ1bmN0aW9uIChmcmFnbWVudFNoYWRlclNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBGUkFHTUVOVF9IRUFERVIgKyBmcmFnbWVudFNoYWRlclNvdXJjZTtcclxuICAgIH1cclxufTtcclxuIiwidmFyIFN5c3RlbU5vdGlmaWVyID0ge1xyXG4gICAgbm9kZTogbnVsbCxcclxuXHJcbiAgICBzZXROb2RlOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICB9LFxyXG5cclxuICAgIHNlbmRFdmVudDogZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xyXG4gICAgICAgICAgICBkYXRhLnN5c3RlbXR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoJ3htbDNkc3lzdGVtJywgdHJ1ZSwgdHJ1ZSwgZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN5c3RlbU5vdGlmaWVyO1xyXG4iLCJ2YXIgR0xDb250ZXh0ID0gcmVxdWlyZShcIi4uL2Jhc2UvY29udGV4dC5qc1wiKTtcclxudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcblxyXG5mdW5jdGlvbiBjb252ZXJ0VG9KU0FycmF5KHZhbHVlKSB7XHJcbiAgICB2YXIganNBcnJheSA9IFt2YWx1ZS5sZW5ndGhdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGpzQXJyYXlbaV0gPSB2YWx1ZVtpXTtcclxuICAgIH1cclxuICAgIHJldHVybiBqc0FycmF5O1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtHTENvbnRleHR9IGNvbnRleHRcclxuICogQHBhcmFtIHtVaW50MzJBcnJheX0gZGF0YVxyXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4SW5kZXhcclxuICovXHJcbnZhciBjcmVhdGVFbGVtZW50QnVmZmVyID0gZnVuY3Rpb24gKGNvbnRleHQsIGRhdGEsIG1heEluZGV4KSB7XHJcbiAgICB2YXIgZ2wgPSBjb250ZXh0LmdsO1xyXG4gICAgdmFyIGJ1ZmZlckRhdGEgPSBkYXRhO1xyXG4gICAgdmFyIGdsVHlwZSA9IGdsLlVOU0lHTkVEX0lOVDtcclxuXHJcbiAgICBpZiAobWF4SW5kZXggPCAoMSA8PCA4KSkge1xyXG4gICAgICAgIGdsVHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XHJcbiAgICAgICAgYnVmZmVyRGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG4gICAgfSBlbHNlIGlmIChtYXhJbmRleCA8ICgxIDw8IDE2KSkge1xyXG4gICAgICAgIGdsVHlwZSA9IGdsLlVOU0lHTkVEX1NIT1JUO1xyXG4gICAgICAgIGJ1ZmZlckRhdGEgPSBuZXcgVWludDE2QXJyYXkoZGF0YSk7XHJcbiAgICB9IGVsc2UgaWYgKCFjb250ZXh0LmV4dGVuc2lvbnNbR0xDb250ZXh0LkVYVEVOU0lPTlMuVUlOVDMyX0lORElDRVNdKSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJUcnlpbmcgdG8gdXNlIGluZGV4IGRhdGEgd2l0aCBpbmRpY2VzIGxhcmdlciB0aGFuIDY1NTM1LCBidXQgdGhpcyBpcyBub3Qgc3VwcG9ydGVkIG9uIHlvdXIgcGxhdGZvcm0uIEluZGV4aW5nIGVycm9ycyB3aWxsIG9jY3VyLlwiKTtcclxuICAgICAgICBnbFR5cGUgPSBnbC5VTlNJR05FRF9TSE9SVDtcclxuICAgICAgICBidWZmZXJEYXRhID0gbmV3IFVpbnQxNkFycmF5KGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcbiAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBidWZmZXJEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICBidWZmZXIuYnl0ZXNQZXJFbGVtZW50ID0gYnVmZmVyRGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgIGJ1ZmZlci5sZW5ndGggPSBkYXRhLmxlbmd0aDtcclxuICAgIGJ1ZmZlci5nbFR5cGUgPSBnbFR5cGU7XHJcbiAgICByZXR1cm4gYnVmZmVyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcbiAqL1xyXG52YXIgY3JlYXRlQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoY29udGV4dCwgZGF0YSkge1xyXG4gICAgdmFyIGdsID0gY29udGV4dC5nbDtcclxuXHJcbiAgICB2YXIgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICBidWZmZXIubGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcbiAgICBidWZmZXIuZ2xUeXBlID0gZ2V0R0xUeXBlRnJvbUFycmF5KGRhdGEpO1xyXG4gICAgcmV0dXJuIGJ1ZmZlcjtcclxufTtcclxuXHJcbnZhciBnZXRHTFR5cGVGcm9tQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgIHZhciBHTCA9IHdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpXHJcbiAgICAgICAgcmV0dXJuIEdMLkJZVEU7XHJcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxyXG4gICAgICAgIHJldHVybiBHTC5VTlNJR05FRF9CWVRFO1xyXG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgSW50MTZBcnJheSlcclxuICAgICAgICByZXR1cm4gR0wuU0hPUlQ7XHJcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSlcclxuICAgICAgICByZXR1cm4gR0wuVU5TSUdORURfU0hPUlQ7XHJcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5KVxyXG4gICAgICAgIHJldHVybiBHTC5JTlQ7XHJcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSlcclxuICAgICAgICByZXR1cm4gR0wuVU5TSUdORURfSU5UO1xyXG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KVxyXG4gICAgICAgIHJldHVybiBHTC5GTE9BVDtcclxuICAgIHJldHVybiBHTC5GTE9BVDtcclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGdldEdMVW5pZm9ybVZhbHVlRnJvbVhmbG93RGF0YUVudHJ5OiBmdW5jdGlvbiAoeGZsb3dEYXRhRW50cnksIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgaWYgKCF4Zmxvd0RhdGFFbnRyeSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgaWYgKHhmbG93RGF0YUVudHJ5LnR5cGUgPT0gWEMuREFUQV9UWVBFLlRFWFRVUkUpIHtcclxuICAgICAgICAgICAgdmFyIHdlYmdsRGF0YSA9IGNvbnRleHQuZ2V0WGZsb3dFbnRyeVdlYkdsRGF0YSh4Zmxvd0RhdGFFbnRyeSk7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gd2ViZ2xEYXRhLnRleHR1cmUgfHwgY29udGV4dC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgICAgIGlmICh3ZWJnbERhdGEuY2hhbmdlZClcclxuICAgICAgICAgICAgICAgIHRleHR1cmUudXBkYXRlRnJvbVRleHR1cmVFbnRyeSh4Zmxvd0RhdGFFbnRyeSk7XHJcblxyXG4gICAgICAgICAgICB3ZWJnbERhdGEudGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICAgICAgICAgIHdlYmdsRGF0YS5jaGFuZ2VkID0gMDtcclxuICAgICAgICAgICAgdmFsdWUgPSBbdGV4dHVyZV07XHJcbiAgICAgICAgfSBlbHNlIGlmICh4Zmxvd0RhdGFFbnRyeS50eXBlID09IFhDLkRBVEFfVFlQRS5CT09MKSB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBDYW4gd2UgZ2V0IFhmbG93IHRvIHJldHVybiBib29sZWFuIGFycmF5cyBhcyBub3JtYWwgSlMgYXJyYXlzPyBXZWJHTCBkb2Vzbid0IGFjY2VwdCBVaW50OEFycmF5cyBoZXJlLi4uXHJcbiAgICAgICAgICAgIC8vVE9ETyBBbHRlcm5hdGl2ZWx5IHdlIGNvdWxkIHNldCBib29sZWFuIHVuaWZvcm1zIHVzaW5nIHVuaWZvcm0xZnYgdG9nZXRoZXIgd2l0aCBGbG9hdDMyQXJyYXlzLCB3aGljaCBhcHBhcmVudGx5IHdvcmtzIHRvb1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnZlcnRUb0pTQXJyYXkoeGZsb3dEYXRhRW50cnkuZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB4Zmxvd0RhdGFFbnRyeS5nZXRWYWx1ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRHTEJ1ZmZlckZyb21YZmxvd0RhdGFFbnRyeTogZnVuY3Rpb24gKHhmbG93RGF0YUVudHJ5LCBjb250ZXh0LCBlbGVtZW50QnVmZmVyKSB7XHJcbiAgICAgICAgdmFyIHdlYmdsRGF0YSA9IGNvbnRleHQuZ2V0WGZsb3dFbnRyeVdlYkdsRGF0YSh4Zmxvd0RhdGFFbnRyeSk7XHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHdlYmdsRGF0YS5idWZmZXI7XHJcbiAgICAgICAgdmFyIGdsID0gY29udGV4dC5nbDtcclxuXHJcbiAgICAgICAgLy8gQWxzbyB3cml0ZSBtaW4gYW5kIG1heCB2YWx1ZXMgZm9yIGVsZW1lbnRCdWZmZXJzXHJcbiAgICAgICAgaWYgKHdlYmdsRGF0YS5jaGFuZ2VkICYmIGVsZW1lbnRCdWZmZXIpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4VmFsdWUgPSB4Zmxvd0RhdGFFbnRyeS5nZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICB2YXIgbWluSW5kZXggPSAxMDAwMDAwMDAsIG1heEluZGV4ID0gMDtcclxuICAgICAgICAgICAgdmFyIGkgPSBpbmRleFZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgbWluSW5kZXggPSBNYXRoLm1pbihtaW5JbmRleCwgaW5kZXhWYWx1ZVtpXSk7XHJcbiAgICAgICAgICAgICAgICBtYXhJbmRleCA9IE1hdGgubWF4KG1heEluZGV4LCBpbmRleFZhbHVlW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3ZWJnbERhdGEubWF4SW5kZXggPSBtYXhJbmRleDtcclxuICAgICAgICAgICAgd2ViZ2xEYXRhLm1pbkluZGV4ID0gbWluSW5kZXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcclxuICAgICAgICBzd2l0Y2ggKHdlYmdsRGF0YS5jaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgWEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1ZBTFVFOlxyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyRGF0YSA9IHhmbG93RGF0YUVudHJ5LmdldFZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChidWZmZXIuZ2xUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgZ2wuVU5TSUdORURfQllURTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckRhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGdsLlVOU0lHTkVEX1NIT1JUOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGdsLlVOU0lHTkVEX0lOVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgd2hhdCB3ZSBleHBlY3QgYW55d2F5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiVW5rbm93biBHTCB0eXBlIGZvciBlbGVtZW50IGJ1ZmZlcjogXCIsIGJ1ZmZlci5nbFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgMCwgYnVmZmVyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB4Zmxvd0RhdGFFbnRyeS5nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFhDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9ORVc6XHJcbiAgICAgICAgICAgIGNhc2UgWEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1NJWkU6XHJcbiAgICAgICAgICAgIGNhc2UgWEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1NJWkVfVFlQRTpcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50QnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gY3JlYXRlRWxlbWVudEJ1ZmZlcihjb250ZXh0LCB4Zmxvd0RhdGFFbnRyeS5nZXRWYWx1ZSgpLCB3ZWJnbERhdGEubWF4SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBjcmVhdGVBcnJheUJ1ZmZlcihjb250ZXh0LCB4Zmxvd0RhdGFFbnRyeS5nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJ1ZmZlci50dXBsZVNpemUgPSB4Zmxvd0RhdGFFbnRyeS5nZXRUdXBsZVNpemUoKTtcclxuICAgICAgICAgICAgICAgIHdlYmdsRGF0YS5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdlYmdsRGF0YS5jaGFuZ2VkID0gMDtcclxuICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSBib3VuZGluZyBib3ggZnJvbSBwb3NpdGlvbnMgYW5kIG9wdGlvbmFsIGluZGljZXNcclxuICAgICAqIFRPRE86IFJlbW92ZSBGbG9hdEFycmF5IGNyZWF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gcG9zaXRpb25zXHJcbiAgICAgKiBAcGFyYW0ge0ludDE2QXJyYXl8bnVsbH0gaW5kZXhcclxuICAgICAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl9XHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAocG9zaXRpb25zLCBpbmRleCkge1xyXG4gICAgICAgIHZhciBiYm94ID0gbmV3IFhNTDNELm1hdGguYmJveC5jcmVhdGUoKSwgaTtcclxuXHJcbiAgICAgICAgaWYgKCFwb3NpdGlvbnMgfHwgcG9zaXRpb25zLmxlbmd0aCA8IDMpXHJcbiAgICAgICAgICAgIHJldHVybiBiYm94O1xyXG5cclxuICAgICAgICBpZiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGkwID0gaW5kZXhbMF0gKiAzO1xyXG4gICAgICAgICAgICBiYm94WzBdID0gcG9zaXRpb25zW2kwXTtcclxuICAgICAgICAgICAgYmJveFsxXSA9IHBvc2l0aW9uc1tpMCArIDFdO1xyXG4gICAgICAgICAgICBiYm94WzJdID0gcG9zaXRpb25zW2kwICsgMl07XHJcbiAgICAgICAgICAgIGJib3hbM10gPSBwb3NpdGlvbnNbaTBdO1xyXG4gICAgICAgICAgICBiYm94WzRdID0gcG9zaXRpb25zW2kwICsgMV07XHJcbiAgICAgICAgICAgIGJib3hbNV0gPSBwb3NpdGlvbnNbaTAgKyAyXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBpbmRleC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkxID0gaW5kZXhbaV0gKiAzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHAxID0gcG9zaXRpb25zW2kxXTtcclxuICAgICAgICAgICAgICAgIHZhciBwMiA9IHBvc2l0aW9uc1tpMSArIDFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHAzID0gcG9zaXRpb25zW2kxICsgMl07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHAxIDwgYmJveFswXSlcclxuICAgICAgICAgICAgICAgICAgICBiYm94WzBdID0gcDE7XHJcbiAgICAgICAgICAgICAgICBpZiAocDIgPCBiYm94WzFdKVxyXG4gICAgICAgICAgICAgICAgICAgIGJib3hbMV0gPSBwMjtcclxuICAgICAgICAgICAgICAgIGlmIChwMyA8IGJib3hbMl0pXHJcbiAgICAgICAgICAgICAgICAgICAgYmJveFsyXSA9IHAzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHAxID4gYmJveFszXSlcclxuICAgICAgICAgICAgICAgICAgICBiYm94WzNdID0gcDE7XHJcbiAgICAgICAgICAgICAgICBpZiAocDIgPiBiYm94WzRdKVxyXG4gICAgICAgICAgICAgICAgICAgIGJib3hbNF0gPSBwMjtcclxuICAgICAgICAgICAgICAgIGlmIChwMyA+IGJib3hbNV0pXHJcbiAgICAgICAgICAgICAgICAgICAgYmJveFs1XSA9IHAzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYmJveFswXSA9IHBvc2l0aW9uc1swXTtcclxuICAgICAgICAgICAgYmJveFsxXSA9IHBvc2l0aW9uc1sxXTtcclxuICAgICAgICAgICAgYmJveFsyXSA9IHBvc2l0aW9uc1syXTtcclxuICAgICAgICAgICAgYmJveFszXSA9IHBvc2l0aW9uc1swXTtcclxuICAgICAgICAgICAgYmJveFs0XSA9IHBvc2l0aW9uc1sxXTtcclxuICAgICAgICAgICAgYmJveFs1XSA9IHBvc2l0aW9uc1syXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDM7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbnNbaV0gPCBiYm94WzBdKVxyXG4gICAgICAgICAgICAgICAgICAgIGJib3hbMF0gPSBwb3NpdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25zW2kgKyAxXSA8IGJib3hbMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgYmJveFsxXSA9IHBvc2l0aW9uc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25zW2kgKyAyXSA8IGJib3hbMl0pXHJcbiAgICAgICAgICAgICAgICAgICAgYmJveFsyXSA9IHBvc2l0aW9uc1tpICsgMl07XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25zW2ldID4gYmJveFszXSlcclxuICAgICAgICAgICAgICAgICAgICBiYm94WzNdID0gcG9zaXRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1tpICsgMV0gPiBiYm94WzRdKVxyXG4gICAgICAgICAgICAgICAgICAgIGJib3hbNF0gPSBwb3NpdGlvbnNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1tpICsgMl0gPiBiYm94WzVdKVxyXG4gICAgICAgICAgICAgICAgICAgIGJib3hbNV0gPSBwb3NpdGlvbnNbaSArIDJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiYm94O1xyXG4gICAgfVxyXG59O1xyXG4iLCJ2YXIgRHJhd2FibGVDbG9zdXJlID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmVyL3NjZW5lL2RyYXdhYmxlY2xvc3VyZS5qc1wiKTtcclxudmFyIEdMTWVzaCA9IHJlcXVpcmUoXCIuLi9iYXNlL21lc2guanNcIik7XHJcbnZhciBYZmxvd1V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XHJcbnZhciBFVkVOVF9UWVBFID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmVyL3NjZW5lL2NvbnN0YW50cy5qc1wiKS5FVkVOVF9UWVBFO1xyXG52YXIgTWF0ZXJpYWxFdmVudHMgPSByZXF1aXJlKFwiLi4vbWF0ZXJpYWxzL2V2ZW50cy5qc1wiKTtcclxudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcbnZhciBDb21wdXRlUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5Db21wdXRlUmVxdWVzdDtcclxuXHJcbnZhciBDSEFOR0VfU1RBVEUgPSB7XHJcbiAgICBOT1RISU5HX0NIQU5HRUQ6IDAsXHJcbiAgICBTVFJVQ1RVUkVfQ0hBTkdFRDogMSxcclxuICAgIFRZUEVfREFUQV9DSEFOR0VEOiAyLFxyXG4gICAgVlNfREFUQV9DSEFOR0VEOiA0LFxyXG4gICAgVFlQRV9DSEFOR0VEOiAyICsgMSxcclxuICAgIFZTX0NIQU5HRUQ6IDQgKyAxLFxyXG4gICAgU0hBREVSX0NIQU5HRUQ6IDMyXHJcbn07XHJcbnZhciBTSEFERVJfQ0xPU1VSRV9ORUVEU19VUERBVEUgPSBDSEFOR0VfU1RBVEUuU1RSVUNUVVJFX0NIQU5HRUQgfCBDSEFOR0VfU1RBVEUuU0hBREVSX0NIQU5HRUQ7XHJcblxyXG52YXIgUkVBRFlfU1RBVEUgPSBEcmF3YWJsZUNsb3N1cmUuUkVBRFlfU1RBVEU7XHJcblxyXG5cclxudmFyIE1FU0hfUEFSQU1FVEVSUyA9IHt9O1xyXG5cclxuTUVTSF9QQVJBTUVURVJTW1dlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVNdID0ge1xyXG4gICAgYXR0cmlidXRlRGF0YToge1wicG9zaXRpb25cIjogWEMuREFUQV9UWVBFLkZMT0FUM30sIHR5cGVEYXRhOiB7XHJcbiAgICAgICAgXCJpbmRleFwiOiBYQy5EQVRBX1RZUEUuSU5ULCBcInNvbGlkXCI6IFhDLkRBVEFfVFlQRS5CT09MLCBcInZlcnRleENvdW50XCI6IFhDLkRBVEFfVFlQRS5JTlRcclxuICAgIH0sIGJib3hGaXg6IHtcclxuICAgICAgICBcImJvdW5kaW5nQm94XCI6IFhDLkRBVEFfVFlQRS5GTE9BVDNcclxuICAgIH0sIGJib3hDb21wdXRlOiB7XHJcbiAgICAgICAgXCJwb3NpdGlvblwiOiBYQy5EQVRBX1RZUEUuRkxPQVQzXHJcbiAgICB9XHJcbn07XHJcbk1FU0hfUEFSQU1FVEVSU1tXZWJHTFJlbmRlcmluZ0NvbnRleHQuTElORV9TVFJJUF0gPSBNRVNIX1BBUkFNRVRFUlNbV2ViR0xSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFU107XHJcbk1FU0hfUEFSQU1FVEVSU1tXZWJHTFJlbmRlcmluZ0NvbnRleHQuTElORVNdID0gTUVTSF9QQVJBTUVURVJTW1dlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVNdO1xyXG5NRVNIX1BBUkFNRVRFUlNbV2ViR0xSZW5kZXJpbmdDb250ZXh0LlBPSU5UU10gPSBNRVNIX1BBUkFNRVRFUlNbV2ViR0xSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFU107XHJcbk1FU0hfUEFSQU1FVEVSU1tXZWJHTFJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVfU1RSSVBdID0gTUVTSF9QQVJBTUVURVJTW1dlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVNdO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB0aGF0IHN5bmNocm9uaXplcyBkYXRhIGNoYW5nZXMgZnJvbSBYZmxvdyB3aXRoIGEgR0xNZXNoIGluc3RhbmNlXHJcbiAqXHJcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XHJcbiAqIEBwYXJhbSB7WGZsb3cuRGF0YU5vZGV9IGRhdGFOb2RlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRcclxuICogQGV4dGVuZHMge0RyYXdhYmxlQ2xvc3VyZX1cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgWGZsb3dNZXNoID0gZnVuY3Rpb24gKGNvbnRleHQsIGRhdGFOb2RlLCB0eXBlLCBvcHQpIHtcclxuICAgIERyYXdhYmxlQ2xvc3VyZS5jYWxsKHRoaXMsIGNvbnRleHQsIERyYXdhYmxlQ2xvc3VyZS5UWVBFUy5NRVNIKTtcclxuICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgIHRoaXMubWVzaCA9IG5ldyBHTE1lc2goY29udGV4dCwgdHlwZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEYXRhIE5vZGUgb2YgdGhlIHJlbmRlck9iamVjdFxyXG4gICAgICogQHR5cGUge1hmbG93LkRhdGFOb2RlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRhdGFOb2RlID0gZGF0YU5vZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaGFkZXIgQ29tcG9zZXIgdGhhdCB3aWxsIHByb3ZpZGUgU2hhZGVyQ2xvc3VyZSBhbmQgUHJvZ3JhbVxyXG4gICAgICogQHR5cGUge0Fic3RyYWN0U2hhZGVyQ29tcG9zZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2hhZGVyQ29tcG9zZXIgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hhZGVyIENsb3N1cmUgdXNlZCBieSB0aGlzIG1lc2hcclxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFNoYWRlckNsb3N1cmV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2hhZGVyQ2xvc3VyZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRyaWJ1dGVzIHJlcXVpcmVkIHRvIGNyZWF0ZSB0aGUgR0xNZXNoXHJcbiAgICAgKiBAdHlwZSB7Q29tcHV0ZVJlcXVlc3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudHlwZVJlcXVlc3QgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJlIGFsbCBhdHRyaWJ1dGVzIHJlcXVpcmVkIGJ5IGRyYXdhYmxlIGF2YWlsYWJsZT9cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnR5cGVEYXRhVmFsaWQgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0cmlidXRlcyBhbmQgdW5pZm9ybXMgdmFsdWVzIGZvciB0aGUgc2hhZGVyXHJcbiAgICAgKiBAdHlwZSB7WGZsb3cuUmVxdWVzdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vYmplY3RTaGFkZXJSZXF1ZXN0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJpdGZpZWxkIHRoYXQgcmVjb3JkcyB0aGUgY2hhbmdlcyByZXBvcnRlZCBieSBYZmxvd1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2hhbmdlU3RhdGUgPSBDSEFOR0VfU1RBVEUuU1RSVUNUVVJFX0NIQU5HRUQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBpZiBib3VuZGluZyBib3ggaGFzIGNoYW5nZWQuIEdldHMgb25seSBjYWxsZWQgaWZcclxuICAgICAqIHRoaXMuYm91bmRpbmdCb3hSZXF1aXJlZCBpcyB0cnVlLlxyXG4gICAgICogQHR5cGUgeyp8ZnVuY3Rpb24oRmxvYXQzMkFycmF5KX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ib3VuZGluZ0JveENoYW5nZWQgPSBvcHQuYm91bmRpbmdCb3hDaGFuZ2VkIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhYZmxvd01lc2gsIERyYXdhYmxlQ2xvc3VyZSwge1xyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudHlwZURhdGFDaGFuZ2VkKHRoaXMudHlwZVJlcXVlc3QsIFhDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICAgICAgdGhpcy5zaGFkZXJDaGFuZ2VkKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNoYWRlckNvbXBvc2VyOiBmdW5jdGlvbiAoc2hhZGVyQ29tcG9zZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYmluZGVkU2hhZGVyQ2hhbmdlZCkgdGhpcy5iaW5kZWRTaGFkZXJDaGFuZ2VkID0gdGhpcy5zaGFkZXJDaGFuZ2VkLmJpbmQodGhpcyk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNoYWRlckNvbXBvc2VyKVxyXG4gICAgICAgICAgICB0aGlzLnNoYWRlckNvbXBvc2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoTWF0ZXJpYWxFdmVudHMuTUFURVJJQUxfU1RSVUNUVVJFX0NIQU5HRUQsIHRoaXMuYmluZGVkU2hhZGVyQ2hhbmdlZCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhZGVyQ29tcG9zZXIgPSBzaGFkZXJDb21wb3NlcjtcclxuICAgICAgICBpZiAodGhpcy5zaGFkZXJDb21wb3NlcilcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXJDb21wb3Nlci5hZGRFdmVudExpc3RlbmVyKE1hdGVyaWFsRXZlbnRzLk1BVEVSSUFMX1NUUlVDVFVSRV9DSEFOR0VELCB0aGlzLmJpbmRlZFNoYWRlckNoYW5nZWQpO1xyXG5cclxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlIHw9IENIQU5HRV9TVEFURS5TSEFERVJfQ0hBTkdFRDtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoc2NlbmUpIHtcclxuICAgICAgICBpZiAodGhpcy5jaGFuZ2VTdGF0ZSA9PT0gQ0hBTkdFX1NUQVRFLk5PVEhJTkdfQ0hBTkdFRCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiVXBkYXRlIG1lc2ggY2xvc3VyZVwiLCB0aGlzLmNoYW5nZVN0YXRlKTtcclxuXHJcbiAgICAgICAgdmFyIG9sZFZhbGlkID0gISF0aGlzLnNoYWRlckNsb3N1cmUgJiYgdGhpcy50eXBlRGF0YVZhbGlkLCBzb21lRXJyb3IgPSBudWxsLCB0eXBlRGF0YVJlc29sdmVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5nZVN0YXRlICYgU0hBREVSX0NMT1NVUkVfTkVFRFNfVVBEQVRFKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1lc2guY2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbmdlU3RhdGUgJiBDSEFOR0VfU1RBVEUuVFlQRV9DSEFOR0VEKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVR5cGVEYXRhKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHR5cGVEYXRhUmVzb2x2ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbmdlU3RhdGUgJiAoU0hBREVSX0NMT1NVUkVfTkVFRFNfVVBEQVRFIHwgQ0hBTkdFX1NUQVRFLlRZUEVfQ0hBTkdFRCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5kZXhCdWZmZXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbmdlU3RhdGUgJiBTSEFERVJfQ0xPU1VSRV9ORUVEU19VUERBVEUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlT2JqZWN0U2hhZGVyUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTaGFkZXJDbG9zdXJlKHNjZW5lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlT2JqZWN0U2hhZGVyRGF0YSgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hhbmdlU3RhdGUgJiBDSEFOR0VfU1RBVEUuVlNfQ0hBTkdFRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVPYmplY3RTaGFkZXJEYXRhKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFOb2RlLmlzU3VidHJlZUxvYWRpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkZXJDbG9zdXJlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZURhdGFWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBzb21lRXJyb3IgPSBlO1xyXG4gICAgICAgICAgICBpZiAoIXR5cGVEYXRhUmVzb2x2ZWQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVEYXRhVmFsaWQgPSBmYWxzZTsgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkZXJDbG9zdXJlID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB2YXIgbmV3VmFsaWQgPSAhIXRoaXMuc2hhZGVyQ2xvc3VyZSAmJiB0aGlzLnR5cGVEYXRhVmFsaWQ7XHJcblxyXG4gICAgICAgIGlmIChvbGRWYWxpZCAhPSBuZXdWYWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogRVZFTlRfVFlQRS5EUkFXQUJMRV9TVEFURV9DSEFOR0VELFxyXG4gICAgICAgICAgICAgICAgbmV3U3RhdGU6IG5ld1ZhbGlkID8gUkVBRFlfU1RBVEUuQ09NUExFVEUgOiBSRUFEWV9TVEFURS5JTkNPTVBMRVRFLFxyXG4gICAgICAgICAgICAgICAgb2xkU3RhdGU6IG9sZFZhbGlkID8gUkVBRFlfU1RBVEUuQ09NUExFVEUgOiBSRUFEWV9TVEFURS5JTkNPTVBMRVRFXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlID0gQ0hBTkdFX1NUQVRFLk5PVEhJTkdfQ0hBTkdFRDtcclxuXHJcbiAgICAgICAgaWYgKHNvbWVFcnJvcikgdGhyb3cgc29tZUVycm9yO1xyXG4gICAgfSxcclxuXHJcbiAgICBjYWxjdWxhdGVCb3VuZGluZ0JveDogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY19lbXB0eSA9IFhNTDNELm1hdGguYmJveC5jcmVhdGUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBib3VuZGluZyBib3ggZnJvbSBwb3NpdGlvbnMgYW5kIGluZGljZXMsIGlmIHByZXNlbnRcclxuICAgICAgICAgICAgdmFyIGRhdGFSZXN1bHQgPSB0aGlzLnR5cGVSZXF1ZXN0LmdldFJlc3VsdCgpO1xyXG4gICAgICAgICAgICB2YXIgYm91bmRpbmdCb3hFbnRyeSA9IGRhdGFSZXN1bHQuZ2V0T3V0cHV0RGF0YShcImJvdW5kaW5nQm94XCIpO1xyXG4gICAgICAgICAgICBpZiAoYm91bmRpbmdCb3hFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveENoYW5nZWQoWGZsb3dVdGlscy5jYWxjdWxhdGVCb3VuZGluZ0JveChib3VuZGluZ0JveEVudHJ5LmdldFZhbHVlKCksIG51bGwpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25FbnRyeSA9IGRhdGFSZXN1bHQuZ2V0T3V0cHV0RGF0YShcInBvc2l0aW9uXCIpO1xyXG4gICAgICAgICAgICBpZiAoIXBvc2l0aW9uRW50cnkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3hDaGFuZ2VkKGNfZW1wdHkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbmRleEVudHJ5ID0gZGF0YVJlc3VsdC5nZXRPdXRwdXREYXRhKFwiaW5kZXhcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3hDaGFuZ2VkKFhmbG93VXRpbHMuY2FsY3VsYXRlQm91bmRpbmdCb3gocG9zaXRpb25FbnRyeS5nZXRWYWx1ZSgpLCBpbmRleEVudHJ5ID8gaW5kZXhFbnRyeS5nZXRWYWx1ZSgpIDogbnVsbCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0oKSksIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Q29tcHV0ZVJlcXVlc3R9IHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSB7WEMuUkVTVUxUX1NUQVRFfSBzdGF0ZVxyXG4gICAgICovXHJcbiAgICB0eXBlRGF0YUNoYW5nZWQ6IGZ1bmN0aW9uIChyZXF1ZXN0LCBzdGF0ZSkge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUgfD0gc3RhdGUgPT0gWEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFID8gQ0hBTkdFX1NUQVRFLlNUUlVDVFVSRV9DSEFOR0VEIDogQ0hBTkdFX1NUQVRFLlRZUEVfREFUQV9DSEFOR0VEO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTogRVZFTlRfVFlQRS5TQ0VORV9TSEFQRV9DSEFOR0VEfSk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RSZWRyYXcoXCJNZXNoIFR5cGUgRGF0YSBDaGFuZ2VcIik7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJYZmxvd01lc2g6IFR5cGUgZGF0YSBjaGFuZ2VkXCIsIHJlcXVlc3QsIHN0YXRlLCB0aGlzLmNoYW5nZVN0YXRlKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TWVzaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lc2g7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldE1lc2hUeXBlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzaC5nbFR5cGU7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZU9iamVjdFNoYWRlclJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5vYmplY3RTaGFkZXJSZXF1ZXN0KSB0aGlzLm9iamVjdFNoYWRlclJlcXVlc3QuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLm9iamVjdFNoYWRlclJlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGFOb2RlLmlzU3VidHJlZUxvYWRpbmcoKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLm9iamVjdFNoYWRlclJlcXVlc3QgPSB0aGlzLnNoYWRlckNvbXBvc2VyLmNyZWF0ZU9iamVjdERhdGFSZXF1ZXN0KHRoaXMuZGF0YU5vZGUsIHRoaXMuc2hhZGVySW5wdXREYXRhQ2hhbmdlZC5iaW5kKHRoaXMpKTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlU2hhZGVyQ2xvc3VyZTogZnVuY3Rpb24gKHNjZW5lKSB7XHJcbiAgICAgICAgdGhpcy5zaGFkZXJDbG9zdXJlID0gbnVsbDtcclxuICAgICAgICBpZiAoIXRoaXMuZGF0YU5vZGUuaXNTdWJ0cmVlTG9hZGluZygpICYmICF0aGlzLmRhdGFOb2RlLmdldE91dHB1dENoYW5uZWxJbmZvKFwicG9zaXRpb25cIikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVzaCBkb2VzIG5vdCBoYXZlICdwb3NpdGlvbicgYXR0cmlidXRlLlwiKTtcclxuICAgICAgICAgICAgLy9YTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIk1lc2ggZG9lcyBub3QgaGF2ZSAncG9zaXRpb24nIGF0dHJpYnV0ZS5cIiwgdGhpcy5tZXNoLCB0aGlzLmdldE1lc2hUeXBlKCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuZGF0YU5vZGUuaXNTdWJ0cmVlTG9hZGluZygpKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmplY3RTaGFkZXJSZXN1bHQgPSB0aGlzLm9iamVjdFNoYWRlclJlcXVlc3QuZ2V0UmVzdWx0KCk7XHJcbiAgICAgICAgICAgIGlmICghb2JqZWN0U2hhZGVyUmVzdWx0LmxvYWRpbmcpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRlckNsb3N1cmUgPSB0aGlzLnNoYWRlckNvbXBvc2VyLmdldFNoYWRlckNsb3N1cmUoc2NlbmUsIHRoaXMub2JqZWN0U2hhZGVyUmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVJbmRleEJ1ZmZlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIEFkZCBJbmRleCBidWZmZXIsIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIHZhciBkYXRhUmVzdWx0ID0gdGhpcy50eXBlUmVxdWVzdC5nZXRSZXN1bHQoKTtcclxuICAgICAgICB2YXIgZW50cnkgPSBkYXRhUmVzdWx0LmdldE91dHB1dERhdGEoXCJpbmRleFwiKTtcclxuICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkuZ2V0VmFsdWUoKSlcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVCdWZmZXIoXCJpbmRleFwiLCBlbnRyeSwgdHJ1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZU9iamVjdFNoYWRlckRhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2hhZGVyQ2xvc3VyZSkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIGlmIG9ubHkgdGhlIGRhdGEgaGFzIGNoYW5nZWQsIGl0IGNhbid0IGdldCB2YWxpZCBhZnRlciB1cGRhdGVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5iaW5kZWRIYW5kbGVCdWZmZXIpIHRoaXMuYmluZGVkSGFuZGxlQnVmZmVyID0gdGhpcy5oYW5kbGVCdWZmZXIuYmluZCh0aGlzKTtcclxuICAgICAgICBpZiAoIXRoaXMuYmluZGVkSGFuZGxlVW5pZm9ybSkgdGhpcy5iaW5kZWRIYW5kbGVVbmlmb3JtID0gdGhpcy5oYW5kbGVVbmlmb3JtLmJpbmQodGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhZGVyQ29tcG9zZXIuZGlzdHJpYnV0ZU9iamVjdFNoYWRlckRhdGEodGhpcy5vYmplY3RTaGFkZXJSZXF1ZXN0LCB0aGlzLmJpbmRlZEhhbmRsZUJ1ZmZlciwgdGhpcy5iaW5kZWRIYW5kbGVVbmlmb3JtKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLm1lc2guaXNSZWFkeVRvUmVuZGVyKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVzaCBoYXMgZW1wdHkgdmVydGV4IGF0dHJpYnV0ZXMuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlVHlwZURhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudHlwZURhdGFWYWxpZCAmJiAhKHRoaXMuY2hhbmdlU3RhdGUgJiBDSEFOR0VfU1RBVEUuU1RSVUNUVVJFX0NIQU5HRUQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gb25seSBpZiBzdHJ1Y3R1cmUgaGFzIGNoYW5nZWQsIGl0IGNhbid0IGdldCB2YWxpZCBhZnRlciB1cGRhdGVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlVHlwZVJlcXVlc3QoKTtcclxuXHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZGluZ0JveCgpO1xyXG5cclxuICAgICAgICB2YXIgZGF0YVJlc3VsdCA9IHRoaXMudHlwZVJlcXVlc3QuZ2V0UmVzdWx0KCk7XHJcblxyXG4gICAgICAgIHZhciBlbnRyeSA9IGRhdGFSZXN1bHQuZ2V0T3V0cHV0RGF0YShcInZlcnRleENvdW50XCIpO1xyXG4gICAgICAgIHRoaXMubWVzaC5zZXRWZXJ0ZXhDb3VudChlbnRyeSAmJiBlbnRyeS5nZXRWYWx1ZSgpID8gZW50cnkuZ2V0VmFsdWUoKSA6IG51bGwpO1xyXG4gICAgICAgIHRoaXMudHlwZURhdGFWYWxpZCA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAqIEBwYXJhbSB7WGZsb3cuQnVmZmVyRW50cnl9IHhmbG93RGF0YUVudHJ5XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc0luZGV4XHJcbiAgICAgKi9cclxuICAgIGhhbmRsZUJ1ZmZlcjogZnVuY3Rpb24gKG5hbWUsIHhmbG93RGF0YUVudHJ5LCBpc0luZGV4KSB7XHJcbiAgICAgICAgaXNJbmRleCA9IGlzSW5kZXggfHwgZmFsc2U7XHJcbiAgICAgICAgdmFyIG1lc2ggPSB0aGlzLm1lc2g7XHJcblxyXG4gICAgICAgIGlmIChuYW1lID09IFwicG9zaXRpb25cIiAmJiAheGZsb3dEYXRhRW50cnkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3Bvc2l0aW9uJyBhdHRyaWJ1dGUgb2YgbWVzaCBpcyBlbXB0eS5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXhmbG93RGF0YUVudHJ5KSB7XHJcbiAgICAgICAgICAgIHRoaXMubWVzaC5yZW1vdmVCdWZmZXIobmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh4Zmxvd0RhdGFFbnRyeS50eXBlID09IFhDLkRBVEFfVFlQRS5URVhUVVJFKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiVGV4dHVyZSBhcyBtZXNoIHBhcmFtZXRlciBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IFhmbG93VXRpbHMuZ2V0R0xCdWZmZXJGcm9tWGZsb3dEYXRhRW50cnkoeGZsb3dEYXRhRW50cnksIHRoaXMuY29udGV4dCwgbmFtZSA9PSBcImluZGV4XCIpO1xyXG4gICAgICAgIGlmIChpc0luZGV4KSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5kZXhSYW5nZSh4Zmxvd0RhdGFFbnRyeSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tZXNoLmNoZWNrQnVmZmVyQ29tcGF0aWJsZShuYW1lLCB4Zmxvd0RhdGFFbnRyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluIGV2ZXJ5IGNhc2UsIHNldCB0aGUgYnVmZmVyLCBiZWNhdXNlIG90aGVyIG1lc2hlcyBtaWdodCBoYXZlIGFscmVhZHlcclxuICAgICAgICAvLyBwZXJmb3JtZWQgb25lIG9yIG1vcmUgb2YgdGhlIHRhc2tzIGFib3ZlXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNldCBidWZmZXJcIiwgbmFtZSwgYnVmZmVyLmlkKTtcclxuICAgICAgICBtZXNoLnNldEJ1ZmZlcihuYW1lLCBidWZmZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVJbmRleFJhbmdlOiBmdW5jdGlvbiAoeGZsb3dEYXRhRW50cnkpIHtcclxuICAgICAgICB2YXIgd2ViZ2xEYXRhID0gdGhpcy5jb250ZXh0LmdldFhmbG93RW50cnlXZWJHbERhdGEoeGZsb3dEYXRhRW50cnkpO1xyXG4gICAgICAgIHRoaXMubWVzaC5zZXRJbmRleFJhbmdlKHdlYmdsRGF0YS5taW5JbmRleCwgd2ViZ2xEYXRhLm1heEluZGV4KTtcclxuICAgIH0sXHJcblxyXG4gICAgLypjaGVja0J1ZmZlclNpemU6IGZ1bmN0aW9uKG5hbWUsIHhmbG93RGF0YUVudHJ5KXtcclxuICAgICBpZih4Zmxvd0RhdGFFbnRyeS5nZXRJdGVyYXRlQ291bnQpe1xyXG4gICAgIHZhciBjbnQgPSB4Zmxvd0RhdGFFbnRyeS5nZXRJdGVyYXRlQ291bnQoKTtcclxuICAgICBpZihjbnQgPj0gdGhpcy5tZXNoLm1heEluZGV4KVxyXG4gICAgIHRocm93IG5ldyBFcnJvcihcIkluZGV4IHJhbmdlIG9mIFtcIiArIHRoaXMubWVzaC5taW5JbmRleCArIFwiLCBcIiArIHRoaXMubWVzaC5tYXhJbmRleCArIFwiXSBcIiArXHJcbiAgICAgXCIgZ29lcyBiZXlvbmQgZWxlbWVudCBjb3VudCBcIiArIGNudCArIFwiIG9mIGF0dHJpYnV0ZSAnXCIgKyBuYW1lICsgXCInXCIpO1xyXG4gICAgIH1cclxuICAgICB9LCovXHJcblxyXG4gICAgaGFuZGxlVW5pZm9ybTogZnVuY3Rpb24gKG5hbWUsIHhmbG93RGF0YUVudHJ5KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gWGZsb3dVdGlscy5nZXRHTFVuaWZvcm1WYWx1ZUZyb21YZmxvd0RhdGFFbnRyeSh4Zmxvd0RhdGFFbnRyeSwgdGhpcy5jb250ZXh0KTtcclxuICAgICAgICB0aGlzLm1lc2guc2V0VW5pZm9ybU92ZXJyaWRlKG5hbWUsIHZhbHVlKTtcclxuICAgIH0sIC8qKlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgdXBkYXRlVHlwZVJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbWVzaENvbmZpZyA9IE1FU0hfUEFSQU1FVEVSU1t0aGlzLmdldE1lc2hUeXBlKCldO1xyXG4gICAgICAgIGlmICghbWVzaENvbmZpZykge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlVuc3VwcG9ydGVkIE1lc2ggcmVxdWVzdDogXCIsIHRoaXMubWVzaCwgdGhpcy5nZXRNZXNoVHlwZSgpKTtcclxuICAgICAgICAgICAgdGhpcy50eXBlRGF0YVZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlcXVlc3ROYW1lcyA9IHRoaXMuZ2V0VHlwZVJlcXVlc3ROYW1lcyhtZXNoQ29uZmlnKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnR5cGVSZXF1ZXN0IHx8IHRoaXMudHlwZVJlcXVlc3QuZmlsdGVyICE9IHJlcXVlc3ROYW1lcykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlUmVxdWVzdCkgdGhpcy50eXBlUmVxdWVzdC5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVSZXF1ZXN0ID0gbmV3IENvbXB1dGVSZXF1ZXN0KHRoaXMuZGF0YU5vZGUsIHJlcXVlc3ROYW1lcywgdGhpcy50eXBlRGF0YUNoYW5nZWQuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUeXBlUmVxdWVzdE5hbWVzOiBmdW5jdGlvbiAobWVzaENvbmZpZykge1xyXG4gICAgICAgIHZhciByZXF1ZXN0TmFtZXMgPSBbXTtcclxuICAgICAgICByZXF1ZXN0TmFtZXMucHVzaC5hcHBseShyZXF1ZXN0TmFtZXMsIE9iamVjdC5rZXlzKG1lc2hDb25maWcudHlwZURhdGEpKTtcclxuICAgICAgICAvLyBXZSBhbHdheXMgcmVxdWVzdCBmaXhlZCBib3VuZGluZyBib3ggdmFsdWVzOiB0aGF0IHdheSB3ZSBjYW4gcmVhY3QsIHdoZW4gdGhvc2UgdmFsdWVzIGdldCBhdmFpbGFibGVcclxuICAgICAgICByZXF1ZXN0TmFtZXMucHVzaC5hcHBseShyZXF1ZXN0TmFtZXMsIE9iamVjdC5rZXlzKG1lc2hDb25maWcuYmJveEZpeCkpO1xyXG4gICAgICAgIHZhciBjb21wdXRlQkJveCA9ICF0aGlzLmNoZWNrWGZsb3dUeXBlcyh0aGlzLmRhdGFOb2RlLCBtZXNoQ29uZmlnLmJib3hGaXgpO1xyXG5cclxuICAgICAgICBpZiAoY29tcHV0ZUJCb3gpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrWGZsb3dUeXBlcyh0aGlzLmRhdGFOb2RlLCBtZXNoQ29uZmlnLmJib3hDb21wdXRlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlRGF0YVZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVxdWVzdE5hbWVzLnB1c2guYXBwbHkocmVxdWVzdE5hbWVzLCBPYmplY3Qua2V5cyhtZXNoQ29uZmlnLmJib3hDb21wdXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0TmFtZXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNoZWNrWGZsb3dUeXBlczogZnVuY3Rpb24gKGRhdGFOb2RlLCByZXF1aXJlbWVudHMpIHtcclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHJlcXVpcmVtZW50cykge1xyXG4gICAgICAgICAgICB2YXIgaW5mbyA9IGRhdGFOb2RlLmdldE91dHB1dENoYW5uZWxJbmZvKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIWluZm8pIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGluZm8udHlwZSAhPSByZXF1aXJlbWVudHNbbmFtZV0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Q29tcHV0ZVJlcXVlc3R9IHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSB7WEMuUkVTVUxUX1NUQVRFfSBzdGF0ZVxyXG4gICAgICovXHJcbiAgICBzaGFkZXJJbnB1dERhdGFDaGFuZ2VkOiBmdW5jdGlvbiAocmVxdWVzdCwgc3RhdGUpIHtcclxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlIHw9IHN0YXRlICE9IFhDLlJFU1VMVF9TVEFURS5DSEFOR0VEX0RBVEFfVkFMVUUgPyBDSEFOR0VfU1RBVEUuU1RSVUNUVVJFX0NIQU5HRUQgOiBDSEFOR0VfU1RBVEUuVlNfREFUQV9DSEFOR0VEO1xyXG4gICAgICAgIC8vIFRPRE86IFdlIGRvbid0IGtub3cgaWYgdGhlIGNoYW5nZSBvZiBkYXRhIG9ubHkgaW5mbHVlbmNlcyB0aGUgc3VyZmFjZSBzaGFkaW5nIG9yIHRoZSBhY3R1YWwgbWVzaCBzaGFwZVxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTogRVZFTlRfVFlQRS5TQ0VORV9TSEFQRV9DSEFOR0VEfSk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RSZWRyYXcoXCJNZXNoIEF0dHJpYnV0ZSBEYXRhIENoYW5nZWRcIik7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJYZmxvd01lc2g6IEF0dHJpYnV0ZSBkYXRhIGNoYW5nZWRcIiwgcmVxdWVzdCwgc3RhdGUsIHRoaXMuY2hhbmdlU3RhdGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzaGFkZXJDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSB8PSBDSEFOR0VfU1RBVEUuU0hBREVSX0NIQU5HRUQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFByb2dyYW06IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaGFkZXJDbG9zdXJlO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhmbG93TWVzaDtcclxuXHJcbiIsIlxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBYTUwzREJveC4gWE1MM0RCb3ggcmVwcmVzZW50cyBhbiBheGlzLWFsaWduZWQgYm94LFxyXG4gKiBkZXNjcmliZWQgYnkgdHdvIHZlY3RvcnMgbWluIGFuZCBtYXguXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1hNTDNEVmVjMz19IG1pbiBUaGUgc21hbGxlciBwb2ludCBvZiB0aGUgYm94LiBEZWZhdWx0OiAoMCwwLDApXHJcbiAqIEBwYXJhbSB7WE1MM0RWZWMzPX0gbWF4IFRoZSBiaWdnZXN0IHBvaW50IG9mIHRoZSBib3guIERlZmF1bHQ6ICgwLDAsMClcclxuICovXHJcbnZhciBYTUwzREJveCA9IGZ1bmN0aW9uKG1pbiwgbWF4LCBjYikge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgIC8qKiBhbm9ueW1vdXMgY2FsbGJhY2sgdG8gaW5mb3JtIHRoaXMgaW5zdGFuY2UgKiAqL1xyXG4gICAgdmFyIHZlY19jYiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGF0Ll9jYWxsYmFjaylcclxuICAgICAgICAgICAgdGhhdC5fY2FsbGJhY2sodGhhdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtYTUwzRFZlYzN9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX21pbiA9IG5ldyB3aW5kb3cuWE1MM0RWZWMzKE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUsIHZlY19jYik7XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7WE1MM0RWZWMzfVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9tYXggPSBuZXcgd2luZG93LlhNTDNEVmVjMygtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFLCB2ZWNfY2IpO1xyXG5cclxuICAgIC8vIENvcHkgY29uc3RydWN0b3JcclxuICAgIGlmIChtaW4gJiYgbWluLm1pbikge1xyXG4gICAgICAgIHRoaXMuX21pbi5zZXQobWluLm1pbik7XHJcbiAgICAgICAgdGhpcy5fbWF4LnNldChtaW4ubWF4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKG1pbilcclxuICAgICAgICAgICAgdGhpcy5fbWluLnNldChtaW4pO1xyXG4gICAgICAgIGlmIChtYXgpXHJcbiAgICAgICAgICAgIHRoaXMuX21heC5zZXQobWF4KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQHByaXZhdGUgKiAqL1xyXG4gICAgdGhpcy5fY2FsbGJhY2sgPSB0eXBlb2YgY2IgPT0gJ2Z1bmN0aW9uJyA/IGNiIDogMDtcclxuXHJcbn07XHJcblxyXG4vKiogQHR5cGUge1hNTDNEVmVjM30gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTDNEQm94LnByb3RvdHlwZSwgXCJtaW5cIiwge1xyXG4gICAgLyoqIEB0aGlzIHtYTUwzREJveH0gKiovXHJcbiAgICBnZXQgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX21pbjsgfSxcclxuICAgIHNldCA6IGZ1bmN0aW9uKCkgeyB0aHJvdyBFcnJvcihcIlhNTDNEQm94OjptaW4gaXMgcmVhZG9ubHkuXCIpOyB9LFxyXG4gICAgY29uZmlndXJhYmxlIDogZmFsc2UsXHJcbiAgICBlbnVtZXJhYmxlIDogZmFsc2VcclxufSk7XHJcblxyXG4vKiogQHR5cGUge1hNTDNEVmVjM30gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTDNEQm94LnByb3RvdHlwZSwgXCJtYXhcIiwge1xyXG4gICAgLyoqIEB0aGlzIHtYTUwzREJveH0gKiovXHJcbiAgICBnZXQgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX21heDsgfSxcclxuICAgIHNldCA6IGZ1bmN0aW9uKCkgeyB0aHJvdyBFcnJvcihcIlhNTDNEQm94OjptYXggaXMgcmVhZG9ubHkuXCIpOyB9LFxyXG4gICAgY29uZmlndXJhYmxlIDogZmFsc2UsXHJcbiAgICBlbnVtZXJhYmxlIDogZmFsc2VcclxufSk7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc2l6ZSBvZiB0aGUgQm94IGluIGVhY2ggZGltZW5zaW9uXHJcbiAqIEByZXR1cm4ge1hNTDNEVmVjM30gU2l6ZSBvZiB0aGUgQm94XHJcbiAqL1xyXG5YTUwzREJveC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHYgPSB0aGlzLl9tYXguc3VidHJhY3QodGhpcy5fbWluKTtcclxuICAgIGlmICh2LnggPCAwKVxyXG4gICAgICAgIHYueCA9IDA7XHJcbiAgICBpZiAodi55IDwgMClcclxuICAgICAgICB2LnkgPSAwO1xyXG4gICAgaWYgKHYueiA8IDApXHJcbiAgICAgICAgdi56ID0gMDtcclxuXHJcbiAgICByZXR1cm4gdjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBjZW50ZXIgb2YgdGhlIEJveFxyXG4gKiBAcmV0dXJucyB7WE1MM0RWZWMzfSB0aGF0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIGJveFxyXG4gKi9cclxuWE1MM0RCb3gucHJvdG90eXBlLmNlbnRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21pbi5hZGQodGhpcy5fbWF4KS5zY2FsZSgwLjUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCBCb3ggZW1wdHkgU2V0cyBtaW4ncyBjb21wb25lbnRzIHRvIE51bWJlci5NQVhfVkFMVUUgYW5kIG1heCdcclxuICogY29tcG9uZW50cyB0byAtTnVtYmVyLk1BWF9WQUxVRS5cclxuICovXHJcblhNTDNEQm94LnByb3RvdHlwZS5tYWtlRW1wdHkgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuX21pbiA9IG5ldyB3aW5kb3cuWE1MM0RWZWMzKE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICAgIE51bWJlci5NQVhfVkFMVUUpO1xyXG4gICAgdGhpcy5fbWF4ID0gbmV3IHdpbmRvdy5YTUwzRFZlYzMoLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICAtTnVtYmVyLk1BWF9WQUxVRSk7XHJcbiAgICBpZiAodGhpcy5fY2FsbGJhY2spXHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sodGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdCwgaWYgdGhpcyBCb3ggaXMgZW1wdHlcclxuICogQHJldHVybnMge2Jvb2xlYW59ICd0cnVlJywgaWYgYm94IGlzIGVtcHR5XHJcbiAqL1xyXG5YTUwzREJveC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLl9taW4ueCA+IHRoaXMuX21heC54IHx8IHRoaXMuX21pbi55ID4gdGhpcy5fbWF4LnkgfHwgdGhpcy5fbWluLnogPiB0aGlzLl9tYXgueik7XHJcbn07XHJcblxyXG4vKipcclxuICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBYTUwzREJveC5cclxuICogQG92ZXJyaWRlXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gSHVtYW4tcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBYTUwzREJveC5cclxuICovXHJcblhNTDNEQm94LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFwiW29iamVjdCBYTUwzREJveF1cIjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgc2V0IG1ldGhvZCBjb3BpZXMgdGhlIHZhbHVlcyBmcm9tIG90aGVyLlxyXG4gKiBAcGFyYW0ge1hNTDNEQm94fSBvdGhlciBUaGUgb3RoZXIgYm94XHJcbiAqL1xyXG5YTUwzREJveC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgIHRoaXMuX21pbi5zZXQob3RoZXIubWluKTtcclxuICAgIHRoaXMuX21heC5zZXQob3RoZXIubWF4KTtcclxuICAgIGlmICh0aGlzLl9jYWxsYmFjaylcclxuICAgICAgICB0aGlzLl9jYWxsYmFjayh0aGlzKTtcclxufTtcclxuXHJcbi8qKiB1cGRhdGVzIHRoZSBtaW4gb3IgbWF4IGFjY29yaW5nIHRvIHRoZSBnaXZlbiBwb2ludCBvciBib3VuZGluZyBib3guXHJcbipcclxuKiBAcGFyYW0gdGhhdCB0aGUgb2JqZWN0IHVzZWQgZm9yIGV4dGVuc2lvbiwgd2hpY2ggY2FuIGJlIGEgWE1MM0RWZWMzIG9yIFhNTDNEQm94XHJcbiovXHJcblhNTDNEQm94LnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbih0aGF0KVxyXG57XHJcbiAgICBpZiAoIXRoYXQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHZhciBtaW4sIG1heDtcclxuICAgIGlmKHRoYXQuY29uc3RydWN0b3IgPT09IHdpbmRvdy5YTUwzREJveClcclxuICAgIHtcclxuICAgICAgICBtaW4gPSB0aGF0Lm1pbjtcclxuICAgICAgICBtYXggPSB0aGF0Lm1heDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYodGhhdC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LlhNTDNEVmVjMylcclxuICAgIHtcclxuICAgICAgICBtaW4gPSB0aGF0O1xyXG4gICAgICAgIG1heCA9IHRoYXQ7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmKG1pbi54IDwgdGhpcy5fbWluLngpXHJcbiAgICAgICAgdGhpcy5fbWluLnggPSBtaW4ueDtcclxuICAgIGlmKG1pbi55IDwgdGhpcy5fbWluLnkpXHJcbiAgICAgICAgdGhpcy5fbWluLnkgPSBtaW4ueTtcclxuICAgIGlmKG1pbi56IDwgdGhpcy5fbWluLnopXHJcbiAgICAgICAgdGhpcy5fbWluLnogPSBtaW4uejtcclxuXHJcbiAgICBpZihtYXgueCA+IHRoaXMuX21heC54KVxyXG4gICAgICAgIHRoaXMuX21heC54ID0gbWF4Lng7XHJcbiAgICBpZihtYXgueSA+IHRoaXMuX21heC55KVxyXG4gICAgICAgIHRoaXMuX21heC55ID0gbWF4Lnk7XHJcbiAgICBpZihtYXgueiA+IHRoaXMuX21heC56KVxyXG4gICAgICAgIHRoaXMuX21heC56ID0gbWF4Lno7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhNTDNEQm94O1xyXG4iLCJ2YXIgWEMgPSByZXF1aXJlKFwiLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIFJlc291cmNlID0gcmVxdWlyZShcIi4uL2Jhc2UvcmVzb3VyY2VtYW5hZ2VyLmpzXCIpLlJlc291cmNlO1xyXG5cclxudmFyIGNfWGZsb3dPYnNlcnZlckxpc3QgPSBbXTtcclxuXHJcbnZhciBYTUwzRERhdGFPYnNlcnZlciA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIHRoaXMub2JzZXJ2ZWQgPSBbXTtcclxufTtcclxuXHJcblhNTDNERGF0YU9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24obm9kZSwgb3B0aW9ucyl7XHJcbiAgICBpZighbm9kZSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbm9kZSB0byBvYnNlcnZlIGlzIG51bGwuXCIpO1xyXG5cclxuXHJcbiAgICBpZighbm9kZS5fY29uZmlndXJlZClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3RlIHRvIG9ic2VydmUgaXMgbm90ICAgKHlldCkuIE1ha2Ugc3VyZSB0byBwYXNzIGFuIFhNTDNEIG5vZGUgYW5kIHRvIGV4ZWN1dGUgXCIgK1xyXG4gICAgICAgICAgICBcInRoaXMgZnVuY3Rpb24gYWZ0ZXIgWE1MM0QgaGFzIGJlZW4gY29uZmlndXJlZCBlLmcuIGluc2lkZSBhIERPTUNvbnRlbnRMb2FkZWQgbGlzdGVuZXIuXCIpO1xyXG5cclxuXHJcbiAgICB2YXIgZGF0YUFkYXB0ZXIgPSBSZXNvdXJjZS5nZXRBZGFwdGVyKG5vZGUsIFwiZGF0YVwiKTtcclxuICAgIGlmKCFkYXRhQWRhcHRlcilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBvYnNlcnZlIG5vZGUuIFhNTDNEYXRhT2JzZXJ2ZXIgY2FuIG9ubHkgb2JzZXJ2ZSBkYXRhIGNvbnRhaW5lcnMgc3VjaCBhcyA8ZGF0YT4sIDxtZXNoPiBvciA8c2hhZGVyPlwiKTtcclxuXHJcbiAgICBpZih0aGlzLm9ic2VydmVkLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIGNfWGZsb3dPYnNlcnZlckxpc3QucHVzaCh0aGlzKTtcclxuXHJcbiAgICB2YXIgZW50cnkgPSB7XHJcbiAgICAgICAgbm9kZTogbm9kZSxcclxuICAgICAgICBjaGFuZ2VkOiBmYWxzZSxcclxuICAgICAgICByZXF1ZXN0OiBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBuYW1lcyA9IG9wdGlvbnMgJiYgb3B0aW9uc1snbmFtZXMnXTtcclxuICAgIHZhciB0eXBlT2ZOYW1lcyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuYW1lcykuc2xpY2UoOCwgLTEpO1xyXG4gICAgaWYgKHR5cGVPZk5hbWVzID09PSBcIlN0cmluZ1wiKSB7XHJcbiAgICAgICAgbmFtZXMgPSBbbmFtZXNdO1xyXG4gICAgfVxyXG5cclxuICAgIGVudHJ5LnJlcXVlc3QgPSBkYXRhQWRhcHRlci5nZXRDb21wdXRlUmVxdWVzdChuYW1lcywgZnVuY3Rpb24ocmVxdWVzdCwgY2hhbmdlVHlwZSl7XHJcbiAgICAgICAgZW50cnkuY2hhbmdlZCA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIC8vIEZldGNoIHJlc3VsdCB0byBzeW5jaHJvbml6ZSBYZmxvdyBzdHJ1Y3R1cmVzIGFuZCBjb25uZWN0IHRvIGNhbGxiYWNrc1xyXG4gICAgLy8gVE9ETzogRmluZCBhbiBvcHRpb24gdG8gY29ubmVjdCByZXF1ZXN0IHRvIGNhbGxiYWNrIHN0cnVjdHVyZSB3aXRob3V0IGNvbXB1dGluZyByZXN1bHRcclxuICAgIGVudHJ5LnJlcXVlc3QuZ2V0UmVzdWx0KCk7XHJcblxyXG4gICAgdGhpcy5vYnNlcnZlZC5wdXNoKGVudHJ5KTtcclxufTtcclxuXHJcblhNTDNERGF0YU9ic2VydmVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLm9ic2VydmVkLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB0aGlzLm9ic2VydmVkW2ldLnJlcXVlc3QuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIHRoaXMub2JzZXJ2ZWQgPSBbXTtcclxuICAgIHZhciBpID0gY19YZmxvd09ic2VydmVyTGlzdC5sZW5ndGg7XHJcbiAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgIGlmKGNfWGZsb3dPYnNlcnZlckxpc3RbaV0gPT0gdGhpcylcclxuICAgICAgICAgICAgY19YZmxvd09ic2VydmVyTGlzdC5zcGxpY2UoaSwgMSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuWE1MM0QudXBkYXRlWGZsb3dPYnNlcnZlciA9IGZ1bmN0aW9uKCl7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY19YZmxvd09ic2VydmVyTGlzdC5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIG9ic2VydmVyID0gY19YZmxvd09ic2VydmVyTGlzdFtpXTtcclxuICAgICAgICB2YXIgcmVjb3JkcyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBvYnNlcnZlci5vYnNlcnZlZC5sZW5ndGg7ICsrail7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IG9ic2VydmVyLm9ic2VydmVkW2pdO1xyXG4gICAgICAgICAgICBpZihlbnRyeS5jaGFuZ2VkKXtcclxuICAgICAgICAgICAgICAgIGVudHJ5LmNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBlbnRyeS5yZXF1ZXN0LmdldFJlc3VsdCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFSZXN1bHQgPSBuZXcgWE1MM0REYXRhUmVzdWx0KHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZWNvcmRzLnB1c2goIG5ldyBYTUwzRERhdGFSZWNvcmQoZW50cnkubm9kZSwgZGF0YVJlc3VsdCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHJlY29yZHMubGVuZ3RoID4gMCAmJiBvYnNlcnZlci5jYWxsYmFjayl7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmNhbGxiYWNrKHJlY29yZHMsIG9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgWE1MM0REYXRhUmVjb3JkID0gZnVuY3Rpb24odGFyZ2V0LCByZXN1bHQpe1xyXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcclxufTtcclxuXHJcblxyXG52YXIgWE1MM0REYXRhUmVzdWx0ID0gZnVuY3Rpb24ocmVzdWx0KXtcclxuICAgIHRoaXMuX2VudHJpZXMgPSB7fTtcclxuICAgIGNvbnN0cnVjdERhdGFSZXN1bHQodGhpcywgcmVzdWx0KTtcclxufTtcclxuXHJcblhNTDNERGF0YVJlc3VsdC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICBpZiAodGhpcy5fZW50cmllc1tuYW1lXSlcclxuICAgICAgICByZXR1cm4gdGhpcy5fZW50cmllc1tuYW1lXS52YWx1ZTtcclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuWE1MM0REYXRhUmVzdWx0LnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgaWYgKHRoaXMuX2VudHJpZXNbbmFtZV0pXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudHJpZXNbbmFtZV0udHlwZTtcclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuWE1MM0REYXRhUmVzdWx0LnByb3RvdHlwZS5nZXROYW1lcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICBmb3IodmFyIG5hbWUgaW4gdGhpcy5fZW50cmllcyl7XHJcbiAgICAgICAgcmVzdWx0LnB1c2gobmFtZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuWE1MM0REYXRhUmVzdWx0LkZMT0FUICA9IDA7XHJcblhNTDNERGF0YVJlc3VsdC5GTE9BVDIgPSAxO1xyXG5YTUwzRERhdGFSZXN1bHQuRkxPQVQzID0gMjtcclxuWE1MM0REYXRhUmVzdWx0LkZMT0FUNCA9IDM7XHJcblhNTDNERGF0YVJlc3VsdC5GTE9BVDRYNCA9IDQ7XHJcblhNTDNERGF0YVJlc3VsdC5JTlQgPSAxMDtcclxuWE1MM0REYXRhUmVzdWx0LklOVDQgPSAxMTtcclxuWE1MM0REYXRhUmVzdWx0LkJPT0wgPSAyMDtcclxuWE1MM0REYXRhUmVzdWx0LlRFWFRVUkUgPSAzMDtcclxuWE1MM0REYXRhUmVzdWx0LkJZVEUgPSA0MDtcclxuWE1MM0REYXRhUmVzdWx0LlVCWVRFID0gNTA7XHJcblxyXG5cclxuZnVuY3Rpb24gY29uc3RydWN0RGF0YVJlc3VsdChkYXRhUmVzdWx0LCByZXN1bHQpe1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHJlc3VsdC5vdXRwdXROYW1lcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIG5hbWUgPSByZXN1bHQub3V0cHV0TmFtZXNbaV07XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gcmVzdWx0LmdldE91dHB1dERhdGEobmFtZSk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZW50cnkgJiYgZW50cnkuZ2V0VmFsdWUoKTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXRYTUwzRERhdGFUeXBlKGVudHJ5LnR5cGUpO1xyXG4gICAgICAgICAgICBkYXRhUmVzdWx0Ll9lbnRyaWVzW25hbWVdID0geyB0eXBlOiB0eXBlLCB2YWx1ZTogdmFsdWV9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0WE1MM0REYXRhVHlwZSh0eXBlKXtcclxuICAgIHN3aXRjaCh0eXBlKXtcclxuICAgICAgICBjYXNlIFhDLkRBVEFfVFlQRS5GTE9BVCA6IHJldHVybiBYTUwzRERhdGFSZXN1bHQuRkxPQVQ7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQyIDogcmV0dXJuIFhNTDNERGF0YVJlc3VsdC5GTE9BVDI7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQzIDogcmV0dXJuIFhNTDNERGF0YVJlc3VsdC5GTE9BVDM7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQ0IDogcmV0dXJuIFhNTDNERGF0YVJlc3VsdC5GTE9BVDQ7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQ0WDQgOiByZXR1cm4gWE1MM0REYXRhUmVzdWx0LkZMT0FUNFg0O1xyXG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLklOVCA6IHJldHVybiBYTUwzRERhdGFSZXN1bHQuSU5UO1xyXG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLklOVDQgOiByZXR1cm4gWE1MM0REYXRhUmVzdWx0LklOVDQ7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuQk9PTCA6IHJldHVybiBYTUwzRERhdGFSZXN1bHQuQk9PTDtcclxuICAgICAgICBjYXNlIFhDLkRBVEFfVFlQRS5URVhUVVJFIDogcmV0dXJuIFhNTDNERGF0YVJlc3VsdC5URVhUVVJFO1xyXG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLkJZVEUgOiByZXR1cm4gWE1MM0REYXRhUmVzdWx0LkJZVEU7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuVUJZVEUgOiByZXR1cm4gWE1MM0REYXRhUmVzdWx0LlVCWVRFO1xyXG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIldIQVQgSVMgVEhJUyBJIERPTidUIEVWRU4uLi5cIik7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBYTUwzRERhdGFDaGFubmVsSW5mbyA9IGZ1bmN0aW9uKHR5cGUsIG9yaWdpbiwgb3JpZ2luYWxOYW1lLCBzZXFMZW5ndGgsIHNlcU1pbktleSwgc2VxTWF4S2V5KXtcclxuICAgIHRoaXMudHlwZSA9IGdldFhNTDNERGF0YVR5cGUodHlwZSk7XHJcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcclxuICAgIHRoaXMub3JpZ2luYWxOYW1lID0gb3JpZ2luYWxOYW1lO1xyXG4gICAgdGhpcy5zZXFMZW5ndGggPSBzZXFMZW5ndGg7XHJcbiAgICB0aGlzLnNlcU1pbktleSA9IHNlcU1pbktleTtcclxuICAgIHRoaXMuc2VxTWF4S2V5ID0gc2VxTWF4S2V5O1xyXG59O1xyXG5cclxuWE1MM0REYXRhQ2hhbm5lbEluZm8uT1JJR0lOX0NISUxEID0gMTtcclxuWE1MM0REYXRhQ2hhbm5lbEluZm8uT1JJR0lOX0NPTVBVVEUgPSAyO1xyXG5YTUwzRERhdGFDaGFubmVsSW5mby5PUklHSU5fUFJPVE8gPSAzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBYTUwzRERhdGFDaGFubmVsSW5mbzogWE1MM0REYXRhQ2hhbm5lbEluZm8sXHJcbiAgICBYTUwzRERhdGFSZXN1bHQ6IFhNTDNERGF0YVJlc3VsdCxcclxuICAgIFhNTDNERGF0YU9ic2VydmVyOiBYTUwzRERhdGFPYnNlcnZlclxyXG59OyIsIlxyXG4vKipcclxuICogQ29uZmlndXJlIGFycmF5IHByb3BlcnRpZXNcclxuICogQHByaXZhdGVcclxuICogQHRoaXMge1hNTDNETWF0cml4fVxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggQXJyYXkgaW5kZXhcclxuICovXHJcbmZ1bmN0aW9uIHByb3AoaW5kZXgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhW2luZGV4XTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhW2luZGV4XSA9IHZhbDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2sodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb25maWd1cmFibGUgOiBmYWxzZSxcclxuICAgICAgICBlbnVtZXJhYmxlIDogZmFsc2VcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFhNTDNETWF0cml4LiBYTUwzRE1hdHJpeCByZXByZXNlbnRzIGEgcmVwcmVzZW50cyBhXHJcbiAqIDR4NCBob21vZ2VuZW91cyBtYXRyaXguXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0xMSBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgMXN0IGNvbHVtbiBvZiB0aGUgMXN0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0xMiBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgMnN0IGNvbHVtbiBvZiB0aGUgMXN0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0xMyBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgM3N0IGNvbHVtbiBvZiB0aGUgMXN0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0xNCBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgNHN0IGNvbHVtbiBvZiB0aGUgMXN0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0yMSBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgMXN0IGNvbHVtbiBvZiB0aGUgMnN0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0yMiBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgMnN0IGNvbHVtbiBvZiB0aGUgMnN0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0yMyBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgM3N0IGNvbHVtbiBvZiB0aGUgMnN0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0yNCBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgNHN0IGNvbHVtbiBvZiB0aGUgMnN0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0zMSBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgMXN0IGNvbHVtbiBvZiB0aGUgM3N0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0zMiBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgMnN0IGNvbHVtbiBvZiB0aGUgM3N0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0zMyBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgM3N0IGNvbHVtbiBvZiB0aGUgM3N0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0zNCBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgNHN0IGNvbHVtbiBvZiB0aGUgM3N0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG00MSBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgMXN0IGNvbHVtbiBvZiB0aGUgNHN0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG00MiBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgMnN0IGNvbHVtbiBvZiB0aGUgNHN0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG00MyBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgM3N0IGNvbHVtbiBvZiB0aGUgNHN0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG00NCBSZXByZXNlbnRzIHRoZSB2YWx1ZSBpbiB0aGUgNHN0IGNvbHVtbiBvZiB0aGUgNHN0XHJcbiAqICAgICAgICAgICAgcm93LlxyXG4gKi9cclxudmFyIFhNTDNETWF0cml4ID0gZnVuY3Rpb24obTExLCBtMTIsIG0xMywgbTE0LCBtMjEsIG0yMiwgbTIzLCBtMjQsIG0zMSxcclxuICAgICAgICBtMzIsIG0zMywgbTM0LCBtNDEsIG00MiwgbTQzLCBtNDQsIGNiKSB7XHJcbiAgICAvKiogQHByaXZhdGUgKi9cclxuICAgIGlmICh0eXBlb2YgbTExID09ICdudW1iZXInICYmIGFyZ3VtZW50cy5sZW5ndGggPj0gMTYpIHtcclxuICAgICAgICB0aGlzLnNldChtMTEsIG0xMiwgbTEzLCBtMTQsIG0yMSwgbTIyLCBtMjMsIG0yNCwgbTMxLCBtMzIsIG0zMywgbTM0LCBtNDEsIG00MiwgbTQzLCBtNDQpO1xyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gdHlwZW9mIGNiID09ICdmdW5jdGlvbicgPyBjYiA6IDA7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtMTEgPT0gJ29iamVjdCcgJiYgYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgdGhpcy5zZXQobTExKTtcclxuICAgIH0gZWxzZXtcclxuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0MzJBcnJheSggWyAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMCwgMCwgMSBdKTtcclxuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IHR5cGVvZiBtMTEgPT0gJ2Z1bmN0aW9uJyA/IG0xMSA6IDA7XHJcbiAgICB9XHJcbn07XHJcbnZhciBwID0gWE1MM0RNYXRyaXgucHJvdG90eXBlO1xyXG5cclxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIm0xMVwiLCBwcm9wKDApKTtcclxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIm0xMlwiLCBwcm9wKDEpKTtcclxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIm0xM1wiLCBwcm9wKDIpKTtcclxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIm0xNFwiLCBwcm9wKDMpKTtcclxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIm0yMVwiLCBwcm9wKDQpKTtcclxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIm0yMlwiLCBwcm9wKDUpKTtcclxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIm0yM1wiLCBwcm9wKDYpKTtcclxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIm0yNFwiLCBwcm9wKDcpKTtcclxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIm0zMVwiLCBwcm9wKDgpKTtcclxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIm0zMlwiLCBwcm9wKDkpKTtcclxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIm0zM1wiLCBwcm9wKDEwKSk7XHJcbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJtMzRcIiwgcHJvcCgxMSkpO1xyXG4vKiogQHR5cGUge251bWJlcn0gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsIFwibTQxXCIsIHByb3AoMTIpKTtcclxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIm00MlwiLCBwcm9wKDEzKSk7XHJcbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJtNDNcIiwgcHJvcCgxNCkpO1xyXG4vKiogQHR5cGUge251bWJlcn0gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsIFwibTQ0XCIsIHByb3AoMTUpKTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBtYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBtMTEgYW5vdGhlciBYTUwzRE1hdHJpeCwgRmxvYXQzMkFycmF5IG9yIGEgbnVtYmVyLiBJbiB0aGUgbGFzdCBjYXNlIHRoZSByZW1haW5pbmcgYXJndW1lbnRzIGFyZSBjb25zaWRlcmVkLlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0xMlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0xM1xyXG4gKiBAcGFyYW0ge251bWJlcj19IG0xNFxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0yMVxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0yMlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0yM1xyXG4gKiBAcGFyYW0ge251bWJlcj19IG0yNFxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0zMVxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0zMlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG0zM1xyXG4gKiBAcGFyYW0ge251bWJlcj19IG0zNFxyXG4gKiBAcGFyYW0ge251bWJlcj19IG00MVxyXG4gKiBAcGFyYW0ge251bWJlcj19IG00MlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG00M1xyXG4gKiBAcGFyYW0ge251bWJlcj19IG00NFxyXG4gKi9cclxucC5zZXQgPSBmdW5jdGlvbihtMTEsIG0xMiwgbTEzLCBtMTQsIG0yMSwgbTIyLCBtMjMsIG0yNCwgbTMxLFxyXG4gICAgICAgIG0zMiwgbTMzLCBtMzQsIG00MSwgbTQyLCBtNDMsIG00NCkge1xyXG5cclxuICAgIGlmICh0eXBlb2YgbTExID09ICdudW1iZXInICYmIGFyZ3VtZW50cy5sZW5ndGggPj0gMTYpIHtcclxuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0MzJBcnJheShhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZihtMTEuX2RhdGEgJiYgbTExLl9kYXRhLmxlbmd0aCAmJiBtMTEuX2RhdGEubGVuZ3RoID09PSAxNikge1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KG0xMS5fZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKG0xMS5sZW5ndGggJiYgbTExLmxlbmd0aCA+PSAxNikge1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KG0xMSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiWE1MM0RNYXRyaXguc2V0KCk6IGludmFsaWQgcGFyYW1ldGVyKHMpLiBFeHBlY3QgWE1MM0RNYXRyaXgsIEZsb2F0MzJBcnJheSBvciAxNiBudW1iZXJzLlwiKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFhNTDNETWF0cml4LlxyXG4gKiBAb3ZlcnJpZGVcclxuICogQHJldHVybiB7c3RyaW5nfSBIdW1hbi1yZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFhNTDNETWF0cml4LlxyXG4gKi9cclxucC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFwiW29iamVjdCBYTUwzRE1hdHJpeF1cIjtcclxufTtcclxuXHJcbnAuc2V0TWF0cml4VmFsdWUgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHZhciBtID0gL14oXFxTKylcXHMrKFxcUyspXFxzKyhcXFMrKVxccysoXFxTKylcXHMrKFxcUyspXFxzKyhcXFMrKVxccysoXFxTKylcXHMrKFxcUyspXFxzKyhcXFMrKVxccysoXFxTKylcXHMrKFxcUyspXFxzKyhcXFMrKVxccysoXFxTKylcXHMrKFxcUyspXFxzKyhcXFMrKVxccysoXFxTKykkL1xyXG4gICAgICAgICAgICAuZXhlYyhzdHIpO1xyXG5cclxuICAgIGlmICghbSlcclxuICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICAgIGNvZGUgOiBET01FeGNlcHRpb24uU1lOVEFYX0VSUixcclxuICAgICAgICAgICAgbWVzc2FnZSA6IFwiU1lOVEFYX0VSUjogRE9NIEV4Y2VwdGlvbiAxMlwiXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICBpZiAobS5sZW5ndGggIT0gMTcpIC8vIG1bMF0gaXMgdGhlIHdob2xlIHN0cmluZywgdGhlIHJlc3QgaXMgdGhlIGFjdHVhbFxyXG4gICAgICAgIC8vIHJlc3VsdFxyXG4gICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgY29kZSA6IERPTUV4Y2VwdGlvbi5TWU5UQVhfRVJSLFxyXG4gICAgICAgICAgICBtZXNzYWdlIDogXCJJbGxlZ2FsIG51bWJlciBvZiBlbGVtZW50czogXCIgKyAobS5sZW5ndGggLSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICsgXCJleHBlY3RlZDogMTZcIlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobS5zbGljZSgxKSk7XHJcbiAgICBpZiAodGhpcy5fY2FsbGJhY2spXHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sodGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogTXVsdGlwbHkgcmV0dXJucyBhIG5ldyBjb25zdHJ1Y3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiB0aGlzIG1hdHJpeFxyXG4gKiBtdWx0aXBsaWVkIGJ5IHRoZSBhcmd1bWVudCB3aGljaCBjYW4gYmUgYW55IG9mOiBYTUwzRE1hdHJpeCwgWE1MM0RWZWMzLFxyXG4gKiBYTUwzRFJvdGF0aW9uLiBUaGlzIG1hdHJpeCBpcyBub3QgbW9kaWZpZWQuXHJcbiAqIEBwYXJhbSB7WE1MM0RNYXRyaXh9IHNlY29uZE1hdHJpeCBNYXRyaXggdG8gbXVsdGlwbHkgd2l0aFxyXG4gKiBAcmV0dXJuIHtYTUwzRE1hdHJpeH0gTmV3IG1hdHJpeCB3aXRoIHRoZSByZXN1bHRcclxuICovXHJcbnAubXVsdGlwbHkgPSBmdW5jdGlvbihzZWNvbmRNYXRyaXgpIHtcclxuICAgIHZhciByZXN1bHQgPSBuZXcgWE1MM0RNYXRyaXgoKTtcclxuICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseShyZXN1bHQuX2RhdGEsIHRoaXMuX2RhdGEsIHNlY29uZE1hdHJpeC5fZGF0YSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludmVyc2UgcmV0dXJucyBhIG5ldyBtYXRyaXggd2hpY2ggaXMgdGhlIGludmVyc2Ugb2YgdGhpcyBtYXRyaXguIFRoaXNcclxuICogbWF0cml4IGlzIG5vdCBtb2RpZmllZC5cclxuICogQHJldHVybiB7WE1MM0RNYXRyaXh9IEludmVydGVkIG1hdHJpeFxyXG4gKiBAdGhyb3dzIERPTUV4Y2VwdGlvbiB3aGVuIHRoZSBtYXRyaXggY2Fubm90IGJlIGludmVydGVkLlxyXG4gKi9cclxucC5pbnZlcnNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFhNTDNETWF0cml4KCk7XHJcbiAgICByZXN1bHQuX2RhdGEgPSBYTUwzRC5tYXRoLm1hdDQuaW52ZXJ0KHJlc3VsdC5fZGF0YSwgdGhpcy5fZGF0YSk7XHJcbiAgICBpZiAocmVzdWx0Ll9kYXRhID09IG51bGwgfHwgaXNOYU4ocmVzdWx0Ll9kYXRhWzBdKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gaW52ZXJ0IG1hdHJpeCB0aGF0IGlzIG5vdCBpbnZlcnRhYmxlLlwiKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBtYXRyaXggd2hpY2ggaXMgdGhpcyBtYXRyaXggbXVsdGlwbGllZCBieSBlYWNoXHJcbiAqIG9mIDMgcm90YXRpb25zIGFib3V0IHRoZSBtYWpvciBheGVzLiBJZiB0aGUgeSBhbmQgeiBjb21wb25lbnRzIGFyZVxyXG4gKiB1bmRlZmluZWQsIHRoZSB4IHZhbHVlIGlzIHVzZWQgdG8gcm90YXRlIHRoZSBvYmplY3QgYWJvdXQgdGhlIHogYXhpcy5cclxuICogUm90YXRpb24gdmFsdWVzIGFyZSBpbiBSQURJQU5TLiBUaGlzIG1hdHJpeCBpcyBub3QgbW9kaWZpZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtYTUwzRE1hdHJpeH0gbmV3IHJvdGF0ZWQgbWF0cml4XHJcbiAqL1xyXG5wLnJvdGF0ZSA9IGZ1bmN0aW9uKHJvdFgsIHJvdFksIHJvdFopIHtcclxuICAgIHZhciByID0gbmV3IFhNTDNETWF0cml4KCk7XHJcbiAgICBpZihyb3RZID09PSB1bmRlZmluZWQgJiYgcm90WiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgWE1MM0QubWF0aC5tYXQ0LnJvdGF0ZVooci5fZGF0YSwgdGhpcy5fZGF0YSwgcm90WCk7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcbiAgICBYTUwzRC5tYXRoLm1hdDQucm90YXRlWihyLl9kYXRhLCB0aGlzLl9kYXRhLCByb3RaKTtcclxuICAgIFhNTDNELm1hdGgubWF0NC5yb3RhdGVZKHIuX2RhdGEsIHIuX2RhdGEsIHJvdFkpO1xyXG4gICAgWE1MM0QubWF0aC5tYXQ0LnJvdGF0ZVgoci5fZGF0YSwgci5fZGF0YSwgcm90WCk7XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSb3RhdGVBeGlzQW5nbGUgcmV0dXJucyBhIG5ldyBtYXRyaXggd2hpY2ggaXMgdGhpcyBtYXRyaXggbXVsdGlwbGllZCBieSBhXHJcbiAqIHJvdGF0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBYTUwzRFJvdGF0aW9uLiBUaGlzIG1hdHJpeCBpcyBub3RcclxuICogbW9kaWZpZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IHgtY29tcG9uZW50IG9mIHRoZSByb3RhdGlvbiBheGlzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IHktY29tcG9uZW50IG9mIHRoZSByb3RhdGlvbiBheGlzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB6IHotY29tcG9uZW50IG9mIHRoZSByb3RhdGlvbiBheGlzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBhbmdsZSBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHtYTUwzRE1hdHJpeH0gVGhlIHJlc3VsdCBvZiB0aGUgcm90YXRpb24gaW4gYSBuZXcgbWF0cml4XHJcbiAqL1xyXG5wLnJvdGF0ZUF4aXNBbmdsZSA9IGZ1bmN0aW9uKHgsIHksIHosIGFuZ2xlKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFhNTDNETWF0cml4KCk7XHJcbiAgICBYTUwzRC5tYXRoLm1hdDQucm90YXRlKHJlc3VsdC5fZGF0YSwgdGhpcy5fZGF0YSwgYW5nbGUsIFsgeCwgeSwgeiBdKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogU2NhbGUgcmV0dXJucyBhIG5ldyBtYXRyaXggd2hpY2ggaXMgdGhpcyBtYXRyaXggbXVsdGlwbGllZCBieSBhIHNjYWxlXHJcbiAqIG1hdHJpeCBjb250YWluaW5nIHRoZSBwYXNzZWQgdmFsdWVzLiBJZiB0aGUgeiBjb21wb25lbnQgaXMgdW5kZWZpbmVkIGEgMVxyXG4gKiBpcyB1c2VkIGluIGl0cyBwbGFjZS4gSWYgdGhlIHkgY29tcG9uZW50IGlzIHVuZGVmaW5lZCB0aGUgeCBjb21wb25lbnRcclxuICogdmFsdWUgaXMgdXNlZCBpbiBpdHMgcGxhY2UuIFRoaXMgbWF0cml4IGlzIG5vdCBtb2RpZmllZC5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWCBzY2FsZSBmYWN0b3IgaW4geCBkaXJlY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXI9fSBzY2FsZVkgc2NhbGUgZmFjdG9yIGluIHkgZGlyZWN0aW9uLiBPcHRpb25hbC4gSWZcclxuICogICAgICAgICAgICB1bmRlZmluZWQgdGhlIHNjYWxlWCB2YWx1ZSBpcyB1c2VkIGluIGl0cyBwbGFjZVxyXG4gKiBAcGFyYW0ge251bWJlcj19IHNjYWxlWiBzY2FsZSBmYWN0b3IgaW4geiBkaXJlY3Rpb24uIE9wdGlvbmFsLiBJZlxyXG4gKiAgICAgICAgICAgIHVuZGVmaW5lZCAxIGlzIHVzZWQuXHJcbiAqIEByZXR1cm5zIHtYTUwzRE1hdHJpeH0gVGhlIHJlc3VsdCBvZiB0aGUgcm90YXRpb24gaW4gYSBuZXcgbWF0cml4XHJcbiAqL1xyXG5wLnNjYWxlID0gZnVuY3Rpb24oc2NhbGVYLCBzY2FsZVksIHNjYWxlWikge1xyXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBYTUwzRE1hdHJpeCgpO1xyXG4gICAgaWYgKCFzY2FsZVopXHJcbiAgICAgICAgc2NhbGVaID0gMTtcclxuICAgIGlmICghc2NhbGVZKVxyXG4gICAgICAgIHNjYWxlWSA9IHNjYWxlWDtcclxuICAgIFhNTDNELm1hdGgubWF0NC5zY2FsZShyZXN1bHQuX2RhdGEsIHRoaXMuX2RhdGEsIFsgc2NhbGVYLCBzY2FsZVksIHNjYWxlWiBdKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNsYXRlIHJldHVybnMgYSBuZXcgbWF0cml4IHdoaWNoIGlzIHRoaXMgbWF0cml4IG11bHRpcGxpZWQgYnkgYVxyXG4gKiB0cmFuc2xhdGlvbiBtYXRyaXggY29udGFpbmluZyB0aGUgcGFzc2VkIHZhbHVlcy4gVGhpcyBtYXRyaXggaXMgbm90XHJcbiAqIG1vZGlmaWVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0geCBUcmFuc2xhdGlvbiBpbiB4IGRpcmVjdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0geSBUcmFuc2xhdGlvbiBpbiB5IGRpcmVjdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0geiBUcmFuc2xhdGlvbiBpbiB6IGRpcmVjdGlvblxyXG4gKiBAcmV0dXJucyB7WE1MM0RNYXRyaXh9IFRoZSAobmV3KSByZXN1bHRpbmcgbWF0cml4XHJcbiAgKi9cclxucC50cmFuc2xhdGUgPSBmdW5jdGlvbih4LCB5LCB6KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFhNTDNETWF0cml4KCk7XHJcbiAgICBYTUwzRC5tYXRoLm1hdDQudHJhbnNsYXRlKHJlc3VsdC5fZGF0YSwgdGhpcy5fZGF0YSwgW3gsIHksIHpdKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhNTDNETWF0cml4O1xyXG5cclxuIiwiXHJcbi8qKiByZXR1cm5zIGFuIFhNTDNEUmF5IHRoYXQgaGFzIGFuIG9yaWdpbiBhbmQgYSBkaXJlY3Rpb24uXHJcbipcclxuKiBJZiB0aGUgYXJndW1lbnRzIGFyZSBub3QgZ2l2ZW4sIHRoZSByYXkncyBvcmlnaW4gaXMgKDAsMCwwKSBhbmRcclxuKiBwb2ludHMgZG93biB0aGUgbmVnYXRpdmUgei1heGlzLlxyXG4qXHJcbiogIEBwYXJhbSB7WE1MM0RWZWMzPX0gb3JpZ2luIChvcHRpb25hbCkgdGhlIG9yaWdpbiBvZiB0aGUgcmF5XHJcbiogIEBwYXJhbSB7WE1MM0RWZWMzPX0gZGlyZWN0aW9uIChvcHRpb25hbCkgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcmF5XHJcbiogIEBwYXJhbSB7ZnVuY3Rpb24oWE1MM0RSYXk9KT19IGNiIENhbGxlZCBpZiB2YWx1ZSBoYXMgY2hhbmdlZC5cclxuKi9cclxudmFyIFhNTDNEUmF5ID0gZnVuY3Rpb24ob3JpZ2luLCBkaXJlY3Rpb24sIGNiKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgdmFyIHZlY19jYiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGF0Ll9jYWxsYmFjaylcclxuICAgICAgICAgICAgdGhhdC5fY2FsbGJhY2sodGhhdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAcHJpdmF0ZSAqL1xyXG4gICAgdGhpcy5fb3JpZ2luID0gbmV3IHdpbmRvdy5YTUwzRFZlYzMoMCwgMCwgMCwgdmVjX2NiKTtcclxuICAgIHRoaXMuX2RpcmVjdGlvbiA9IG5ldyB3aW5kb3cuWE1MM0RWZWMzKDAsIDAsIC0xLCB2ZWNfY2IpO1xyXG5cclxuICAgIGlmIChvcmlnaW4gJiYgb3JpZ2luLm9yaWdpbikge1xyXG4gICAgICAgIHRoaXMuc2V0KG9yaWdpbiwgZGlyZWN0aW9uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKG9yaWdpbikge1xyXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW4uc2V0KG9yaWdpbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uLnNldChkaXJlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAcHJpdmF0ZSAqICovXHJcbiAgICB0aGlzLl9jYWxsYmFjayA9IHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nID8gY2IgOiAwO1xyXG5cclxufTtcclxudmFyIHAgPSBYTUwzRFJheS5wcm90b3R5cGU7XHJcblxyXG4vKiogQHR5cGUge1hNTDNEVmVjM30gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsIFwib3JpZ2luXCIsIHtcclxuICAgIC8qKiBAdGhpcyB7WE1MM0RSYXl9ICogKi9cclxuICAgIGdldCA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fb3JpZ2luOyB9LFxyXG4gICAgc2V0IDogZnVuY3Rpb24oKSB7IHRocm93IEVycm9yKFwiQ2FuJ3Qgc2V0IGF4aXMuIFhNTDNEUmF5OjpvcmlnaW4gaXMgcmVhZG9ubHkuXCIpOyB9LFxyXG4gICAgY29uZmlndXJhYmxlIDogZmFsc2UsXHJcbiAgICBlbnVtZXJhYmxlIDogZmFsc2VcclxufSk7XHJcblxyXG4vKiogQHR5cGUge1hNTDNEVmVjM30gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsIFwiZGlyZWN0aW9uXCIsIHtcclxuICAgIC8qKiBAdGhpcyB7WE1MM0RSYXl9ICogKi9cclxuICAgIGdldCA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZGlyZWN0aW9uOyB9LFxyXG4gICAgc2V0IDogZnVuY3Rpb24oKSB7IHRocm93IEVycm9yKFwiQ2FuJ3Qgc2V0IGF4aXMuIFhNTDNEUmF5OjpfZGlyZWN0aW9uIGlzIHJlYWRvbmx5LlwiKTsgfSxcclxuICAgIGNvbmZpZ3VyYWJsZSA6IGZhbHNlLFxyXG4gICAgZW51bWVyYWJsZSA6IGZhbHNlXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBzZXQgbWV0aG9kIGNvcGllcyB0aGUgdmFsdWVzIGZyb20gb3RoZXIuXHJcbiAqIEBwYXJhbSB7WE1MM0RSYXl9IG90aGVyIFRoZSBvdGhlciByYXlcclxuICovXHJcbnAuc2V0ID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgIHRoaXMuX29yaWdpbi5zZXQob3RoZXIub3JpZ2luKTtcclxuICAgIHRoaXMuX2RpcmVjdGlvbi5zZXQob3RoZXIuZGlyZWN0aW9uKTtcclxuICAgIGlmICh0aGlzLl9jYWxsYmFjaylcclxuICAgICAgICB0aGlzLl9jYWxsYmFjayh0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFhNTDNEUmF5LlxyXG4gKiBAb3ZlcnJpZGVcclxuICogQHJldHVybiB7c3RyaW5nfSBIdW1hbi1yZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFhNTDNEUmF5LlxyXG4gKi9cclxucC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFwiW29iamVjdCBYTUwzRFJheV1cIjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWE1MM0RSYXk7XHJcbiIsIlxyXG5mdW5jdGlvbiBvcnRob2dvbmFsKHYpIHtcclxuICAgIGlmICgoTWF0aC5hYnModi5fZGF0YVsxXSkgPj0gMC45Kk1hdGguYWJzKHYuX2RhdGFbMF0pKSAmJiAoTWF0aC5hYnModi5fZGF0YVsyXSkgPj0gMC45Kk1hdGguYWJzKHYuX2RhdGFbMF0pKSlcclxuICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUwzRFZlYzMoMC4wLCAtdi5fZGF0YVsyXSwgdi5fZGF0YVsxXSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBpZiAoKE1hdGguYWJzKHYuX2RhdGFbMF0pID49IDAuOSpNYXRoLmFicyh2Ll9kYXRhWzFdKSkgJiYgKE1hdGguYWJzKHYuX2RhdGFbMl0pID49IDAuOSpNYXRoLmFicyh2Ll9kYXRhWzFdKSkpXHJcbiAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUwzRFZlYzMoLXYuX2RhdGFbMl0sIDAuMCwgdi5fZGF0YVswXSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MM0RWZWMzKC12Ll9kYXRhWzFdLCB2Ll9kYXRhWzBdLCAwLjApO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBYTUwzRFJvdGF0aW9uLiBYTUwzRFJvdGF0aW9uIHJlcHJlc2VudHMgYVxyXG4gKiB0aHJlZS1kaW1lbnNpb25hbCB2ZWN0b3IgYXMgYSAzLXR1cGxlIGZsb2F0aW5nIHBvaW50IHZhbHVlcy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEB0aGlzIHtYTUwzRFJvdGF0aW9ufVxyXG4gKiBAcGFyYW0ge1hNTDNEVmVjMz19IGF4aXNcclxuICogQHBhcmFtIHtudW1iZXI9fSBhbmdsZVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFhNTDNEVmVjMz0pPX0gY2IgQ2FsbGVkLCBpZiB2YWx1ZSBoYXMgY2hhbmdlZC5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhhcyB0aGlzIGFzIGZpcnN0IHBhcmFtZXRlci5cclxuICovXHJcbnZhciBYTUwzRFJvdGF0aW9uID0gZnVuY3Rpb24oYXhpcywgYW5nbGUsIGNiKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcclxuXHJcbiAgICB2YXIgdmVjX2NiID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhhdC5fdXBkYXRlUXVhdGVybmlvbigpO1xyXG4gICAgICAgIGlmICh0aGF0Ll9jYWxsYmFjaylcclxuICAgICAgICAgICAgdGhhdC5fY2FsbGJhY2sodGhhdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAcHJpdmF0ZSAqL1xyXG4gICAgdGhpcy5fYXhpcyA9IG5ldyB3aW5kb3cuWE1MM0RWZWMzKDAsIDAsIDEsIHZlY19jYik7XHJcbiAgICAvKiogQHByaXZhdGUgKi9cclxuICAgIHRoaXMuX2FuZ2xlID0gMDtcclxuXHJcbiAgICB0aGlzLl91cGRhdGVRdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgaWYoYXhpcyAhPT0gdW5kZWZpbmVkICYmIGF4aXMgIT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLnNldChheGlzLCBhbmdsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLl9jYWxsYmFjayA9IHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nID8gY2IgOiAwO1xyXG59O1xyXG5cclxudmFyIHAgPSBYTUwzRFJvdGF0aW9uLnByb3RvdHlwZTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgc2V0IG1ldGhvZCBjb3BpZXMgdGhlIHZhbHVlcyBmcm9tIG90aGVyLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgYW5vdGhlciBYTUwzRFJvdGF0aW9uLCBGbG9hdDMyQXJyYXkgb3IgWE1MM0RWZWMzLiBJbiB0aGUgbGFzdCBjYXNlIHRoZSAybmQgYXJndW1lbnQgaXMgY29uc2lkZXJlZC5cclxuICogQHBhcmFtIHtudW1iZXI9fSBhbmdsZVxyXG4gKi9cclxucC5zZXQgPSBmdW5jdGlvbihvdGhlciwgYW5nbGUpIHtcclxuICAgIGlmKG90aGVyLmF4aXMgJiYgb3RoZXIuYW5nbGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMuc2V0QXhpc0FuZ2xlKG90aGVyLmF4aXMsIG90aGVyLmFuZ2xlKTtcclxuICAgIH0gZWxzZSBpZihvdGhlci5sZW5ndGggJiYgb3RoZXIubGVuZ3RoID49IDQpIHtcclxuICAgICAgICB0aGlzLl9zZXRRdWF0ZXJuaW9uKG90aGVyKTtcclxuICAgIH0gZWxzZSBpZihvdGhlci5fZGF0YSAmJiBvdGhlci5fZGF0YS5sZW5ndGggJiYgb3RoZXIuX2RhdGEubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgdGhpcy5zZXRBeGlzQW5nbGUob3RoZXIsIGFuZ2xlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJYTUwzRFJvdGF0aW9uLnNldCgpOiBpbnZhbGlkIGFyZ3VtZW50IGdpdmVuLiBFeHBlY3QgWE1MM0RSb3RhdGlvbiBvciBGbG9hdDMyQXJyYXkuXCIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcImF4aXNcIiwge1xyXG4gICAgLyoqIEB0aGlzIHtYTUwzRFJvdGF0aW9ufSAqICovXHJcbiAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXhpcztcclxuICAgIH0sXHJcbiAgICBzZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aHJvdyBFcnJvcihcIkNhbid0IHNldCBheGlzLiBYTUwzRFJvdGF0aW9uOjpheGlzIGlzIHJlYWRvbmx5LlwiKTtcclxuICAgIH0sXHJcbiAgICBjb25maWd1cmFibGUgOiBmYWxzZSxcclxuICAgIGVudW1lcmFibGUgOiBmYWxzZVxyXG59KTtcclxuXHJcbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJhbmdsZVwiLCB7XHJcbiAgICAvKiogQHRoaXMge1hNTDNEUm90YXRpb259ICogKi9cclxuICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbmdsZTtcclxuICAgIH0sXHJcbiAgICBzZXQgOiBmdW5jdGlvbihhbmdsZSkge1xyXG4gICAgICAgIHRoaXMuX2FuZ2xlID0gYW5nbGU7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlUXVhdGVybmlvbigpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFjaylcclxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2sodGhpcyk7XHJcbn0sXHJcbmNvbmZpZ3VyYWJsZSA6IGZhbHNlLFxyXG5lbnVtZXJhYmxlIDogZmFsc2VcclxufSk7XHJcblxyXG4vKipcclxuICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBYTUwzRFJvdGF0aW9uLlxyXG4gKiBAb3ZlcnJpZGVcclxuICogQHRoaXMge1hNTDNEUm90YXRpb259XHJcbiAqIEByZXR1cm4ge3N0cmluZ30gSHVtYW4tcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBYTUwzRFJvdGF0aW9uLlxyXG4gKi9cclxucC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFwiW29iamVjdCBYTUwzRFJvdGF0aW9uXVwiO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlcGxhY2VzIHRoZSBleGlzdGluZyByb3RhdGlvbiB3aXRoIHRoZSBheGlzLWFuZ2xlIHJlcHJlc2VudGF0aW9uIHBhc3NlZFxyXG4gKiBhcyBhcmd1bWVudFxyXG4gKi9cclxucC5zZXRBeGlzQW5nbGUgPSBmdW5jdGlvbihheGlzLCBhbmdsZSkge1xyXG4gICAgaWYgKHR5cGVvZiBheGlzICE9ICdvYmplY3QnIHx8IGlzTmFOKGFuZ2xlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgYXhpcyBhbmQvb3IgYW5nbGUgdmFsdWVzOiBcIiArIFwiKCBheGlzPVwiXHJcbiAgICAgICAgICAgICAgICArIGF4aXMgKyBcIiBhbmdsZT1cIiArIGFuZ2xlICsgXCIgKVwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBzbGljZT9cclxuICAgIHRoaXMuX2F4aXMuX2RhdGFbMF0gPSBheGlzLl9kYXRhWzBdO1xyXG4gICAgdGhpcy5fYXhpcy5fZGF0YVsxXSA9IGF4aXMuX2RhdGFbMV07XHJcbiAgICB0aGlzLl9heGlzLl9kYXRhWzJdID0gYXhpcy5fZGF0YVsyXTtcclxuICAgIHRoaXMuX2FuZ2xlID0gYW5nbGU7XHJcbiAgICB0aGlzLl91cGRhdGVRdWF0ZXJuaW9uKCk7XHJcbiAgICBpZiAodGhpcy5fY2FsbGJhY2spXHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sodGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVwbGFjZXMgdGhlIGV4aXN0aW5nIHJvdGF0aW9uIHdpdGggb25lIGNvbXB1dGVkIGZyb20gdGhlIHR3byB2ZWN0b3JzXHJcbiAqIHBhc3NlZCBhcyBhcmd1bWVudHMuIHtYTUwzRFZlY30gZnJvbSBGaXJzdCB2ZWN0b3Ige1hNTDNEVmVjfSBmcm9tIFNlY29uZFxyXG4gKiB2ZWN0b3JcclxuICovXHJcbnAuc2V0Um90YXRpb24gPSBmdW5jdGlvbihmcm9tLCB0bykge1xyXG4gICAgdmFyIGEgPSBmcm9tLm5vcm1hbGl6ZSgpO1xyXG4gICAgdmFyIGIgPSB0by5ub3JtYWxpemUoKTtcclxuXHJcbiAgICB2YXIgYXhpcyA9IGEuY3Jvc3MoYik7XHJcbiAgICBpZiAoIWF4aXMubGVuZ3RoKCkpIHtcclxuICAgICAgICAvLyBmcm9tIGFuZCB0byBhcmUgcGFyYWxsZWxcclxuICAgICAgICBheGlzID0gb3J0aG9nb25hbChhKTtcclxuICAgIH1cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBhbHNvIGNhbGxiYWNrXHJcbiAgICB0aGlzLnNldEF4aXNBbmdsZShheGlzLCBNYXRoLmFjb3MoYS5kb3QoYikpKTtcclxufTtcclxuXHJcbnAuX3VwZGF0ZVF1YXRlcm5pb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBsID0gdGhpcy5fYXhpcy5sZW5ndGgoKTtcclxuICAgIGlmIChsID4gMC4wMDAwMSkge1xyXG4gICAgICAgIHZhciBzID0gTWF0aC5zaW4odGhpcy5fYW5nbGUgLyAyKSAvIGw7XHJcbiAgICAgICAgdGhpcy5fZGF0YVswXSA9IHRoaXMuX2F4aXMueCAqIHM7XHJcbiAgICAgICAgdGhpcy5fZGF0YVsxXSA9IHRoaXMuX2F4aXMueSAqIHM7XHJcbiAgICAgICAgdGhpcy5fZGF0YVsyXSA9IHRoaXMuX2F4aXMueiAqIHM7XHJcbiAgICAgICAgdGhpcy5fZGF0YVszXSA9IE1hdGguY29zKHRoaXMuX2FuZ2xlIC8gMik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIFhNTDNELm1hdGgucXVhdC5zZXQodGhpcy5fZGF0YSwgMCwgMCwgMCwgMSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVwbGFjZXMgdGhlIGV4aXN0aW5nIG1hdHJpeCB3aXRoIG9uZSBjb21wdXRlZCBmcm9tIHBhcnNpbmcgdGhlIHBhc3NlZFxyXG4gKiBzdHJpbmcuXHJcbiAqIEBwYXJhbSBzdHIgU3RyaW5nIHRvIHBhcnNlXHJcbiAqL1xyXG5wLnNldEF4aXNBbmdsZVZhbHVlID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICB2YXIgbSA9IC9eXFxzKihcXFMrKVxccysoXFxTKylcXHMrKFxcUyspXFxzKyhcXFMrKVxccyokLy5leGVjKHN0cik7XHJcbiAgICBpZiAoIW0pXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIEF4aXNBbmdsZSBzdHJpbmc6IFwiICsgc3RyKTtcclxuXHJcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYWxzbyBjYWxsYmFja1xyXG4gICAgdGhpcy5zZXRBeGlzQW5nbGUobmV3IHdpbmRvdy5YTUwzRFZlYzMoK21bMV0sICttWzJdLCArbVszXSksICttWzRdKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBMaW5lYXIgaW50ZXJwb2xhdGlvbiBvZiB0aGlzIHJvdGF0aW9uIHJvdDAgd2l0aCB0aGUgcGFzc2VkIHJvdGF0aW9uIHJvdDFcclxuICogd2l0aCBmYWN0b3IgdC4gVGhlIHJlc3VsdCBpcyAoMS10KXJvdDAgKyB0IHJvdDEuIFR5cGljYWxseSByZWFsaXplZCB3aXRoXHJcbiAqIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJhc2VkIG9uIHF1YXRlcm5pb25zLlxyXG4gKiBAcGFyYW0ge1hNTDNEUm90YXRpb259IHJvdDEgdGhlIHBhc3NlZCByb3RhdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdCB0aGUgZmFjdG9yXHJcbiAqL1xyXG5wLmludGVycG9sYXRlID0gZnVuY3Rpb24ocm90MSwgdCkge1xyXG4gICAgdmFyIGRlc3QgPSBYTUwzRC5tYXRoLnF1YXQuY3JlYXRlKCksIHJlc3VsdCA9IG5ldyBYTUwzRFJvdGF0aW9uKCk7XHJcbiAgICBYTUwzRC5tYXRoLnF1YXQuc2xlcnAoZGVzdCwgdGhpcy5fZGF0YSwgcm90MS5fZGF0YSwgdCk7XHJcbiAgICByZXN1bHQuX3NldFF1YXRlcm5pb24oZGVzdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlcGxhY2VzIHRoZSBleGlzdGluZyByb3RhdGlvbiB3aXRoIHRoZSBxdWF0ZXJuaW9uIHJlcHJlc2VudGF0aW9uIHBhc3NlZFxyXG4gKiBhcyBhcmd1bWVudFxyXG4gKiBAcGFyYW0ge1hNTDNEVmVjM30gdmVjdG9yXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXJcclxuICovXHJcbnAuc2V0UXVhdGVybmlvbiA9IGZ1bmN0aW9uKHZlY3Rvciwgc2NhbGFyKSB7XHJcbiAgICB0aGlzLl9zZXRRdWF0ZXJuaW9uKCBbIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnosIHNjYWxhciBdKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgWE1MM0RNYXRyaXggdGhhdCBkZXNjcmliZXMgdGhpcyAzRCByb3RhdGlvbiBpbiBhXHJcbiAqIDR4NCBtYXRyaXggcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm4ge1hNTDNETWF0cml4fSBSb3RhdGlvbiBtYXRyaXhcclxuICovXHJcbnAudG9NYXRyaXggPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBxID0gWE1MM0QubWF0aC5xdWF0LmNvcHkoWE1MM0QubWF0aC5xdWF0LmNyZWF0ZSgpLCB0aGlzLl9kYXRhKTtcclxuICAgIHZhciBtID0gbmV3IFhNTDNETWF0cml4KCk7XHJcbiAgICBYTUwzRC5tYXRoLm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24obS5fZGF0YSwgcSwgWzAsIDAsIDBdKTtcclxuICAgIHJldHVybiBtO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJvdGF0ZXMgdGhlIHZlY3RvciBwYXNzZWQgYXMgcGFyYW1ldGVyIHdpdGggdGhpcyByb3RhdGlvblxyXG4gKiByZXByZXNlbnRhdGlvbi4gVGhlIHJlc3VsdCBpcyByZXR1cm5lZCBhcyBuZXcgdmVjdG9yIGluc3RhbmNlLlxyXG4gKiBOZWl0aGVyIHRoaXMgbm9yIHRoZSBpbnB1dFZlY3RvciBhcmUgY2hhbmdlZC5cclxuICogNHg0IG1hdHJpeCByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHtYTUwzRFZlYzN9IGlucHV0VmVjdG9yXHJcbiAqIEByZXR1cm4ge1hNTDNEVmVjM30gVGhlIHJvdGF0ZWQgdmVjdG9yXHJcbiAqL1xyXG5wLnJvdGF0ZVZlYzMgPSBmdW5jdGlvbihpbnB1dFZlY3Rvcikge1xyXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBYTUwzRFZlYzMoKTtcclxuICAgIFhNTDNELm1hdGgudmVjMy50cmFuc2Zvcm1RdWF0KHJlc3VsdC5fZGF0YSwgaW5wdXRWZWN0b3IuX2RhdGEsIHRoaXMuX2RhdGEpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXBsYWNlcyB0aGUgZXhpc3Rpbmcgcm90YXRpb24gd2l0aCB0aGUgcXVhdGVybmlvbiByZXByZXNlbnRhdGlvbiBwYXNzZWRcclxuICogYXMgYXJndW1lbnRcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtBcnJheX0gcVxyXG4gKi9cclxucC5fc2V0UXVhdGVybmlvbiA9IGZ1bmN0aW9uKHEpIHtcclxuICAgIHZhciBzID0gTWF0aC5zcXJ0KDEgLSBxWzNdICogcVszXSk7XHJcbiAgICBpZiAocyA8IDAuMDAxIHx8IGlzTmFOKHMpKSB7XHJcbiAgICAgICAgdGhpcy5fYXhpcy5fZGF0YVswXSA9IDA7XHJcbiAgICAgICAgdGhpcy5fYXhpcy5fZGF0YVsxXSA9IDA7XHJcbiAgICAgICAgdGhpcy5fYXhpcy5fZGF0YVsyXSA9IDE7XHJcbiAgICAgICAgdGhpcy5fYW5nbGUgPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBzID0gMSAvIHM7XHJcbiAgICAgICAgdGhpcy5fYXhpcy5fZGF0YVswXSA9IHFbMF0gKiBzO1xyXG4gICAgICAgIHRoaXMuX2F4aXMuX2RhdGFbMV0gPSBxWzFdICogcztcclxuICAgICAgICB0aGlzLl9heGlzLl9kYXRhWzJdID0gcVsyXSAqIHM7XHJcbiAgICAgICAgdGhpcy5fYW5nbGUgPSAyICogTWF0aC5hY29zKHFbM10pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fZGF0YSA9IFhNTDNELm1hdGgucXVhdC5jb3B5KFhNTDNELm1hdGgucXVhdC5jcmVhdGUoKSwgcSk7XHJcbiAgICBpZiAodGhpcy5fY2FsbGJhY2spXHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sodGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogTXVsdGlwbGllcyB0aGlzIHJvdGF0aW9uIHdpdGggdGhlIHBhc3NlZCByb3RhdGlvbi4gVGhpcyByb3RhdGlvbiBpcyBub3RcclxuICogY2hhbmdlZC5cclxuICpcclxuICogQHBhcmFtIHtYTUwzRFJvdGF0aW9ufSByb3QxXHJcbiAqIEByZXR1cm4ge1hNTDNEUm90YXRpb259IFRoZSByZXN1bHRcclxuICovXHJcbnAubXVsdGlwbHkgPSBmdW5jdGlvbihyb3QxKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFhNTDNEUm90YXRpb24oKSwgcSA9IFhNTDNELm1hdGgucXVhdC5jcmVhdGUoKTtcclxuICAgIFhNTDNELm1hdGgucXVhdC5tdWx0aXBseShxLCB0aGlzLl9kYXRhLCByb3QxLl9kYXRhKTtcclxuICAgIHJlc3VsdC5fc2V0UXVhdGVybmlvbihxKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoaXMgcm90YXRpb24uIFJlc3VsdCBpcyBhIG5ld2x5XHJcbiAqIGNyZWF0ZWQgdmVjdG9yLiBUaGlzIGlzIG5vdCBtb2RpZmllZC5cclxuICovXHJcbnAubm9ybWFsaXplID0gZnVuY3Rpb24odGhhdCkge1xyXG4gICAgdmFyIG5hID0gdGhpcy5fYXhpcy5ub3JtYWxpemUoKTtcclxuICAgIHJldHVybiBuZXcgWE1MM0RSb3RhdGlvbihuYSwgdGhpcy5fYW5nbGUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHF1YXRlcm5pb24sIHRoYXQgdW5kZXJsaWVzIHRoaXMgcm90YXRpb24uXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX1cclxuICovXHJcbnAuZ2V0UXVhdGVybmlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFhNTDNELm1hdGgucXVhdC5jb3B5KFhNTDNELm1hdGgucXVhdC5jcmVhdGUoKSwgdGhpcy5fZGF0YSk7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IHRoaXMgcm90YXRpb24gYmFzZWQgb24gdGhlIGdpdmVuIGJhc2UgdmVjdG9ycy5cclxuICpcclxuICogQHBhcmFtIHtYTUwzRFZlYzN9IHhBeGlzXHJcbiAqIEBwYXJhbSB7WE1MM0RWZWMzfSB5QXhpc1xyXG4gKiBAcGFyYW0ge1hNTDNEVmVjM30gekF4aXNcclxuICovXHJcbnAuc2V0RnJvbUJhc2lzID0gZnVuY3Rpb24oeEF4aXMsIHlBeGlzLCB6QXhpcykge1xyXG4gICAgdmFyIHEgPSBYTUwzRC5tYXRoLnF1YXQuY3JlYXRlKCk7XHJcbiAgICBYTUwzRC5tYXRoLnF1YXQuc2V0RnJvbUJhc2lzKHhBeGlzLl9kYXRhLCB5QXhpcy5fZGF0YSwgekF4aXMuX2RhdGEsIHEpO1xyXG4gICAgdGhpcy5fc2V0UXVhdGVybmlvbihxKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWE1MM0RSb3RhdGlvbjsiLCJcclxuLyoqXHJcbiAqIENvbmZpZ3VyZSBhcnJheSBwcm9wZXJ0aWVzXHJcbiAqICBAcHJpdmF0ZVxyXG4gKiAgQHRoaXMge1hNTDNEVmVjM31cclxuICogIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBBcnJheSBpbmRleFxyXG4gKi9cclxuZnVuY3Rpb24gcHJvcChpbmRleCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbaW5kZXhdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0IDogZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGFbaW5kZXhdID0gdmFsO1xyXG4gICAgICAgICAgICAvLyBWYWx1ZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWxsYmFjaylcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrKHRoaXMpO1xyXG4gICAgfSxcclxuICAgIGNvbmZpZ3VyYWJsZSA6IGZhbHNlLFxyXG4gICAgZW51bWVyYWJsZSA6IGZhbHNlXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBYTUwzRFZlYzMuIFhNTDNEVmVjMyByZXByZXNlbnRzIGFcclxuICogdGhyZWUtZGltZW5zaW9uYWwgdmVjdG9yIGFzIGEgMy10dXBsZSBmbG9hdGluZyBwb2ludCB2YWx1ZXMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAdGhpcyB7WE1MM0RWZWMzfVxyXG4gKiBAcGFyYW0ge251bWJlcj19IHggVGhlIHggdmFsdWUgKG9wdGlvbmFsKS4gRGVmYXVsdDogMC5cclxuICogQHBhcmFtIHtudW1iZXI9fSB5IFRoZSB5IHZhbHVlIChvcHRpb25hbCkuIERlZmF1bHQ6IDAuXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0geiBUaGUgeiB2YWx1ZSAob3B0aW9uYWwpLiBEZWZhdWx0OiAwLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFhNTDNEVmVjMz0pPX0gY2IgQ2FsbGVkLCBpZiB2YWx1ZSBoYXMgY2hhbmdlZC5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhhcyB0aGlzIGFzIGZpcnN0IHBhcmFtZXRlci5cclxuICovXHJcbnZhciBYTUwzRFZlYzMgPSBmdW5jdGlvbih4LCB5LCB6LCBjYikge1xyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcclxuXHJcbiAgICBpZih4ICE9PSB1bmRlZmluZWQgJiYgeCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuc2V0KHgseSx6KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9jYWxsYmFjayA9IHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nID8gY2IgOiAwO1xyXG5cclxufSwgcCA9IFhNTDNEVmVjMy5wcm90b3R5cGU7XHJcblxyXG4vKipcclxuICogVGhlIHNldCBtZXRob2QgY29waWVzIHRoZSB2YWx1ZXMgZnJvbSBvdGhlci5cclxuICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBvdGhlciBhbm90aGVyIFhNTDNEVmVjMywgRmxvYXQzMkFycmF5IG9yIGEgbnVtYmVyLiBJbiB0aGUgbGFzdCBjYXNlIHRoZSBvdGhlciBhcmdzIGFyZSBjb25zaWRlcmVkLCB0b28uXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0geVxyXG4gKiBAcGFyYW0ge251bWJlcj19IHpcclxuICovXHJcbnAuc2V0ID0gZnVuY3Rpb24ob3RoZXIseSx6KSB7XHJcbiAgICBpZihvdGhlci5sZW5ndGggJiYgb3RoZXIubGVuZ3RoID49IDMpIHtcclxuICAgICAgICB0aGlzLl9kYXRhWzBdID0gb3RoZXJbMF07XHJcbiAgICAgICAgdGhpcy5fZGF0YVsxXSA9IG90aGVyWzFdO1xyXG4gICAgICAgIHRoaXMuX2RhdGFbMl0gPSBvdGhlclsyXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYob3RoZXIuX2RhdGEgJiYgb3RoZXIuX2RhdGEubGVuZ3RoICYmIG90aGVyLl9kYXRhLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgIHRoaXMuX2RhdGFbMF0gPSBvdGhlci5fZGF0YVswXTtcclxuICAgICAgICB0aGlzLl9kYXRhWzFdID0gb3RoZXIuX2RhdGFbMV07XHJcbiAgICAgICAgdGhpcy5fZGF0YVsyXSA9IG90aGVyLl9kYXRhWzJdO1xyXG4gICAgfSBlbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMykge1xyXG4gICAgICAgIHRoaXMuX2RhdGFbMF0gPSBvdGhlcjtcclxuICAgICAgICB0aGlzLl9kYXRhWzFdID0geTtcclxuICAgICAgICB0aGlzLl9kYXRhWzJdID0gejtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9jYWxsYmFjaylcclxuICAgICAgICB0aGlzLl9jYWxsYmFjayh0aGlzKTtcclxufTtcclxuXHJcbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJ4XCIsIHByb3AoMCkpO1xyXG4vKiogQHR5cGUge251bWJlcn0gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsIFwieVwiLCBwcm9wKDEpKTtcclxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcInpcIiwgcHJvcCgyKSk7XHJcblxyXG4vKipcclxuICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBYTUwzRFZlYzMuXHJcbiAqIEBvdmVycmlkZVxyXG4gKiBAdGhpcyB7WE1MM0RWZWMzfVxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEh1bWFuLXJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgWE1MM0RWZWMzLlxyXG4gKi9cclxucC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFwiW29iamVjdCBYTUwzRFZlYzNdXCI7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29tcG9uZW50LXdpc2UgYWRkaXRpb24gb2YgdGhpcyB2ZWN0b3Igd2l0aCBhIHNlY29uZCB2ZWN0b3JcclxuICogcGFzc2VkIGFzIHBhcmFtZXRlci4gUmVzdWx0IGlzIGEgbmV3bHkgY3JlYXRlZCB2ZWN0b3IuIFRoaXMgaXMgbm90XHJcbiAqIG1vZGlmaWVkLlxyXG4gKiBAcGFyYW0ge1hNTDNEVmVjM30gdGhhdCBUaGUgdmVjdG9yIHRvIGFkZFxyXG4gKiBAcmV0dXJuIHtYTUwzRFZlYzN9IFRoZSBuZXcgdmVjdG9yIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb25cclxuICovXHJcbnAuYWRkID0gZnVuY3Rpb24odGhhdCkge1xyXG4gICAgaWYgKHRoYXQuX2RhdGEpXHJcbiAgICAgICAgcmV0dXJuIG5ldyBYTUwzRFZlYzModGhpcy5fZGF0YVswXSArIHRoYXQuX2RhdGFbMF0sIHRoaXMuX2RhdGFbMV1cclxuICAgICAgICAgICAgICAgICsgdGhhdC5fZGF0YVsxXSwgdGhpcy5fZGF0YVsyXSArIHRoYXQuX2RhdGFbMl0pO1xyXG4gICAgcmV0dXJuIG5ldyBYTUwzRFZlYzModGhpcy5fZGF0YVswXSArIHRoYXQueCwgdGhpcy5fZGF0YVsxXSArIHRoYXQueSxcclxuICAgICAgICAgICAgdGhpcy5fZGF0YVsyXSArIHRoYXQueik7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29tcG9uZW50LXdpc2Ugc3VidHJhY3Rpb24gb2YgdGhpcyB2ZWN0b3Igd2l0aCBhIHNlY29uZFxyXG4gKiB2ZWN0b3IgcGFzc2VkIGFzIHBhcmFtZXRlci4gUmVzdWx0IGlzIGEgbmV3bHkgY3JlYXRlZCB2ZWN0b3IuIFRoaXMgaXMgbm90XHJcbiAqIG1vZGlmaWVkLlxyXG4gKiBAcGFyYW0ge1hNTDNEVmVjM30gdGhhdCBUaGUgdmVjdG9yIHRvIHN1YnRyYWN0XHJcbiAqIEByZXR1cm4ge1hNTDNEVmVjM30gVGhlIG5ldyB2ZWN0b3Igd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvblxyXG4gKi9cclxucC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKHRoYXQpIHtcclxuICAgIGlmICh0aGF0Ll9kYXRhKVxyXG4gICAgICAgIHJldHVybiBuZXcgWE1MM0RWZWMzKHRoaXMuX2RhdGFbMF0gLSB0aGF0Ll9kYXRhWzBdLCB0aGlzLl9kYXRhWzFdXHJcbiAgICAgICAgICAgICAgICAtIHRoYXQuX2RhdGFbMV0sIHRoaXMuX2RhdGFbMl0gLSB0aGF0Ll9kYXRhWzJdKTtcclxuICAgIHJldHVybiBuZXcgWE1MM0RWZWMzKHRoaXMuX2RhdGFbMF0gLSB0aGF0LngsIHRoaXMuX2RhdGFbMV0gLSB0aGF0LnksXHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGFbMl0gLSB0aGF0LnopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGlzIHZlY3Rvci5cclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGVuZ3RoIG9mIHRoaXMgdmVjdG9yXHJcbiAqL1xyXG5wLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCgodGhpcy5fZGF0YVswXSAqIHRoaXMuX2RhdGFbMF0pXHJcbiAgICAgICAgICAgICsgKHRoaXMuX2RhdGFbMV0gKiB0aGlzLl9kYXRhWzFdKVxyXG4gICAgICAgICAgICArICh0aGlzLl9kYXRhWzJdICogdGhpcy5fZGF0YVsyXSkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBzZXRWZWMzVmFsdWUgbWV0aG9kIHJlcGxhY2VzIHRoZSBleGlzdGluZyB2ZWN0b3Igd2l0aCBvbmUgY29tcHV0ZWRcclxuICogZnJvbSBwYXJzaW5nIHRoZSBwYXNzZWQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gcGFyc2VcclxuICogQHRocm93cyB7RXJyb3J9IElmIHBhc3NlZCBzdHJpbmcgY2FuIG5vdCBiZSBwYXJzZWRcclxuICovXHJcbnAuc2V0VmVjM1ZhbHVlID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICB2YXIgbSA9IC9eXFxzKihcXFMrKVxccysoXFxTKylcXHMrKFxcUyspXFxzKiQvLmV4ZWMoc3RyKTtcclxuICAgIGlmICghbSkgLy8gVE9ETyBUaHJvdyBET01FeGNlcHRpb25cclxuICAgICAgICB0aHJvdyBFcnJvcihcIldyb25nIGZvcm1hdCBmb3IgWE1MM0RWZWMzOjpzZXRWZWMzVmFsdWVcIik7XHJcbiAgICB0aGlzLl9kYXRhWzBdID0gK21bMV07XHJcbiAgICB0aGlzLl9kYXRhWzFdID0gK21bMl07XHJcbiAgICB0aGlzLl9kYXRhWzJdID0gK21bM107XHJcbiAgICBpZiAodGhpcy5fY2FsbGJhY2spXHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sodGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29tcG9uZW50LXdpc2UgbXVsdGlwbGljYXRpb24gb2YgdGhpcyB2ZWN0b3Igd2l0aCBhIHNlY29uZFxyXG4gKiB2ZWN0b3IgcGFzc2VkIGFzIHBhcmFtZXRlci4gUmVzdWx0IGlzIGEgbmV3bHkgY3JlYXRlZCB2ZWN0b3IuIFRoaXMgaXMgbm90XHJcbiAqIG1vZGlmaWVkLlxyXG4gKiBAcGFyYW0ge1hNTDNEVmVjM30gdGhhdCBUaGUgdmVjdG9yIHRvIG11bHRpcGx5XHJcbiAqIEByZXR1cm4ge1hNTDNEVmVjM30gVGhlIG5ldyB2ZWN0b3Igd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvblxyXG4gKi9cclxucC5tdWx0aXBseSA9IGZ1bmN0aW9uKHRoYXQpIHtcclxuICAgIGlmICh0aGF0Ll9kYXRhKVxyXG4gICAgICAgIHJldHVybiBuZXcgWE1MM0RWZWMzKHRoaXMuX2RhdGFbMF0gKiB0aGF0Ll9kYXRhWzBdLCB0aGlzLl9kYXRhWzFdXHJcbiAgICAgICAgICAgICAgICAqIHRoYXQuX2RhdGFbMV0sIHRoaXMuX2RhdGFbMl0gKiB0aGF0Ll9kYXRhWzJdKTtcclxuICAgIHJldHVybiBuZXcgWE1MM0RWZWMzKHRoaXMuX2RhdGFbMF0gKiB0aGF0LngsIHRoaXMuX2RhdGFbMV0gKiB0aGF0LnksXHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGFbMl0gKiB0aGF0LnopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNvbXBvbmVudC13aXNlIG11bHRpcGxpY2F0aW9uIG9mIHRoaXMgdmVjdG9yIHdpdGggYSBmYWN0b3JcclxuICogcGFzc2VkIGFzIHBhcmFtZXRlci4gUmVzdWx0IGlzIGEgbmV3bHkgY3JlYXRlZCB2ZWN0b3IuIFRoaXMgaXMgbm90XHJcbiAqIG1vZGlmaWVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFjIFRoZSBmYWN0b3IgZm9yIHRoZSBtdWx0aXBsaWNhdGlvblxyXG4gKiBAcmV0dXJuIHtYTUwzRFZlYzN9IFRoZSBuZXcgYW5kIHNjYWxlZCB2ZWN0b3JcclxuICovXHJcbnAuc2NhbGUgPSBmdW5jdGlvbihmYWMpIHtcclxuICAgIHJldHVybiBuZXcgWE1MM0RWZWMzKHRoaXMuX2RhdGFbMF0gKiBmYWMsIHRoaXMuX2RhdGFbMV0gKiBmYWMsXHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGFbMl0gKiBmYWMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhpcyB2ZWN0b3Igd2l0aCBhIHNlY29uZCB2ZWN0b3IgcGFzc2VkIGFzXHJcbiAqIHBhcmFtZXRlci4gUmVzdWx0IGlzIGEgbmV3bHkgY3JlYXRlZCB2ZWN0b3IuIFRoaXMgaXMgbm90IG1vZGlmaWVkLlxyXG4gKiBAcGFyYW0ge1hNTDNEVmVjM30gdGhhdCBUaGUgc2Vjb25kIHZlY3RvclxyXG4gKiBAcmV0dXJuIHtYTUwzRFZlYzN9IFRoZSBuZXcgdmVjdG9yIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgY3Jvc3MgcHJvZHVjdFxyXG4gKi9cclxucC5jcm9zcyA9IGZ1bmN0aW9uKHRoYXQpIHtcclxuICAgIGlmICh0aGF0Ll9kYXRhKVxyXG4gICAgICAgIHJldHVybiBuZXcgWE1MM0RWZWMzKHRoaXMuX2RhdGFbMV0gKiB0aGF0Ll9kYXRhWzJdIC0gdGhpcy5fZGF0YVsyXVxyXG4gICAgICAgICAgICAgICAgKiB0aGF0Ll9kYXRhWzFdLCB0aGlzLl9kYXRhWzJdICogdGhhdC5fZGF0YVswXVxyXG4gICAgICAgICAgICAgICAgLSB0aGlzLl9kYXRhWzBdICogdGhhdC5fZGF0YVsyXSwgdGhpcy5fZGF0YVswXVxyXG4gICAgICAgICAgICAgICAgKiB0aGF0Ll9kYXRhWzFdIC0gdGhpcy5fZGF0YVsxXSAqIHRoYXQuX2RhdGFbMF0pO1xyXG5cclxuICAgIHJldHVybiBuZXcgWE1MM0RWZWMzKHRoaXMuX2RhdGFbMV0gKiB0aGF0LnogLSB0aGlzLl9kYXRhWzJdICogdGhhdC55LFxyXG4gICAgICAgICAgICB0aGlzLl9kYXRhWzJdICogdGhhdC54IC0gdGhpcy5fZGF0YVswXSAqIHRoYXQueiwgdGhpcy5fZGF0YVswXVxyXG4gICAgICAgICAgICAgICAgICAgICogdGhhdC55IC0gdGhpcy5fZGF0YVsxXSAqIHRoYXQueCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29tcG9uZW50IHdpc2UgbXVsdGlwbGljYXRpb24gYnkgLTEgb2YgdGhpcyB2ZWN0b3IuIFJlc3VsdCBpc1xyXG4gKiBhIG5ld2x5IGNyZWF0ZWQgdmVjdG9yLiBUaGlzIGlzIG5vdCBtb2RpZmllZC5cclxuICogQHJldHVybiB7WE1MM0RWZWMzfSBUaGUgbmV3IGFuZCBuZWdhdGVkIHZlY3RvclxyXG4gKi9cclxucC5uZWdhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBuZXcgWE1MM0RWZWMzKC10aGlzLl9kYXRhWzBdLCAtdGhpcy5fZGF0YVsxXSwgLXRoaXMuX2RhdGFbMl0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgdmVjdG9yIHdpdGggYSBzZWNvbmQgdmVjdG9yIHBhc3NlZCBhc1xyXG4gKiBwYXJhbWV0ZXIuIFRoaXMgaXMgbm90IG1vZGlmaWVkLlxyXG4gKiBAcGFyYW0ge1hNTDNEVmVjM30gdGhhdCBUaGUgc2Vjb25kIHZlY3RvclxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZXN1bHQgb2YgdGhlIGRvdCBwcm9kdWN0XHJcbiAqL1xyXG5wLmRvdCA9IGZ1bmN0aW9uKHRoYXQpIHtcclxuICAgIHJldHVybiAodGhpcy5fZGF0YVswXSAqIHRoYXQueCArIHRoaXMuX2RhdGFbMV0gKiB0aGF0LnkgKyB0aGlzLl9kYXRhWzJdXHJcbiAgICAgICAgICAgICogdGhhdC56KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhpcyB2ZWN0b3IuIFJlc3VsdCBpcyBhIG5ld2x5IGNyZWF0ZWRcclxuICogdmVjdG9yLiBUaGlzIGlzIG5vdCBtb2RpZmllZC5cclxuICogQHJldHVybiB7WE1MM0RWZWMzfSBUaGUgbmV3IGFuZCBub3JtYWxpemVkIHZlY3RvclxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgbGVuZ3RoIG9mIHRoaXMgdmVjdG9yIGlzIHplcm9cclxuICovXHJcbnAubm9ybWFsaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgbiA9IHRoaXMubGVuZ3RoKCk7XHJcbiAgICBpZiAobilcclxuICAgICAgICBuID0gMS4wIC8gbjtcclxuICAgIGVsc2VcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFhNTDNEVmVjMyh0aGlzLl9kYXRhWzBdICogbiwgdGhpcy5fZGF0YVsxXSAqIG4sXHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGFbMl0gKiBuKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWE1MM0RWZWMzOyIsIi8vIEFkZCBjb252aWVuZW50IGFycmF5IG1ldGhvZHMgaWYgbm9uLWV4aXN0YW50XHJcbmlmICghQXJyYXkuZm9yRWFjaCkge1xyXG4gICAgQXJyYXkuZm9yRWFjaCA9IGZ1bmN0aW9uKGFycmF5LCBmdW4sIHRoaXNwKSB7XHJcbiAgICAgICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSBpbiBhcnJheSkge1xyXG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc3AsIGFycmF5W2ldLCBpLCBhcnJheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmlmICghQXJyYXkubWFwKSB7XHJcbiAgICBBcnJheS5tYXAgPSBmdW5jdGlvbihhcnJheSwgZnVuLCB0aGlzcCkge1xyXG4gICAgICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpIGluIGFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBmdW4uY2FsbCh0aGlzcCwgYXJyYXlbaV0sIGksIGFycmF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxufVxyXG5pZiAoIUFycmF5LmZpbHRlcikge1xyXG4gICAgQXJyYXkuZmlsdGVyID0gZnVuY3Rpb24oYXJyYXksIGZ1biwgdGhpc3ApIHtcclxuICAgICAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIHZhciByZXMgPSBbXTtcclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSBpbiBhcnJheSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGFycmF5W2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZ1bi5jYWxsKHRoaXNwLCB2YWwsIGksIGFycmF5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHZhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbn1cclxuXHJcbmlmICghQXJyYXkuZXJhc2UpIHtcclxuICAgIEFycmF5LmVyYXNlID0gZnVuY3Rpb24oYXJyYXksIG9iamVjdCkge1xyXG4gICAgICAgIHZhciBlcmFzZWQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgaWR4ID0gLTE7XHJcbiAgICAgICAgd2hpbGUoIChpZHggPSBhcnJheS5pbmRleE9mKG9iamVjdCkgKSAhPSAtMSl7XHJcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgICBlcmFzZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXJhc2VkO1xyXG4gICAgfTtcclxufVxyXG5cclxuaWYgKCFBcnJheS5zZXQpIHtcclxuICAgIEFycmF5LnNldCA9IGZ1bmN0aW9uKGFycmF5LCBvZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCtpXSA9IHZhbHVlW2ldO1xyXG4gICAgfTtcclxufVxyXG5cclxuaWYgKCFBcnJheS5pc0FycmF5KSB7XHJcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9O1xyXG59XHJcbiIsInZhciBDU1NNYXRyaXggPSByZXF1aXJlKFwiLi9jc3NNYXRyaXguanNcIik7XHJcblxyXG52YXIgY3NzID0ge307XHJcblxyXG5jc3MuVFJBTlNGT1JNX1BST1BFUlRZID0gbnVsbDtcclxuXHJcbmNzcy5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCd0cmFuc2Zvcm0nIGluIGRvY3VtZW50LmJvZHkuc3R5bGUpIHtcclxuICAgICAgICBjc3MuVFJBTlNGT1JNX1BST1BFUlRZID0gJ3RyYW5zZm9ybSdcclxuICAgIH0gZWxzZSBpZiAoJ1dlYmtpdFRyYW5zZm9ybScgaW4gZG9jdW1lbnQuYm9keS5zdHlsZSkge1xyXG4gICAgICAgIGNzcy5UUkFOU0ZPUk1fUFJPUEVSVFkgPSAnLXdlYmtpdC10cmFuc2Zvcm0nXHJcbiAgICB9IGVsc2UgaWYgKCdNb3pUcmFuc2Zvcm0nIGluIGRvY3VtZW50LmJvZHkuc3R5bGUpIHtcclxuICAgICAgICBjc3MuVFJBTlNGT1JNX1BST1BFUlRZID0gJy1tb3otdHJhbnNmb3JtJ1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiTm8gc3VwcG9ydGVkIHRyYW5zZm9ybSBjc3MgcHJvcGVydHkgZm91bmRcIik7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuY3NzLmdldElubGluZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiAobm9kZSwgcHJvcGVydHkpIHtcclxuICAgIHZhciBzdHlsZVZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XHJcbiAgICBpZiAoc3R5bGVWYWx1ZSkge1xyXG4gICAgICAgIHZhciBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwcm9wZXJ0eSArIFwiXFxzKjooW147XSspXCIsIFwiaVwiKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gcGF0dGVybi5leGVjKHN0eWxlVmFsdWUpO1xyXG4gICAgICAgIGlmIChyZXN1bHQpXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbMV0udHJpbSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5jc3MuZ2V0UHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uIChub2RlLCBwcm9wZXJ0eSkge1xyXG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXRJbmxpbmVQcm9wZXJ0eVZhbHVlKG5vZGUsIHByb3BlcnR5KTtcclxuICAgIGlmICh2YWx1ZSlcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcblxyXG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XHJcbiAgICByZXR1cm4gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XHJcbn07XHJcblxyXG5jc3MuZ2V0Q1NTTWF0cml4ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIGlmICghY3NzLlRSQU5TRk9STV9QUk9QRVJUWSB8fCAhQ1NTTWF0cml4KVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIHZhciBzdHlsZSA9IG51bGw7XHJcblxyXG4gICAgaWYgKGNzcy5UUkFOU0ZPUk1fUFJPUEVSVFkgIT0gXCJ0cmFuc2Zvcm1cIilcclxuICAgICAgICBzdHlsZSA9IGNzcy5nZXRJbmxpbmVQcm9wZXJ0eVZhbHVlKG5vZGUsIFwidHJhbnNmb3JtXCIpO1xyXG5cclxuICAgIGlmICghc3R5bGUpXHJcbiAgICAgICAgc3R5bGUgPSBjc3MuZ2V0UHJvcGVydHlWYWx1ZShub2RlLCBjc3MuVFJBTlNGT1JNX1BST1BFUlRZKTtcclxuXHJcbiAgICBpZiAoIXN0eWxlIHx8IHN0eWxlID09IFwibm9uZVwiKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSBudWxsO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXN1bHQgPSBuZXcgQ1NTTWF0cml4KHN0eWxlKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkVycm9yIHBhcnNpbmcgdHJhbnNmb3JtIHByb3BlcnR5OiBcIiArIHN0eWxlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG59O1xyXG5cclxuXHJcbmNzcy5jb252ZXJ0Q3NzVG9NYXQ0ID0gZnVuY3Rpb24gKGNzc01hdHJpeCwgbSkge1xyXG4gICAgdmFyIG1hdHJpeCA9IG0gfHwgWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG4gICAgbWF0cml4WzBdID0gY3NzTWF0cml4Lm0xMTtcclxuICAgIG1hdHJpeFsxXSA9IGNzc01hdHJpeC5tMTI7XHJcbiAgICBtYXRyaXhbMl0gPSBjc3NNYXRyaXgubTEzO1xyXG4gICAgbWF0cml4WzNdID0gY3NzTWF0cml4Lm0xNDtcclxuICAgIG1hdHJpeFs0XSA9IGNzc01hdHJpeC5tMjE7XHJcbiAgICBtYXRyaXhbNV0gPSBjc3NNYXRyaXgubTIyO1xyXG4gICAgbWF0cml4WzZdID0gY3NzTWF0cml4Lm0yMztcclxuICAgIG1hdHJpeFs3XSA9IGNzc01hdHJpeC5tMjQ7XHJcbiAgICBtYXRyaXhbOF0gPSBjc3NNYXRyaXgubTMxO1xyXG4gICAgbWF0cml4WzldID0gY3NzTWF0cml4Lm0zMjtcclxuICAgIG1hdHJpeFsxMF0gPSBjc3NNYXRyaXgubTMzO1xyXG4gICAgbWF0cml4WzExXSA9IGNzc01hdHJpeC5tMzQ7XHJcbiAgICBtYXRyaXhbMTJdID0gY3NzTWF0cml4Lm00MTtcclxuICAgIG1hdHJpeFsxM10gPSBjc3NNYXRyaXgubTQyO1xyXG4gICAgbWF0cml4WzE0XSA9IGNzc01hdHJpeC5tNDM7XHJcbiAgICBtYXRyaXhbMTVdID0gY3NzTWF0cml4Lm00NDtcclxuICAgIHJldHVybiBtYXRyaXg7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNzcztcclxuXHJcbiIsIlxyXG4vKipcclxuICogIGNsYXNzIEZpcm1pbkNTU01hdHJpeFxyXG4gKlxyXG4gKiAgVGhlIFtbRmlybWluQ1NTTWF0cml4XV0gY2xhc3MgaXMgYSBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcclxuICogIGBDU1NNYXRyaXhgIGludGVyZmFjZSBkZWZpbmVkIGluIHRoZSBbQ1NTIDJEIFRyYW5zZm9ybXNdWzJkXSBhbmRcclxuICogIFtDU1MgM0QgVHJhbnNmb3Jtc11bM2RdIE1vZHVsZSBzcGVjaWZpY2F0aW9ucy5cclxuICpcclxuICogIFsyZF06IGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtMmQtdHJhbnNmb3Jtcy9cclxuICogIFszZF06IGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtM2QtdHJhbnNmb3Jtcy9cclxuICpcclxuICogIFRoZSBpbXBsZW1lbnRhdGlvbiB3YXMgbGFyZ2VseSBjb3BpZWQgZnJvbSB0aGUgYFdlYktpdENTU01hdHJpeGAgY2xhc3MsIGFuZFxyXG4gKiAgdGhlIHN1cHBhcnRpbmcgbWF0aHMgbGlicmFyaWVzIGluIHRoZSBbV2ViS2l0XVt3ZWJraXRdIHByb2plY3QuIFRoaXMgaXMgb25lXHJcbiAqICByZWFzb24gd2h5IG11Y2ggb2YgdGhlIGNvZGUgbG9va3MgbW9yZSBsaWtlIEMrKyB0aGFuIEphdmFTY3JpcHQuXHJcbiAqXHJcbiAqICBbd2Via2l0XTogaHR0cDovL3dlYmtpdC5vcmcvXHJcbiAqXHJcbiAqICBJdHMgQVBJIGlzIGEgc3VwZXJzZXQgb2YgdGhhdCBwcm92aWRlZCBieSBgV2ViS2l0Q1NTTWF0cml4YCwgbGFyZ2VseVxyXG4gKiAgYmVjYXVzZSB2YXJpb3VzIHBpZWNlcyBvZiBzdXBwb3J0aW5nIGNvZGUgaGF2ZSBiZWVuIGFkZGVkIGFzIGluc3RhbmNlXHJcbiAqICBtZXRob2RzIHJhdGhlciB0aGFuIHBvbGx1dGUgdGhlIGdsb2JhbCBuYW1lc3BhY2UuIEV4YW1wbGVzIG9mIHRoZXNlIGluY2x1ZGVcclxuICogIFtbRmlybWluQ1NTTWF0cml4I2lzQWZmaW5lXV0sIFtbRmlybWluQ1NTTWF0cml4I2lzSWRlbnRpdHlPclRyYW5zbGF0aW9uXV1cclxuICogIGFuZCBbW0Zpcm1pbkNTU01hdHJpeCNhZGpvaW50XV0uXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiAgbmV3IEZpcm1pbkNTU01hdHJpeChkb21zdHIpXHJcbiAqICAtIGRvbXN0ciAoU3RyaW5nKTogYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSAyRCBvciAzRCB0cmFuc2Zvcm0gbWF0cml4XHJcbiAqICAgIGluIHRoZSBmb3JtIGdpdmVuIGJ5IHRoZSBDU1MgdHJhbnNmb3JtIHByb3BlcnR5LCBpLmUuIGp1c3QgbGlrZSB0aGVcclxuICogICAgb3V0cHV0IGZyb20gW1tGaXJtaW5DU1NNYXRyaXgjdG9TdHJpbmddXS5cclxuICpcclxuICogIEBjb25zdHJ1Y3RvclxyXG4gKiovXHJcbnZhciBGaXJtaW5DU1NNYXRyaXggPSBmdW5jdGlvbihkb21zdHIpIHtcclxuICAgIHRoaXMubTExID0gdGhpcy5tMjIgPSB0aGlzLm0zMyA9IHRoaXMubTQ0ID0gMTtcclxuXHJcbiAgICB0aGlzLm0xMiA9IHRoaXMubTEzID0gdGhpcy5tMTQgPVxyXG4gICAgdGhpcy5tMjEgPSAgICAgICAgICAgIHRoaXMubTIzID0gdGhpcy5tMjQgPVxyXG4gICAgdGhpcy5tMzEgPSB0aGlzLm0zMiA9ICAgICAgICAgICAgdGhpcy5tMzQgPVxyXG4gICAgdGhpcy5tNDEgPSB0aGlzLm00MiA9IHRoaXMubTQzICAgICAgICAgICAgPSAwO1xyXG5cclxuICAgIGlmICh0eXBlb2YgZG9tc3RyID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICB0aGlzLnNldE1hdHJpeFZhbHVlKGRvbXN0cik7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeC5kaXNwbGF5TmFtZSA9IFwiRmlybWluQ1NTTWF0cml4XCJcclxuICoqL1xyXG5GaXJtaW5DU1NNYXRyaXguZGlzcGxheU5hbWUgPSBcIkZpcm1pbkNTU01hdHJpeFwiO1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXguZGVncmVlc1RvUmFkaWFucyhhbmdsZSkgLT4gTnVtYmVyXHJcbiAqICAtIGFuZ2xlIChOdW1iZXIpOiBhbiBhbmdsZSBpbiBkZWdyZWVzLlxyXG4gKlxyXG4gKiAgQ29udmVydHMgYW5nbGVzIGluIGRlZ3JlZXMsIHdoaWNoIGFyZSB1c2VkIGJ5IHRoZSBleHRlcm5hbCBBUEksIHRvIGFuZ2xlc1xyXG4gKiAgaW4gcmFkaWFucyB1c2VkIGluIGludGVybmFsIGNhbGN1bGF0aW9ucy5cclxuICoqL1xyXG5GaXJtaW5DU1NNYXRyaXguZGVncmVlc1RvUmFkaWFucyA9IGZ1bmN0aW9uKGFuZ2xlKSB7XHJcbiAgICByZXR1cm4gYW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXguZGV0ZXJtaW5hbnQyeDIoYSwgYiwgYywgZCkgLT4gTnVtYmVyXHJcbiAqICAtIGEgKE51bWJlcik6IHRvcC1sZWZ0IHZhbHVlIG9mIHRoZSBtYXRyaXguXHJcbiAqICAtIGIgKE51bWJlcik6IHRvcC1yaWdodCB2YWx1ZSBvZiB0aGUgbWF0cml4LlxyXG4gKiAgLSBjIChOdW1iZXIpOiBib3R0b20tbGVmdCB2YWx1ZSBvZiB0aGUgbWF0cml4LlxyXG4gKiAgLSBkIChOdW1iZXIpOiBib3R0b20tcmlnaHQgdmFsdWUgb2YgdGhlIG1hdHJpeC5cclxuICpcclxuICogIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgMngyIG1hdHJpeC5cclxuICoqL1xyXG5GaXJtaW5DU1NNYXRyaXguZGV0ZXJtaW5hbnQyeDIgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XHJcbiAgICByZXR1cm4gYSAqIGQgLSBiICogYztcclxufTtcclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4LmRldGVybWluYW50M3gzKG1hdHJpeCkgLT4gTnVtYmVyXHJcbiAqICAtIGExIChOdW1iZXIpOiBtYXRyaXggdmFsdWUgaW4gcG9zaXRpb24gWzEsIDFdLlxyXG4gKiAgLSBhMiAoTnVtYmVyKTogbWF0cml4IHZhbHVlIGluIHBvc2l0aW9uIFsxLCAyXS5cclxuICogIC0gYTMgKE51bWJlcik6IG1hdHJpeCB2YWx1ZSBpbiBwb3NpdGlvbiBbMSwgM10uXHJcbiAqICAtIGIxIChOdW1iZXIpOiBtYXRyaXggdmFsdWUgaW4gcG9zaXRpb24gWzIsIDFdLlxyXG4gKiAgLSBiMiAoTnVtYmVyKTogbWF0cml4IHZhbHVlIGluIHBvc2l0aW9uIFsyLCAyXS5cclxuICogIC0gYjMgKE51bWJlcik6IG1hdHJpeCB2YWx1ZSBpbiBwb3NpdGlvbiBbMiwgM10uXHJcbiAqICAtIGMxIChOdW1iZXIpOiBtYXRyaXggdmFsdWUgaW4gcG9zaXRpb24gWzMsIDFdLlxyXG4gKiAgLSBjMiAoTnVtYmVyKTogbWF0cml4IHZhbHVlIGluIHBvc2l0aW9uIFszLCAyXS5cclxuICogIC0gYzMgKE51bWJlcik6IG1hdHJpeCB2YWx1ZSBpbiBwb3NpdGlvbiBbMywgM10uXHJcbiAqXHJcbiAqICBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIDN4MyBtYXRyaXguXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LmRldGVybWluYW50M3gzID0gZnVuY3Rpb24oYTEsIGEyLCBhMywgYjEsIGIyLCBiMywgYzEsIGMyLCBjMykge1xyXG4gICAgdmFyIGRldGVybWluYW50MngyID0gRmlybWluQ1NTTWF0cml4LmRldGVybWluYW50MngyO1xyXG4gICAgcmV0dXJuIGExICogZGV0ZXJtaW5hbnQyeDIoYjIsIGIzLCBjMiwgYzMpIC1cclxuICAgIGIxICogZGV0ZXJtaW5hbnQyeDIoYTIsIGEzLCBjMiwgYzMpICtcclxuICAgIGMxICogZGV0ZXJtaW5hbnQyeDIoYTIsIGEzLCBiMiwgYjMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXguZGV0ZXJtaW5hbnQ0eDQobWF0cml4KSAtPiBOdW1iZXJcclxuICogIC0gbWF0cml4IChGaXJtaW5DU1NNYXRyaXgpOiB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQgb2YuXHJcbiAqXHJcbiAqICBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIDR4NCBtYXRyaXguXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LmRldGVybWluYW50NHg0ID0gZnVuY3Rpb24obSkge1xyXG4gICAgdmFyIGRldGVybWluYW50M3gzID0gRmlybWluQ1NTTWF0cml4LmRldGVybWluYW50M3gzLFxyXG5cclxuICAgICAgICAvLyBBc3NpZ24gdG8gaW5kaXZpZHVhbCB2YXJpYWJsZSBuYW1lcyB0byBhaWQgc2VsZWN0aW5nIGNvcnJlY3QgZWxlbWVudHNcclxuICAgIGExID0gbS5tMTEsIGIxID0gbS5tMjEsIGMxID0gbS5tMzEsIGQxID0gbS5tNDEsXHJcbiAgICBhMiA9IG0ubTEyLCBiMiA9IG0ubTIyLCBjMiA9IG0ubTMyLCBkMiA9IG0ubTQyLFxyXG4gICAgYTMgPSBtLm0xMywgYjMgPSBtLm0yMywgYzMgPSBtLm0zMywgZDMgPSBtLm00MyxcclxuICAgIGE0ID0gbS5tMTQsIGI0ID0gbS5tMjQsIGM0ID0gbS5tMzQsIGQ0ID0gbS5tNDQ7XHJcblxyXG4gICAgcmV0dXJuIGExICogZGV0ZXJtaW5hbnQzeDMoYjIsIGIzLCBiNCwgYzIsIGMzLCBjNCwgZDIsIGQzLCBkNCkgLVxyXG4gICAgYjEgKiBkZXRlcm1pbmFudDN4MyhhMiwgYTMsIGE0LCBjMiwgYzMsIGM0LCBkMiwgZDMsIGQ0KSArXHJcbiAgICBjMSAqIGRldGVybWluYW50M3gzKGEyLCBhMywgYTQsIGIyLCBiMywgYjQsIGQyLCBkMywgZDQpIC1cclxuICAgIGQxICogZGV0ZXJtaW5hbnQzeDMoYTIsIGEzLCBhNCwgYjIsIGIzLCBiNCwgYzIsIGMzLCBjNCk7XHJcbn07XHJcblxyXG4vKipcclxuICogRmlybWluQ1NTTWF0cml4LnRvTWF0cml4U3RyaW5nKHRyYW5zZm9ybVZhbHVlKSAtPiBTdHJpbmdcclxuICogLSB0cmFuc2Zvcm1WYWx1ZSAoU3RyaW5nKTogYGVsLnN0eWxlLldlYmtpdFRyYW5zZm9ybWAtc3R5bGUgc3RyaW5nIChsaWtlIGByb3RhdGUoMThyYWQpIHRyYW5zbGF0ZTNkKDUwcHgsIDEwMHB4LCAxMHB4KWApXHJcbiAqXHJcbiAqIFRyYW5mb3JtcyBhIGBlbC5zdHlsZS5XZWJraXRUcmFuc2Zvcm1gLXN0eWxlIHN0cmluZ1xyXG4gKiAobGlrZSBgcm90YXRlKDE4cmFkKSB0cmFuc2xhdGUzZCg1MHB4LCAxMDBweCwgMTBweClgKVxyXG4gKiBpbnRvIGEgYGdldENvbXB1dGVkU3R5bGUoZWwpYC1zdHlsZSBtYXRyaXggc3RyaW5nXHJcbiAqIChsaWtlIGBtYXRyaXgzZCgwLjY2MDMxNjcwODI0NDA4MjgsIC0wLjc1MDk4NzI0Njc3MTY3MzcsIDAsIDAsIDAuNzUwOTg3MjQ2NzcxNjczNywgMC42NjAzMTY3MDgyNDQwODI4LCAwLCAwLCAwLCAwLCAxLCAwLCAxMDguMTE0NTYwMDg5MzcxNTEsIDI4LjQ4MjMwODQ4NTgyNDU5NiwgMTAsIDEpYClcclxuICoqL1xyXG5GaXJtaW5DU1NNYXRyaXgudG9NYXRyaXhTdHJpbmcgPSBmdW5jdGlvbiAodHJhbnNmb3JtVmFsdWUpIHtcclxuICAgIHZhciByZ3ggPSB7XHJcbiAgICAgICAgZnVuY3Rpb25TaWduYXR1cmU6IC8oXFx3KylcXChbXlxcKV0rXFwpL2lnLFxyXG4gICAgICAgIG5hbWVBbmRBcmd1bWVudHM6IC8oXFx3KylcXCgoW15cXCldKylcXCkvaSxcclxuICAgICAgICB1bml0czogLyhbLVxcK10/WzAtOV0rW1xcLjAtOV0qKShkZWd8cmFkfGdyYWR8cHh8JSkqL1xyXG4gICAgfTtcclxuICAgIHZhciB0cmFuc2Zvcm1TdGF0ZW1lbnRzID0gdHJhbnNmb3JtVmFsdWUubWF0Y2goLyhcXHcrKVxcKFteXFwpXStcXCkvaWcpO1xyXG4gICAgdmFyIG9ubHlNYXRyaWNlcyA9IHRyYW5zZm9ybVN0YXRlbWVudHMgJiYgdHJhbnNmb3JtU3RhdGVtZW50cy5ldmVyeShmdW5jdGlvbiAodCkgeyByZXR1cm4gKC9ebWF0cml4LykudGVzdCh0KSB9KTtcclxuICAgIGlmICghdHJhbnNmb3JtU3RhdGVtZW50cyB8fCBvbmx5TWF0cmljZXMpIHJldHVybiB0cmFuc2Zvcm1WYWx1ZTtcclxuXHJcbiAgICB2YXIgdmFsdWVzID0gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8udmFsdWUgfTtcclxuICAgIHZhciBjc3NGdW5jdGlvblRvSnNGdW5jdGlvbiA9IHtcclxuICAgICAgICBtYXRyaXg6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHZhciBtMiA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoby51bnBhcnNlZCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbS5tdWx0aXBseShtMilcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1hdHJpeDNkOiBmdW5jdGlvbiAobSwgbykge1xyXG4gICAgICAgICAgICB2YXIgbTIgPSBuZXcgRmlybWluQ1NTTWF0cml4KG8udW5wYXJzZWQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG0ubXVsdGlwbHkobTIpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcGVyc3BlY3RpdmU6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHZhciBtMiA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoKTtcclxuICAgICAgICAgICAgbTIubTM0IC09IDEgLyBvLnZhbHVlWzBdLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG0ubXVsdGlwbHkobTIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJvdGF0ZTogZnVuY3Rpb24gKG0sIG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0ucm90YXRlLmFwcGx5KG0sIG8udmFsdWUubWFwKHZhbHVlcykpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb3RhdGUzZDogZnVuY3Rpb24gKG0sIG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0ucm90YXRlQXhpc0FuZ2xlLmFwcGx5KG0sIG8udmFsdWUubWFwKHZhbHVlcykpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb3RhdGVYOiBmdW5jdGlvbiAobSwgbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbS5yb3RhdGUuYXBwbHkobSwgW28udmFsdWVbMF0udmFsdWUsIDAsIDBdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvdGF0ZVk6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtLnJvdGF0ZS5hcHBseShtLCBbMCwgby52YWx1ZVswXS52YWx1ZSwgMF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm90YXRlWjogZnVuY3Rpb24gKG0sIG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0ucm90YXRlLmFwcGx5KG0sIFswLCAwLCBvLnZhbHVlWzBdLnZhbHVlXSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtLnNjYWxlLmFwcGx5KG0sIG8udmFsdWUubWFwKHZhbHVlcykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2NhbGUzZDogZnVuY3Rpb24gKG0sIG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0uc2NhbGUuYXBwbHkobSwgby52YWx1ZS5tYXAodmFsdWVzKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzY2FsZVg6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtLnNjYWxlLmFwcGx5KG0sIG8udmFsdWUubWFwKHZhbHVlcykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2NhbGVZOiBmdW5jdGlvbiAobSwgbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbS5zY2FsZS5hcHBseShtLCBbMCwgby52YWx1ZVswXS52YWx1ZSwgMF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2NhbGVaOiBmdW5jdGlvbiAobSwgbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbS5zY2FsZS5hcHBseShtLCBbMCwgMCwgby52YWx1ZVswXS52YWx1ZV0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNrZXc6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHZhciBtWCA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoJ3NrZXdYKCcgKyBvLnZhbHVlWzBdLnVucGFyc2VkICsgJyknKTtcclxuICAgICAgICAgICAgdmFyIG1ZID0gbmV3IEZpcm1pbkNTU01hdHJpeCgnc2tld1koJyArIG8udmFsdWVbMV0udW5wYXJzZWQgKyAnKScpO1xyXG4gICAgICAgICAgICB2YXIgc00gPSAnbWF0cml4KDEuMDAwMDAsICcrIG1ZLmIgKycsICcrIG1YLmMgKycsIDEuMDAwMDAwLCAwLjAwMDAwMCwgMC4wMDAwMDApJztcclxuICAgICAgICAgICAgdmFyIG0yID0gbmV3IEZpcm1pbkNTU01hdHJpeChzTSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbS5tdWx0aXBseShtMik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBza2V3WDogZnVuY3Rpb24gKG0sIG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0uc2tld1guYXBwbHkobSwgW28udmFsdWVbMF0udmFsdWVdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNrZXdZOiBmdW5jdGlvbiAobSwgbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbS5za2V3WS5hcHBseShtLCBbby52YWx1ZVswXS52YWx1ZV0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKG0sIG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0udHJhbnNsYXRlLmFwcGx5KG0sIG8udmFsdWUubWFwKHZhbHVlcykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJhbnNsYXRlM2Q6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtLnRyYW5zbGF0ZS5hcHBseShtLCBvLnZhbHVlLm1hcCh2YWx1ZXMpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRyYW5zbGF0ZVg6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtLnRyYW5zbGF0ZS5hcHBseShtLCBbby52YWx1ZVswXS52YWx1ZSwgMCwgMF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJhbnNsYXRlWTogZnVuY3Rpb24gKG0sIG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0udHJhbnNsYXRlLmFwcGx5KG0sIFswLCBvLnZhbHVlWzBdLnZhbHVlLCAwXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmFuc2xhdGVaOiBmdW5jdGlvbiAobSwgbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbS50cmFuc2xhdGUuYXBwbHkobSwgWzAsIDAsIG8udmFsdWVbMF0udmFsdWVdKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIHBhcnNlVHJhbnNmb3JtU3RhdGVtZW50ID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgIHZhciBwYWlyID0gc3RyLm1hdGNoKHJneC5uYW1lQW5kQXJndW1lbnRzKS5zbGljZSgxKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAga2V5OiBwYWlyWzBdLFxyXG4gICAgICAgICAgICB2YWx1ZTogcGFpclsxXS5zcGxpdCgvLCA/LykubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gdmFsdWUubWF0Y2goLyhbLVxcK10/WzAtOV0rW1xcLjAtOV0qKShkZWd8cmFkfGdyYWR8cHh8JSkqLykgfHwgW107XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChwYXJ0c1sxXSksXHJcbiAgICAgICAgICAgICAgICAgICAgdW5pdHM6IHBhcnRzWzJdLFxyXG4gICAgICAgICAgICAgICAgICAgIHVucGFyc2VkOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHVucGFyc2VkOiBzdHJcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgdHJhbnNmb3JtT3BlcmF0aW9ucyA9IHRyYW5zZm9ybVN0YXRlbWVudHMubWFwKHBhcnNlVHJhbnNmb3JtU3RhdGVtZW50KTtcclxuICAgIHZhciBzdGFydGluZ01hdHJpeCA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoKTtcclxuICAgIHZhciB0cmFuc2Zvcm1lZE1hdHJpeCA9IHRyYW5zZm9ybU9wZXJhdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChtYXRyaXgsIG9wZXJhdGlvbikge1xyXG4gICAgICAgIC8vIGNvbnZlcnQgdG8gZGVncmVlcyBiL2MgYWxsIENTU01hdHJpeCBtZXRob2RzIGV4cGVjdCBkZWdyZWVzXHJcbiAgICAgICAgb3BlcmF0aW9uLnZhbHVlID0gb3BlcmF0aW9uLnZhbHVlLm1hcChmdW5jdGlvbiAob3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24udW5pdHMgPT0gJ3JhZCcpIHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9IG9wZXJhdGlvbi52YWx1ZSAqICgxODAgLyBNYXRoLlBJKTtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi51bml0cyA9ICdkZWcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi51bml0cyA9PSAnZ3JhZCcpIHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9IG9wZXJhdGlvbi52YWx1ZSAvICg0MDAgLyAzNjApOyAvLyA0MDAgZ3JhZGlhbnMgaW4gMzYwIGRlZ3JlZXNcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi51bml0cyA9ICdkZWcnXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb247XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBqc0Z1bmN0aW9uID0gY3NzRnVuY3Rpb25Ub0pzRnVuY3Rpb25bb3BlcmF0aW9uLmtleV07XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGpzRnVuY3Rpb24obWF0cml4LCBvcGVyYXRpb24pO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IG1hdHJpeDtcclxuICAgIH0sIHN0YXJ0aW5nTWF0cml4KTtcclxuXHJcbiAgICByZXR1cm4gdHJhbnNmb3JtZWRNYXRyaXgudG9TdHJpbmcoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I2EgLT4gTnVtYmVyXHJcbiAqICBUaGUgZmlyc3QgMkQgdmVjdG9yIHZhbHVlLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNiIC0+IE51bWJlclxyXG4gKiAgVGhlIHNlY29uZCAyRCB2ZWN0b3IgdmFsdWUuXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I2MgLT4gTnVtYmVyXHJcbiAqICBUaGUgdGhpcmQgMkQgdmVjdG9yIHZhbHVlLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNkIC0+IE51bWJlclxyXG4gKiAgVGhlIGZvdXJ0aCAyRCB2ZWN0b3IgdmFsdWUuXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I2UgLT4gTnVtYmVyXHJcbiAqICBUaGUgZmlmdGggMkQgdmVjdG9yIHZhbHVlLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNmIC0+IE51bWJlclxyXG4gKiAgVGhlIHNpeHRoIDJEIHZlY3RvciB2YWx1ZS5cclxuICoqL1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTExIC0+IE51bWJlclxyXG4gKiAgVGhlIDNEIG1hdHJpeCB2YWx1ZSBpbiB0aGUgZmlyc3Qgcm93IGFuZCBmaXJzdCBjb2x1bW4uXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I20xMiAtPiBOdW1iZXJcclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIGZpcnN0IHJvdyBhbmQgc2Vjb25kIGNvbHVtbi5cclxuICoqL1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTEzIC0+IE51bWJlclxyXG4gKiAgVGhlIDNEIG1hdHJpeCB2YWx1ZSBpbiB0aGUgZmlyc3Qgcm93IGFuZCB0aGlyZCBjb2x1bW4uXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I20xNCAtPiBOdW1iZXJcclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIGZpcnN0IHJvdyBhbmQgZm91cnRoIGNvbHVtbi5cclxuICoqL1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTIxIC0+IE51bWJlclxyXG4gKiAgVGhlIDNEIG1hdHJpeCB2YWx1ZSBpbiB0aGUgc2Vjb25kIHJvdyBhbmQgZmlyc3QgY29sdW1uLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNtMjIgLT4gTnVtYmVyXHJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSBzZWNvbmQgcm93IGFuZCBzZWNvbmQgY29sdW1uLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNtMjMgLT4gTnVtYmVyXHJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSBzZWNvbmQgcm93IGFuZCB0aGlyZCBjb2x1bW4uXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I20yNCAtPiBOdW1iZXJcclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIHNlY29uZCByb3cgYW5kIGZvdXJ0aCBjb2x1bW4uXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I20zMSAtPiBOdW1iZXJcclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIHRoaXJkIHJvdyBhbmQgZmlyc3QgY29sdW1uLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNtMzIgLT4gTnVtYmVyXHJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSB0aGlyZCByb3cgYW5kIHNlY29uZCBjb2x1bW4uXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I20zMyAtPiBOdW1iZXJcclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIHRoaXJkIHJvdyBhbmQgdGhpcmQgY29sdW1uLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNtMzQgLT4gTnVtYmVyXHJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSB0aGlyZCByb3cgYW5kIGZvdXJ0aCBjb2x1bW4uXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I200MSAtPiBOdW1iZXJcclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIGZvdXJ0aCByb3cgYW5kIGZpcnN0IGNvbHVtbi5cclxuICoqL1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTQyIC0+IE51bWJlclxyXG4gKiAgVGhlIDNEIG1hdHJpeCB2YWx1ZSBpbiB0aGUgZm91cnRoIHJvdyBhbmQgc2Vjb25kIGNvbHVtbi5cclxuICoqL1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTQzIC0+IE51bWJlclxyXG4gKiAgVGhlIDNEIG1hdHJpeCB2YWx1ZSBpbiB0aGUgZm91cnRoIHJvdyBhbmQgdGhpcmQgY29sdW1uLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNtNDQgLT4gTnVtYmVyXHJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSBmb3VydGggcm93IGFuZCBmb3VydGggY29sdW1uLlxyXG4gKiovXHJcblxyXG5bW1wibTExXCIsIFwiYVwiXSxcclxuICAgIFtcIm0xMlwiLCBcImJcIl0sXHJcbiAgICBbXCJtMjFcIiwgXCJjXCJdLFxyXG4gICAgW1wibTIyXCIsIFwiZFwiXSxcclxuICAgIFtcIm00MVwiLCBcImVcIl0sXHJcbiAgICBbXCJtNDJcIiwgXCJmXCJdXS5mb3JFYWNoKGZ1bmN0aW9uKHBhaXIpIHtcclxuICAgIHZhciBrZXkzZCA9IHBhaXJbMF0sIGtleTJkID0gcGFpclsxXTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmlybWluQ1NTTWF0cml4LnByb3RvdHlwZSwga2V5MmQsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICAgICAgICB0aGlzW2tleTNkXSA9IHZhbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1trZXkzZF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlIDogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGUgOiB0cnVlXHJcbiAgICB9KTtcclxufSk7XHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNpc0FmZmluZSgpIC0+IEJvb2xlYW5cclxuICpcclxuICogIERldGVybWluZXMgd2hldGhlciB0aGUgbWF0cml4IGlzIGFmZmluZS5cclxuICoqL1xyXG5GaXJtaW5DU1NNYXRyaXgucHJvdG90eXBlLmlzQWZmaW5lID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tMTMgPT09IDAgJiYgdGhpcy5tMTQgPT09IDAgJiZcclxuICAgIHRoaXMubTIzID09PSAwICYmIHRoaXMubTI0ID09PSAwICYmXHJcbiAgICB0aGlzLm0zMSA9PT0gMCAmJiB0aGlzLm0zMiA9PT0gMCAmJlxyXG4gICAgdGhpcy5tMzMgPT09IDEgJiYgdGhpcy5tMzQgPT09IDAgJiZcclxuICAgIHRoaXMubTQzID09PSAwICYmIHRoaXMubTQ0ID09PSAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjbXVsdGlwbHkob3RoZXJNYXRyaXgpIC0+IEZpcm1pbkNTU01hdHJpeFxyXG4gKiAgLSBvdGhlck1hdHJpeCAoRmlybWluQ1NTTWF0cml4KTogdGhlIG1hdHJpeCB0byBtdWx0aXBseSB0aGlzIG9uZSBieS5cclxuICpcclxuICogIE11bHRpcGxpZXMgdGhlIG1hdHJpeCBieSBhIGdpdmVuIG1hdHJpeCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxyXG4gKiovXHJcbkZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbihvdGhlck1hdHJpeCkge1xyXG4gICAgaWYgKCFvdGhlck1hdHJpeCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgdmFyIGEgPSBvdGhlck1hdHJpeCxcclxuICAgIGIgPSB0aGlzLFxyXG4gICAgYyA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoKTtcclxuXHJcbiAgICBjLm0xMSA9IGEubTExICogYi5tMTEgKyBhLm0xMiAqIGIubTIxICsgYS5tMTMgKiBiLm0zMSArIGEubTE0ICogYi5tNDE7XHJcbiAgICBjLm0xMiA9IGEubTExICogYi5tMTIgKyBhLm0xMiAqIGIubTIyICsgYS5tMTMgKiBiLm0zMiArIGEubTE0ICogYi5tNDI7XHJcbiAgICBjLm0xMyA9IGEubTExICogYi5tMTMgKyBhLm0xMiAqIGIubTIzICsgYS5tMTMgKiBiLm0zMyArIGEubTE0ICogYi5tNDM7XHJcbiAgICBjLm0xNCA9IGEubTExICogYi5tMTQgKyBhLm0xMiAqIGIubTI0ICsgYS5tMTMgKiBiLm0zNCArIGEubTE0ICogYi5tNDQ7XHJcblxyXG4gICAgYy5tMjEgPSBhLm0yMSAqIGIubTExICsgYS5tMjIgKiBiLm0yMSArIGEubTIzICogYi5tMzEgKyBhLm0yNCAqIGIubTQxO1xyXG4gICAgYy5tMjIgPSBhLm0yMSAqIGIubTEyICsgYS5tMjIgKiBiLm0yMiArIGEubTIzICogYi5tMzIgKyBhLm0yNCAqIGIubTQyO1xyXG4gICAgYy5tMjMgPSBhLm0yMSAqIGIubTEzICsgYS5tMjIgKiBiLm0yMyArIGEubTIzICogYi5tMzMgKyBhLm0yNCAqIGIubTQzO1xyXG4gICAgYy5tMjQgPSBhLm0yMSAqIGIubTE0ICsgYS5tMjIgKiBiLm0yNCArIGEubTIzICogYi5tMzQgKyBhLm0yNCAqIGIubTQ0O1xyXG5cclxuICAgIGMubTMxID0gYS5tMzEgKiBiLm0xMSArIGEubTMyICogYi5tMjEgKyBhLm0zMyAqIGIubTMxICsgYS5tMzQgKiBiLm00MTtcclxuICAgIGMubTMyID0gYS5tMzEgKiBiLm0xMiArIGEubTMyICogYi5tMjIgKyBhLm0zMyAqIGIubTMyICsgYS5tMzQgKiBiLm00MjtcclxuICAgIGMubTMzID0gYS5tMzEgKiBiLm0xMyArIGEubTMyICogYi5tMjMgKyBhLm0zMyAqIGIubTMzICsgYS5tMzQgKiBiLm00MztcclxuICAgIGMubTM0ID0gYS5tMzEgKiBiLm0xNCArIGEubTMyICogYi5tMjQgKyBhLm0zMyAqIGIubTM0ICsgYS5tMzQgKiBiLm00NDtcclxuXHJcbiAgICBjLm00MSA9IGEubTQxICogYi5tMTEgKyBhLm00MiAqIGIubTIxICsgYS5tNDMgKiBiLm0zMSArIGEubTQ0ICogYi5tNDE7XHJcbiAgICBjLm00MiA9IGEubTQxICogYi5tMTIgKyBhLm00MiAqIGIubTIyICsgYS5tNDMgKiBiLm0zMiArIGEubTQ0ICogYi5tNDI7XHJcbiAgICBjLm00MyA9IGEubTQxICogYi5tMTMgKyBhLm00MiAqIGIubTIzICsgYS5tNDMgKiBiLm0zMyArIGEubTQ0ICogYi5tNDM7XHJcbiAgICBjLm00NCA9IGEubTQxICogYi5tMTQgKyBhLm00MiAqIGIubTI0ICsgYS5tNDMgKiBiLm0zNCArIGEubTQ0ICogYi5tNDQ7XHJcblxyXG4gICAgcmV0dXJuIGM7XHJcbn07XHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNpc0lkZW50aXR5T3JUcmFuc2xhdGlvbigpIC0+IEJvb2xlYW5cclxuICpcclxuICogIFJldHVybnMgd2hldGhlciB0aGUgbWF0cml4IGlzIHRoZSBpZGVudGl0eSBtYXRyaXggb3IgYSB0cmFuc2xhdGlvbiBtYXRyaXguXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LnByb3RvdHlwZS5pc0lkZW50aXR5T3JUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHQgPSB0aGlzO1xyXG4gICAgcmV0dXJuIHQubTExID09PSAxICYmIHQubTEyID09PSAwICYmIHQubTEzID09PSAwICYmIHQubTE0ID09PSAwICYmXHJcbiAgICB0Lm0yMSA9PT0gMCAmJiB0Lm0yMiA9PT0gMSAmJiB0Lm0yMyA9PT0gMCAmJiB0Lm0yNCA9PT0gMCAmJlxyXG4gICAgdC5tMzEgPT09IDAgJiYgdC5tMzEgPT09IDAgJiYgdC5tMzMgPT09IDEgJiYgdC5tMzQgPT09IDAgJiZcclxuICAgICAgICAvKiBtNDEsIG00MiBhbmQgbTQzIGFyZSB0aGUgdHJhbnNsYXRpb24gcG9pbnRzICovICAgdC5tNDQgPT09IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNhZGpvaW50KCkgLT4gRmlybWluQ1NTTWF0cml4XHJcbiAqXHJcbiAqICBSZXR1cm5zIHRoZSBhZGpvaW50IG1hdHJpeC5cclxuICoqL1xyXG5GaXJtaW5DU1NNYXRyaXgucHJvdG90eXBlLmFkam9pbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZXN1bHQgPSBuZXcgRmlybWluQ1NTTWF0cml4KCksIHQgPSB0aGlzLFxyXG4gICAgZGV0ZXJtaW5hbnQzeDMgPSBGaXJtaW5DU1NNYXRyaXguZGV0ZXJtaW5hbnQzeDMsXHJcblxyXG4gICAgYTEgPSB0Lm0xMSwgYjEgPSB0Lm0xMiwgYzEgPSB0Lm0xMywgZDEgPSB0Lm0xNCxcclxuICAgIGEyID0gdC5tMjEsIGIyID0gdC5tMjIsIGMyID0gdC5tMjMsIGQyID0gdC5tMjQsXHJcbiAgICBhMyA9IHQubTMxLCBiMyA9IHQubTMyLCBjMyA9IHQubTMzLCBkMyA9IHQubTM0LFxyXG4gICAgYTQgPSB0Lm00MSwgYjQgPSB0Lm00MiwgYzQgPSB0Lm00MywgZDQgPSB0Lm00NDtcclxuXHJcbiAgICAvLyBSb3cgY29sdW1uIGxhYmVsaW5nIHJldmVyc2VkIHNpbmNlIHdlIHRyYW5zcG9zZSByb3dzICYgY29sdW1uc1xyXG4gICAgcmVzdWx0Lm0xMSA9ICBkZXRlcm1pbmFudDN4MyhiMiwgYjMsIGI0LCBjMiwgYzMsIGM0LCBkMiwgZDMsIGQ0KTtcclxuICAgIHJlc3VsdC5tMjEgPSAtZGV0ZXJtaW5hbnQzeDMoYTIsIGEzLCBhNCwgYzIsIGMzLCBjNCwgZDIsIGQzLCBkNCk7XHJcbiAgICByZXN1bHQubTMxID0gIGRldGVybWluYW50M3gzKGEyLCBhMywgYTQsIGIyLCBiMywgYjQsIGQyLCBkMywgZDQpO1xyXG4gICAgcmVzdWx0Lm00MSA9IC1kZXRlcm1pbmFudDN4MyhhMiwgYTMsIGE0LCBiMiwgYjMsIGI0LCBjMiwgYzMsIGM0KTtcclxuXHJcbiAgICByZXN1bHQubTEyID0gLWRldGVybWluYW50M3gzKGIxLCBiMywgYjQsIGMxLCBjMywgYzQsIGQxLCBkMywgZDQpO1xyXG4gICAgcmVzdWx0Lm0yMiA9ICBkZXRlcm1pbmFudDN4MyhhMSwgYTMsIGE0LCBjMSwgYzMsIGM0LCBkMSwgZDMsIGQ0KTtcclxuICAgIHJlc3VsdC5tMzIgPSAtZGV0ZXJtaW5hbnQzeDMoYTEsIGEzLCBhNCwgYjEsIGIzLCBiNCwgZDEsIGQzLCBkNCk7XHJcbiAgICByZXN1bHQubTQyID0gIGRldGVybWluYW50M3gzKGExLCBhMywgYTQsIGIxLCBiMywgYjQsIGMxLCBjMywgYzQpO1xyXG5cclxuICAgIHJlc3VsdC5tMTMgPSAgZGV0ZXJtaW5hbnQzeDMoYjEsIGIyLCBiNCwgYzEsIGMyLCBjNCwgZDEsIGQyLCBkNCk7XHJcbiAgICByZXN1bHQubTIzID0gLWRldGVybWluYW50M3gzKGExLCBhMiwgYTQsIGMxLCBjMiwgYzQsIGQxLCBkMiwgZDQpO1xyXG4gICAgcmVzdWx0Lm0zMyA9ICBkZXRlcm1pbmFudDN4MyhhMSwgYTIsIGE0LCBiMSwgYjIsIGI0LCBkMSwgZDIsIGQ0KTtcclxuICAgIHJlc3VsdC5tNDMgPSAtZGV0ZXJtaW5hbnQzeDMoYTEsIGEyLCBhNCwgYjEsIGIyLCBiNCwgYzEsIGMyLCBjNCk7XHJcblxyXG4gICAgcmVzdWx0Lm0xNCA9IC1kZXRlcm1pbmFudDN4MyhiMSwgYjIsIGIzLCBjMSwgYzIsIGMzLCBkMSwgZDIsIGQzKTtcclxuICAgIHJlc3VsdC5tMjQgPSAgZGV0ZXJtaW5hbnQzeDMoYTEsIGEyLCBhMywgYzEsIGMyLCBjMywgZDEsIGQyLCBkMyk7XHJcbiAgICByZXN1bHQubTM0ID0gLWRldGVybWluYW50M3gzKGExLCBhMiwgYTMsIGIxLCBiMiwgYjMsIGQxLCBkMiwgZDMpO1xyXG4gICAgcmVzdWx0Lm00NCA9ICBkZXRlcm1pbmFudDN4MyhhMSwgYTIsIGEzLCBiMSwgYjIsIGIzLCBjMSwgYzIsIGMzKTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjaW52ZXJzZSgpIC0+IEZpcm1pbkNTU01hdHJpeCB8IG51bGxcclxuICpcclxuICogIElmIHRoZSBtYXRyaXggaXMgaW52ZXJ0aWJsZSwgcmV0dXJucyBpdHMgaW52ZXJzZSwgb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cclxuICoqL1xyXG5GaXJtaW5DU1NNYXRyaXgucHJvdG90eXBlLmludmVyc2UgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBpbnYsIGRldCwgcmVzdWx0LCBpLCBqO1xyXG5cclxuICAgIGlmICh0aGlzLmlzSWRlbnRpdHlPclRyYW5zbGF0aW9uKCkpIHtcclxuICAgICAgICBpbnYgPSBuZXcgRmlybWluQ1NTTWF0cml4KCk7XHJcblxyXG4gICAgICAgIGlmICghKHRoaXMubTQxID09PSAwICYmIHRoaXMubTQyID09PSAwICYmIHRoaXMubTQzID09PSAwKSkge1xyXG4gICAgICAgICAgICBpbnYubTQxID0gLXRoaXMubTQxO1xyXG4gICAgICAgICAgICBpbnYubTQyID0gLXRoaXMubTQyO1xyXG4gICAgICAgICAgICBpbnYubTQzID0gLXRoaXMubTQzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGludjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFkam9pbnQgbWF0cml4XHJcbiAgICByZXN1bHQgPSB0aGlzLmFkam9pbnQoKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIDR4NCBkZXRlcm1pbmFudFxyXG4gICAgZGV0ID0gRmlybWluQ1NTTWF0cml4LmRldGVybWluYW50NHg0KHRoaXMpO1xyXG5cclxuICAgIC8vIElmIHRoZSBkZXRlcm1pbmFudCBpcyB6ZXJvLCB0aGVuIHRoZSBpbnZlcnNlIG1hdHJpeCBpcyBub3QgdW5pcXVlXHJcbiAgICBpZiAoTWF0aC5hYnMoZGV0KSA8IDFlLTgpIHJldHVybiBudWxsO1xyXG5cclxuICAgIC8vIFNjYWxlIHRoZSBhZGpvaW50IG1hdHJpeCB0byBnZXQgdGhlIGludmVyc2VcclxuICAgIGZvciAoaSA9IDE7IGkgPCA1OyBpKyspIHtcclxuICAgICAgICBmb3IgKGogPSAxOyBqIDwgNTsgaisrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFsoXCJtXCIgKyBpKSArIGpdIC89IGRldDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I3JvdGF0ZShyb3RYLCByb3RZLCByb3RaKSAtPiBGaXJtaW5DU1NNYXRyaXhcclxuICogIC0gcm90WCAoTnVtYmVyKTogdGhlIHJvdGF0aW9uIGFyb3VuZCB0aGUgeCBheGlzLlxyXG4gKiAgLSByb3RZIChOdW1iZXIpOiB0aGUgcm90YXRpb24gYXJvdW5kIHRoZSB5IGF4aXMuIElmIHVuZGVmaW5lZCwgdGhlIHhcclxuICogICAgY29tcG9uZW50IGlzIHVzZWQuXHJcbiAqICAtIHJvdFogKE51bWJlcik6IHRoZSByb3RhdGlvbiBhcm91bmQgdGhlIHogYXhpcy4gSWYgdW5kZWZpbmVkLCB0aGUgeFxyXG4gKiAgICBjb21wb25lbnQgaXMgdXNlZC5cclxuICpcclxuICogIFJldHVybnMgdGhlIHJlc3VsdCBvZiByb3RhdGluZyB0aGUgbWF0cml4IGJ5IGEgZ2l2ZW4gdmVjdG9yLlxyXG4gKlxyXG4gKiAgSWYgb25seSB0aGUgZmlyc3QgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHRoZSBtYXRyaXggaXMgb25seSByb3RhdGVkIGFib3V0XHJcbiAqICB0aGUgeiBheGlzLlxyXG4gKiovXHJcbkZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24ocngsIHJ5LCByeikge1xyXG4gICAgdmFyIGRlZ3JlZXNUb1JhZGlhbnMgPSBGaXJtaW5DU1NNYXRyaXguZGVncmVlc1RvUmFkaWFucztcclxuXHJcbiAgICBpZiAodHlwZW9mIHJ4ICE9IFwibnVtYmVyXCIgfHwgaXNOYU4ocngpKSByeCA9IDA7XHJcblxyXG4gICAgaWYgKCh0eXBlb2YgcnkgIT0gXCJudW1iZXJcIiB8fCBpc05hTihyeSkpICYmXHJcbiAgICAodHlwZW9mIHJ6ICE9IFwibnVtYmVyXCIgfHwgaXNOYU4ocnopKSkge1xyXG4gICAgICAgIHJ6ID0gcng7XHJcbiAgICAgICAgcnggPSAwO1xyXG4gICAgICAgIHJ5ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHJ5ICE9IFwibnVtYmVyXCIgfHwgaXNOYU4ocnkpKSByeSA9IDA7XHJcbiAgICBpZiAodHlwZW9mIHJ6ICE9IFwibnVtYmVyXCIgfHwgaXNOYU4ocnopKSByeiA9IDA7XHJcblxyXG4gICAgcnggPSBkZWdyZWVzVG9SYWRpYW5zKHJ4KTtcclxuICAgIHJ5ID0gZGVncmVlc1RvUmFkaWFucyhyeSk7XHJcbiAgICByeiA9IGRlZ3JlZXNUb1JhZGlhbnMocnopO1xyXG5cclxuICAgIHZhciB0eCA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoKSxcclxuICAgIHR5ID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpLFxyXG4gICAgdHogPSBuZXcgRmlybWluQ1NTTWF0cml4KCksXHJcbiAgICBzaW5BLCBjb3NBLCBzaW5BMjtcclxuXHJcbiAgICByeiAvPSAyO1xyXG4gICAgc2luQSA9IE1hdGguc2luKHJ6KTtcclxuICAgIGNvc0EgPSBNYXRoLmNvcyhyeik7XHJcbiAgICBzaW5BMiA9IHNpbkEgKiBzaW5BO1xyXG5cclxuICAgIC8vIE1hdHJpY2VzIGFyZSBpZGVudGl0eSBvdXRzaWRlIHRoZSBhc3NpZ25lZCB2YWx1ZXNcclxuICAgIHR6Lm0xMSA9IHR6Lm0yMiA9IDEgLSAyICogc2luQTI7XHJcbiAgICB0ei5tMTIgPSB0ei5tMjEgPSAyICogc2luQSAqIGNvc0E7XHJcbiAgICB0ei5tMjEgKj0gLTE7XHJcblxyXG4gICAgcnkgLz0gMjtcclxuICAgIHNpbkEgID0gTWF0aC5zaW4ocnkpO1xyXG4gICAgY29zQSAgPSBNYXRoLmNvcyhyeSk7XHJcbiAgICBzaW5BMiA9IHNpbkEgKiBzaW5BO1xyXG5cclxuICAgIHR5Lm0xMSA9IHR5Lm0zMyA9IDEgLSAyICogc2luQTI7XHJcbiAgICB0eS5tMTMgPSB0eS5tMzEgPSAyICogc2luQSAqIGNvc0E7XHJcbiAgICB0eS5tMTMgKj0gLTE7XHJcblxyXG4gICAgcnggLz0gMjtcclxuICAgIHNpbkEgPSBNYXRoLnNpbihyeCk7XHJcbiAgICBjb3NBID0gTWF0aC5jb3MocngpO1xyXG4gICAgc2luQTIgPSBzaW5BICogc2luQTtcclxuXHJcbiAgICB0eC5tMjIgPSB0eC5tMzMgPSAxIC0gMiAqIHNpbkEyO1xyXG4gICAgdHgubTIzID0gdHgubTMyID0gMiAqIHNpbkEgKiBjb3NBO1xyXG4gICAgdHgubTMyICo9IC0xO1xyXG5cclxuICAgIHZhciBpc0lkZW50aXR5ID0gKHRoaXMudG9TdHJpbmcoKSA9PT0gKG5ldyBGaXJtaW5DU1NNYXRyaXgpLnRvU3RyaW5nKCkpO1xyXG5cclxuICAgIHJldHVybiAoaXNJZGVudGl0eSlcclxuICAgID8gdHoubXVsdGlwbHkodHkpLm11bHRpcGx5KHR4KVxyXG4gICAgOiB0aGlzLm11bHRpcGx5KHR4KS5tdWx0aXBseSh0eSkubXVsdGlwbHkodHopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjcm90YXRlQXhpc0FuZ2xlKHJvdFgsIHJvdFksIHJvdFosIGFuZ2xlKSAtPiBGaXJtaW5DU1NNYXRyaXhcclxuICogIC0gcm90WCAoTnVtYmVyKTogdGhlIHJvdGF0aW9uIGFyb3VuZCB0aGUgeCBheGlzLlxyXG4gKiAgLSByb3RZIChOdW1iZXIpOiB0aGUgcm90YXRpb24gYXJvdW5kIHRoZSB5IGF4aXMuIElmIHVuZGVmaW5lZCwgdGhlIHhcclxuICogICAgY29tcG9uZW50IGlzIHVzZWQuXHJcbiAqICAtIHJvdFogKE51bWJlcik6IHRoZSByb3RhdGlvbiBhcm91bmQgdGhlIHogYXhpcy4gSWYgdW5kZWZpbmVkLCB0aGUgeFxyXG4gKiAgICBjb21wb25lbnQgaXMgdXNlZC5cclxuICogIC0gYW5nbGUgKE51bWJlcik6IHRoZSBhbmdsZSBvZiByb3RhdGlvbiBhYm91dCB0aGUgYXhpcyB2ZWN0b3IsIGluIGRlZ3JlZXMuXHJcbiAqXHJcbiAqICBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygcm90YXRpbmcgdGhlIG1hdHJpeCBhcm91bmQgYSBnaXZlbiB2ZWN0b3IgYnkgYSBnaXZlblxyXG4gKiAgYW5nbGUuXHJcbiAqXHJcbiAqICBJZiB0aGUgZ2l2ZW4gdmVjdG9yIGlzIHRoZSBvcmlnaW4gdmVjdG9yIHRoZW4gdGhlIG1hdHJpeCBpcyByb3RhdGVkIGJ5IHRoZVxyXG4gKiAgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSB6IGF4aXMuXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LnByb3RvdHlwZS5yb3RhdGVBeGlzQW5nbGUgPSBmdW5jdGlvbih4LCB5LCB6LCBhKSB7XHJcbiAgICBpZiAodHlwZW9mIHggIT0gXCJudW1iZXJcIiB8fCBpc05hTih4KSkgeCA9IDA7XHJcbiAgICBpZiAodHlwZW9mIHkgIT0gXCJudW1iZXJcIiB8fCBpc05hTih5KSkgeSA9IDA7XHJcbiAgICBpZiAodHlwZW9mIHogIT0gXCJudW1iZXJcIiB8fCBpc05hTih6KSkgeiA9IDA7XHJcbiAgICBpZiAodHlwZW9mIGEgIT0gXCJudW1iZXJcIiB8fCBpc05hTihhKSkgYSA9IDA7XHJcbiAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwICYmIHogPT09IDApIHogPSAxO1xyXG5cclxuICAgIHZhciB0ICAgPSBuZXcgRmlybWluQ1NTTWF0cml4KCksXHJcbiAgICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSxcclxuICAgIGNvc0EsIHNpbkEsIHNpbkEyLCBjc0EsIHgyLCB5MiwgejI7XHJcblxyXG4gICAgYSAgICAgPSAoRmlybWluQ1NTTWF0cml4LmRlZ3JlZXNUb1JhZGlhbnMoYSkgfHwgMCkgLyAyO1xyXG4gICAgY29zQSAgPSBNYXRoLmNvcyhhKTtcclxuICAgIHNpbkEgID0gTWF0aC5zaW4oYSk7XHJcbiAgICBzaW5BMiA9IHNpbkEgKiBzaW5BO1xyXG5cclxuICAgIC8vIEJhZCB2ZWN0b3IsIHVzZSBzb21ldGhpbmcgc2Vuc2libGVcclxuICAgIGlmIChsZW4gPT09IDApIHtcclxuICAgICAgICB4ID0gMDtcclxuICAgICAgICB5ID0gMDtcclxuICAgICAgICB6ID0gMTtcclxuICAgIH0gZWxzZSBpZiAobGVuICE9PSAxKSB7XHJcbiAgICAgICAgeCAvPSBsZW47XHJcbiAgICAgICAgeSAvPSBsZW47XHJcbiAgICAgICAgeiAvPSBsZW47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT3B0aW1pc2UgY2FzZXMgd2hlcmUgYXhpcyBpcyBhbG9uZyBtYWpvciBheGlzXHJcbiAgICBpZiAoeCA9PT0gMSAmJiB5ID09PSAwICYmIHogPT09IDApIHtcclxuICAgICAgICB0Lm0yMiA9IHQubTMzID0gMSAtIDIgKiBzaW5BMjtcclxuICAgICAgICB0Lm0yMyA9IHQubTMyID0gMiAqIGNvc0EgKiBzaW5BO1xyXG4gICAgICAgIHQubTMyICo9IC0xO1xyXG4gICAgfSBlbHNlIGlmICh4ID09PSAwICYmIHkgPT09IDEgJiYgeiA9PT0gMCkge1xyXG4gICAgICAgIHQubTExID0gdC5tMzMgPSAxIC0gMiAqIHNpbkEyO1xyXG4gICAgICAgIHQubTEzID0gdC5tMzEgPSAyICogY29zQSAqIHNpbkE7XHJcbiAgICAgICAgdC5tMTMgKj0gLTE7XHJcbiAgICB9IGVsc2UgaWYgKHggPT09IDAgJiYgeSA9PT0gMCAmJiB6ID09PSAxKSB7XHJcbiAgICAgICAgdC5tMTEgPSB0Lm0yMiA9IDEgLSAyICogc2luQTI7XHJcbiAgICAgICAgdC5tMTIgPSB0Lm0yMSA9IDIgKiBjb3NBICogc2luQTtcclxuICAgICAgICB0Lm0yMSAqPSAtMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3NBID0gc2luQSAqIGNvc0E7XHJcbiAgICAgICAgeDIgID0geCAqIHg7XHJcbiAgICAgICAgeTIgID0geSAqIHk7XHJcbiAgICAgICAgejIgID0geiAqIHo7XHJcblxyXG4gICAgICAgIHQubTExID0gMSAtIDIgKiAoeTIgKyB6MikgKiBzaW5BMjtcclxuICAgICAgICB0Lm0xMiA9IDIgKiAoeCAqIHkgKiBzaW5BMiArIHogKiBjc0EpO1xyXG4gICAgICAgIHQubTEzID0gMiAqICh4ICogeiAqIHNpbkEyIC0geSAqIGNzQSk7XHJcbiAgICAgICAgdC5tMjEgPSAyICogKHkgKiB4ICogc2luQTIgLSB6ICogY3NBKTtcclxuICAgICAgICB0Lm0yMiA9IDEgLSAyICogKHoyICsgeDIpICogc2luQTI7XHJcbiAgICAgICAgdC5tMjMgPSAyICogKHkgKiB6ICogc2luQTIgKyB4ICogY3NBKTtcclxuICAgICAgICB0Lm0zMSA9IDIgKiAoeiAqIHggKiBzaW5BMiArIHkgKiBjc0EpO1xyXG4gICAgICAgIHQubTMyID0gMiAqICh6ICogeSAqIHNpbkEyIC0geCAqIGNzQSk7XHJcbiAgICAgICAgdC5tMzMgPSAxIC0gMiAqICh4MiArIHkyKSAqIHNpbkEyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLm11bHRpcGx5KHQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjc2NhbGUoc2NhbGVYLCBzY2FsZVksIHNjYWxlWikgLT4gRmlybWluQ1NTTWF0cml4XHJcbiAqICAtIHNjYWxlWCAoTnVtYmVyKTogdGhlIHNjYWxpbmcgZmFjdG9yIGluIHRoZSB4IGF4aXMuXHJcbiAqICAtIHNjYWxlWSAoTnVtYmVyKTogdGhlIHNjYWxpbmcgZmFjdG9yIGluIHRoZSB5IGF4aXMuIElmIHVuZGVmaW5lZCwgdGhlIHhcclxuICogICAgY29tcG9uZW50IGlzIHVzZWQuXHJcbiAqICAtIHNjYWxlWiAoTnVtYmVyKTogdGhlIHNjYWxpbmcgZmFjdG9yIGluIHRoZSB6IGF4aXMuIElmIHVuZGVmaW5lZCwgMSBpc1xyXG4gKiAgICB1c2VkLlxyXG4gKlxyXG4gKiAgUmV0dXJucyB0aGUgcmVzdWx0IG9mIHNjYWxpbmcgdGhlIG1hdHJpeCBieSBhIGdpdmVuIHZlY3Rvci5cclxuICoqL1xyXG5GaXJtaW5DU1NNYXRyaXgucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24oc2NhbGVYLCBzY2FsZVksIHNjYWxlWikge1xyXG4gICAgdmFyIHRyYW5zZm9ybSA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIHNjYWxlWCAhPSBcIm51bWJlclwiIHx8IGlzTmFOKHNjYWxlWCkpIHNjYWxlWCA9IDE7XHJcbiAgICBpZiAodHlwZW9mIHNjYWxlWSAhPSBcIm51bWJlclwiIHx8IGlzTmFOKHNjYWxlWSkpIHNjYWxlWSA9IHNjYWxlWDtcclxuICAgIGlmICh0eXBlb2Ygc2NhbGVaICE9IFwibnVtYmVyXCIgfHwgaXNOYU4oc2NhbGVaKSkgc2NhbGVaID0gMTtcclxuXHJcbiAgICB0cmFuc2Zvcm0ubTExID0gc2NhbGVYO1xyXG4gICAgdHJhbnNmb3JtLm0yMiA9IHNjYWxlWTtcclxuICAgIHRyYW5zZm9ybS5tMzMgPSBzY2FsZVo7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHkodHJhbnNmb3JtKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I3NrZXdYKHNrZXdYKSAtPiBGaXJtaW5DU1NNYXRyaXhcclxuICogIC0gc2tld1ggKE51bWJlcik6IHRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeCBheGlzLlxyXG4gKlxyXG4gKiAgUmV0dXJucyB0aGUgcmVzdWx0IG9mIHNrZXdpbmcgdGhlIG1hdHJpeCBieSBhIGdpdmVuIHZlY3Rvci5cclxuICoqL1xyXG5GaXJtaW5DU1NNYXRyaXgucHJvdG90eXBlLnNrZXdYID0gZnVuY3Rpb24oZGVncmVlcykge1xyXG4gICAgdmFyIHJhZGlhbnMgPSBGaXJtaW5DU1NNYXRyaXguZGVncmVlc1RvUmFkaWFucyhkZWdyZWVzKTtcclxuICAgIHZhciB0cmFuc2Zvcm0gPSBuZXcgRmlybWluQ1NTTWF0cml4KCk7XHJcblxyXG4gICAgdHJhbnNmb3JtLmMgPSBNYXRoLnRhbihyYWRpYW5zKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseSh0cmFuc2Zvcm0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjc2tld1koc2tld1kpIC0+IEZpcm1pbkNTU01hdHJpeFxyXG4gKiAgLSBza2V3WSAoTnVtYmVyKTogdGhlIHNjYWxpbmcgZmFjdG9yIGluIHRoZSB4IGF4aXMuXHJcbiAqXHJcbiAqICBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc2tld2luZyB0aGUgbWF0cml4IGJ5IGEgZ2l2ZW4gdmVjdG9yLlxyXG4gKiovXHJcbkZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUuc2tld1kgPSBmdW5jdGlvbihkZWdyZWVzKSB7XHJcbiAgICB2YXIgcmFkaWFucyA9IEZpcm1pbkNTU01hdHJpeC5kZWdyZWVzVG9SYWRpYW5zKGRlZ3JlZXMpO1xyXG4gICAgdmFyIHRyYW5zZm9ybSA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoKTtcclxuXHJcbiAgICB0cmFuc2Zvcm0uYiA9IE1hdGgudGFuKHJhZGlhbnMpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLm11bHRpcGx5KHRyYW5zZm9ybSk7XHJcbn07XHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCN0cmFuc2xhdGUoeCwgeSwgeikgLT4gRmlybWluQ1NTTWF0cml4XHJcbiAqICAtIHggKE51bWJlcik6IHRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxyXG4gKiAgLSB5IChOdW1iZXIpOiB0aGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICogIC0geiAoTnVtYmVyKTogdGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IuIElmIHVuZGVmaW5lZCwgMCBpcyB1c2VkLlxyXG4gKlxyXG4gKiAgUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRyYW5zbGF0aW5nIHRoZSBtYXRyaXggYnkgYSBnaXZlbiB2ZWN0b3IuXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbih4LCB5LCB6KSB7XHJcbiAgICB2YXIgdCA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIHggIT0gXCJudW1iZXJcIiB8fCBpc05hTih4KSkgeCA9IDA7XHJcbiAgICBpZiAodHlwZW9mIHkgIT0gXCJudW1iZXJcIiB8fCBpc05hTih5KSkgeSA9IDA7XHJcbiAgICBpZiAodHlwZW9mIHogIT0gXCJudW1iZXJcIiB8fCBpc05hTih6KSkgeiA9IDA7XHJcblxyXG4gICAgdC5tNDEgPSB4O1xyXG4gICAgdC5tNDIgPSB5O1xyXG4gICAgdC5tNDMgPSB6O1xyXG5cclxuICAgIHJldHVybiB0aGlzLm11bHRpcGx5KHQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjc2V0TWF0cml4VmFsdWUoZG9tc3RyKSAtPiB1bmRlZmluZWRcclxuICogIC0gZG9tc3RyIChTdHJpbmcpOiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIDJEIG9yIDNEIHRyYW5zZm9ybSBtYXRyaXhcclxuICogICAgaW4gdGhlIGZvcm0gZ2l2ZW4gYnkgdGhlIENTUyB0cmFuc2Zvcm0gcHJvcGVydHksIGkuZS4ganVzdCBsaWtlIHRoZVxyXG4gKiAgICBvdXRwdXQgZnJvbSBbW0Zpcm1pbkNTU01hdHJpeCN0b1N0cmluZ11dLlxyXG4gKlxyXG4gKiAgU2V0cyB0aGUgbWF0cml4IHZhbHVlcyB1c2luZyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyB0aGF0IHByb2R1Y2VkXHJcbiAqICBieSB0aGUgW1tGaXJtaW5DU1NNYXRyaXgjdG9TdHJpbmddXSBtZXRob2QuXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LnByb3RvdHlwZS5zZXRNYXRyaXhWYWx1ZSA9IGZ1bmN0aW9uKGRvbXN0cikge1xyXG4gICAgZG9tc3RyID0gRmlybWluQ1NTTWF0cml4LnRvTWF0cml4U3RyaW5nKGRvbXN0ci50cmltKCkpO1xyXG4gICAgdmFyIG1zdHIgICA9IGRvbXN0ci5tYXRjaCgvXm1hdHJpeCgzZCk/XFwoXFxzKiguKylcXHMqXFwpJC8pLFxyXG4gICAgaXMzZCwgY2h1bmtzLCBsZW4sIHBvaW50cywgaSwgY2h1bms7XHJcblxyXG4gICAgaWYgKCFtc3RyKSByZXR1cm47XHJcblxyXG4gICAgaXMzZCAgID0gISFtc3RyWzFdO1xyXG4gICAgY2h1bmtzID0gbXN0clsyXS5zcGxpdCgvXFxzKixcXHMqLyk7XHJcbiAgICBsZW4gICAgPSBjaHVua3MubGVuZ3RoO1xyXG4gICAgcG9pbnRzID0gbmV3IEFycmF5KGxlbik7XHJcblxyXG4gICAgaWYgKChpczNkICYmIGxlbiAhPT0gMTYpIHx8ICEoaXMzZCB8fCBsZW4gPT09IDYpKSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbnZhbGlkIENTUyBNYXRyaXg6IFwiLCBkb21zdHIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBjaHVuayA9IGNodW5rc1tpXTtcclxuICAgICAgICBpZiAoY2h1bmsubWF0Y2goL14tP1xcZCsoXFwuXFxkKyk/JC8pKSB7XHJcbiAgICAgICAgICAgIHBvaW50c1tpXSA9IHBhcnNlRmxvYXQoY2h1bmspO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiSW52YWxpZCBDU1MgTWF0cml4OiBcIiwgZG9tc3RyKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICB2YXIgcG9pbnQgPSBpczNkID9cclxuICAgICAgICAoXCJtXCIgKyAoTWF0aC5mbG9vcihpIC8gNCkgKyAxKSkgKyAoaSAlIDQgKyAxKSA6XHJcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICsgOTcpOyAvLyBBU0NJSSBjaGFyIDk3ID09ICdhJ1xyXG4gICAgICAgIHRoaXNbcG9pbnRdID0gcG9pbnRzW2ldO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjdG9TdHJpbmcoKSAtPiBTdHJpbmdcclxuICpcclxuICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeC5cclxuICoqL1xyXG5GaXJtaW5DU1NNYXRyaXgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXMsIHBvaW50cywgcHJlZml4O1xyXG5cclxuICAgIGlmICh0aGlzLmlzQWZmaW5lKCkpIHtcclxuICAgICAgICBwcmVmaXggPSBcIm1hdHJpeChcIjtcclxuICAgICAgICBwb2ludHMgPSBbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIl07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHByZWZpeCA9IFwibWF0cml4M2QoXCI7XHJcbiAgICAgICAgcG9pbnRzID0gW1wibTExXCIsIFwibTEyXCIsIFwibTEzXCIsIFwibTE0XCIsXHJcbiAgICAgICAgICAgIFwibTIxXCIsIFwibTIyXCIsIFwibTIzXCIsIFwibTI0XCIsXHJcbiAgICAgICAgICAgIFwibTMxXCIsIFwibTMyXCIsIFwibTMzXCIsIFwibTM0XCIsXHJcbiAgICAgICAgICAgIFwibTQxXCIsIFwibTQyXCIsIFwibTQzXCIsIFwibTQ0XCJdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwcmVmaXggKyBwb2ludHMubWFwKGZ1bmN0aW9uKHApIHtcclxuICAgICAgICByZXR1cm4gc2VsZltwXS50b0ZpeGVkKDYpO1xyXG4gICAgfSkuam9pbihcIiwgXCIpICsgXCIpXCI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZpcm1pbkNTU01hdHJpeDtcclxuXHJcbiIsInZhciBwcmludFN0YWNrVHJhY2UgPSByZXF1aXJlKFwiLi4vY29udHJpYi9zdGFja3RyYWNlLTAuNC5qc1wiKTtcclxudmFyIE9wdGlvbnMgPSByZXF1aXJlKFwiLi9vcHRpb25zLmpzXCIpO1xyXG5cclxuKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIHZhciBPUFRJT05fTE9HTEVWRUwgPSBcImxvZ2xldmVsXCI7XHJcbiAgICBPcHRpb25zLnJlZ2lzdGVyKE9QVElPTl9MT0dMRVZFTCwgXCJ3YXJuaW5nXCIpO1xyXG5cclxuICAgIG5zLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgQUxMOiAwLFxyXG4gICAgICAgIERFQlVHOiAxLFxyXG4gICAgICAgIElORk86IDIsXHJcbiAgICAgICAgV0FSTklORzogMyxcclxuICAgICAgICBFUlJPUjogNCxcclxuICAgICAgICBFWENFUFRJT046IDUsXHJcbiAgICAgICAgcGFyYW1zOiB7fSxcclxuICAgICAgICBpc1NldHVwOiBmYWxzZSxcclxuICAgICAgICBsb2dsZXZlbDogNCxcclxuICAgICAgICBsb2dsZXZlbHM6IHtcclxuICAgICAgICAgICAgYWxsOiAwLFxyXG4gICAgICAgICAgICBkZWJ1ZzogMSxcclxuICAgICAgICAgICAgaW5mbzogMixcclxuICAgICAgICAgICAgd2FybmluZzogMyxcclxuICAgICAgICAgICAgZXJyb3I6IDQsXHJcbiAgICAgICAgICAgIGV4Y2VwdGlvbjogNVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldHVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWJ1ZyA9IFhNTDNELmRlYnVnO1xyXG4gICAgICAgICAgICBpZiAoIWRlYnVnLmlzU2V0dXApIHtcclxuICAgICAgICAgICAgICAgIGRlYnVnLmlzU2V0dXAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZGVidWcubG9nbGV2ZWwgPSBkZWJ1Zy5sb2dsZXZlbHNbT3B0aW9ucy5nZXRWYWx1ZShPUFRJT05fTE9HTEVWRUwpXSB8fCAzO1xyXG4gICAgICAgICAgICAgICAgT3B0aW9ucy5hZGRPYnNlcnZlcihmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoa2V5ID09IE9QVElPTl9MT0dMRVZFTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Zy5sb2dsZXZlbCA9IGRlYnVnLmxvZ2xldmVsc1t2YWx1ZV0gfHwgMztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3NldExvZ0xldmVsOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRvTG9nOiBmdW5jdGlvbiAobG9nVHlwZSwgYXJncykge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gWE1MM0QuZGVidWcucGFyYW1zO1xyXG4gICAgICAgICAgICBpZiAocGFyYW1zLnhtbDNkX25vbG9nIHx8IGxvZ1R5cGUgPCBYTUwzRC5kZWJ1Zy5sb2dsZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGxvZ1R5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFhNTDNELmRlYnVnLklORk86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmluZm8uYXBwbHkod2luZG93LmNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFhNTDNELmRlYnVnLldBUk5JTkc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4uYXBwbHkod2luZG93LmNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFhNTDNELmRlYnVnLkVSUk9SOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5lcnJvci5hcHBseSh3aW5kb3cuY29uc29sZSwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgWE1MM0QuZGVidWcuRVhDRVBUSU9OOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5lcnJvcihwcmludFN0YWNrVHJhY2Uoe2U6IGFyZ3NbMF0sIGd1ZXNzOiB0cnVlfSkuam9pbignXFxuJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFhNTDNELmRlYnVnLkRFQlVHOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5kZWJ1Zy5hcHBseSh3aW5kb3cuY29uc29sZSwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2dEZWJ1ZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5kb0xvZyhYTUwzRC5kZWJ1Zy5ERUJVRywgYXJndW1lbnRzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvZ0luZm86IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcuZG9Mb2coWE1MM0QuZGVidWcuSU5GTywgYXJndW1lbnRzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvZ1dhcm5pbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcuZG9Mb2coWE1MM0QuZGVidWcuV0FSTklORywgYXJndW1lbnRzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvZ0Vycm9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmRvTG9nKFhNTDNELmRlYnVnLkVSUk9SLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9nRXhjZXB0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmRvTG9nKFhNTDNELmRlYnVnLkVYQ0VQVElPTiwgYXJndW1lbnRzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFzc2VydDogZnVuY3Rpb24gKGMsIG1zZykge1xyXG4gICAgICAgICAgICBpZiAoIWMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYWxsZXI7XHJcbiAgICAgICAgICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVyID0gWE1MM0QuZGVidWcuYXNzZXJ0LmNhbGxlciA/IFhNTDNELmRlYnVnLmFzc2VydC5jYWxsZXIubmFtZSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaChlKXtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxlcilcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5kb0xvZyhYTUwzRC5kZWJ1Zy5XQVJOSU5HLCBbXCJBc3NlcnRpb24gZmFpbGVkIGluIFwiICsgY2FsbGVyLCBtc2cgXSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcuZG9Mb2coWE1MM0QuZGVidWcuV0FSTklORywgW1wiQXNzZXJ0aW9uIGZhaWxlZFwiLCBtc2cgXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHRyYWNlOiBmdW5jdGlvbiAobXNnLCBsb2dUeXBlKSB7XHJcbiAgICAgICAgICAgIGxvZ1R5cGUgPSBsb2dUeXBlICE9PSB1bmRlZmluZWQgPyBsb2dUeXBlIDogWE1MM0QuZGVidWcuRVJST1I7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZS50cmFjZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1zZykge1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmRvTG9nKGxvZ1R5cGUsIFttc2ddKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLnRyYWNlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBwcmludFN0YWNrVHJhY2UoKTtcclxuICAgICAgICAgICAgICAgIG1zZyAmJiBzdGFjay5zcGxpY2UoMCwgMCwgbXNnKTtcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmRvTG9nKGxvZ1R5cGUsIHN0YWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0TnVtYmVyV2l0aFBhZGRpbmc6IGZ1bmN0aW9uIChudW1iZXIsIHdpZHRoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBcIlwiICsgbnVtYmVyO1xyXG4gICAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA8IHdpZHRoKSByZXMgPSBcIiBcIiArIHJlcztcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZvcm1hdFNvdXJjZUNvZGU6IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VMaW5lcyA9IHNvdXJjZS5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VMaW5lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZ2V0TnVtYmVyV2l0aFBhZGRpbmcoaSArIDEsIDMpICsgXCIgIFwiICsgc291cmNlTGluZXNbaV0gKyBcIlxcblwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbn0obW9kdWxlKSk7XHJcbiIsIi8vIHV0aWxzL21pc2MuanNcclxuXHJcbndpbmRvdy5yZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcclxuICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgIHx8XHJcbiAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcclxuICAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbihmLCBmcHMpe1xyXG4gICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGYsIDEwMDAgLyBmcHMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gIH0pKCk7XHJcblxyXG4oZnVuY3Rpb24oZXhwb3J0cykge1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2VuZHMgc2luZ2xlIG9yIG11bHRpcGxlIGFkYXB0ZXIgZnVuY3Rpb25zIGJ5IGNhbGxpbmcgZnVuY3Rpb25zXHJcbiAgICAgKiBzcGVjaWZpZWQgaW4gZnVuY3MgcGFyYW1ldGVyIGZvciBlYWNoIGFkYXB0ZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBub2RlLlxyXG4gICAgICpcclxuICAgICAqIGZ1bmNzIHBhcmFtZXRlciBpcyB1c2VkIGFzIGEgZGljdGlvbmFyeSB3aGVyZSBlYWNoIGtleSBpcyB1c2VkIGFzIG5hbWUgb2YgYVxyXG4gICAgICogYWRhcHRlciBmdW5jdGlvbiB0byBjYWxsLCBhbmQgY29ycmVzcG9uZGluZyB2YWx1ZSBpcyBhIGxpc3Qgb2YgYXJndW1lbnRzXHJcbiAgICAgKiAoaS5lLiBtdXN0IGJlIGFuIGFycmF5KS4gRm9yIGV4YW1wbGUgc2VuZEFkYXB0ZXJFdmVudChub2RlLCB7bWV0aG9kIDogWzEsMiwzXX0pXHJcbiAgICAgKiB3aWxsIGNhbGwgZnVuY3Rpb24gJ21ldGhvZCcgd2l0aCBhcmd1bWVudHMgMSwyLDMgZm9yIGVhY2ggYWRhcHRlciBvZiB0aGUgbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZ1bmNzXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgYWxsIHJldHVybmVkIHZhbHVlc1xyXG4gICAgICovXHJcbiAgICBleHBvcnRzLmNhbGxBZGFwdGVyRnVuYyA9IGZ1bmN0aW9uKG5vZGUsIGZ1bmNzKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLl9jb25maWd1cmVkID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgdmFyIGFkYXB0ZXJzID0gbm9kZS5fY29uZmlndXJlZC5hZGFwdGVycztcclxuICAgICAgICBmb3IgKHZhciBhZGFwdGVyIGluIGFkYXB0ZXJzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGZ1bmMgaW4gZnVuY3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhZGFwdGVyT2JqZWN0ID0gYWRhcHRlcnNbYWRhcHRlcl07XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRIYW5kbGVyID0gYWRhcHRlck9iamVjdFtmdW5jXTtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChldmVudEhhbmRsZXIuYXBwbHkoYWRhcHRlck9iamVjdCwgZnVuY3NbZnVuY10pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2VuZHMgc2luZ2xlIG9yIG11bHRpcGxlIGFkYXB0ZXIgZXZlbnRzIGJ5IGNhbGxpbmcgZnVuY3Rpb25zXHJcbiAgICAgKiBzcGVjaWZpZWQgaW4gZXZlbnRzIHBhcmFtZXRlciBmb3IgZWFjaCBhZGFwdGVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBldmVudHMgcGFyYW1ldGVyIGlzIHVzZWQgYXMgYSBkaWN0aW9uYXJ5IHdoZXJlIGVhY2gga2V5IGlzIHVzZWQgYXMgbmFtZSBvZiBhXHJcbiAgICAgKiBhZGFwdGVyIGZ1bmN0aW9uIHRvIGNhbGwsIGFuZCBjb3JyZXNwb25kaW5nIHZhbHVlIGlzIGEgbGlzdCBvZiBhcmd1bWVudHNcclxuICAgICAqIChpLmUuIG11c3QgYmUgYW4gYXJyYXkpLiBGb3IgZXhhbXBsZSBzZW5kQWRhcHRlckV2ZW50KG5vZGUsIHttZXRob2QgOiBbMSwyLDNdfSlcclxuICAgICAqIHdpbGwgY2FsbCBmdW5jdGlvbiAnbWV0aG9kJyB3aXRoIGFyZ3VtZW50cyAxLDIsMyBmb3IgZWFjaCBhZGFwdGVyIG9mIHRoZSBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRzXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBmYWxzZSBpZiBub2RlIGlzIG5vdCBjb25maWd1cmVkLlxyXG4gICAgICovXHJcbiAgICBleHBvcnRzLnNlbmRBZGFwdGVyRXZlbnQgPSBmdW5jdGlvbihub2RlLCBldmVudHMpIHtcclxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5fY29uZmlndXJlZCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIGFkYXB0ZXJzID0gbm9kZS5fY29uZmlndXJlZC5hZGFwdGVycztcclxuICAgICAgICBmb3IgKHZhciBhZGFwdGVyIGluIGFkYXB0ZXJzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGV2ZW50IGluIGV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IGFkYXB0ZXJzW2FkYXB0ZXJdW2V2ZW50XTtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIuYXBwbHkoYWRhcHRlcnNbYWRhcHRlcl0sIGV2ZW50c1tldmVudF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBEaXNwYXRjaCBjdXN0b20gSFRNTCBldmVudFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgZWxlbWVudCBvciBkb2N1bWVudC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgY3VzdG9tIGV2ZW50IHR5cGUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhbkJ1YmJsZSBXaGV0aGVyIHRoZSBldmVudCBwcm9wYWdhdGVzIHVwd2FyZC4gU2V0cyB0aGUgdmFsdWUgZm9yIHRoZSBidWJibGVzIHByb3BlcnR5LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjYW5jZWxhYmxlIFdoZXRoZXIgdGhlIGV2ZW50IGlzIGNhbmNlbGFibGUgYW5kIHNvIHByZXZlbnREZWZhdWx0IGNhbiBiZSBjYWxsZWQuIFNldHMgdGhlIHZhbHVlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIGZvciB0aGUgY2FuY2VsYWJsZSBwcm9wZXJ0eS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXRhaWwgQSB1c2VyLWRlZmluZWQgb2JqZWN0IHRoYXQgY2FuIGNvbnRhaW4gYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXZlbnQuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgcGFyYW1ldGVyIGNhbiBiZSBvZiBhbnkgdHlwZSwgb3IgbnVsbC4gVGhpcyB2YWx1ZSBpcyByZXR1cm5lZCBpbiB0aGUgZGV0YWlsIHByb3BlcnR5IG9mIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgZXhwb3J0cy5kaXNwYXRjaEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24odGFyZ2V0LCBldmVudFR5cGUsIGNhbkJ1YmJsZSwgY2FuY2VsYWJsZSwgZGV0YWlsKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XHJcbiAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50VHlwZSwgY2FuQnViYmxlLCBjYW5jZWxhYmxlLCBkZXRhaWwpO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBEaXNwYXRjaCBIVE1MIGV2ZW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAgICBlbGVtZW50IG9yIGRvY3VtZW50XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIHN0YW5kYXJkIGV2ZW50IHR5cGUgZS5nLiBsb2FkLCBjbGlja1xyXG4gICAgICovXHJcbiAgICBleHBvcnRzLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50VHlwZSkge1xyXG4gICAgICAgIHZhciBldnQgPSBudWxsO1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudHNcIik7XHJcbiAgICAgICAgICAgICAgICBldnQuaW5pdEV2ZW50KGV2ZW50VHlwZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZ0KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZmlyZUV2ZW50KCdvbicgKyBldmVudFR5cGUsIGV2dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgIHZhciBfX2F1dG9DcmVhdGVkVmlld0lkID0gMDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYWN0aXZlIHZpZXcgZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB4bWwzZCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0geG1sM2RcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGFjdGl2ZSB2aWV3IGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgZXhwb3J0cy5nZXRPckNyZWF0ZUFjdGl2ZVZpZXcgPSBmdW5jdGlvbih4bWwzZClcclxuICAgIHtcclxuICAgICAgICAvLyB0cnkgdG8gcmVzb2x2ZSByZWZlcmVuY2VcclxuICAgICAgICB2YXIgcmVmID0geG1sM2QuYWN0aXZlVmlldztcclxuICAgICAgICBpZihyZWYpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgdiA9IHdpbmRvdy5YTUwzRC5VUklSZXNvbHZlci5yZXNvbHZlTG9jYWwocmVmKTtcclxuICAgICAgICAgICAgaWYoIXYpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlhNTDNEIEVycm9yOiB4bWwzZCByZWZlcmVuY2VzIHZpZXcgdGhhdCBpcyBub3QgZGVmaW5lZDogJ1wiICsgcmVmICsgXCInLlwiO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBkaWRuJ3Qgc3VjY2VlZCwgc28gbm93IHRyeSB0byBqdXN0IHRha2UgdGhlIGZpcnN0IHZpZXdcclxuICAgICAgICB2YXIgZmlyc3RWaWV3ID0geG1sM2QucXVlcnlTZWxlY3RvcihcInZpZXdcIik7XHJcbiAgICAgICAgaWYoZmlyc3RWaWV3KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gaWYgaXQgaGFzIGFuIGlkLCBzZXQgaXQgYXMgYWN0aXZlXHJcbiAgICAgICAgICAgIGlmKGZpcnN0Vmlldy5pZCAmJiBmaXJzdFZpZXcuaWQubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgIHhtbDNkLmFjdGl2ZVZpZXcgPSBcIiNcIiArIGZpcnN0Vmlldy5pZDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmaXJzdFZpZXc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBkaWRuJ3QgZmluZCBhbnk6IGNyZWF0ZSBuZXcgb25lXHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcInhtbDNkIGVsZW1lbnQgaGFzIG5vIHZpZXcgZGVmaW5lZDogY3JlYXRpbmcgb25lLlwiKTtcclxuXHJcbiAgICAgICAgdmFyIHZpZCA9IFwieG1sM2QuYXV0b2NyZWF0ZWR2aWV3X1wiICsgX19hdXRvQ3JlYXRlZFZpZXdJZCsrO1xyXG4gICAgICAgIHZhciB2ID0gWE1MM0QuY3JlYXRlRWxlbWVudChcInZpZXdcIik7XHJcbiAgICAgICAgdi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB2aWQpO1xyXG5cclxuICAgICAgICB4bWwzZC5hcHBlbmRDaGlsZCh2KTtcclxuICAgICAgICB4bWwzZC5zZXRBdHRyaWJ1dGUoXCJhY3RpdmVWaWV3XCIsIFwiI1wiICsgdmlkKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICB9O1xyXG59KG1vZHVsZS5leHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYXNzIHRvIGhhbmRsZSBvcHRpb25zLiBDdXJyZW50bHkgb25seSB1c2VkIGZvciBnbG9iYWwgb3B0aW9ucywgY291bGRcclxuICAgICAqIGJlIGV4dGVuZGVkIHRvIHdvcmsgaGllcmFyY2hpY2FsbHkgdG8gY29uZmlndXJlIG90aGVyIGVsZW1lbnRzLlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7fTtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7IFwiKlwiOiBbXSB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBPcHRpb25zLnByb3RvdHlwZSA9IHtcclxuICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24gKGtleSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb24gYWxyZWFkeSByZWdpc3RlcmVkICdcIiArIGtleSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1trZXldID0ge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzZXRWYWx1ZTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBrZXkgJ1wiICsga2V5ICsgXCInXCIpO1xyXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zW2tleV0uY3VycmVudFZhbHVlID0gdGhpcy5fb3B0aW9uc1trZXldLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5ub3RpZnlPYnNlcnZlcnMoa2V5LCB0aGlzLl9vcHRpb25zW2tleV0uY3VycmVudFZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBrZXkgJ1wiICsga2V5ICsgXCInXCIpO1xyXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zW2tleV0uY3VycmVudFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMubm90aWZ5T2JzZXJ2ZXJzKGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBrZXkgJ1wiICsga2V5ICsgXCInXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zW2tleV0uY3VycmVudFZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0S2V5czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fb3B0aW9ucyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBub3RpZnlPYnNlcnZlcnM6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIE5vdGlmeSBzcGVjaWZpYyBvYnNlcnZlcnNcclxuICAgICAgICAgICAgaWYodGhpcy5fbGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1trZXldLmZvckVhY2goZnVuY3Rpb24obCkge1xyXG4gICAgICAgICAgICAgICAgICAgbChrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vdGlmeSBnZW5lcmljIG9ic2VydmVyc1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbXCIqXCJdLmZvckVhY2goZnVuY3Rpb24obCkge1xyXG4gICAgICAgICAgICAgICBsKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZE9ic2VydmVyOiBmdW5jdGlvbiAoa2V5LCBvYnNlcnZlcikge1xyXG4gICAgICAgICAgICBpZih0eXBlb2Yga2V5ID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyID0ga2V5O1xyXG4gICAgICAgICAgICAgICAga2V5ID0gXCIqXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZighdGhpcy5fb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPT0gXCIqXCIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHJlZ2lzdGVyIHRvIHVua25vd24gb3B0aW9uICdcIiArIGtleSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZighdGhpcy5fbGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1trZXldID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2tleV0ucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVPYnNlcnZlcjogZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgZmlsdGVyIGluIHRoaXMuX2xpc3RlbmVycykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tmaWx0ZXJdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGxpc3RlbmVycy5pbmRleE9mKG9ic2VydmVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChpZHggIT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIEdsb2JhbE9wdGlvbnMgPSBuZXcgT3B0aW9ucygpO1xyXG5cclxuICAgIEdsb2JhbE9wdGlvbnMuc2V0T3B0aW9uc0Zyb21RdWVyeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpLnNwbGl0KCcmJyk7XHJcblxyXG4gICAgICAgIHAuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIga2V5VmFsID0gZS5zcGxpdCgnPScpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleVZhbFswXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKFwieG1sM2QtXCIpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleVZhbFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0Qub3B0aW9ucy5zZXRWYWx1ZShrZXkuc3Vic3RyKDYpLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnICYmIFhNTDNELmRlYnVnLmxvZ0Vycm9yKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbnMuZXhwb3J0cyA9IEdsb2JhbE9wdGlvbnM7XHJcblxyXG59KG1vZHVsZSkpO1xyXG4iLCIoZnVuY3Rpb24oZXhwb3J0cykge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyBVUklcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgVVJJIGFzIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICB2YXIgVVJJID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgIHN0ciA9IHN0ciB8fCBcIlwiO1xyXG4gICAgICAgIGlmIChzdHIuaW5kZXhPZihcImJsb2I6XCIpID09IDApIHtcclxuICAgICAgICAgICAgLy8gQmFzZWQgb24gaHR0cDovL3d3dy53My5vcmcvVFIvRmlsZUFQSS8jdXJsXHJcbiAgICAgICAgICAgIHZhciBwYXJzZXIgPSAvXig/OihbXjpcXC8/XFwjXSspOik/KFteXFwjXSopKD86XFwjKC4qKSk/LztcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHN0ci5tYXRjaChwYXJzZXIpO1xyXG4gICAgICAgICAgICAvKiogIEB0eXBlIHtib29sZWFufSAqL1xyXG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gcmVzdWx0ICE9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKiAgQHR5cGUgez9zdHJpbmd9ICovXHJcbiAgICAgICAgICAgIHRoaXMuc2NoZW1lID0gcmVzdWx0WzFdIHx8IG51bGw7XHJcbiAgICAgICAgICAgIC8qKiAgQHR5cGUgez9zdHJpbmd9ICovXHJcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5ID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqICBAdHlwZSB7P3N0cmluZ30gKi9cclxuICAgICAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqICBAdHlwZSB7P3N0cmluZ30gKi9cclxuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKiAgQHR5cGUgez9zdHJpbmd9ICovXHJcbiAgICAgICAgICAgIHRoaXMub3BhcXVlU3RyaW5nID0gcmVzdWx0WzJdIHx8IG51bGw7XHJcbiAgICAgICAgICAgIC8qKiAgQHR5cGUgez9zdHJpbmd9ICovXHJcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSByZXN1bHRbM10gfHwgbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBCYXNlZCBvbiB0aGUgcmVnZXggaW4gUkZDMjM5NiBBcHBlbmRpeCBCLlxyXG4gICAgICAgICAgICB2YXIgcGFyc2VyID0gL14oPzooW146XFwvP1xcI10rKTopPyg/OlxcL1xcLyhbXlxcLz9cXCNdKikpPyhbXj9cXCNdKikoPzpcXD8oW15cXCNdKikpPyg/OlxcIyguKikpPy87XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBzdHIubWF0Y2gocGFyc2VyKTtcclxuICAgICAgICAgICAgLyoqICBAdHlwZSB7Ym9vbGVhbn0gKi9cclxuICAgICAgICAgICAgdGhpcy52YWxpZCA9IHJlc3VsdCAhPSBudWxsO1xyXG4gICAgICAgICAgICAvKiogIEB0eXBlIHs/c3RyaW5nfSAqL1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVtZSA9IHJlc3VsdFsxXSB8fCBudWxsO1xyXG4gICAgICAgICAgICAvKiogIEB0eXBlIHs/c3RyaW5nfSAqL1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhvcml0eSA9IHJlc3VsdFsyXSB8fCBudWxsO1xyXG4gICAgICAgICAgICAvKiogIEB0eXBlIHs/c3RyaW5nfSAqL1xyXG4gICAgICAgICAgICB0aGlzLnBhdGggPSByZXN1bHRbM10gfHwgbnVsbDtcclxuICAgICAgICAgICAgLyoqICBAdHlwZSB7P3N0cmluZ30gKi9cclxuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHJlc3VsdFs0XSB8fCBudWxsO1xyXG4gICAgICAgICAgICAvKiogIEB0eXBlIHs/c3RyaW5nfSAqL1xyXG4gICAgICAgICAgICB0aGlzLm9wYXF1ZVN0cmluZyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKiAgQHR5cGUgez9zdHJpbmd9ICovXHJcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSByZXN1bHRbNV0gfHwgbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBVUkkgaXMgcmVsYXRpdmUgdG8gY3VycmVudCBkb2N1bWVudFxyXG4gICAgICovXHJcbiAgICBVUkkucHJvdG90eXBlLmlzTG9jYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1lICE9IFwiYmxvYlwiICYmICF0aGlzLmF1dGhvcml0eSAmJiAhdGhpcy5wYXRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBVUkkgaXMgYWJzb2x1dGVcclxuICAgICAqL1xyXG4gICAgVVJJLnByb3RvdHlwZS5pc0Fic29sdXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtZSAhPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFic29sdXRlIFVSSSByZWxhdGl2ZSB0byB0aGUgcHJvdmlkZWQgZG9jdW1lbnQgdXJpXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZG9jVXJpIHVyaSBvZiBkb2N1bWVudCBmcm9tIHdoaWNoIHRoaXMgdXJpIG9yaWdpbmF0ZXNcclxuICAgICAqIEByZXR1cm5zIHtVUkl9XHJcbiAgICAgKi9cclxuICAgIFVSSS5wcm90b3R5cGUuZ2V0QWJzb2x1dGVVUkkgPSBmdW5jdGlvbiAoZG9jVXJpKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkIHx8IHRoaXMuaXNBYnNvbHV0ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRvY1VyaU9iaiA9IG5ldyBVUkkoZG9jVXJpKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucGF0aCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXRoLmluZGV4T2YoXCIvXCIpID09IDApIHtcclxuICAgICAgICAgICAgICAgIGRvY1VyaU9iai5wYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9jVXJpT2JqLnBhdGggPSBkb2NVcmlPYmoucGF0aC5zdWJzdHIoMCwgZG9jVXJpT2JqLnBhdGgubGFzdEluZGV4T2YoXCIvXCIpICsgMSkgKyB0aGlzLnBhdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG9jVXJpT2JqLnF1ZXJ5ID0gdGhpcy5xdWVyeTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucXVlcnkpIHtcclxuICAgICAgICAgICAgZG9jVXJpT2JqLnF1ZXJ5ID0gdGhpcy5xdWVyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jVXJpT2JqLmZyYWdtZW50ID0gdGhpcy5mcmFnbWVudDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRvY1VyaU9iajtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaWYgdGhpcyBVUkkgaGFzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgcHJvdmlkZWQgcmVmZXJlbmNlXHJcbiAgICAgKiBAcGFyYW0ge1VSSXxzdHJpbmd9IG90aGVyXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgVVJJLnByb3RvdHlwZS5oYXNTYW1lT3JpZ2luID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgb3RoZXIgPSBuZXcgVVJJKG90aGVyKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lID09IFwiYmxvYlwiIHx8IHRoaXMuc2NoZW1lID09IFwiZGF0YVwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1lID09IG90aGVyLnNjaGVtZSAmJiB0aGlzLmF1dGhvcml0eSA9PSBvdGhlci5hdXRob3JpdHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbi8vIFJlc3RvcmUgdGhlIFVSSSB0byBpdCdzIHN0cmluZ3kgZ2xvcnkuXHJcbiAgICBVUkkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzdHIgPSBcIlwiO1xyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZSA9PSBcImJsb2JcIikge1xyXG4gICAgICAgICAgICBzdHIgPSBcImJsb2I6XCIgKyB0aGlzLm9wYXF1ZVN0cmluZztcclxuICAgICAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgIHN0ciArPSBcIiNcIiArIHRoaXMuZnJhZ21lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lKSB7XHJcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLnNjaGVtZSArIFwiOlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5hdXRob3JpdHkpIHtcclxuICAgICAgICAgICAgc3RyICs9IFwiLy9cIiArIHRoaXMuYXV0aG9yaXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYXRoKSB7XHJcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLnBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHN0ciArPSBcIj9cIiArIHRoaXMucXVlcnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIHN0ciArPSBcIiNcIiArIHRoaXMuZnJhZ21lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG5cclxuLy8gUmVzdG9yZSB0aGUgVVJJIHRvIGl0J3Mgc3RyaW5neSBnbG9yeSBtaW51cyB0aGUgZnJhZ21lbnRcclxuICAgIFVSSS5wcm90b3R5cGUudG9TdHJpbmdXaXRob3V0RnJhZ21lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lID09IFwiYmxvYlwiKSB7XHJcbiAgICAgICAgICAgIHN0ciA9IFwiYmxvYjpcIiArIHRoaXMub3BhcXVlU3RyaW5nO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zY2hlbWUpIHtcclxuICAgICAgICAgICAgc3RyICs9IHRoaXMuc2NoZW1lICsgXCI6XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmF1dGhvcml0eSkge1xyXG4gICAgICAgICAgICBzdHIgKz0gXCIvL1wiICsgdGhpcy5hdXRob3JpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBhdGgpIHtcclxuICAgICAgICAgICAgc3RyICs9IHRoaXMucGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucXVlcnkpIHtcclxuICAgICAgICAgICAgc3RyICs9IFwiP1wiICsgdGhpcy5xdWVyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyBVUklSZXNvbHZlclxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBVUklSZXNvbHZlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNvbHZlIGEgbG9jYWwgVVJJIHRvIGFuIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xVUkkpfSB1cmkgRWxlbWVudCB0byByZXNvbHZlXHJcbiAgICAgKiBAcGFyYW0ge0RvY3VtZW50PX0gZG9jdW1lbnQgQmFzZSBkb2N1bWVudCB0byB1c2VcclxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSByZXNvbHZlZCBlbGVtZW50IG9yIG51bGwgaWYgaXQgY291bGQgbm90IGJlIHJlc29sdmVkXHJcbiAgICAgKi9cclxuICAgIFVSSVJlc29sdmVyLnJlc29sdmVMb2NhbCA9IGZ1bmN0aW9uICh1cmksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB1cmkgPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHVyaSA9IG5ldyBVUkkodXJpKTtcclxuICAgICAgICBkb2N1bWVudCA9IGRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudDtcclxuXHJcbiAgICAgICAgaWYgKHVyaS5zY2hlbWUgPT0gJ3VybicgfHwgdXJpLnNjaGVtZSA9PSBcImJsb2JcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdXJpLnBhdGggJiYgdXJpLmZyYWdtZW50KSB7IC8vIGxvY2FsIHVyaVxyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodXJpLmZyYWdtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIFVSSVJlc29sdmVyLnJlc29sdmUgPSBmdW5jdGlvbiAodXJpLCBkb2N1bWVudCkge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJZb3UgYXJlIHVzaW5nIGRlcHJlY2F0ZWQgWE1MM0QuVVJJUmVzb2x2ZXIucmVzb2x2ZS4gVXNlIFhNTDNELlVSSVJlc29sdmVyLnJlc29sdmVMb2NhbCBpbnN0ZWFkLlwiKTtcclxuICAgICAgICByZXR1cm4gVVJJUmVzb2x2ZXIucmVzb2x2ZUxvY2FsKHVyaSwgZG9jdW1lbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLlVSSSA9IFVSSTtcclxuICAgIGV4cG9ydHMuVVJJUmVzb2x2ZXIgPSBVUklSZXNvbHZlcjtcclxuXHJcbiAgICB3aW5kb3cuWE1MM0QuVVJJUmVzb2x2ZXIgPSBVUklSZXNvbHZlcjtcclxuXHJcbn0obW9kdWxlLmV4cG9ydHMpKTtcclxuIiwiLy9UT0RPOiBIZWxwZnVsIEFQSSBtZXRob2RzIGNvbmNlcm5pbmcgV2ViQ0wgd2lsbCBiZSBhZGRlZCB3aGVuIG5lZWRlZC4gUGxlYXNlIHByb3ZpZGUgZmVlZGJhY2shXHJcblxyXG4vKipcclxuICogQGZpbGUgV2ViQ0wgQVBJLiBQcm92aWRlcyB1c2VmdWwgbWV0aG9kcyBmb3IgaW5pdGlhbGlzaW5nIGFuZCB1dGlsaXNpbmcgdGhlIFdlYkNMIHBsYXRmb3JtLlxyXG4gKiBAdmVyc2lvbiAwLjJcclxuICogQGF1dGhvciBUb25pIERhaGxcclxuICovXHJcblxyXG4oZnVuY3Rpb24gKG5hbWVzcGFjZSwgdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIHBsYXRmb3JtcyA9IFtdLFxyXG4gICAgICAgIGRldmljZXMgPSBbXSxcclxuICAgICAgICBjdHggPSBudWxsLFxyXG5cclxuICAgICAgICBXZWJDTE5hbWVzcGFjZUF2YWlsYWJsZSA9IGZhbHNlLFxyXG4gICAgICAgIE9wZW5DTERyaXZlcnNBdmFpbGFibGUgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqICAgICBAY29uc3RhbnQge3N0cmluZ30gREVGQVVMVF9ERVZJQ0VcclxuICAgICAqICAgICBAZGVmYXVsdCBcIkNQVVwiXHJcbiAgICAgKi9cclxuICAgIHZhciBERUZBVUxUX0RFVklDRSA9IFwiQ1BVXCIsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqICAgICBAcmVhZG9ubHlcclxuICAgICAgICAgKiAgICAgQG5hbWUgQ0xfRVJST1JfQ09ERVNcclxuICAgICAgICAgKiAgICAgQGVudW0ge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ0xfRVJST1JfQ09ERVMgPSB7XHJcbiAgICAgICAgICAgIFwiU1VDQ0VTU1wiOiAwLFxyXG4gICAgICAgICAgICBcIkRFVklDRV9OT1RfRk9VTkRcIjogLTEsXHJcbiAgICAgICAgICAgIFwiREVWSUNFX05PVF9BVkFJTEFCTEVcIjogLTIsXHJcbiAgICAgICAgICAgIFwiQ09NUElMRVJfTk9UX0FWQUlMQUJMRVwiOiAtMyxcclxuICAgICAgICAgICAgXCJNRU1fT0JKRUNUX0FMTE9DQVRJT05fRkFJTFVSRVwiOiAtNCxcclxuICAgICAgICAgICAgXCJPVVRfT0ZfUkVTT1VSQ0VTXCI6IC01LFxyXG4gICAgICAgICAgICBcIk9VVF9PRl9IT1NUX01FTU9SWVwiOiAtNixcclxuICAgICAgICAgICAgXCJQUk9GSUxJTkdfSU5GT19OT1RfQVZBSUxBQkxFXCI6IC03LFxyXG4gICAgICAgICAgICBcIk1FTV9DT1BZX09WRVJMQVBcIjogLTgsXHJcbiAgICAgICAgICAgIFwiSU1BR0VfRk9STUFUX01JU01BVENIXCI6IC05LFxyXG4gICAgICAgICAgICBcIklNQUdFX0ZPUk1BVF9OT1RfU1VQUE9SVEVEXCI6IC0xMCxcclxuICAgICAgICAgICAgXCJCVUlMRF9QUk9HUkFNX0ZBSUxVUkVcIjogLTExLFxyXG4gICAgICAgICAgICBcIk1BUF9GQUlMVVJFXCI6IC0xMixcclxuICAgICAgICAgICAgXCJJTlZBTElEX1ZBTFVFXCI6IC0zMCxcclxuICAgICAgICAgICAgXCJJTlZBTElEX0RFVklDRV9UWVBFXCI6IC0zMSxcclxuICAgICAgICAgICAgXCJJTlZBTElEX1BMQVRGT1JNXCI6IC0zMixcclxuICAgICAgICAgICAgXCJJTlZBTElEX0RFVklDRVwiOiAtMzMsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9DT05URVhUXCI6IC0zNCxcclxuICAgICAgICAgICAgXCJJTlZBTElEX1FVRVVFX1BST1BFUlRJRVNcIjogLTM1LFxyXG4gICAgICAgICAgICBcIklOVkFMSURfQ09NTUFORF9RVUVVRVwiOiAtMzYsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9IT1NUX1BUUlwiOiAtMzcsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9NRU1fT0JKRUNUXCI6IC0zOCxcclxuICAgICAgICAgICAgXCJJTlZBTElEX0lNQUdFX0ZPUk1BVF9ERVNDUklQVE9SXCI6IC0zOSxcclxuICAgICAgICAgICAgXCJJTlZBTElEX0lNQUdFX1NJWkVcIjogLTQwLFxyXG4gICAgICAgICAgICBcIklOVkFMSURfU0FNUExFUlwiOiAtNDEsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9CSU5BUllcIjogLTQyLFxyXG4gICAgICAgICAgICBcIklOVkFMSURfQlVJTERfT1BUSU9OU1wiOiAtNDMsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9QUk9HUkFNXCI6IC00NCxcclxuICAgICAgICAgICAgXCJJTlZBTElEX1BST0dSQU1fRVhFQ1VUQUJMRVwiOiAtNDUsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9LRVJORUxfTkFNRVwiOiAtNDYsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9LRVJORUxfREVGSU5JVElPTlwiOiAtNDcsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9LRVJORUxcIjogLTQ4LFxyXG4gICAgICAgICAgICBcIklOVkFMSURfQVJHX0lOREVYXCI6IC00OSxcclxuICAgICAgICAgICAgXCJJTlZBTElEX0FSR19WQUxVRVwiOiAtNTAsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9BUkdfU0laRVwiOiAtNTEsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9LRVJORUxfQVJHU1wiOiAtNTIsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9XT1JLX0RJTUVOU0lPTlwiOiAtNTMsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9XT1JLX0dST1VQX1NJWkVcIjogLTU0LFxyXG4gICAgICAgICAgICBcIklOVkFMSURfV09SS19JVEVNX1NJWkVcIjogLTU1LFxyXG4gICAgICAgICAgICBcIklOVkFMSURfR0xPQkFMX09GRlNFVFwiOiAtNTYsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9FVkVOVF9XQUlUX0xJU1RcIjogLTU3LFxyXG4gICAgICAgICAgICBcIklOVkFMSURfRVZFTlRcIjogLTU4LFxyXG4gICAgICAgICAgICBcIklOVkFMSURfT1BFUkFUSU9OXCI6IC01OSxcclxuICAgICAgICAgICAgXCJJTlZBTElEX0dMX09CSkVDVFwiOiAtNjAsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9CVUZGRVJfU0laRVwiOiAtNjEsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9NSVBfTEVWRUxcIjogLTYyLFxyXG4gICAgICAgICAgICBcIklOVkFMSURfR0xPQkFMX1dPUktfU0laRVwiOiAtNjNcclxuICAgICAgICB9O1xyXG4gICAgT2JqZWN0LmZyZWV6ZShDTF9FUlJPUl9DT0RFUyk7XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcclxuICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIENMIGVycm9yIG5hbWUgY29ycmVzcG9uZGluZyB0byBhIENMIGVycm9yIGNvZGVcclxuICAgICAqXHJcbiAgICAgKiBAZnVuY3Rpb24gWE1MM0Qud2ViY2x+Z2V0Q0xFcnJvck5hbWVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlcnJvckNvZGVcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDTEVycm9yTmFtZShlcnJvckNvZGUpIHtcclxuICAgICAgICB2YXIgcHJvcDtcclxuXHJcbiAgICAgICAgaWYgKGlzTnVtYmVyKGVycm9yQ29kZSkpIHtcclxuICAgICAgICAgICAgZm9yIChwcm9wIGluIENMX0VSUk9SX0NPREVTKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQ0xfRVJST1JfQ09ERVNbcHJvcF0gPT09IGVycm9yQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiR290IHVua25vd24gT3BlbkNMIEVycm9yIENvZGU6XCIsIGVycm9yQ29kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gXCJVTktOT1dOX0VSUk9SXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFuIGVycm9yIGNvZGUgZnJvbSBhIENMIGVycm9yIG1lc3NhZ2UgKHRocm93biBieSBOb2tpYSBXZWJDTCBQbHVnaW4pXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVcclxuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfEJvb2xlYW59XHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRFcnJvckNvZGVGcm9tQ0xFcnJvcihlKSB7XHJcbiAgICAgICAgdmFyIGNvZGUgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAoZS5uYW1lICYmIHR5cGVvZiBlLm5hbWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgaWYgKENMX0VSUk9SX0NPREVTW2UubmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDTF9FUlJPUl9DT0RFU1tlLm5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlLm1lc3NhZ2UgJiYgdHlwZW9mIGUubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBjb2RlID0gZS5tZXNzYWdlLm1hdGNoKC8tP1xcZCsvZyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29kZSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoY29kZVtjb2RlLmxlbmd0aCAtIDFdLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgaW5zdGFuY2Ugb2YgV2ViQ0xFcnJvclxyXG4gICAgICpcclxuICAgICAqIEBjb25zdHJ1Y3RvciBYTUwzRC53ZWJjbH5XZWJDTEVycm9yXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWU9XCJXZWJDTEVycm9yXCJdIEVycm9yIG5hbWVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbXNnPVwiR2VuZXJpYyBXZWJDTCBlcnJvci5cIl0gVGhlIGRlc2lyZWQgZXJyb3IgbWVzc2FnZVxyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gV2ViQ0xFcnJvcihuYW1lLCBtc2cpIHtcclxuICAgICAgICBpZiAobmFtZSAmJiB0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIldlYkNMIEFQSTogV2ViQ0xFcnJvcjogRXJyb3IgbmFtZSBub3QgdHlwZSBvZiBTdHJpbmdcIik7XHJcbiAgICAgICAgICAgIG5hbWUgPSBcIlwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1zZyAmJiB0eXBlb2YgbXNnICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiV2ViQ0wgQVBJOiBXZWJDTEVycm9yOiBFcnJvciBtZXNzYWdlIG5vdCB0eXBlIG9mIFN0cmluZ1wiKTtcclxuICAgICAgICAgICAgbXNnID0gXCJcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgXCJXZWJDTEVycm9yXCI7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbXNnIHx8IFwiR2VuZXJpYyBXZWJDTCBlcnJvci5cIjtcclxuICAgICAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcclxuICAgIH1cclxuXHJcbiAgICBXZWJDTEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcclxuICAgIFdlYkNMRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2ViQ0xFcnJvcjtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgV2ViQ0wgbmFtZXNwYWNlIGlzIGF2YWlsYWJsZS4gVGhlIG5hbWVzcGFjZSBjYW4gYmUgcHJvdmlkZWQgYnkgYSBXZWJDTCBwbHVnaW4gb3IgbmF0aXZlIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5oYXNXZWJDTE5hbWVzcGFjZVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBoYXNXZWJDTE5hbWVzcGFjZSgpIHtcclxuICAgICAgICBXZWJDTE5hbWVzcGFjZUF2YWlsYWJsZSA9IHdpbmRvdy53ZWJjbCAmJiB3ZWJjbC5nZXRQbGF0Zm9ybXM7XHJcblxyXG4gICAgICAgIHJldHVybiBXZWJDTE5hbWVzcGFjZUF2YWlsYWJsZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBhIGJhc2ljIFdlYkNMIG1ldGhvZCB0byBzZWUgaWYgdGhlIE9wZW5DTCBkcml2ZXJzIGFyZSB3b3JraW5nIG9uIHVzZXJzIGRldmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAZnVuY3Rpb24gWE1MM0Qud2ViY2x+aGFzT3BlbkNMRHJpdmVyc1xyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBoYXNPcGVuQ0xEcml2ZXJzKCkge1xyXG4gICAgICAgIHZhciBwbGF0QXJyO1xyXG4gICAgICAgIE9wZW5DTERyaXZlcnNBdmFpbGFibGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBwbGF0QXJyID0gd2ViY2wuZ2V0UGxhdGZvcm1zKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBPcGVuQ0xEcml2ZXJzQXZhaWxhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXBsYXRBcnIgfHwgcGxhdEFyci5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgT3BlbkNMRHJpdmVyc0F2YWlsYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIE9wZW5DTERyaXZlcnNBdmFpbGFibGU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tYmluZXMgV2ViQ0wgbmFtZXNwYWNlIGFuZCBkcml2ZXIgdGVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAZnVuY3Rpb24gWE1MM0Qud2ViY2x+aXNBdmFpbGFibGVcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gaXNBdmFpbGFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGhhc1dlYkNMTmFtZXNwYWNlKCkgJiYgaGFzT3BlbkNMRHJpdmVycygpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpc2VzIHRoZSBXZWJDTCBBUEkgd2l0aCBkZWZhdWx0IHZhbHVlcyB1c2luZyBhIHByZWRlZmluZWQgZGV2aWNlIHR5cGUgb3IgYSBkZWZhdWx0IGRldmljZSB0eXBlLlxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5pbml0XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9XCJDUFVcIl0gRGV2aWNlIHR5cGVcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBpbml0KHR5cGUpIHtcclxuICAgICAgICAvLyBDaGVja2luZyBpZiBXZWJDTCBpcyBhdmFpbGFibGUgaW4gdGhlIHVzZXJzIHN5c3RlbVxyXG4gICAgICAgIGlmICghaGFzV2ViQ0xOYW1lc3BhY2UoKSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiV2ViQ0wgQVBJOiBVbmZvcnR1bmF0ZWx5IHlvdXIgc3lzdGVtIGRvZXMgbm90IHN1cHBvcnQgV2ViQ0wuIFwiICtcclxuICAgICAgICAgICAgICAgIFwiV2ViQ0wgbmFtZXNwYWNlIGlzIG5vdCBhdmFpbGFibGUuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWhhc09wZW5DTERyaXZlcnMoKSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiV2ViQ0wgQVBJOiBVbmZvcnR1bmF0ZWx5IHlvdXIgc3lzdGVtIGRvZXMgbm90IHN1cHBvcnQgV2ViQ0wuIFwiICtcclxuICAgICAgICAgICAgICAgIFwiT3BlbkNMIGRyaXZlcnMgYXJlIG5vdCB3b3JraW5nIHByb3Blcmx5LlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2V0UGxhdGZvcm1zKCk7XHJcblxyXG4gICAgICAgIGRldmljZXMgPSBnZXREZXZpY2VzQnlUeXBlKHR5cGUgfHwgREVGQVVMVF9ERVZJQ0UpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGluZyBkZWZhdWx0IGNvbnRleHRcclxuICAgICAgICBjdHggPSBjcmVhdGVDb250ZXh0KGRldmljZXMpO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYWxsIGF2YWlsYWJsZSBXZWJDTCBkZXZpY2UgcGxhdGZvcm1zLlxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5nZXRQbGF0Zm9ybXNcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFBsYXRmb3JtcygpIHtcclxuICAgICAgICBpZihwbGF0Zm9ybXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHBsYXRmb3JtcyA9IHdlYmNsLmdldFBsYXRmb3JtcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYWxsIGRldmljZXMgb2YgYSBjaG9zZW4gdHlwZSBmcm9tIGEgc2VsZWN0ZWQgcGxhdGZvcm0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlPVwiQ1BVXCJdIERldmljZSB0eXBlXHJcbiAgICAgKiBAcGFyYW0ge0lXZWJDTFBsYXRmb3JtfSBwbGF0Zm9ybVxyXG4gICAgICogQHJldHVybnMge0FycmF5fEJvb2xlYW59XHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRQbGF0Zm9ybURldmljZXNCeVR5cGUodHlwZSwgcGxhdGZvcm0pIHtcclxuICAgICAgICB2YXIgZGV2aWNlQXJyID0gW10sIGVyckNvZGU7XHJcblxyXG4gICAgICAgIGlmICghcGxhdGZvcm0pIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGdldFBsYXRmb3JtRGV2aWNlc0J5VHlwZSgpOiBwbGF0Zm9ybSB3YXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0eXBlID0gdHlwZSB8fCBERUZBVUxUX0RFVklDRTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiQ1BVXCIpIHtcclxuICAgICAgICAgICAgICAgIGRldmljZUFyciA9IHBsYXRmb3JtLmdldERldmljZXMod2ViY2wuREVWSUNFX1RZUEVfQ1BVKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIkdQVVwiKSB7XHJcbiAgICAgICAgICAgICAgICBkZXZpY2VBcnIgPSBwbGF0Zm9ybS5nZXREZXZpY2VzKHdlYmNsLkRFVklDRV9UWVBFX0dQVSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJBTExcIikge1xyXG4gICAgICAgICAgICAgICAgZGV2aWNlQXJyID0gcGxhdGZvcm0uZ2V0RGV2aWNlcyh3ZWJjbC5ERVZJQ0VfVFlQRV9BTEwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZXJyQ29kZSA9IGdldEVycm9yQ29kZUZyb21DTEVycm9yKGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFlcnJDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVyckNvZGUgIT09IENMX0VSUk9SX0NPREVTLkRFVklDRV9OT1RfRk9VTkQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXZWJDTEVycm9yKGdldENMRXJyb3JOYW1lKGVyckNvZGUpLCBcIkNvdWxkIG5vdCBnZXQgZGV2aWNlcy5cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkZXZpY2VBcnI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCBkZXZpY2VzIG9mIGEgc2VsZWN0ZWQgdHlwZSBmcm9tIGFsbCBhdmFpbGFibGUgcGxhdGZvcm1zLlxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5nZXREZXZpY2VzQnlUeXBlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBEZXZpY2UgdHlwZVxyXG4gICAgICogQHJldHVybnMge0FycmF5fEJvb2xlYW59XHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBnZXREZXZpY2VzQnlUeXBlKHR5cGUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0QXJyID0gW10sIGRldmljZUFyciwgaTtcclxuXHJcbiAgICAgICAgZ2V0UGxhdGZvcm1zKCk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IHBsYXRmb3Jtcy5sZW5ndGg7IGktLTspIHtcclxuICAgICAgICAgICAgZGV2aWNlQXJyID0gZ2V0UGxhdGZvcm1EZXZpY2VzQnlUeXBlKHR5cGUsIHBsYXRmb3Jtc1tpXSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGV2aWNlQXJyKSB7XHJcbiAgICAgICAgICAgICAgICBkZXZpY2VBcnIuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEFyci5wdXNoKHYpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdEFyci5sZW5ndGggPT09IDAgPyBmYWxzZSA6IHJlc3VsdEFycjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwbGF0Zm9ybSBvbiB3aGVyZSB0aGUgZGV2aWNlIGlzLlxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5nZXREZXZpY2VQbGF0Zm9ybVxyXG4gICAgICogQHBhcmFtIHtJV2ViQ0xEZXZpY2V9IGRldmljZVxyXG4gICAgICogQHJldHVybnMge0lXZWJDTFBsYXRmb3JtfEJvb2xlYW59XHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBnZXREZXZpY2VQbGF0Zm9ybShkZXZpY2UpIHtcclxuICAgICAgICB2YXIgcGxhdGZvcm07XHJcblxyXG4gICAgICAgIGlmICghZGV2aWNlKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBnZXREZXZpY2VQbGF0Zm9ybSgpOiBkZXZpY2Ugd2FzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcGxhdGZvcm0gPSBkZXZpY2UuZ2V0SW5mbyh3ZWJjbC5ERVZJQ0VfUExBVEZPUk0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdmFyIGVyckNvZGUgPSBnZXRFcnJvckNvZGVGcm9tQ0xFcnJvcihlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZXJyQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNMRXJyb3IoZ2V0Q0xFcnJvck5hbWUoZXJyQ29kZSksIFwiQ291bGQgbm90IGdldCB0aGUgcGxhdGZvcm0gb2YgdGhlIGRldmljZS5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGxhdGZvcm07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNsQ3R4XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldENvbnRleHREZXZpY2VzKGNsQ3R4KSB7XHJcbiAgICAgICAgdmFyIGRldmljZUFyciA9IFtdLCBlcnJDb2RlO1xyXG5cclxuICAgICAgICBpZighY2xDdHgpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGdldENvbnRleHREZXZpY2VzKCk6IGNsQ3R4IHdhcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGRldmljZUFyciA9IGNsQ3R4LmdldEluZm8od2ViY2wuQ09OVEVYVF9ERVZJQ0VTKTtcclxuICAgICAgICB9Y2F0Y2goZSkge1xyXG4gICAgICAgICAgICBlcnJDb2RlID0gZ2V0RXJyb3JDb2RlRnJvbUNMRXJyb3IoZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWVyckNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ0xFcnJvcihnZXRDTEVycm9yTmFtZShlcnJDb2RlKSwgXCJDb3VsZCBub3QgZ2V0IGRldmljZXMuXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRldmljZUFyci5sZW5ndGggPT09IDAgPyBmYWxzZSA6IGRldmljZUFycjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBXZWJDTCBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmNyZWF0ZUNvbnRleHRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcGVydGllc11cclxuICAgICAqIEByZXR1cm5zIHtJV2ViQ0xDb250ZXh0fVxyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29udGV4dChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgIC8qXHJcbiAgICAgICAgdmFyIHByb3BzID0ge1xyXG4gICAgICAgICAgICBkZXZpY2VzOiBnZXREZXZpY2VzQnlUeXBlKERFRkFVTFRfREVWSUNFKVxyXG4gICAgICAgICAgICB9LCBjb250ZXh0O1xyXG5cclxuICAgICAgICBYTUwzRC5leHRlbmQocHJvcHMsIHByb3BlcnRpZXMpOyovXHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gd2ViY2wuY3JlYXRlQ29udGV4dChwcm9wZXJ0aWVzKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJDb2RlID0gZ2V0RXJyb3JDb2RlRnJvbUNMRXJyb3IoZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWVyckNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNMRXJyb3IoZ2V0Q0xFcnJvck5hbWUoZXJyQ29kZSksIFwiRmFpbGVkIHRvIGNyZWF0ZSBhIFdlYkNMIGNvbnRleHQuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IFdlYkNMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmdldERlZmF1bHRDb250ZXh0XHJcbiAgICAgKiBAcmV0dXJucyB7SVdlYkNMQ29udGV4dH1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldERlZmF1bHRDb250ZXh0KCkge1xyXG4gICAgICAgIHJldHVybiBjdHg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIFdlYkNMIHByb2dyYW0gZnJvbSBhIHN0cmluZyBvZiBXZWJDTCBjb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5jcmVhdGVQcm9ncmFtXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZVN0clxyXG4gICAgICogQHBhcmFtIHtJV2ViQ0xDb250ZXh0fSBjbEN0eFxyXG4gICAgICogQHJldHVybnMge0lXZWJDTFByb2dyYW0gfCBCb29sZWFufVxyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShjb2RlU3RyLCBjbEN0eCkge1xyXG4gICAgICAgIHZhciBwcm9ncmFtO1xyXG5cclxuICAgICAgICBjbEN0eCA9IGNsQ3R4IHx8IGN0eDtcclxuXHJcbiAgICAgICAgaWYgKCFjb2RlU3RyKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBjcmVhdGVQcm9ncmFtKCk6IGNvZGVTdHIgd2FzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjbEN0eCkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIldlYkNMIEFQSTogY3JlYXRlUHJvZ3JhbSgpOiBjbEN0eCB3YXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBwcm9ncmFtID0gY2xDdHguY3JlYXRlUHJvZ3JhbShjb2RlU3RyKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJDb2RlID0gZ2V0RXJyb3JDb2RlRnJvbUNMRXJyb3IoZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWVyckNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXZWJDTEVycm9yKGdldENMRXJyb3JOYW1lKGVyckNvZGUpLCBcIkZhaWxlZCB0byBjcmVhdGUgYSBXZWJDTCBwcm9ncmFtLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGRzIGEgV2ViQ0wgcHJvZ3JhbS5cclxuICAgICAqXHJcbiAgICAgKiBAZnVuY3Rpb24gWE1MM0Qud2ViY2x+YnVpbGRQcm9ncmFtXHJcbiAgICAgKiBAcGFyYW0ge0lXZWJDTFByb2dyYW19IHByb2dyYW1cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRldmljZUFyclxyXG4gICAgICogQHJldHVybnMge0lXZWJDTFByb2dyYW18Qm9vbGVhbn1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGJ1aWxkUHJvZ3JhbShwcm9ncmFtLCBkZXZpY2VBcnIpIHtcclxuICAgICAgICBkZXZpY2VBcnIgPSBkZXZpY2VBcnIgfHwgZGV2aWNlcztcclxuXHJcbiAgICAgICAgaWYgKCFwcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBidWlsZFByb2dyYW0oKTogcHJvZ3JhbSB3YXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBwcm9ncmFtLmJ1aWxkKGRldmljZUFyciwgXCJcIik7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB2YXIgZXJyQ29kZSA9IGdldEVycm9yQ29kZUZyb21DTEVycm9yKGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFlcnJDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXZWJDTEVycm9yKGdldENMRXJyb3JOYW1lKGVyckNvZGUpLFxyXG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5nZXRCdWlsZEluZm8oZGV2aWNlQXJyWzBdLCBXZWJDTC5QUk9HUkFNX0JVSUxEX0xPRykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgV2ViQ0wgS2VybmVsIHVzaW5nIGEgZGVmaW5lZCBwcm9ncmFtLlxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5jcmVhdGVLZXJuZWxcclxuICAgICAqIEBwYXJhbSB7SVdlYkNMUHJvZ3JhbX0gcHJvZ3JhbVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAqIEByZXR1cm5zIHtJV2ViQ0xLZXJuZWx8Qm9vbGVhbn1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUtlcm5lbChwcm9ncmFtLCBuYW1lKSB7XHJcbiAgICAgICAgdmFyIGtlcm5lbDtcclxuXHJcbiAgICAgICAgaWYgKCFwcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBjcmVhdGVLZXJuZWwoKTogcHJvZ3JhbSB3YXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIW5hbWUpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGNyZWF0ZUtlcm5lbCgpOiBuYW1lIHdhcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGtlcm5lbCA9IHByb2dyYW0uY3JlYXRlS2VybmVsKG5hbWUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdmFyIGVyckNvZGUgPSBnZXRFcnJvckNvZGVGcm9tQ0xFcnJvcihlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZXJyQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ0xFcnJvcihnZXRDTEVycm9yTmFtZShlcnJDb2RlKSwgXCJGYWlsZWQgdG8gY3JlYXRlIGEgV2ViQ0wga2VybmVsLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBrZXJuZWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgV2ViQ0wgQ29tbWFuZCBRdWV1ZSBmb3IgcXVldWVpbmcga2VybmVscyBmb3IgZXhlY3V0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5jcmVhdGVDb21tYW5kUXVldWVcclxuICAgICAqIEBwYXJhbSB7SVdlYkNMRGV2aWNlfSBkZXZpY2VcclxuICAgICAqIEBwYXJhbSB7SVdlYkNMQ29udGV4dH0gY2xDdHhcclxuICAgICAqIEByZXR1cm5zIHtJV2ViQ0xDb21tYW5kUXVldWV8Qm9vbGVhbn1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbW1hbmRRdWV1ZShkZXZpY2UsIGNsQ3R4KSB7XHJcbiAgICAgICAgdmFyIGNtZFF1ZXVlO1xyXG5cclxuICAgICAgICBjbEN0eCA9IGNsQ3R4IHx8IGN0eDtcclxuXHJcbiAgICAgICAgaWYoIWNsQ3R4KSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBjcmVhdGVDb21tYW5kUXVldWU6IGNsQ3R4IHdhcyBub3QgZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY21kUXVldWUgPSBjbEN0eC5jcmVhdGVDb21tYW5kUXVldWUoZGV2aWNlIHx8IGRldmljZXNbMF0sIDApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdmFyIGVyckNvZGUgPSBnZXRFcnJvckNvZGVGcm9tQ0xFcnJvcihlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZXJyQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ0xFcnJvcihnZXRDTEVycm9yTmFtZShnZXRFcnJvckNvZGVGcm9tQ0xFcnJvcihlKSksIFwiQ291bGQgbm90IGNyZWF0ZSBDb21tYW5kUXVldWUuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNtZFF1ZXVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnB1dC9vdXRwdXQgYnVmZmVyIHRvIGJlIHVzZWQgd2l0aCBhIFdlYkNMIGtlcm5lbFxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5jcmVhdGVCdWZmZXJcclxuICAgICAqIEBwYXJhbSB7aW50fSBzaXplXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxyXG4gICAgICogQHBhcmFtIHtJV2ViQ0xDb250ZXh0fSBjbEN0eFxyXG4gICAgICogQHJldHVybnMge0lXZWJDTE1lbW9yeU9iamVjdHxCb29sZWFufVxyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyKHNpemUsIHR5cGUsIGNsQ3R4KSB7XHJcbiAgICAgICAgY2xDdHggPSBjbEN0eCB8fCBjdHg7XHJcblxyXG4gICAgICAgIGlmICghc2l6ZSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIldlYkNMIEFQSTogY3JlYXRlQnVmZmVyKCk6IEJ1ZmZlciBzaXplIHdhcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9ZWxzZSBpZiAoIWlzTnVtYmVyKHNpemUpIHx8IHNpemUgPCAwKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBjcmVhdGVCdWZmZXIoKTogQnVmZmVyIHNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlci5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIldlYkNMIEFQSTogY3JlYXRlQnVmZmVyKCk6IEJ1ZmZlciB0eXBlIHdhcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCFjbEN0eCkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIldlYkNMIEFQSTogY3JlYXRlQnVmZmVyKCk6IGNsQ3R4IHdhcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInJcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsQ3R4LmNyZWF0ZUJ1ZmZlcih3ZWJjbC5NRU1fUkVBRF9PTkxZLCBzaXplKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIndcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsQ3R4LmNyZWF0ZUJ1ZmZlcih3ZWJjbC5NRU1fV1JJVEVfT05MWSwgc2l6ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyd1wiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xDdHguY3JlYXRlQnVmZmVyKHdlYmNsLk1FTV9SRUFEX1dSSVRFLCBzaXplKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBjcmVhdGVCdWZmZXIoKTogVW5rbm93biBidWZmZXIgdHlwZTpcIiwgdHlwZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJDb2RlID0gZ2V0RXJyb3JDb2RlRnJvbUNMRXJyb3IoZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWVyckNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNMRXJyb3IoZ2V0Q0xFcnJvck5hbWUoZXJyQ29kZSksIFwiQ291bGQgbm90IGNyZWF0ZSBhIFdlYkNMIGJ1ZmZlci5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBLZXJuZWxNYW5hZ2VyLlxyXG4gICAgICpcclxuICAgICAqIEBuYW1lIEtlcm5lbE1hbmFnZXJcclxuICAgICAqIEBjb25zdHJ1Y3RvciBYTUwzRC53ZWJjbH5LZXJuZWxNYW5hZ2VyXHJcbiAgICAgKi9cclxuXHJcbiAgICB2YXIgS2VybmVsTWFuYWdlciA9IGZ1bmN0aW9uIChjbEN0eCwgZGV2aWNlQXJyKSB7XHJcbiAgICAgICAgdmFyIGtlcm5lbHMgPSB7fTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGFuZCBidWlsZHMgYSBXZWJDTCBwcm9ncmFtIGZyb20gYSBjb2RlIHN0cmluZyBhbmQgY3JlYXRlcyBhIFdlYkNMIGtlcm5lbCBmcm9tIHRoZSBwcm9ncmFtLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gS2VybmVsTWFuYWdlcn5yZWdpc3RlclxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZVN0clxyXG4gICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAobmFtZSwgY29kZVN0cikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtlcm5lbHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiV2ViQ0wgQVBJOiBrZXJuZWxzLnJlZ2lzdGVyKCk6IEtlcm5lbCB3aXRoIGEgc2FtZSBuYW1lIGlzIGFscmVhZHkgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBrZXJuZWxzLnJlZ2lzdGVyKCk6IEtlcm5lbCBuYW1lIHdhcyBub3QgZGVmaW5lZCBvciB3YXMgbm90IHR5cGUgb2YgU3RyaW5nLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2RlU3RyICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGtlcm5lbHMucmVnaXN0ZXIoKTogS2VybmVsIGNvZGUgd2FzIG5vdCBkZWZpbmVkIG9yIHdhcyBub3QgdHlwZSBvZiBTdHJpbmcuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3JhbSwga2VybmVsO1xyXG5cclxuICAgICAgICAgICAgICAgIHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKGNvZGVTdHIsIGNsQ3R4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBidWlsZFByb2dyYW0ocHJvZ3JhbSwgZGV2aWNlQXJyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocHJvZ3JhbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtlcm5lbCA9IGNyZWF0ZUtlcm5lbChwcm9ncmFtLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoa2VybmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2VybmVsc1tuYW1lXSA9IGtlcm5lbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZWFsbG9jYXRlcyBhbmQgdW5yZWdpc3RlcnMgYSBrZXJuZWwuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBLZXJuZWxNYW5hZ2VyfnVuUmVnaXN0ZXJcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICB1blJlZ2lzdGVyOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtlcm5lbHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXJuZWxzW25hbWVdLnJlbGVhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJDb2RlID0gZ2V0RXJyb3JDb2RlRnJvbUNMRXJyb3IoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVyckNvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXZWJDTEVycm9yKGdldENMRXJyb3JOYW1lKGVyckNvZGUpLCBcIkNvdWxkIG5vdCByZWxlYXNlIGtlcm5lbCByZXNvdXJjZXMuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUga2VybmVsc1tuYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgYSBrZXJuZWwgb2YgYSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIEtlcm5lbE1hbmFnZXJ+Z2V0S2VybmVsXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtJV2ViQ0xLZXJuZWwgfCBCb29sZWFufVxyXG4gICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIGdldEtlcm5lbDogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoa2VybmVscy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXJuZWxzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIGFyZ3VtZW50cyBvZiBhIHNwZWNpZmllZCBrZXJuZWwuXHJcbiAgICAgICAgICAgICAqIFRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGlzIGZ1bmN0aW9uIGlzIGEgcmVnaXN0ZXJlZCBrZXJuZWwgbmFtZSwgb3RoZXIgYXJndW1lbnRzIGFyZSB0aGUga2VybmVsIGFyZ3VtZW50cyByZXNwZWN0aXZlbHkuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBLZXJuZWxNYW5hZ2VyfnNldEFyZ3NcclxuICAgICAgICAgICAgICogQHBhcmFtIHtJV2ViQ0xLZXJuZWx9IGtlcm5lbCBXZWJDTCBrZXJuZWxcclxuICAgICAgICAgICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEtlcm5lbCBhcmd1bWVudHMgaW4gdGhlIHNhbWUgb3JkZXIgYXMgZGVmaW5lZCBpbiB0aGUga2VybmVsIGNvZGVcclxuICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgc2V0QXJnczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGtlcm5lbCwgaW5wdXRBcmdzLCBuS2VybmVsQXJncywgaTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIldlYkNMIEFQSTogc2V0QXJncygpOiBObyBrZXJuZWwgYXJndW1lbnRzIHdlcmUgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGtlcm5lbCA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICBpbnB1dEFyZ3MgPSBhcmdzLnNsaWNlKDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgha2VybmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIldlYkNMIEFQSTogc2V0QXJncygpOiBXZWJDTCBrZXJuZWwgd2FzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbktlcm5lbEFyZ3MgPSBrZXJuZWwuZ2V0SW5mbyh3ZWJjbC5LRVJORUxfTlVNX0FSR1MpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dEFyZ3MubGVuZ3RoID4gbktlcm5lbEFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiV2ViQ0w6IHNldEFyZ3M6IElucHV0IGFyZ3MgYW1vdW50ID4ga2VybmVsIHByb2dyYW0gYXJncyBhbW91bnQhIElnbm9yaW5nIGV4dHJhIGFyZ3VtZW50cy5cIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0QXJncy5sZW5ndGggPCBuS2VybmVsQXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0w6IHNldEFyZ3M6IE5vdCBlbm91Z2ggYXJndW1lbnRzIHdlcmUgZ2l2ZW4gdG8gV2ViQ0wga2VybmVsLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJBcmdzIGZvciBrZXJuZWw6XCIsIGtlcm5lbC5nZXRJbmZvKHdlYmNsLktFUk5FTF9GVU5DVElPTl9OQU1FKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaSA9IG5LZXJuZWxBcmdzO1xyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIkFyZzpcIiwgaSwgaW5wdXRBcmdzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2VybmVsLnNldEFyZyhpLCBpbnB1dEFyZ3NbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyQ29kZSA9IGdldEVycm9yQ29kZUZyb21DTEVycm9yKGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVyckNvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNMRXJyb3IoZ2V0Q0xFcnJvck5hbWUoZXJyQ29kZSksIFwiQ291bGQgbm90IHNldCBrZXJuZWwgYXJndW1lbnRzLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBXZWJDTCBpcyBhdmFpbGFibGUgYW5kIGF0dGFjaGVzIGEgY29udGV4dCB0byB0aGUgZ2l2ZW4gb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gd2ViY2xPYmplY3QgdGhlIG9iamVjdCB0aGF0IHRoZSBjb250ZXh0IHdpbGwgYmUgYXR0YWNoZWQgdG9cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpbml0V2ViQ0xQbGF0Zm9ybSh3ZWJjbE9iamVjdCkge1xyXG4gICAgICAgIGlmICghaXNBdmFpbGFibGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY2xQbGF0Zm9ybXMgPSBnZXRQbGF0Zm9ybXMoKTtcclxuICAgICAgICBpZiAoIWNsUGxhdGZvcm1zIHx8IGNsUGxhdGZvcm1zLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFRyeWluZyBpbml0aWFsbHkgdG8gdXNlIEdQVSAoZm9yIHRoZSBiZXN0IHBlcmZvcm1hbmNlKS4gVXNpbmcgQ1BVIGFzIGEgZmFsbGJhY2suXHJcbiAgICAgICAgICAgIHZhciBjbERldmljZXMgPSBnZXREZXZpY2VzQnlUeXBlKFwiR1BVXCIpIHx8IGdldERldmljZXNCeVR5cGUoXCJDUFVcIik7XHJcbiAgICAgICAgICAgIGlmICghY2xEZXZpY2VzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNsQ3R4ID0gY3JlYXRlQ29udGV4dChjbERldmljZXMpO1xyXG4gICAgICAgICAgICB2YXIgY21kUXVldWUgPSBjcmVhdGVDb21tYW5kUXVldWUoY2xEZXZpY2VzWzBdLCBjbEN0eCk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogIFRPRE86IE1heWJlIHdlIHNob3VsZCBqdXN0IHN0b3JlIHRoZSBjbC1wbGF0Zm9ybSBvYmplY3RzIGluIEMuY2wgc28gdGhleSBhcmUgbW9yZSBlYXNpbHkgYXZhaWxhYmxlIGFuZFxyXG4gICAgICAgICAgICAgKiAgdG8gYXZvaWQgbG9uZyBwcm90b3R5cGUgY2hhaW5zLiBPciB3ZSBjb3VsZCBwYXNzIHRoZSBncmFwaCBjb250ZXh0IHRvIGVhY2ggbm9kZSBvZiB0aGUgZ3JhcGguXHJcbiAgICAgICAgICAgICAqICBIb3dldmVyLCBpdCB3b3VsZCBiZSBnb29kIHRvIGFsbG93IGVhY2ggR3JhcGggb2JqZWN0IHRvIGhhdmUgYXQgbGVhc3Qgb3duIGNvbnRleHQsIGNtZFF1ZXVlIGFuZCBrZXJuZWxNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgd2ViY2xPYmplY3QuY2wgPSB7XHJcbiAgICAgICAgICAgICAgICBBUEk6IHdlYmNsLFxyXG4gICAgICAgICAgICAgICAga2VybmVsTWFuYWdlcjogbmV3IEtlcm5lbE1hbmFnZXIoY2xDdHgsIGNsRGV2aWNlcyksXHJcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybXM6IGNsUGxhdGZvcm1zLFxyXG4gICAgICAgICAgICAgICAgZGV2aWNlczogY2xEZXZpY2VzLFxyXG4gICAgICAgICAgICAgICAgY3R4OiBjbEN0eCxcclxuICAgICAgICAgICAgICAgIGNtZFF1ZXVlOiBjbWRRdWV1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIlN1Y2Nlc3NmdWxseSBpbml0aWFsaXplZCBXZWJDTCBwbGF0Zm9ybS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFQSVxyXG4gICAgICpcclxuICAgICAqIEBuYW1lc3BhY2Ugd2ViY2xcclxuICAgICAqIEBtZW1iZXJPZiBYTUwzRFxyXG4gICAgICovXHJcblxyXG4gICAgbmFtZXNwYWNlWyd3ZWJjbCddID0ge1xyXG4gICAgICAgIFwiaW5pdFwiOiBpbml0LFxyXG4gICAgICAgIFwiY3JlYXRlQ29udGV4dFwiOiBjcmVhdGVDb250ZXh0LFxyXG4gICAgICAgIFwiY3JlYXRlUHJvZ3JhbVwiOiBjcmVhdGVQcm9ncmFtLFxyXG4gICAgICAgIFwiYnVpbGRQcm9ncmFtXCI6IGJ1aWxkUHJvZ3JhbSxcclxuICAgICAgICBcImNyZWF0ZUtlcm5lbFwiOiBjcmVhdGVLZXJuZWwsXHJcbiAgICAgICAgXCJjcmVhdGVDb21tYW5kUXVldWVcIjogY3JlYXRlQ29tbWFuZFF1ZXVlLFxyXG4gICAgICAgIFwiY3JlYXRlQnVmZmVyXCI6IGNyZWF0ZUJ1ZmZlcixcclxuICAgICAgICBcImdldERlZmF1bHRDb250ZXh0XCI6IGdldERlZmF1bHRDb250ZXh0LFxyXG4gICAgICAgIFwiZ2V0UGxhdGZvcm1zXCI6IGdldFBsYXRmb3JtcyxcclxuICAgICAgICBcImdldERldmljZXNCeVR5cGVcIjogZ2V0RGV2aWNlc0J5VHlwZSxcclxuICAgICAgICBcImdldENvbnRleHREZXZpY2VzXCI6IGdldENvbnRleHREZXZpY2VzLFxyXG4gICAgICAgIFwiZ2V0RGV2aWNlUGxhdGZvcm1cIjogZ2V0RGV2aWNlUGxhdGZvcm0sXHJcblxyXG4gICAgICAgIC8qKiBAbmFtZSBYTUwzRC53ZWJjbH5rZXJuZWxzICovXHJcbiAgICAgICAgXCJrZXJuZWxzXCI6IG5ldyBLZXJuZWxNYW5hZ2VyKCksXHJcbiAgICAgICAgXCJLZXJuZWxNYW5hZ2VyXCI6IEtlcm5lbE1hbmFnZXIsXHJcblxyXG4gICAgICAgIFwiaGFzV2ViQ0xOYW1lc3BhY2VcIjogaGFzV2ViQ0xOYW1lc3BhY2UsXHJcbiAgICAgICAgXCJoYXNPcGVuQ0xEcml2ZXJzXCI6IGhhc09wZW5DTERyaXZlcnMsXHJcbiAgICAgICAgXCJpc0F2YWlsYWJsZVwiOiBpc0F2YWlsYWJsZSxcclxuICAgICAgICBcIldlYkNMRXJyb3JcIjogV2ViQ0xFcnJvcixcclxuICAgICAgICBcImdldENMRXJyb3JOYW1lXCI6IGdldENMRXJyb3JOYW1lXHJcbiAgICB9O1xyXG5cclxuICAgIGluaXRXZWJDTFBsYXRmb3JtKG5hbWVzcGFjZS53ZWJjbCk7XHJcbiAgICB3aW5kb3cuWE1MM0Qud2ViY2wgPSBuYW1lc3BhY2Uud2ViY2w7XHJcblxyXG59KG1vZHVsZS5leHBvcnRzKSk7XHJcbiIsIi8vIEVycm9yIENhbGxiYWNrczpcclxudmFyIGNfZXJyb3JDYWxsYmFja3MgPSBbXTtcclxuXHJcbnZhciBjX2xpc3RlZENhbGxiYWNrcyA9IFtdO1xyXG52YXIgY19saXN0ZWRDYWxsYmFja3NEYXRhID0gW107XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICByZWdpc3RlckVycm9yQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIGNfZXJyb3JDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9LFxyXG5cclxuICAgIG5vdGlmeUVycm9yOiBmdW5jdGlvbiAobWVzc2FnZSwgbm9kZSkge1xyXG4gICAgICAgIGlmIChjX2Vycm9yQ2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjX2Vycm9yQ2FsbGJhY2tzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBjX2Vycm9yQ2FsbGJhY2tzW2ldKG1lc3NhZ2UsIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogRG8gRGVmYXVsdCBlcnJvciBwcmludGluZ1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGN0b3IgQ29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgUGFyZW50IGNsYXNzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IG1ldGhvZHMgTWV0aG9kcyB0byBhZGQgdG8gdGhlIGNsYXNzXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBjcmVhdGVDbGFzczogZnVuY3Rpb24gKGN0b3IsIHBhcmVudCwgbWV0aG9kcykge1xyXG4gICAgICAgIG1ldGhvZHMgPSBtZXRob2RzIHx8IHt9O1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgLyoqIEBjb25zdHJ1Y3RvciAqL1xyXG4gICAgICAgICAgICB2YXIgRiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xyXG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBGKCk7XHJcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcclxuICAgICAgICAgICAgY3Rvci5zdXBlcmNsYXNzID0gcGFyZW50LnByb3RvdHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgbSBpbiBtZXRob2RzKSB7XHJcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlW21dID0gbWV0aG9kc1ttXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN0b3I7XHJcbiAgICB9LFxyXG5cclxuICAgIGV4dGVuZDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcclxuICAgICAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsdXN0ZXIgaW50ZXJuYWwgbm90aWZpY2F0aW9ucyB0byBhdm9pZCBtdWx0aXBsZSBub3RpZmljYXRpb25zXHJcbiAgICAgKiBvZiBzYW1lIHR5cGUuIE1haW5seSBmb3IgUmVxdWVzdHMgYW5kIFJlc3VsdHNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdE9yUmVzdWx0IFJlcXVlc3Qgb3IgUmVzdWx0XHJcbiAgICAgKiBAcGFyYW0ge1JFU1VMVF9TVEFURX0gcmVzdWx0U3RhdGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9xdWV1ZVJlc3VsdENhbGxiYWNrOiBmdW5jdGlvbiAocmVxdWVzdE9yUmVzdWx0LCByZXN1bHRTdGF0ZSkge1xyXG4gICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICBpZiAoKCBpbmRleCA9IGNfbGlzdGVkQ2FsbGJhY2tzLmluZGV4T2YocmVxdWVzdE9yUmVzdWx0KSkgPT0gLTEpIHtcclxuICAgICAgICAgICAgaW5kZXggPSBjX2xpc3RlZENhbGxiYWNrcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNfbGlzdGVkQ2FsbGJhY2tzLnB1c2gocmVxdWVzdE9yUmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByZXZEYXRhID0gY19saXN0ZWRDYWxsYmFja3NEYXRhW2luZGV4XTtcclxuXHJcbiAgICAgICAgaWYgKCFwcmV2RGF0YSB8fCBwcmV2RGF0YSA8IHJlc3VsdFN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNfbGlzdGVkQ2FsbGJhY2tzRGF0YVtpbmRleF0gPSByZXN1bHRTdGF0ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9mbHVzaFJlc3VsdENhbGxiYWNrczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChjX2xpc3RlZENhbGxiYWNrcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjX2xpc3RlZENhbGxiYWNrcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY19saXN0ZWRDYWxsYmFja3NbaV0uX29uUG9zdHBvbmVkUmVzdWx0Q2hhbmdlZChjX2xpc3RlZENhbGxiYWNrc0RhdGFbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNfbGlzdGVkQ2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgICAgIGNfbGlzdGVkQ2FsbGJhY2tzRGF0YSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwidmFyIEMgPSB7fTtcclxuXHJcbkMuRVBTSUxPTiA9IDAuMDAwMDAxO1xyXG5cclxuLyoqXHJcbiAqIFR5cGUgb2YgRGF0YUVudHJ5XHJcbiAqIEBlbnVtXHJcbiAqL1xyXG5DLkRBVEFfVFlQRSA9IHtcclxuICAgIFVOS05PV046IDAsXHJcbiAgICBGTE9BVDogMSxcclxuICAgIEZMT0FUMjogMixcclxuICAgIEZMT0FUMzogMyxcclxuICAgIEZMT0FUNDogNCxcclxuICAgIEZMT0FUM1gzOiA1LFxyXG4gICAgRkxPQVQ0WDQ6IDEwLFxyXG4gICAgSU5UOiAyMCxcclxuICAgIElOVDQ6IDIxLFxyXG4gICAgQk9PTDogMzAsXHJcbiAgICBURVhUVVJFOiA0MCxcclxuICAgIEJZVEU6IDUwLFxyXG4gICAgVUJZVEU6IDYwLFxyXG4gICAgZnJvbVN0cmluZzogZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci50b1VwcGVyQ2FzZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzW3N0ci50b1VwcGVyQ2FzZSgpXTtcclxuICAgIH1cclxufTtcclxuXHJcbkMuREFUQV9UWVBFX01BUCA9IHtcclxuICAgICdmbG9hdCc6IEMuREFUQV9UWVBFLkZMT0FULFxyXG4gICAgJ2Zsb2F0Mic6IEMuREFUQV9UWVBFLkZMT0FUMixcclxuICAgICdmbG9hdDMnOiBDLkRBVEFfVFlQRS5GTE9BVDMsXHJcbiAgICAnZmxvYXQ0JzogQy5EQVRBX1RZUEUuRkxPQVQ0LFxyXG4gICAgJ2Zsb2F0M3gzJzogQy5EQVRBX1RZUEUuRkxPQVQzWDMsXHJcbiAgICAnZmxvYXQ0eDQnOiBDLkRBVEFfVFlQRS5GTE9BVDRYNCxcclxuICAgICdpbnQnOiBDLkRBVEFfVFlQRS5JTlQsXHJcbiAgICAnaW50NCc6IEMuREFUQV9UWVBFLklOVDQsXHJcbiAgICAnYm9vbCc6IEMuREFUQV9UWVBFLkJPT0wsXHJcbiAgICAndGV4dHVyZSc6IEMuREFUQV9UWVBFLlRFWFRVUkUsXHJcbiAgICAnYnl0ZSc6IEMuREFUQV9UWVBFLkJZVEUsXHJcbiAgICAndWJ5dGUnOiBDLkRBVEFfVFlQRS5VQllURVxyXG59O1xyXG5cclxuLy8gVmFsdWVzIGFyZSBjaG9zZW4gdG8gYmUgaW4gbGluZSB3aXRoIERBVEFfVFlQRVxyXG5DLlRFWFRVUkVfVFlQRSA9IHtcclxuICAgIFVOS05PV046IDAsIEZMT0FUOiAxLCBVQllURTogNjAsIFVTSE9SVF81XzZfNTogNzAsIFVTSE9SVF80XzRfNF80OiA3MSwgVVNIT1JUXzVfNV81XzE6IDcyXHJcbn07XHJcblxyXG5DLlRFWFRVUkVfRk9STUFUID0ge1xyXG4gICAgVU5LTk9XTjogMCwgQUxQSEE6IDEwMCwgUkdCOiAxMDEsIFJHQkE6IDEwMiwgTFVNSU5BTkNFOiAxMDMsIExVTUlOQU5DRV9BTFBIQTogMTA0XHJcbn07XHJcblxyXG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFID0ge307XHJcbkMuREFUQV9UWVBFX1RVUExFX1NJWkVbQy5EQVRBX1RZUEUuRkxPQVRdID0gMTtcclxuQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtDLkRBVEFfVFlQRS5GTE9BVDJdID0gMjtcclxuQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtDLkRBVEFfVFlQRS5GTE9BVDNdID0gMztcclxuQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtDLkRBVEFfVFlQRS5GTE9BVDRdID0gNDtcclxuQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtDLkRBVEFfVFlQRS5GTE9BVDNYM10gPSA5O1xyXG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLkZMT0FUNFg0XSA9IDE2O1xyXG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLklOVF0gPSAxO1xyXG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLklOVDRdID0gNDtcclxuQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtDLkRBVEFfVFlQRS5CT09MXSA9IDE7XHJcbkMuREFUQV9UWVBFX1RVUExFX1NJWkVbQy5EQVRBX1RZUEUuVEVYVFVSRV0gPSAxO1xyXG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLkJZVEVdID0gMTtcclxuQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtDLkRBVEFfVFlQRS5VQllURV0gPSAxO1xyXG5cclxuQy5UWVBFRF9BUlJBWV9NQVAgPSB7fTtcclxuQy5UWVBFRF9BUlJBWV9NQVBbQy5EQVRBX1RZUEUuRkxPQVRdID0gRmxvYXQzMkFycmF5O1xyXG5DLlRZUEVEX0FSUkFZX01BUFtDLkRBVEFfVFlQRS5GTE9BVDJdID0gRmxvYXQzMkFycmF5O1xyXG5DLlRZUEVEX0FSUkFZX01BUFtDLkRBVEFfVFlQRS5GTE9BVDNdID0gRmxvYXQzMkFycmF5O1xyXG5DLlRZUEVEX0FSUkFZX01BUFtDLkRBVEFfVFlQRS5GTE9BVDRdID0gRmxvYXQzMkFycmF5O1xyXG5DLlRZUEVEX0FSUkFZX01BUFtDLkRBVEFfVFlQRS5GTE9BVDRYNF0gPSBGbG9hdDMyQXJyYXk7XHJcbkMuVFlQRURfQVJSQVlfTUFQW0MuREFUQV9UWVBFLklOVF0gPSBJbnQzMkFycmF5O1xyXG5DLlRZUEVEX0FSUkFZX01BUFtDLkRBVEFfVFlQRS5JTlQ0XSA9IEludDMyQXJyYXk7XHJcbkMuVFlQRURfQVJSQVlfTUFQW0MuREFUQV9UWVBFLkJPT0xdID0gSW50OEFycmF5O1xyXG5DLlRZUEVEX0FSUkFZX01BUFtDLkRBVEFfVFlQRS5CWVRFXSA9IEludDhBcnJheTtcclxuQy5UWVBFRF9BUlJBWV9NQVBbQy5EQVRBX1RZUEUuVUJZVEVdID0gVWludDhBcnJheTtcclxuXHJcbi8vIHRleHR1cmUgZm9ybWF0c1xyXG4vLyBmbG9hdCBhbmQgdWJ5dGUgYXJlIG1hcHBlZCB0byBEQVRBX1RZUEUgdmFsdWVzIGFib3ZlXHJcbkMuVFlQRURfQVJSQVlfTUFQW0MuVEVYVFVSRV9UWVBFLlVTSE9SVF80XzRfNF80XSA9IFVpbnQxNkFycmF5O1xyXG5DLlRZUEVEX0FSUkFZX01BUFtDLlRFWFRVUkVfVFlQRS5VU0hPUlRfNV82XzVdID0gVWludDE2QXJyYXk7XHJcbkMuVFlQRURfQVJSQVlfTUFQW0MuVEVYVFVSRV9UWVBFLlVTSE9SVF81XzVfNV8xXSA9IFVpbnQxNkFycmF5O1xyXG5cclxuQy5URVhUVVJFX0ZPUk1BVF9UVVBMRV9TSVpFID0ge307XHJcbkMuVEVYVFVSRV9GT1JNQVRfVFVQTEVfU0laRVtDLlRFWFRVUkVfRk9STUFULkFMUEhBXSA9IDE7XHJcbkMuVEVYVFVSRV9GT1JNQVRfVFVQTEVfU0laRVtDLlRFWFRVUkVfRk9STUFULlJHQl0gPSAzO1xyXG5DLlRFWFRVUkVfRk9STUFUX1RVUExFX1NJWkVbQy5URVhUVVJFX0ZPUk1BVC5SR0JBXSA9IDQ7XHJcbkMuVEVYVFVSRV9GT1JNQVRfVFVQTEVfU0laRVtDLlRFWFRVUkVfRk9STUFULkxVTUlOQU5DRV0gPSAxO1xyXG5DLlRFWFRVUkVfRk9STUFUX1RVUExFX1NJWkVbQy5URVhUVVJFX0ZPUk1BVC5MVU1JTkFOQ0VfQUxQSEFdID0gMjtcclxuXHJcbkMuZ2V0VHlwZU5hbWUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgaW4gQy5EQVRBX1RZUEVfTUFQKSB7XHJcbiAgICAgICAgaWYgKEMuREFUQV9UWVBFX01BUFtpXSA9PT0gdHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQGVudW0ge251bWJlcn1cclxuICovXHJcbkMuVEVYX0ZJTFRFUl9UWVBFID0ge1xyXG4gICAgTkVBUkVTVDogMHgyNjAwLCBMSU5FQVI6IDB4MjYwMSwgTUlQTUFQX05FQVJFU1Q6IDB4MjcwMCwgTUlQTUFQX0xJTkVBUjogMHgyNzAxXHJcblxyXG59O1xyXG4vKipcclxuICogQGVudW0ge251bWJlcn1cclxuICovXHJcbkMuVEVYX1dSQVBfVFlQRSA9IHtcclxuICAgIENMQU1QOiAweDgxMkYsIFJFUEVBVDogMHgyOTAxXHJcbn07XHJcbi8qKlxyXG4gKiBAZW51bSB7bnVtYmVyfVxyXG4gKi9cclxuQy5URVhfVFlQRSA9IHtcclxuICAgIFRFWFRVUkVfMkQ6IDB4MERFMVxyXG59O1xyXG5cclxuQy5TSEFERVJfQ09OU1RBTlRfS0VZID0ge1xyXG4gICAgV09STERfVFJBTlNGT1JNOiAxLFxyXG4gICAgVklFV19UUkFOU0ZPUk06IDIsXHJcbiAgICBTQ1JFRU5fVFJBTlNGT1JNOiAzLFxyXG4gICAgV09STERfVFJBTlNGT1JNX05PUk1BTDogNCxcclxuICAgIFZJRVdfVFJBTlNGT1JNX05PUk1BTDogNSxcclxuICAgIFNDUkVFTl9UUkFOU0ZPUk1fTk9STUFMOiA2LFxyXG4gICAgT0JKRUNUX0lEOiA3XHJcbn07XHJcblxyXG5DLlZTX0FUVFJJQl9UUkFOU0ZPUk0gPSB7XHJcbiAgICBOT05FOiAwLCBWSUVXX1BPSU5UOiAxLCBXT1JMRF9QT0lOVDogMiwgVklFV19OT1JNQUw6IDMsIFdPUkxEX05PUk1BTDogNFxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBGaWx0ZXIgVHlwZSBvZiBEYXRhTm9kZVxyXG4gKiBLRUVQIC0gS2VlcCBvbmx5IHRoZSBwcm92aWRlZCBuYW1lc1xyXG4gKiBSRU1PVkUgLSBSZW1vdmUgcHJvdmlkZWQgbmFtZXMgKGlnbm9yZXMgbmFtZSBtYXBwaW5nKVxyXG4gKiBSRU5BTUUgLSBPbmx5IGFwcGx5IG5hbWUgbWFwcGluZ1xyXG4gKiBAZW51bVxyXG4gKi9cclxuQy5EQVRBX0ZJTFRFUl9UWVBFID0ge1xyXG4gICAgTk9ORTogMCwgUkVOQU1FOiAxLCBLRUVQOiAyLCBSRU1PVkU6IDNcclxufTtcclxuXHJcblxyXG4vKipcclxuICogVE9ETzogTWF5YmUgbWVyZ2UgdGhpcyBzdHJ1Y3R1cmUgd2l0aCBSRVNVTFRfU1RBVEUgdG8gYXZvaWQgYmFjayBhbmQgZm9ydGggY29udmVyc2lvbiB3aXRoaW4gbm90aWZpY2F0aW9uIGNoYWluXHJcbiAqIEBlbnVtIHtudW1iZXJ9XHJcbiAqL1xyXG5DLkRBVEFfRU5UUllfU1RBVEUgPSB7XHJcbiAgICBDSEFOR0VEX1ZBTFVFOiAxLFxyXG4gICAgQ0hBTkdFRF9ORVc6IDIsXHJcbiAgICBMT0FEX1NUQVJUOiAzLFxyXG4gICAgTE9BRF9FTkQ6IDQsXHJcbiAgICBDSEFOR0VEX1NJWkU6IDUsXHJcbiAgICBDSEFOR0VEX1JFTU9WRUQ6IDYsIC8vIE5vdCBqdXN0IHRoZSBzaXplIGNoYW5nZWQsIGJ1dCBhbHNvIHF1YWxpZmllclxyXG4gICAgLy8gaWYgd2UgaGF2ZSAwLCAxIG9yIG1hbnkgdHVwbGVzIGluIHZhbHVlXHJcbiAgICBDSEFOR0VEX1NJWkVfVFlQRTogN1xyXG59O1xyXG5cclxuLyoqIFRPRE86IE1lcmdlIHdpdGggQy5QTEFURk9STT8gKiovXHJcbkMuUkVTVUxUX1RZUEUgPSB7XHJcbiAgICBDT01QVVRFOiAwLCBWUzogMVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUeXBlIG9mIE1vZGlmaWNhdGlvbiwgdXNlZCBpbnRlcm5hbGx5IG9ubHlcclxuICogT3JkZXJlZCBieSBpbXBvcnRhbmNlLlxyXG4gKiBAZW51bVxyXG4gKi9cclxuQy5SRVNVTFRfU1RBVEUgPSB7XHJcbiAgICBOT05FOiAwLCBDSEFOR0VEX0RBVEFfVkFMVUU6IDEsIENIQU5HRURfREFUQV9TSVpFOiAyLCBDSEFOR0VEX1NUUlVDVFVSRTogMywgLy8gVE9ETzogRmVsaXg6IFN0aWxsIHJlcXVpcmVkP1xyXG4gICAgSU1BR0VfTE9BRF9TVEFSVDogNCwgSU1BR0VfTE9BRF9FTkQ6IDVcclxufTtcclxuXHJcblxyXG4vKipcclxuICogVHlwZSBvZiBTZXF1ZW5jZSBhY2Nlc3MgLSB1c2VkIGJ5IG9wZXJhdG9yc1xyXG4gKiBAZW51bVxyXG4gKi9cclxuQy5TRVFVRU5DRSA9IHtcclxuICAgIE5PX0FDQ0VTUzogMCwgUFJFVl9CVUZGRVI6IDEsIE5FWFRfQlVGRkVSOiAyLCBMSU5FQVJfV0VJR0hUOiAzXHJcbn07XHJcblxyXG5cclxuQy5JVEVSQVRJT05fVFlQRSA9IHtcclxuICAgIE5VTEw6IDAsIE9ORTogMSwgTUFOWTogMlxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFR5cGUgb2YgSW5mb3JtYXRpb24gRXh0cmFjdGlvbiAtIHVzZWQgYnkgb3BlcmF0b3JzXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBlbnVtXHJcbiAqL1xyXG4vL1RPRE86IFRoaXMgc2VlbXMgdG8gYmUgdW51c2VkLCBpcyBpdCBzdGlsbCBuZWVkZWQ/XHJcbkMuRVhUUkFDVCA9IHtcclxuICAgIE5PX0VYVFJBQzogMCwgVEVYX1dJRFRIOiAxLCBURVhfSEVJR0hUOiAyXHJcbn07XHJcblxyXG5DLk9SSUdJTiA9IHtcclxuICAgIENISUxEOiAxLCBDT01QVVRFOiAyLCBQUk9UTzogM1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFR5cGVzIG9mIHBsYXRmb3JtcyB0byBwZXJmb3JtIGNvbXB1dGF0aW9uIG9uXHJcbiAqIEB0eXBlIHtlbnVtfVxyXG4gKi9cclxuQy5QTEFURk9STSA9IHtcclxuICAgIEpBVkFTQ1JJUFQ6IDAsIEdMU0w6IDEsIENMOiAyLCBBU1lOQzogM1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBvc3NpYmxlIHN0YXRlcyBvZiBhIFByb2Nlc3NOb2RlXHJcbiAqIEB0eXBlIHtlbnVtfVxyXG4gKi9cclxuQy5QUk9DRVNTX1NUQVRFID0ge1xyXG4gICAgTU9ESUZJRUQ6IDAsIC8vIFdlIGRvbid0IGtub3cgKFRPRE8gRmVsaXg6IEZpbmQgb3V0ISlcclxuICAgIExPQURJTkc6IDEsIC8vIFNvbWV0aGluZyBzdGlsbCBsb2FkaW5nIChibG9ja2VkKVxyXG4gICAgSU5WQUxJRDogMywgLy8gSW5wdXQgaXMgaW52YWxpZCAobWlnaHQgaGFwcGVuIGV2ZW4gYWZ0ZXIgb3BlcmF0b3Igc2VsZWN0aW9uIC0gZS5nLiBiZWNhdXNlIG9mIGVtcHR5IGFycmF5IG91dHB1dCBldGMuKVxyXG4gICAgVU5QUk9DRVNTRUQ6IDQsIC8vIFByb2Nlc3Mgbm9kZSBpcyBkaXJ0eVxyXG4gICAgUFJPQ0VTU0VEOiA1IC8vIEFsbCBkYXRhIGlzIHVwLXRvLWRhdGVcclxufTtcclxuXHJcbi8vd2luZG93LlhmbG93LlBMQVRGT1JNID0gQy5QTEFURk9STTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQztcclxuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcclxudmFyIEMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XHJcbnJlcXVpcmUoXCIuLi8uLi91dGlscy9hcnJheS5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiBDb250ZW50IG9mIHRoaXMgZmlsZTpcclxuICogQWxsIENvZGUgZm9yIGhhbmRsaW5nIGRhdGEgZW50cmllcyBjb25uZWN0ZWQgdG8gWGZsb3cgaW5jbHVkaW5nOlxyXG4gKiAgLSBCdWZmZXJFbnRyaWVzOiBUeXBlZCB2YWx1ZSBidWZmZXJzIChlLmcgZmxvYXQzIGJ1ZmZlciwgd2l0aG91dCBuYW1lKVxyXG4gKiAgLSBUZXh0dXJlRW50cmllczogZS5nLiBpbWFnZXNcclxuICpcclxuICogIFRoaXMgZmlsZSBhbHNvIGluY2x1ZGVzIHRoZSBEYXRhQ2hhbmdlTm90aWZpZXIgdXNlZCB0byByZWFjdCB0byBjaGFuZ2VzIG9uIFhmbG93IGRhdGEgc3RydWN0dXJlc1xyXG4gKi9cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBTYW1wbGVyQ29uZmlnXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbi8qKlxyXG4gKiBTYW1wbGVyQ29uZmlnIGlzIHVzZWQgdG8gZGVmaW5lIHNhbXBsZXIgcHJvcGVydGllcyBvZiBhIFRleHR1cmVFbnRyeSBvciBJbWFnZURhdGFUZXh0dXJlRW50cnlcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgU2FtcGxlckNvbmZpZyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLm1pbkZpbHRlciA9IDA7XHJcbiAgICB0aGlzLm1hZ0ZpbHRlciA9IDA7XHJcbiAgICB0aGlzLm1pcEZpbHRlciA9IDA7XHJcbiAgICB0aGlzLndyYXBTID0gMDtcclxuICAgIHRoaXMud3JhcFQgPSAwO1xyXG4gICAgdGhpcy53cmFwVSA9IDA7XHJcbiAgICB0aGlzLnRleHR1cmVUeXBlID0gMDtcclxuICAgIHRoaXMuY29sb3JSID0gMDtcclxuICAgIHRoaXMuY29sb3JHID0gMDtcclxuICAgIHRoaXMuY29sb3JCID0gMDtcclxuICAgIHRoaXMuZ2VuZXJhdGVNaXBNYXAgPSAwO1xyXG59O1xyXG5cclxuU2FtcGxlckNvbmZpZy5wcm90b3R5cGUuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMubWluRmlsdGVyID0gQy5URVhfRklMVEVSX1RZUEUuTElORUFSO1xyXG4gICAgdGhpcy5tYWdGaWx0ZXIgPSBDLlRFWF9GSUxURVJfVFlQRS5MSU5FQVI7XHJcbiAgICB0aGlzLm1pcEZpbHRlciA9IEMuVEVYX0ZJTFRFUl9UWVBFLk5FQVJFU1Q7XHJcbiAgICB0aGlzLndyYXBTID0gQy5URVhfV1JBUF9UWVBFLkNMQU1QO1xyXG4gICAgdGhpcy53cmFwVCA9IEMuVEVYX1dSQVBfVFlQRS5DTEFNUDtcclxuICAgIHRoaXMud3JhcFUgPSBDLlRFWF9XUkFQX1RZUEUuQ0xBTVA7XHJcbiAgICB0aGlzLnRleHR1cmVUeXBlID0gQy5URVhfVFlQRS5URVhUVVJFXzJEO1xyXG4gICAgdGhpcy5jb2xvclIgPSAwO1xyXG4gICAgdGhpcy5jb2xvckcgPSAwO1xyXG4gICAgdGhpcy5jb2xvckIgPSAwO1xyXG4gICAgdGhpcy5nZW5lcmF0ZU1pcE1hcCA9IDA7XHJcbn07XHJcblxyXG5TYW1wbGVyQ29uZmlnLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgdGhpcy5taW5GaWx0ZXIgPSBvdGhlci5taW5GaWx0ZXI7XHJcbiAgICB0aGlzLm1hZ0ZpbHRlciA9IG90aGVyLm1hZ0ZpbHRlcjtcclxuICAgIHRoaXMubWlwRmlsdGVyID0gb3RoZXIubWlwRmlsdGVyO1xyXG4gICAgdGhpcy53cmFwUyA9IG90aGVyLndyYXBTO1xyXG4gICAgdGhpcy53cmFwVCA9IG90aGVyLndyYXBUO1xyXG4gICAgdGhpcy53cmFwVSA9IG90aGVyLndyYXBVO1xyXG4gICAgdGhpcy50ZXh0dXJlVHlwZSA9IG90aGVyLnRleHR1cmVUeXBlO1xyXG4gICAgdGhpcy5jb2xvclIgPSBvdGhlci5jb2xvclI7XHJcbiAgICB0aGlzLmNvbG9yRyA9IG90aGVyLmNvbG9yRztcclxuICAgIHRoaXMuY29sb3JCID0gb3RoZXIuY29sb3JCO1xyXG4gICAgdGhpcy5nZW5lcmF0ZU1pcE1hcCA9IG90aGVyLmdlbmVyYXRlTWlwTWFwO1xyXG59O1xyXG5cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBEYXRhRW50cnlcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBhYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhbGwgRGF0YUVudHJpZXMgY29ubmVjdGVkIHRvIGFuIHhmbG93IGdyYXBoLlxyXG4gKiBAYWJzdHJhY3RcclxuICogQHBhcmFtIHtDLkRBVEFfVFlQRX0gdHlwZSBUeXBlIG9mIERhdGFFbnRyeVxyXG4gKi9cclxudmFyIERhdGFFbnRyeSA9IGZ1bmN0aW9uKHR5cGUpe1xyXG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XHJcbiAgICAvKiogQHR5cGUge0FycmF5LjxGdW5jdGlvbihEYXRhRW50cnksIEMuREFUQV9FTlRSWV9TVEFURSk+fSAqKi9cclxuICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xyXG4gICAgLyoqIEFkZCByZWxhdGVkIGN1c3RvbSBkYXRhIChlLmcuIFdlYkdMIGJ1ZmZlcnMpICoqL1xyXG4gICAgdGhpcy51c2VyRGF0YSA9IHt9O1xyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFFbnRyeS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBpcyByZWFkLW9ubHlcIik7XHJcbiAgICB9LFxyXG4gICAgLyoqIEByZXR1cm4ge0MuREFUQV9UWVBFfSAqL1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fdHlwZTsgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKERhdGFFbnRyeSwgQy5EQVRBX0VOVFJZX1NUQVRFKX0gY2FsbGJhY2tcclxuICovXHJcbkRhdGFFbnRyeS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihjYWxsYmFjayl7XHJcbiAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtmdW5jdGlvbihEYXRhRW50cnksIEMuREFUQV9FTlRSWV9TVEFURSl9IGNhbGxiYWNrXHJcbiAqL1xyXG5EYXRhRW50cnkucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oY2FsbGJhY2spe1xyXG4gICAgQXJyYXkuZXJhc2UodGhpcy5fbGlzdGVuZXJzLCBjYWxsYmFjayk7XHJcbn07XHJcblxyXG4vKipcclxuICovXHJcbkRhdGFFbnRyeS5wcm90b3R5cGUuX25vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbigpe1xyXG4gICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1ZBTFVFKTtcclxufTtcclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBCdWZmZXJFbnRyeVxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8qKlxyXG4gKiBBIHR5cGVkIHZhbHVlIGJ1ZmZlciBiYXNpY2FsbHkgbGlua2luZyB0byBhIHR5cGVkIGFycmF5LlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMge0RhdGFFbnRyeX1cclxuICogQHBhcmFtIHtDLkRBVEFfVFlQRX0gdHlwZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgQSB0eXBlZCBhcnJheVxyXG4gKi9cclxudmFyIEJ1ZmZlckVudHJ5ID0gZnVuY3Rpb24odHlwZSwgdmFsdWUpe1xyXG4gICAgRGF0YUVudHJ5LmNhbGwodGhpcywgdHlwZSk7XHJcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX05FVyk7XHJcbn07XHJcbkJhc2UuY3JlYXRlQ2xhc3MoQnVmZmVyRW50cnksIERhdGFFbnRyeSk7XHJcblxyXG5cclxuLyoqXHJcbiAqICBTZXQgdmFsdWUgb2YgZW50cnkuIFRyaWdnZXJzIG5vdGlmaWNhdGlvbiBjaGFpblxyXG4gKiAgQHBhcmFtIHtPYmplY3R9IHYgVmFsdWUgdG8gc2V0IChoYXMgdG8gYmUgYSBUeXBlZEFycmF5KVxyXG4gKi9cclxuQnVmZmVyRW50cnkucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odil7XHJcbiAgICB0aGlzLl9zZXRWYWx1ZSh2KTtcclxuICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQXJlIHRoZXJlIG5vLCBvbmUgb3IgbWFueSB2YWx1ZXM/XHJcbiAqIEBwYXJhbSBzaXplXHJcbiAqIEBwYXJhbSB0dXBsZVNpemVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGdldFNpemVUeXBlKHNpemUsIHR1cGxlU2l6ZSl7XHJcbiAgICBpZihzaXplID49IHR1cGxlU2l6ZSoyKVxyXG4gICAgICAgIHJldHVybiAyO1xyXG4gICAgZWxzZSBpZihzaXplID49IHR1cGxlU2l6ZSlcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gMDtcclxufVxyXG5cclxuQnVmZmVyRW50cnkucHJvdG90eXBlLl9zZXRWYWx1ZSA9IGZ1bmN0aW9uKHYpe1xyXG4gICAgdmFyIG9sZFNpemUgPSAodGhpcy5fdmFsdWUgPyB0aGlzLl92YWx1ZS5sZW5ndGggOiAwKSwgbmV3U2l6ZSA9ICh2ID8gdi5sZW5ndGggOiAwKSwgdHVwbGVTaXplID0gdGhpcy5nZXRUdXBsZVNpemUoKTtcclxuICAgIHZhciBub3RpZmljYXRpb247XHJcbiAgICBpZihnZXRTaXplVHlwZShvbGRTaXplLCB0dXBsZVNpemUpICE9IGdldFNpemVUeXBlKG5ld1NpemUsIHR1cGxlU2l6ZSkpXHJcbiAgICAgICAgbm90aWZpY2F0aW9uID0gQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfU0laRV9UWVBFO1xyXG4gICAgZWxzZSBpZihvbGRTaXplICE9IG5ld1NpemUpe1xyXG4gICAgICAgIG5vdGlmaWNhdGlvbiA9IEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1NJWkU7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIG5vdGlmaWNhdGlvbiA9IEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fdmFsdWUgPSB2O1xyXG4gICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIG5vdGlmaWNhdGlvbik7XHJcbn07XHJcblxyXG4vKiogQHJldHVybiB7T2JqZWN0fSAqL1xyXG5CdWZmZXJFbnRyeS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJ1ZmZlciBsZW5ndGhcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKi9cclxuQnVmZmVyRW50cnkucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPyB0aGlzLl92YWx1ZS5sZW5ndGggOiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHVwbGUgc2l6ZSAoZS5nIDEsIDIsIDMsIDQsIDE2KVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuQnVmZmVyRW50cnkucHJvdG90eXBlLmdldFR1cGxlU2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIEMuREFUQV9UWVBFX1RVUExFX1NJWkVbdGhpcy5fdHlwZV07XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIHR1cGxlIGNvdW50XHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICovXHJcbkJ1ZmZlckVudHJ5LnByb3RvdHlwZS5nZXRJdGVyYXRlQ291bnQgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0TGVuZ3RoKCkgLyB0aGlzLmdldFR1cGxlU2l6ZSgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIElzIHZhbHVlIG5vdCBzZXQgb3IgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIDBcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5CdWZmZXJFbnRyeS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gIXRoaXMuX3ZhbHVlIHx8ICF0aGlzLmdldExlbmd0aCgpO1xyXG59O1xyXG5cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBUZXh0dXJlRW50cnlcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG52YXIgdG1wQ2FudmFzLCB0bXBDb250ZXh0O1xyXG5cclxuQy50b0ltYWdlRGF0YSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xyXG4gICAgaWYoaW1hZ2VEYXRhIGluc3RhbmNlb2YgSW1hZ2VEYXRhKVxyXG4gICAgICAgIHJldHVybiBpbWFnZURhdGE7XHJcbiAgICBpZighaW1hZ2VEYXRhLmRhdGEpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gZGF0YSBwcm9wZXJ0eVwiKTtcclxuICAgIGlmKCFpbWFnZURhdGEud2lkdGgpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gd2lkdGggcHJvcGVydHlcIik7XHJcbiAgICBpZighaW1hZ2VEYXRhLmhlaWdodClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBoZWlnaHQgcHJvcGVydHlcIik7XHJcbiAgICBpZighdG1wQ29udGV4dCkge1xyXG4gICAgICAgIHRtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIHRtcENvbnRleHQgPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIH1cclxuICAgIHZhciBuZXdJbWFnZURhdGEgPSB0bXBDb250ZXh0LmNyZWF0ZUltYWdlRGF0YShpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGltYWdlRGF0YS5kYXRhLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIHYgPSBpbWFnZURhdGEuZGF0YVtpXTtcclxuICAgICAgICBpZih2ID4gMjU1KVxyXG4gICAgICAgICAgICB2ID0gMjU1O1xyXG4gICAgICAgIGlmKHYgPCAwKVxyXG4gICAgICAgICAgICB2ID0gMDtcclxuICAgICAgICBuZXdJbWFnZURhdGEuZGF0YVtpXSA9IHY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3SW1hZ2VEYXRhO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gVGV4ZWxTb3VyY2Uoc291cmNlT3JXaWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpIHtcclxuICAgIGlmICh0eXBlb2Ygc291cmNlT3JXaWR0aCA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGlmIChzb3VyY2VPcldpZHRoLm5vZGVOYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IHNvdXJjZU9yV2lkdGgubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSBcInZpZGVvXCIgJiYgKHR5cGVvZiBzb3VyY2VPcldpZHRoLmNvbXBsZXRlID09PSBcInVuZGVmaW5lZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc291cmNlT3JXaWR0aCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9XaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9IZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEodGhpcy5yZWFkeVN0YXRlID09IDAgfHwgdGhpcy52aWRlb1dpZHRoIDw9IDAgfHwgdGhpcy52aWRlb0hlaWdodCA8PSAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNvdXJjZU9yV2lkdGgudGV4ZWxGb3JtYXQgPSBDLlRFWFRVUkVfRk9STUFULlJHQkE7XHJcbiAgICAgICAgICAgIHNvdXJjZU9yV2lkdGgudGV4ZWxUeXBlID0gQy5URVhUVVJFX1RZUEUuVUJZVEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vYXNzdW1lIHNvdXJjZSBpcyBhIGltYWdlIGRhdGEgbGlrZSBvYmplY3RcclxuICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2VPcldpZHRoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgQy5URVhUVVJFX0ZPUk1BVC5SR0JBO1xyXG4gICAgICAgIHR5cGUgPSAgdHlwZSB8fCBDLlRFWFRVUkVfVFlQRS5VQllURTtcclxuICAgICAgICAvL2NyZWF0ZSBhIG5ldyB0ZXhlbCBzb3VyY2UgYmFja2VkIGJ5IHR5cGUgYXJyYXlcclxuICAgICAgICB0aGlzLl9zb3VyY2UgPSB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBzb3VyY2VPcldpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgdGV4ZWxGb3JtYXQ6IGZvcm1hdCxcclxuICAgICAgICAgICAgdGV4ZWxUeXBlOiB0eXBlLFxyXG4gICAgICAgICAgICBkYXRhOiBuZXcgQy5UWVBFRF9BUlJBWV9NQVBbdHlwZV0oc291cmNlT3JXaWR0aCAqIGhlaWdodCAqIEMuVEVYVFVSRV9GT1JNQVRfVFVQTEVfU0laRVtmb3JtYXRdKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGV4ZWxTb3VyY2UucHJvdG90eXBlLCB7XHJcbiAgICBpbWFnZURhdGE6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuX3NvdXJjZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLl9zb3VyY2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX3NvdXJjZSwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLl9zb3VyY2Uud2lkdGgsIHRoaXMuX3NvdXJjZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgc291cmNlLnRleGVsRm9ybWF0ID0gdGhpcy5fc291cmNlLnRleGVsRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgc291cmNlLnRleGVsVHlwZSA9IHRoaXMuX3NvdXJjZS50ZXhlbFR5cGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gVE9ETyB0aGlzIGlzIHZlcnkgY29uZnVzaW5nLiBhc0dMVGV4dHVyZURhdGEgaXMgdGV4ZWxzb3VyY2Uuc291cmNlXHJcbiAgICBnbFRleHR1cmVEYXRhOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbXBsZXRlOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc291cmNlLmNvbXBsZXRlID09PSBcInVuZGVmaW5lZFwiID8gdHJ1ZSA6IHRoaXMuX3NvdXJjZS5jb21wbGV0ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2lkdGg6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS53aWR0aCA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBoZWlnaHQ6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS5oZWlnaHQgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgdGV4ZWxGb3JtYXQ6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS50ZXhlbEZvcm1hdDogQy5URVhUVVJFX0ZPUk1BVC5VTktOT1dOO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB0ZXhlbFR5cGU6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS50ZXhlbFR5cGU6IEMuVEVYVFVSRV9UWVBFLlVOS05PV047XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBBIGRhdGEgZW50cnkgZm9yIGEgdGV4dHVyZS5cclxuICogTm90ZTogZWFjaCBUZXh0dXJlRW50cnkgaW5jbHVkZXMgYSBzYW1wbGVyQ29uZmlnLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMge0RhdGFFbnRyeX1cclxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZSAvL1RPRE86IFdoaWNoIGtpbmRzIGFyZSBzdXBwb3J0ZWQ/XHJcbiAqL1xyXG5UZXh0dXJlRW50cnkgPSBmdW5jdGlvbihzb3VyY2Upe1xyXG4gICAgRGF0YUVudHJ5LmNhbGwodGhpcywgQy5EQVRBX1RZUEUuVEVYVFVSRSk7XHJcbiAgICB0aGlzLl9zYW1wbGVyQ29uZmlnID0gbmV3IFNhbXBsZXJDb25maWcoKTtcclxuICAgIHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuc2V0SW1hZ2Uoc291cmNlKTtcclxuXHJcbiAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfTkVXKTtcclxufTtcclxuXHJcbkJhc2UuY3JlYXRlQ2xhc3MoVGV4dHVyZUVudHJ5LCBEYXRhRW50cnkpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGV4dHVyZUVudHJ5LnByb3RvdHlwZSwge1xyXG4gICAgd2lkdGg6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS53aWR0aCA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBoZWlnaHQ6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS5oZWlnaHQgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgdGV4ZWxGb3JtYXQ6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS50ZXhlbEZvcm1hdDogQy5URVhUVVJFX0ZPUk1BVC5VTktOT1dOO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB0ZXhlbFR5cGU6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS50ZXhlbFR5cGU6IEMuVEVYVFVSRV9UWVBFLlVOS05PV047XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcblRleHR1cmVFbnRyeS5wcm90b3R5cGUuaXNMb2FkaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoIXRoaXMuX3NvdXJjZSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgcmV0dXJuICF0aGlzLl9zb3VyY2UuY29tcGxldGU7XHJcbn07XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcblRleHR1cmVFbnRyeS5wcm90b3R5cGUuX2NyZWF0ZUltYWdlID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBzYW1wbGVyQ29uZmlnKSB7XHJcbiAgICBpZiAoIXRoaXMuX3NvdXJjZSB8fCB0aGlzLndpZHRoICE9IHdpZHRoIHx8IHRoaXMuaGVpZ2h0ICE9IGhlaWdodCB8fCB0aGlzLmZvcm1hdCAhPSBmb3JtYXQgfHwgdGhpcy50eXBlICE9IHR5cGUpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gbmV3IFRleGVsU291cmNlKHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSk7XHJcblxyXG4gICAgICAgIGlmICghc2FtcGxlckNvbmZpZykge1xyXG4gICAgICAgICAgICBzYW1wbGVyQ29uZmlnID0gbmV3IFNhbXBsZXJDb25maWcoKTtcclxuICAgICAgICAgICAgc2FtcGxlckNvbmZpZy5zZXREZWZhdWx0cygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fc2FtcGxlckNvbmZpZy5zZXQoc2FtcGxlckNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fc2V0SW1hZ2Uoc291cmNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fbm90aWZ5Q2hhbmdlZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IGltYWdlIHNvdXJjZSBvZiBhIFRleHR1cmUgRW50cnlcclxuICogVE9ETzogVGhpcyBpcyBjYWxsZWQgZXZlbiBpZiBpbWFnZSBpcyBqdXN0IGxvYWRlZCAob24gWE1MM0Qgc2lkZSkuIEFkZCBhIG5vdGlmeUltYWdlTG9hZGVkIG1ldGhvZCBjb3VsZFxyXG4gKiBiZSBoZWxwZnVsXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fFRleGVsU291cmNlfG51bGx9IGVsZW1lbnRcclxuICogQHBhcmFtIHtib29sZWFuP30gZm9yY2VMb2FkQ2FsbGJhY2sgdHJpZ2dlciBsb2FkIGNhbGxiYWNrIGlmIGRhdGEgY2hhbmdlc1xyXG4gKi9cclxuVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5zZXRJbWFnZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBmb3JjZUxvYWRDYWxsYmFjaykge1xyXG4gICAgdGhpcy5fc2V0SW1hZ2UoZWxlbWVudCwgZm9yY2VMb2FkQ2FsbGJhY2spO1xyXG4gICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxufTtcclxuXHJcblRleHR1cmVFbnRyeS5wcm90b3R5cGUuX3NldEltYWdlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGZvcmNlTG9hZENhbGxiYWNrKSB7XHJcbiAgICBpZiAoIWVsZW1lbnQpXHJcbiAgICAgICAgdGhpcy5fc2V0U291cmNlKG51bGwsIGZvcmNlTG9hZENhbGxiYWNrKTtcclxuICAgIGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBUZXhlbFNvdXJjZSlcclxuICAgICAgICB0aGlzLl9zZXRTb3VyY2UoZWxlbWVudCwgZm9yY2VMb2FkQ2FsbGJhY2spO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHRoaXMuX3NldFNvdXJjZShuZXcgVGV4ZWxTb3VyY2UoZWxlbWVudCksIGZvcmNlTG9hZENhbGxiYWNrKTtcclxufTtcclxuXHJcblRleHR1cmVFbnRyeS5wcm90b3R5cGUuX3NldFNvdXJjZSA9IGZ1bmN0aW9uKHMsIGZvcmNlTG9hZENhbGxiYWNrKSB7XHJcbiAgICB2YXIgcHJldkxvYWRpbmcgPSB0aGlzLmlzTG9hZGluZygpO1xyXG4gICAgdGhpcy5fc291cmNlID0gcztcclxuICAgIHZhciBsb2FkaW5nID0gdGhpcy5pc0xvYWRpbmcoKTtcclxuICAgIGlmKGZvcmNlTG9hZENhbGxiYWNrICYmICFsb2FkaW5nICYmICFwcmV2TG9hZGluZyl7XHJcbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIEMuREFUQV9FTlRSWV9TVEFURS5MT0FEX1NUQVJUKTtcclxuICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgQy5EQVRBX0VOVFJZX1NUQVRFLkxPQURfRU5EKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYobG9hZGluZyl7XHJcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIEMuREFUQV9FTlRSWV9TVEFURS5MT0FEX1NUQVJUKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYodGhpcy5fbG9hZGluZyl7XHJcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBDLkRBVEFfRU5UUllfU1RBVEUuTE9BRF9FTkQpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9WQUxVRSk7XHJcbn07XHJcblxyXG5UZXh0dXJlRW50cnkucHJvdG90eXBlLmFzR0xUZXh0dXJlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5nbFRleHR1cmVEYXRhO1xyXG59O1xyXG5cclxuLyoqIEByZXR1cm4ge0ltYWdlRGF0YX0gKi9cclxuVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLl9zb3VyY2UpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAoIXRoaXMuaXNMb2FkaW5nKCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5pbWFnZURhdGE7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vKiogQHJldHVybiB7U2FtcGxlckNvbmZpZ30gKi9cclxuVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5nZXRTYW1wbGVyQ29uZmlnID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLl9zYW1wbGVyQ29uZmlnO1xyXG59O1xyXG5cclxuLyoqIEByZXR1cm4ge251bWJlcn0gKi9cclxuVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIDE7XHJcbn07XHJcblRleHR1cmVFbnRyeS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vKiogQHJldHVybiB7bnVtYmVyfSAqL1xyXG5UZXh0dXJlRW50cnkucHJvdG90eXBlLmdldEl0ZXJhdGVDb3VudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIDE7XHJcbn07XHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gSW1hZ2VEYXRhVGV4dHVyZUVudHJ5XHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLyoqXHJcbiAqIFNhbWUgYXMgVGV4dHVyZUVudHJ5LCBvbmx5IGJhc2VkIG9uIGltYWdlRGF0YS5cclxuICogVGhpcyBjbGFzcyBpcyB1c2VkIGZvciB4ZmxvdyBydW5uaW5nIGluc2lkZSBXZWIgV29ya2VycyAod2hpY2ggZG9uJ3Qgc3VwcG9ydCBIVE1MIGltYWdlcylcclxuICogQHBhcmFtIGltYWdlRGF0YVxyXG4gKiBAZXh0ZW5kc3tEYXRhRW50cnl9XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEltYWdlRGF0YVRleHR1cmVFbnRyeSA9IGZ1bmN0aW9uKGltYWdlRGF0YSl7XHJcbiAgICBEYXRhRW50cnkuY2FsbCh0aGlzLCBDLkRBVEFfVFlQRS5URVhUVVJFKTtcclxuICAgIHRoaXMuX3NhbXBsZXJDb25maWcgPSBuZXcgU2FtcGxlckNvbmZpZygpO1xyXG4gICAgdGhpcy5faW1hZ2VEYXRhID0gbnVsbDtcclxuICAgIHRoaXMuX3RleGVsRm9ybWF0ID0gQy5URVhUVVJFX0ZPUk1BVC5SR0JBO1xyXG4gICAgdGhpcy5fdGV4ZWxUeXBlID0gQy5URVhUVVJFX1RZUEUuVUJZVEU7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlSW1hZ2VEYXRhKGltYWdlRGF0YSk7XHJcblxyXG4gICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX05FVyk7XHJcbn07XHJcblxyXG5CYXNlLmNyZWF0ZUNsYXNzKEltYWdlRGF0YVRleHR1cmVFbnRyeSwgRGF0YUVudHJ5KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEltYWdlRGF0YVRleHR1cmVFbnRyeS5wcm90b3R5cGUsIHtcclxuICAgIHdpZHRoOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbWFnZURhdGEgPyB0aGlzLl9pbWFnZURhdGEud2lkdGggOiAtMTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgaGVpZ2h0OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbWFnZURhdGEgPyB0aGlzLl9pbWFnZURhdGEuaGVpZ2h0IDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRleGVsRm9ybWF0OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXhlbEZvcm1hdDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgdGV4ZWxUeXBlOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXhlbFR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcblxyXG5cclxuSW1hZ2VEYXRhVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5pc0xvYWRpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAhdGhpcy5faW1hZ2VEYXRhO1xyXG59O1xyXG5cclxuSW1hZ2VEYXRhVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5fdXBkYXRlSW1hZ2VEYXRhID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XHJcbiAgICB0aGlzLl90ZXhlbEZvcm1hdCA9IEMuVEVYVFVSRV9GT1JNQVQuUkdCQTtcclxuICAgIHRoaXMuX3RleGVsVHlwZSA9IEMuVEVYVFVSRV9UWVBFLlVCWVRFO1xyXG4gICAgdGhpcy5faW1hZ2VEYXRhID0gaW1hZ2VEYXRhO1xyXG59O1xyXG5cclxuLyoqIENyZWF0ZSBuZXcgaW1hZ2VcclxuICogVE9ETzogSmFuOiBXcml0ZSBzb3VyY2UgZG9jdW1lbnRhdGlvblxyXG4gKiBAcGFyYW0gd2lkdGhcclxuICogQHBhcmFtIGhlaWdodFxyXG4gKiBAcGFyYW0gZm9ybWF0XHJcbiAqIEBwYXJhbSB0eXBlXHJcbiAqIEBwYXJhbSBzYW1wbGVyQ29uZmlnXHJcbiAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9XHJcbiAqL1xyXG5JbWFnZURhdGFUZXh0dXJlRW50cnkucHJvdG90eXBlLl9jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgc2FtcGxlckNvbmZpZykge1xyXG4gICAgaWYgKCF0aGlzLl9pbWFnZURhdGEgfHwgdGhpcy5nZXRXaWR0aCgpICE9IHdpZHRoIHx8IHRoaXMuZ2V0SGVpZ2h0KCkgIT0gaGVpZ2h0IHx8IHRoaXMuX2Zvcm1hdCAhPSBmb3JtYXQgfHwgdGhpcy5fdHlwZSAhPSB0eXBlKSB7XHJcbiAgICAgICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWR0aCBvciBoZWlnaHQgaXMgbm90IHNwZWNpZmllZFwiKTtcclxuICAgICAgICB0aGlzLl90ZXhlbEZvcm1hdCA9IGZvcm1hdDtcclxuICAgICAgICB0aGlzLl90ZXhlbFR5cGUgPSB0eXBlO1xyXG4gICAgICAgIGlmICghc2FtcGxlckNvbmZpZykge1xyXG4gICAgICAgICAgICBzYW1wbGVyQ29uZmlnID0gbmV3IFNhbXBsZXJDb25maWcoKTtcclxuICAgICAgICAgICAgc2FtcGxlckNvbmZpZy5zZXREZWZhdWx0cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zYW1wbGVyQ29uZmlnLnNldChzYW1wbGVyQ29uZmlnKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge3t3aWR0aDogKiwgaGVpZ2h0OiAqLCBkYXRhOiBudWxsfEFycmF5QnVmZmVyVmlld319XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgZGF0YTogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYodHlwZSA9PSBDLlRFWFRVUkVfVFlQRS5GTE9BVCl7XHJcbiAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCpoZWlnaHQqNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGSVhNRTogV2Ugc2hvdWxkIGFsbG9jYXRlIFVpbnQ4Q2xhbXBlZEFycmF5IGhlcmUgaW5zdGVhZFxyXG4gICAgICAgICAgICAvLyBCdXQgVWludDhDbGFtcGVkQXJyYXkgY2FuJ3QgYmUgYWxsb2NhdGVkIGluIENocm9tZSBpbnNpZGUgYSBXZWIgV29ya2VyXHJcbiAgICAgICAgICAgIC8vIFNlZSBidWc6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE3NjQ3OVxyXG4gICAgICAgICAgICAvLyBBcyBhIHdvcmsgYXJvdW5kLCB3ZSBhbGxvY2F0ZSBJbnQxNkFycmF5IHdoaWNoIHJlc3VsdHMgaW4gY29ycmVjdCBjbGFtcGluZyBvdXRzaWRlIG9mIHdlYiB3b3JrZXJcclxuICAgICAgICAgICAgaWYoVWludDhBcnJheSA9PSBVaW50OENsYW1wZWRBcnJheSlcclxuICAgICAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhID0gbmV3IEludDE2QXJyYXkod2lkdGgqaGVpZ2h0KjQpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBpbWFnZURhdGEuZGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCpoZWlnaHQqNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2ltYWdlRGF0YSA9IGltYWdlRGF0YTtcclxuICAgIH1cclxuICAgIHRoaXMuX25vdGlmeUNoYW5nZWQoKTtcclxufTtcclxuXHJcbi8qKiBAcGFyYW0ge09iamVjdH0gdiAqL1xyXG5JbWFnZURhdGFUZXh0dXJlRW50cnkucHJvdG90eXBlLnNldEltYWdlRGF0YSA9IGZ1bmN0aW9uKHYpIHtcclxuICAgIHRoaXMuX3VwZGF0ZUltYWdlRGF0YSh2KTtcclxuICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9WQUxVRSk7XHJcbiAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG59O1xyXG5cclxuSW1hZ2VEYXRhVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ltYWdlRGF0YSAmJiB0aGlzLl9pbWFnZURhdGEud2lkdGggfHwgMDtcclxufTtcclxuXHJcbkltYWdlRGF0YVRleHR1cmVFbnRyeS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW1hZ2VEYXRhICYmIHRoaXMuX2ltYWdlRGF0YS5oZWlnaHQgfHwgMDtcclxufTtcclxuXHJcbi8qKiBAcmV0dXJuIHtJbWFnZURhdGF9ICovXHJcbkltYWdlRGF0YVRleHR1cmVFbnRyeS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbWFnZURhdGE7XHJcbn07XHJcblxyXG4vKiogQHJldHVybiB7U2FtcGxlckNvbmZpZ30gKi9cclxuSW1hZ2VEYXRhVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5nZXRTYW1wbGVyQ29uZmlnID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLl9zYW1wbGVyQ29uZmlnO1xyXG59O1xyXG5cclxuLyoqIEByZXR1cm4ge251bWJlcn0gKi9cclxuSW1hZ2VEYXRhVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIDE7XHJcbn07XHJcbkltYWdlRGF0YVRleHR1cmVFbnRyeS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5cclxuLyoqIEByZXR1cm4ge251bWJlcn0gKi9cclxuSW1hZ2VEYXRhVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5nZXRJdGVyYXRlQ291bnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAxO1xyXG59O1xyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIERhdGFDaGFuZ2VOb3RpZmllclxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4vKipcclxuICogVXNlZCB0byBsaXN0ZW4gdG8gbW9kaWZpY2F0aW9ucyBvZiBhbnkgRGF0YUVudHJ5IGNvbm5lY3RlZCB0byBhbiBYZmxvdyBncmFwaC5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgRGF0YUNoYW5nZU5vdGlmaWVyID0ge1xyXG4gICAgX2xpc3RlbmVyczogW11cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKERhdGFFbnRyeSwgQy5EQVRBX0VOVFJZX1NUQVRFKX0gY2FsbGJhY2tcclxuICovXHJcbkRhdGFDaGFuZ2VOb3RpZmllci5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKERhdGFFbnRyeSwgQy5EQVRBX0VOVFJZX1NUQVRFKX0gY2FsbGJhY2tcclxuICovXHJcbkRhdGFDaGFuZ2VOb3RpZmllci5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuICAgIEFycmF5LmVyYXNlKHRoaXMuX2xpc3RlbmVycywgY2FsbGJhY2spO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7RGF0YUVudHJ5fSBkYXRhRW50cnlcclxuICogQHBhcmFtIHtDLkRBVEFfRU5UUllfU1RBVEV9IG5vdGlmaWNhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKGRhdGFFbnRyeSwgbm90aWZpY2F0aW9uKXtcclxuICAgIHZhciBpO1xyXG4gICAgLy8gR2xvYmFsIG5vdGlmaWNhdGlvbnNcclxuICAgIGZvcihpID0gMDsgaSA8IERhdGFDaGFuZ2VOb3RpZmllci5fbGlzdGVuZXJzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICBEYXRhQ2hhbmdlTm90aWZpZXIuX2xpc3RlbmVyc1tpXShkYXRhRW50cnksIG5vdGlmaWNhdGlvbik7XHJcbiAgICB9XHJcbiAgICAvLyBJbnRlcm5hbCBhbmQgZXh0ZXJuYWwgbGlzdGVuZXJzXHJcbiAgICBmb3IoaSA9IDA7IGkgPCBkYXRhRW50cnkuX2xpc3RlbmVycy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgZGF0YUVudHJ5Ll9saXN0ZW5lcnNbaV0oZGF0YUVudHJ5LCBub3RpZmljYXRpb24pO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIERhdGFFbnRyeTogRGF0YUVudHJ5LFxyXG4gICAgQnVmZmVyRW50cnk6IEJ1ZmZlckVudHJ5LFxyXG4gICAgVGV4dHVyZUVudHJ5OiBUZXh0dXJlRW50cnksXHJcbiAgICBJbWFnZURhdGFUZXh0dXJlRW50cnk6IEltYWdlRGF0YVRleHR1cmVFbnRyeSxcclxuICAgIFNhbXBsZXJDb25maWc6IFNhbXBsZXJDb25maWcsXHJcbiAgICBEYXRhQ2hhbmdlTm90aWZpZXI6IERhdGFDaGFuZ2VOb3RpZmllclxyXG59O1xyXG4iLCJ2YXIgQyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIE1hcHBpbmcgPSByZXF1aXJlKFwiLi8uLi9wcm9jZXNzaW5nL21hcHBpbmcuanNcIik7XHJcbnJlcXVpcmUoXCIuLi8uLi91dGlscy9hcnJheS5qc1wiKTtcclxuXHJcbnZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XHJcbnZhciBDaGFubmVsTm9kZSA9IHJlcXVpcmUoXCIuLi9wcm9jZXNzaW5nL2NoYW5uZWwtbm9kZS5qc1wiKS5DaGFubmVsTm9kZTtcclxudmFyIFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL3V0aWxzLmpzXCIpO1xyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIEdyYXBoTm9kZVxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBvdGhlciBncmFwaCBub2Rlc1xyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGFic3RyYWN0XHJcbiAqIEBwYXJhbSB7R3JhcGh9IGdyYXBoIFJlZmVyZW5jZSB0byBwYXJlbnQgZ3JhcGhcclxuICovXHJcbnZhciBHcmFwaE5vZGUgPSBmdW5jdGlvbigpe1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgbm9kZXMgdGhhdCBhZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgbm9kZVxyXG4gICAgICogQHR5cGUgYXJyYXk8R3JhcGhOb2RlPlxyXG4gICAgICoqL1xyXG4gICAgdGhpcy5fcGFyZW50cyA9IFtdO1xyXG59O1xyXG5cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBJbnB1dE5vZGVcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vKipcclxuICogQW4gSW5wdXROb2RlIGluY2x1ZGUgYW4gRGF0YUVudHJ5LCBhIG5hbWUgYW5kIG90aGVyIGluZm9ybWF0aW9uXHJcbiAqIFRoaXMgY2xhc3MgbWlycm9ycyBYTUwzRCBlbGVtZW50cyBzdWNoIGFzIDxmbG9hdDM+LCA8aW50PiBvciA8dGV4dHVyZT5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7R3JhcGh9IGdyYXBoXHJcbiAqIEBleHRlbmRzIHtHcmFwaE5vZGV9XHJcbiAqL1xyXG52YXIgSW5wdXROb2RlID0gZnVuY3Rpb24oKXtcclxuICAgIEdyYXBoTm9kZS5jYWxsKHRoaXMpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYW1lIG9mIHRoZSBpbnB1dCBub2RlXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fbmFtZSA9IFwiXCI7XHJcbiAgICAvKipcclxuICAgICAqIFNlcXVlbmNlIGtleVxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2tleSA9IDA7XHJcbiAgICAvKipcclxuICAgICAqIERhdGFFbnRyeSBub2RlIHRoYXQgaG9sZHMgdGhlIHZhbHVlXHJcbiAgICAgKiBAdHlwZSB7RGF0YUVudHJ5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9kYXRhID0gbnVsbDtcclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhpcyBub2RlcyBpcyBhIHBhcmFtZXRlciB3aXRoaW4gYSA8ZGF0YWZsb3c+XHJcbiAgICAgKiB0aGlzIGlzIHNldCB0byB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLCBvdGhlcndpc2UgbnVsbFxyXG4gICAgICogQHR5cGUge251bGx8U3RyaW5nfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fcGFyYW1OYW1lID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4cGVyaW1lbnRhbCEgQXBwbHkgZGlmZmVyZW50IG92ZXJyaWRlIGxvZ2ljIGluIG9yZGVyXHJcbiAgICAgKiB0byBwcm9wYWdhdGUgZ2xvYmFsIHBhcmFtZXRlcnMgdG8gdGhlIHNvdXJjZSBvZiB0aGUgZ3JhcGhcclxuICAgICAqIENvdWxkIGJlIHVzZWQgZm9yIGluc3RhbmNlIGZvciBMT0QgY29uY2VwdHMsIHdoZXJlIHRoZVxyXG4gICAgICogcmVuZGVyZXIgcHJvcGFnYXRlcyB0aGUgZGlzdGFuY2UgYWxvbmcgdGhlIGdyYXBoXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3BhcmFtR2xvYmFsID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ2FjaGUgbGlzdGVuZXIgZm9yIERhdGFFbnRyeVxyXG4gICAgICogIEBzZWUge0lucHV0Tm9kZS5vbkRhdGFDaGFuZ2V9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2RhdGFMaXN0ZW5lciA9IHRoaXMub25EYXRhQ2hhbmdlLmJpbmQodGhpcyk7XHJcbn07XHJcbkJhc2UuY3JlYXRlQ2xhc3MoSW5wdXROb2RlLCBHcmFwaE5vZGUpO1xyXG5cclxuLyoqXHJcbiAqIFByb3BhZ2F0ZSBldmVudHMgZnJvbSBEYXRhRW50cnkgdG8gcGFyZW50IG5vZGVzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZVxyXG4gKiBAcGFyYW0ge0MuREFUQV9FTlRSWV9TVEFURX0gbm90aWZpY2F0aW9uXHJcbiAqL1xyXG5JbnB1dE5vZGUucHJvdG90eXBlLm9uRGF0YUNoYW5nZSA9IGZ1bmN0aW9uKG5ld1ZhbHVlLCBub3RpZmljYXRpb24pIHtcclxuICAgIHZhciBkb3duTm90ZTtcclxuICAgIHN3aXRjaChub3RpZmljYXRpb24pe1xyXG4gICAgICAgIGNhc2UgQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfVkFMVUU6IGRvd25Ob3RlID0gQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9EQVRBX1ZBTFVFOyBicmVhaztcclxuICAgICAgICBjYXNlIEMuREFUQV9FTlRSWV9TVEFURS5MT0FEX1NUQVJUOiBkb3duTm90ZSA9IEMuUkVTVUxUX1NUQVRFLklNQUdFX0xPQURfU1RBUlQ7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQy5EQVRBX0VOVFJZX1NUQVRFLkxPQURfRU5EOiBkb3duTm90ZSA9IEMuUkVTVUxUX1NUQVRFLklNQUdFX0xPQURfRU5EOyBicmVhaztcclxuICAgICAgICBjYXNlIEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1NJWkVfVFlQRTogZG93bk5vdGUgPSBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9TSVpFOiBkb3duTm90ZSA9IEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfREFUQV9TSVpFOyBicmVhaztcclxuICAgICAgICBkZWZhdWx0OiBkb3duTm90ZSA9IEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfREFUQV9TSVpFOyBicmVhaztcclxuICAgIH1cclxuICAgIG5vdGlmeVBhcmVudHNPbkNoYW5nZWQodGhpcyxkb3duTm90ZSk7XHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5wdXROb2RlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcclxuICAgIC8qKiBAcGFyYW0ge3N0cmluZ30gdiAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcclxuICAgICAgICB0aGlzLl9uYW1lID0gdjtcclxuICAgICAgICBub3RpZnlQYXJlbnRzT25DaGFuZ2VkKHRoaXMsIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcclxuICAgICAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG4gICAgfSxcclxuICAgIC8qKiBAcmV0dXJuIHtzdHJpbmd9ICovXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9uYW1lOyB9XHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KElucHV0Tm9kZS5wcm90b3R5cGUsIFwia2V5XCIsIHtcclxuICAgIC8qKiBAcGFyYW0ge251bWJlcn0gdiAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcclxuICAgICAgICB0aGlzLl9rZXkgPSB2O1xyXG4gICAgICAgIG5vdGlmeVBhcmVudHNPbkNoYW5nZWQodGhpcywgQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbiAgICB9LFxyXG4gICAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2tleTsgfVxyXG59KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnB1dE5vZGUucHJvdG90eXBlLCBcInBhcmFtTmFtZVwiLCB7XHJcbiAgICAvKiogQHBhcmFtIHtzdHJpbmd9IHYgKi9cclxuICAgIHNldDogZnVuY3Rpb24odil7XHJcbiAgICAgICAgdGhpcy5fcGFyYW1OYW1lID0gdjtcclxuICAgICAgICBub3RpZnlQYXJlbnRzT25DaGFuZ2VkKHRoaXMsIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcclxuICAgICAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG4gICAgfSxcclxuICAgIC8qKiBAcmV0dXJuIHtzdHJpbmd9ICovXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9wYXJhbU5hbWU7IH1cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5wdXROb2RlLnByb3RvdHlwZSwgXCJwYXJhbUdsb2JhbFwiLCB7XHJcbiAgICAvKiogQHBhcmFtIHtib29sZWFufSB2ICovXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHRoaXMuX3BhcmFtR2xvYmFsID0gdjtcclxuICAgICAgICBub3RpZnlQYXJlbnRzT25DaGFuZ2VkKHRoaXMsIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcclxuICAgICAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG4gICAgfSxcclxuICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fcGFyYW1HbG9iYWw7IH1cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5wdXROb2RlLnByb3RvdHlwZSwgXCJkYXRhXCIsIHtcclxuICAgIC8qKiBAcGFyYW0ge0RhdGFFbnRyeX0gZGF0YUVudHJ5ICovXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKGRhdGFFbnRyeSl7XHJcbiAgICAgICAgdmFyIHByZXZEYXRhTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmKHRoaXMuX2RhdGEpIHtcclxuICAgICAgICAgICAgcHJldkRhdGFMb2FkaW5nID0gdGhpcy5fZGF0YS5fbG9hZGluZztcclxuICAgICAgICAgICAgdGhpcy5fZGF0YS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9kYXRhTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YUVudHJ5O1xyXG4gICAgICAgIGlmKHRoaXMuX2RhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YS5hZGRMaXN0ZW5lcih0aGlzLl9kYXRhTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihwcmV2RGF0YUxvYWRpbmcgIT0gdGhpcy5fZGF0YS5fbG9hZGluZyl7XHJcbiAgICAgICAgICAgIG5vdGlmeVBhcmVudHNPbkNoYW5nZWQodGhpcywgdGhpcy5fZGF0YS5fbG9hZGluZyA/IEMuUkVTVUxUX1NUQVRFLklNQUdFX0xPQURfU1RBUlQgOlxyXG4gICAgICAgICAgICAgICAgQy5SRVNVTFRfU1RBVEUuSU1BR0VfTE9BRF9FTkQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG4gICAgfSxcclxuICAgIC8qKiBAcmV0dXJuIHtEYXRhRW50cnl9ICovXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9kYXRhOyB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEdldHRlciBmb3IgbG9jYWwgcGFyYW1ldGVyIG5hbWUsIHJldHVybnMgbnVsbCBpZiB0aGlzIGlzIGEgZ2xvYmFsXHJcbiAqIHBhcmFtZXRlclxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bnVsbHxTdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5JbnB1dE5vZGUucHJvdG90eXBlLl9nZXRQYXJhbU5hbWVzID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLl9wYXJhbUdsb2JhbCA/IG51bGwgOiB0aGlzLl9wYXJhbU5hbWU7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0dGVyIGZvciBnbG9iYWwgcGFyYW1ldGVyIG5hbWUsIHJldHVybnMgbnVsbCBpZiB0aGlzIGlzIG5vdCBhIGdsb2JhbFxyXG4gKiBwYXJhbWV0ZXJcclxuICpcclxuICogQHJldHVybnMge251bGx8U3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuSW5wdXROb2RlLnByb3RvdHlwZS5fZ2V0R2xvYmFsUGFyYW1OYW1lcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5fcGFyYW1HbG9iYWwgPyB0aGlzLl9wYXJhbU5hbWUgOiBudWxsO1xyXG59O1xyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIERhdGFOb2RlXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG52YXIgY194Zmxvd05vZGVJZCA9IDA7XHJcbmZ1bmN0aW9uIGdldFhmbG93Tm9kZUlkKCl7XHJcbiAgICByZXR1cm4gKytjX3hmbG93Tm9kZUlkO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIERhdGFOb2RlIGlzIHRoZSBjZW50cmFsIHN0cnVjdHVyZSBvZiBhbiBYZmxvdyBHcmFwaC5cclxuICogSXQgaXMgdXNlZCB0byBidWlsZCBhIGRhdGEgY29tcG9zaXRpb24gZ3JhcGggYXMgd2VsbCBhcyBhIGRhdGEgZmxvdy5cclxuICogSXQgbWlycm9yIHRoZSA8ZGF0YT4gZWxlbWVudCBvZiBYTUwzRFxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtHcmFwaH0gZ3JhcGggQ29udGV4dCBncmFwaFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGF0YUZsb3cgaXMgdGhpcyBub2RlIGEgZGF0YWZsb3dcclxuICogQGV4dGVuZHMge0dyYXBoTm9kZX1cclxuICovXHJcbnZhciBEYXRhTm9kZSA9IGZ1bmN0aW9uKGlzRGF0YUZsb3cpe1xyXG4gICAgR3JhcGhOb2RlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXJrZXIsIGlmIHRoaXMgZGF0YSBub2RlIGlzIGV4cGVjdGluZyBkYXRhLiBYZmxvd1xyXG4gICAgICogaXMgbm90IG1vbml0b3JpbmcgYW55IGxvYWQgZXZlbnRzLiBUaGlzIG11c3QgYmUgc2V0XHJcbiAgICAgKiBmcm9tIGV4dGVybmFsXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwZXJpbWVudGFsISBQcmlvcml0eS4gSG93IGltcG9ydGFudCBpcyB0aGlzIGRhdGE/XHJcbiAgICAgKiAwOiBWZXJ5IGltcG9ydGFudFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fbG9hZExldmVsID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIGxvYWRpbmcgZXZlbnRzOiBJZiBwcm9ncmVzcyBsZXZlbFxyXG4gICAgICogcmVhY2hlcyBpbmZpbml0eSwgbG9hZGluZyBldmVudHMgYXJlIHRyaWdnZXJlZFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fcHJvZ3Jlc3NMZXZlbCA9IEluZmluaXR5O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2xvYmFsbHkgdW5pcXVlIGlkXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaWQgPSBnZXRYZmxvd05vZGVJZCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhpcyBub2RlIGEgcHJvdG8gbm9kZVxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2lzUHJvdG9Ob2RlID0gaXNEYXRhRmxvdztcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoaWxkcmVuLiBJbnB1dE5vZGVzIGFuZCBEYXRhTm9kZXMgKGFzIGZvdW5kIGluIERPTSlcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBEYXRhTm9kZSB0aGF0IGhhcyBiZWVuIHJlZmVyZW5jZSB2aWEgc3JjXHJcbiAgICAgKiBAdHlwZSB7RGF0YU5vZGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3NvdXJjZU5vZGUgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmllbGQgdG8gYXR0YWNoIGN1c3RvbSBkYXRhXHJcbiAgICAgKiBAdHlwZSB7bnVsbHxPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3VzZXJEYXRhID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmaWx0ZXIgdHlwZSBvZiB0aGlzIG5vZGUgKGtlZXAsIHJlbmFtZSwgcmVtb3ZlIC4uLilcclxuICAgICAqIEB0eXBlIHtEQVRBX0ZJTFRFUl9UWVBFfVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9maWx0ZXJUeXBlID0gQy5EQVRBX0ZJTFRFUl9UWVBFLk5PTkU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmUgdGhlIG1hcHBpbmdcclxuICAgICAqIEB0eXBlIHtNYXBwaW5nLk1hcHBpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2ZpbHRlck1hcHBpbmcgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RyaW5nIGlkZW50aWZpZXIgZm9yIG9wZXJhdG9yXHJcbiAgICAgKiBUT0RPOiBPcGVyYXRvciBjbGFzc1xyXG4gICAgICogQHR5cGUge3N0cmluZ3xPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2NvbXB1dGVPcGVyYXRvciA9IFwiXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcnVlLCBpZiBjb21wdXRlIGlzIGEgZGF0YWZsb3cgcmVmZXJlbmNlXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fY29tcHV0ZVVzZXNEYXRhZmxvdyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcGluZyBmb3IgaW5wdXQgb2Ygb3BlcmF0b3IsXHJcbiAgICAgKiBlLmcuIChwb3NpdGlvbiwgdGV4Y29vcmQpIG9yICh7cG9zaXRpb246IHBvcywgdGV4Y29vcmQ6IHV2fSlcclxuICAgICAqIEB0eXBlIHtNYXBwaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9jb21wdXRlSW5wdXRNYXBwaW5nID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHBpbmcgZm9yIG91dHB1dCBvZiBvcGVyYXRvcixcclxuICAgICAqIGUuZy4gKHBvc2l0aW9uLCB0ZXhjb29yZCkgPSAuLi4gb3Ige3Bvc2l0aW9uOiBwb3MsIHRleGNvb3JkOiB1dn0gPSAuLi5cclxuICAgICAqIEB0eXBlIHtNYXBwaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9jb21wdXRlT3V0cHV0TWFwcGluZyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBkYXRhZmxvdyBub2RlIGhhcyBiZWVuIHJlc29sdmVkLCB0aGlzXHJcbiAgICAgKiBlbnRyeSBpcyBzZXRcclxuICAgICAqIEB0eXBlIHtEYXRhTm9kZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fZGF0YWZsb3dOb2RlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIChvcHRpbWl6ZWQpIHZlcnNpb24gb2YgdGhpcyBkYXRhIG5vZGVcclxuICAgICAqIEB0eXBlIHtDaGFubmVsTm9kZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fY2hhbm5lbE5vZGUgPSBuZXcgQ2hhbm5lbE5vZGUodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgb2YgY2FjaGVkIGNoYW5uZWwgbm9kZXMgZm9yIGRhdGFmbG93IGluc3RhbmNlcyB3aXRoIHZhcnlpbmdcclxuICAgICAqIGlucHV0IGFyZ3VtZW50cyAoc3BlY2lhbGl6ZWQgbm9kZXMpXHJcbiAgICAgKiBUT0RPOiBVc2UgV2Vha01hcD9cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgQ2hhbm5lbE5vZGU+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9zdWJzdGl0dXRpb25Ob2RlcyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FjaGVkIHZlcnNpb24gb2YgbG9jYWwgcGFyYW0gbmFtZXMgY29sbGVjdGVkIGZyb21cclxuICAgICAqIGNoaWxkcmVuXHJcbiAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3BhcmFtTmFtZXMgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FjaGVkIHZlcnNpb24gb2YgZ2xvYmFsIHBhcmFtIG5hbWVzIGNvbGxlY3RlZCBmcm9tXHJcbiAgICAgKiBjaGlsZHJlblxyXG4gICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9nbG9iYWxQYXJhbU5hbWVzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBsYXRmb3JtLCB0aGlzIGRhdGEgbm9kZSBzaG91bGQgYmUgZXhlY3V0ZWQgb25cclxuICAgICAqIFRPRE86IFRoaXMgc2hvdWxkIGJlIGltcGxpY2l0LCBub3QgZXhwbGljaXRcclxuICAgICAqIEB0eXBlIHtudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9wbGF0Zm9ybSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnNlcnZlcnMgb2YgdGhlIG5vZGUncyBDLlJFU1VMVF9TVEFURVxyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9ic2VydmVycyBvZiB0aGUgbm9kZSdzIHByb2dyZXNzIGxldmVsXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xvYWRMaXN0ZW5lcnMgPSBbXTtcclxuXHJcbn07XHJcbkJhc2UuY3JlYXRlQ2xhc3MoRGF0YU5vZGUsIEdyYXBoTm9kZSk7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFOb2RlLnByb3RvdHlwZSwgXCJzb3VyY2VOb2RlXCIsIHtcclxuICAgIC8qKiBAcGFyYW0gez9EYXRhTm9kZX0gbmV3U291cmNlTm9kZSAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbihuZXdTb3VyY2VOb2RlKXtcclxuICAgICAgICByZXBsYWNlTm9kZUluSGllcmFyY2h5KHRoaXMsIFwiX3NvdXJjZU5vZGVcIiwgbmV3U291cmNlTm9kZSk7XHJcbiAgICAgICAgdXBkYXRlUHJvZ3Jlc3NMZXZlbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm5vdGlmeShDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxuICAgIH0sXHJcbiAgICAvKiogQHJldHVybiB7P0RhdGFOb2RlfSAqL1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fc291cmNlTm9kZTsgfVxyXG59KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTm9kZS5wcm90b3R5cGUsIFwiZGF0YWZsb3dOb2RlXCIsIHtcclxuICAgIC8qKiBAcGFyYW0gez9EYXRhTm9kZX0gbmV3RGF0YWZsb3dOb2RlICovXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKG5ld0RhdGFmbG93Tm9kZSl7XHJcbiAgICAgICAgaWYobmV3RGF0YWZsb3dOb2RlICYmICF0aGlzLl9jb21wdXRlVXNlc0RhdGFmbG93KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgZGF0YWZsb3dOb2RlIHdoZW4gY29tcHV0ZSBkb2Vzbid0IHVzZSBkYXRhZmxvdy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcGxhY2VOb2RlSW5IaWVyYXJjaHkodGhpcywgXCJfZGF0YWZsb3dOb2RlXCIsIG5ld0RhdGFmbG93Tm9kZSk7XHJcbiAgICAgICAgdXBkYXRlUHJvZ3Jlc3NMZXZlbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm5vdGlmeShDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxuICAgIH0sXHJcbiAgICAvKiogQHJldHVybiB7P0RhdGFOb2RlfSAqL1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fZGF0YWZsb3dOb2RlOyB9XHJcbn0pO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTm9kZS5wcm90b3R5cGUsIFwidXNlckRhdGFcIiwge1xyXG4gICAgLyoqIEBwYXJhbSB7P0RhdGFOb2RlfSB2ICovXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHRoaXMuX3VzZXJEYXRhID0gdjtcclxuICAgIH0sXHJcbiAgICAvKiogQHJldHVybiB7P0RhdGFOb2RlfSAqL1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fdXNlckRhdGE7IH1cclxufSk7XHJcblxyXG4vKipcclxuICogU2V0IChmcm9tIGV4dGVybmFsKSBpZiBtb3JlIGRhdGEgaXMgZXhwZWN0ZWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9hZGluZ1xyXG4gKi9cclxuRGF0YU5vZGUucHJvdG90eXBlLnNldExvYWRpbmcgPSBmdW5jdGlvbihsb2FkaW5nKXtcclxuICAgIGlmKHRoaXMuX2xvYWRpbmcgIT0gbG9hZGluZyl7XHJcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IGxvYWRpbmc7XHJcbiAgICAgICAgdGhpcy5fY2hhbm5lbE5vZGUuc2V0U3RydWN0dXJlT3V0T2ZTeW5jKCk7XHJcbiAgICAgICAgdGhpcy5fY2hhbm5lbE5vZGUubG9hZGluZyA9IGxvYWRpbmc7XHJcbiAgICAgICAgZm9yICh2YXIgc3ViIGluIHRoaXMuX3N1YnN0aXR1dGlvbk5vZGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBzdWJOb2RlID0gdGhpcy5fc3Vic3RpdHV0aW9uTm9kZXNbc3ViXTtcclxuICAgICAgICAgICAgc3ViTm9kZS5zZXRTdHJ1Y3R1cmVPdXRPZlN5bmMoKTtcclxuICAgICAgICAgICAgc3ViTm9kZS5sb2FkaW5nID0gbG9hZGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlUHJvZ3Jlc3NMZXZlbCh0aGlzKTtcclxuICAgICAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgaWYgdGhpcyBvciBhbnkgY2hpbGQgbm9kZSBpcyBsb2FkaW5nXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuRGF0YU5vZGUucHJvdG90eXBlLmlzU3VidHJlZUxvYWRpbmcgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuX3Byb2dyZXNzTGV2ZWwgPT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gKi9cclxuRGF0YU5vZGUucHJvdG90eXBlLmdldFByb2dyZXNzTGV2ZWwgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuX3Byb2dyZXNzTGV2ZWw7XHJcbn07XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFOb2RlLnByb3RvdHlwZSwgXCJmaWx0ZXJUeXBlXCIsIHtcclxuICAgIC8qKiBAcGFyYW0ge0MuREFUQV9GSUxURVJfVFlQRX0gdiAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcclxuICAgICAgICB0aGlzLl9maWx0ZXJUeXBlID0gdjtcclxuICAgICAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbiAgICB9LFxyXG4gICAgLyoqIEByZXR1cm4ge0MuREFUQV9GSUxURVJfVFlQRX0gKi9cclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2ZpbHRlclR5cGU7IH1cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YU5vZGUucHJvdG90eXBlLCBcImZpbHRlck1hcHBpbmdcIiwge1xyXG4gICAgLyoqIEBwYXJhbSB7TWFwcGluZ30gdiAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcclxuICAgICAgICBzd2FwTWFwcGluZyh0aGlzLCBcIl9maWx0ZXJNYXBwaW5nXCIsIHYpO1xyXG4gICAgICAgIHRoaXMubm90aWZ5KCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxuICAgIH0sXHJcbiAgICAvKiogQHJldHVybiB7TWFwcGluZ30gKi9cclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2ZpbHRlck1hcHBpbmc7IH1cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YU5vZGUucHJvdG90eXBlLCBcImNvbXB1dGVPcGVyYXRvclwiLCB7XHJcbiAgICAvKiogQHBhcmFtIHtzdHJpbmd9IHYgKi9cclxuICAgIHNldDogZnVuY3Rpb24odil7XHJcbiAgICAgICAgdGhpcy5fY29tcHV0ZU9wZXJhdG9yID0gdjtcclxuICAgICAgICB0aGlzLl9jb21wdXRlVXNlc0RhdGFmbG93ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ub3RpZnkoIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcclxuICAgICAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG4gICAgfSxcclxuICAgIC8qKiBAcmV0dXJuIHtzdHJpbmd9ICovXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9jb21wdXRlVXNlc0RhdGFmbG93ID8gbnVsbCA6IHRoaXMuX2NvbXB1dGVPcGVyYXRvcjsgfVxyXG59KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTm9kZS5wcm90b3R5cGUsIFwiY29tcHV0ZURhdGFmbG93VXJsXCIsIHtcclxuICAgIC8qKiBAcGFyYW0ge3N0cmluZ30gdiAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcclxuICAgICAgICB0aGlzLl9jb21wdXRlT3BlcmF0b3IgPSB2O1xyXG4gICAgICAgIHRoaXMuX2NvbXB1dGVVc2VzRGF0YWZsb3cgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubm90aWZ5KCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxuICAgIH0sXHJcbiAgICAvKiogQHJldHVybiB7c3RyaW5nfSAqL1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fY29tcHV0ZVVzZXNEYXRhZmxvdyA/IHRoaXMuX2NvbXB1dGVPcGVyYXRvciA6IG51bGw7IH1cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YU5vZGUucHJvdG90eXBlLCBcImNvbXB1dGVJbnB1dE1hcHBpbmdcIiwge1xyXG4gICAgLyoqIEBwYXJhbSB7TWFwcGluZ30gdiAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcclxuICAgICAgICBzd2FwTWFwcGluZyh0aGlzLCBcIl9jb21wdXRlSW5wdXRNYXBwaW5nXCIsIHYpO1xyXG4gICAgICAgIHRoaXMubm90aWZ5KCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxuICAgIH0sXHJcbiAgICAvKiogQHJldHVybiB7TWFwcGluZ30gKi9cclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2NvbXB1dGVJbnB1dE1hcHBpbmc7IH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTm9kZS5wcm90b3R5cGUsIFwiY29tcHV0ZU91dHB1dE1hcHBpbmdcIiwge1xyXG4gICAgLyoqIEBwYXJhbSB7TWFwcGluZ30gdiAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcclxuICAgICAgICBzd2FwTWFwcGluZyh0aGlzLCBcIl9jb21wdXRlT3V0cHV0TWFwcGluZ1wiLCB2KTtcclxuICAgICAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbiAgICB9LFxyXG4gICAgLyoqIEByZXR1cm4ge01hcHBpbmd9ICovXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9jb21wdXRlT3V0cHV0TWFwcGluZzsgfVxyXG59KTtcclxuXHJcbi8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xyXG5EYXRhTm9kZS5wcm90b3R5cGUuaXNQcm90b05vZGUgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuX2lzUHJvdG9Ob2RlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7R3JhcGhOb2RlfSBjaGlsZFxyXG4gKi9cclxuRGF0YU5vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24oY2hpbGQpe1xyXG4gICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICBhZGRQYXJlbnQodGhpcywgY2hpbGQpO1xyXG4gICAgdXBkYXRlUHJvZ3Jlc3NMZXZlbCh0aGlzKTtcclxuICAgIHRoaXMubm90aWZ5KCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG59O1xyXG4vKipcclxuICogQHBhcmFtIHtHcmFwaE5vZGV9IGNoaWxkXHJcbiAqL1xyXG5EYXRhTm9kZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCl7XHJcbiAgICBBcnJheS5lcmFzZSh0aGlzLl9jaGlsZHJlbiwgY2hpbGQpO1xyXG4gICAgcmVtb3ZlUGFyZW50KHRoaXMsIGNoaWxkKTtcclxuICAgIHVwZGF0ZVByb2dyZXNzTGV2ZWwodGhpcyk7XHJcbiAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0dyYXBoTm9kZX0gY2hpbGRcclxuICogQHBhcmFtIHtHcmFwaE5vZGV9IGJlZm9yZU5vZGVcclxuICovXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbihjaGlsZCwgYmVmb3JlTm9kZSl7XHJcbiAgICB2YXIgaWR4ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihiZWZvcmVOb2RlKTtcclxuICAgIGlmKGlkeCA9PSAtMSlcclxuICAgICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgIGVsc2VcclxuICAgICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaWR4LCAwLCBjaGlsZCk7XHJcbiAgICBhZGRQYXJlbnQodGhpcywgY2hpbGQpO1xyXG4gICAgLy8gVE9ETzogTmV4dCB0aHJlZSBjYWxscyBvbiBhbGwgc3RydWN0dXJhbCBjaGFuZ2VzLiBBZGQgTWV0aG9kXHJcbiAgICB1cGRhdGVQcm9ncmVzc0xldmVsKHRoaXMpO1xyXG4gICAgdGhpcy5ub3RpZnkoIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcclxuICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogcmVtb3ZlIGFsbCBjaGlsZHJlbiBvZiB0aGUgRGF0YU5vZGVcclxuICovXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5jbGVhckNoaWxkcmVuID0gZnVuY3Rpb24oKXtcclxuICAgIGZvcih2YXIgaSA9MDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgKytpKXtcclxuICAgICAgICByZW1vdmVQYXJlbnQodGhpcywgdGhpcy5fY2hpbGRyZW5baV0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcclxuICAgIHVwZGF0ZVByb2dyZXNzTGV2ZWwodGhpcyk7XHJcbiAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxufTtcclxuXHJcbi8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xyXG4vKipcclxuICogRGV0YWNoIHRoaXMgRGF0YU5vZGUgZnJvbSBhbGwgY29ubmVjdGlvbnMsIGluY2x1ZGluZyBzb3VyY2UtIGFuZCBwcm90by1ub2RlIHJlZmVyZW5jZXNcclxuICovXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5kZXRhY2hGcm9tUGFyZW50cyA9IGZ1bmN0aW9uKCl7XHJcbiAgICBmb3IodmFyIGkgPTA7IGkgPCB0aGlzLl9wYXJlbnRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50c1tpXTtcclxuICAgICAgICBpZihwYXJlbnQuX3NvdXJjZU5vZGUgPT0gdGhpcylcclxuICAgICAgICAgICAgcGFyZW50LnNvdXJjZU5vZGUgPSBudWxsO1xyXG4gICAgICAgIGVsc2UgaWYocGFyZW50Ll9kYXRhZmxvd05vZGUgPT0gdGhpcyl7XHJcbiAgICAgICAgICAgIHBhcmVudC5kYXRhZmxvd05vZGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXRzIHBsYXRmb3JtIG9mIGEgRGF0YU5vZGUuIElmIF9wbGF0Zm9ybSBpcyBkZWZpbmVkLCBpdCB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHBsYXRmb3JtIHNldHRpbmcgb2ZcclxuICogYW4gWGZsb3cgZ3JhcGguXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfEMuUExBVEZPUk18bnVsbH0gcGxhdGZvcm1TcmNcclxuICovXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5zZXRQbGF0Zm9ybSA9IGZ1bmN0aW9uKHBsYXRmb3JtU3JjKSB7XHJcbiAgICBpZiAodHlwZW9mIHBsYXRmb3JtU3JjID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChwbGF0Zm9ybVNyYyA9PT0gXCJjbFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtID0gQy5QTEFURk9STS5DTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGxhdGZvcm1TcmMgPT09IFwiZ2xcIikge1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybSA9IEMuUExBVEZPUk0uR0xTTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGxhdGZvcm1TcmMgPT09IFwianNcIikge1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybSA9IEMuUExBVEZPUk0uSkFWQVNDUklQVDtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCFpc05hTihwYXJzZUZsb2F0KHBsYXRmb3JtU3JjKSkgJiYgaXNGaW5pdGUocGxhdGZvcm1TcmMpKSB7XHJcbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBwbGF0Zm9ybVNyYztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubm90aWZ5KEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcclxuICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQGNvbnN0XHJcbiAqL1xyXG52YXIgZmlsdGVyUGFyc2VyID0gL14oW0EtWmEtelxcc10qKVxcKChbXigpXSspXFwpJC87XHJcblxyXG4vKipcclxuICogU2V0IGZpbHRlciBieSBzdHJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IGZpbHRlclN0cmluZ1xyXG4gKi9cclxuRGF0YU5vZGUucHJvdG90eXBlLnNldEZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlclN0cmluZyl7XHJcbiAgICBmaWx0ZXJTdHJpbmcgPSBmaWx0ZXJTdHJpbmcgfHwgXCJcIjtcclxuICAgIHZhciBuZXdUeXBlID0gQy5EQVRBX0ZJTFRFUl9UWVBFLlJFTkFNRTtcclxuICAgIHZhciBuZXdNYXBwaW5nID0gbnVsbDtcclxuICAgIGlmKGZpbHRlclN0cmluZyl7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZpbHRlclN0cmluZy50cmltKCkubWF0Y2goZmlsdGVyUGFyc2VyKTtcclxuICAgICAgICBpZihyZXN1bHQpe1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHJlc3VsdFsxXS50cmltKCk7XHJcbiAgICAgICAgICAgIHN3aXRjaCh0eXBlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJrZWVwXCI6IG5ld1R5cGUgPSBDLkRBVEFfRklMVEVSX1RZUEUuS0VFUDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVtb3ZlXCI6IG5ld1R5cGUgPSBDLkRBVEFfRklMVEVSX1RZUEUuUkVNT1ZFOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZW5hbWVcIjogbmV3VHlwZSA9IEMuREFUQV9GSUxURVJfVFlQRS5SRU5BTUU7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBCYXNlLm5vdGlmeUVycm9yKFwiVW5rbm93biBmaWx0ZXIgdHlwZTpcIiArIHR5cGUsIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5ld01hcHBpbmcgPSBNYXBwaW5nLk1hcHBpbmcucGFyc2UocmVzdWx0WzJdLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgQmFzZS5ub3RpZnlFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBmaWx0ZXIgJ1wiICsgZmlsdGVyU3RyaW5nICsgXCInXCIsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmKCFuZXdNYXBwaW5nKXtcclxuICAgICAgICAvLyBUT0RPIFJlbW92ZSB0aGlzPyAoTWFwcGluZyBjYW4gYmUgbnVsbCBmcm9tIG5vdyBvbilcclxuICAgICAgICBuZXdNYXBwaW5nID0gbmV3IE1hcHBpbmcuT3JkZXJNYXBwaW5nKCk7XHJcbiAgICB9XHJcbiAgICBzd2FwTWFwcGluZyh0aGlzLCBcIl9maWx0ZXJNYXBwaW5nXCIsIG5ld01hcHBpbmcpO1xyXG4gICAgdGhpcy5fZmlsdGVyVHlwZSA9IG5ld1R5cGU7XHJcbiAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxufTtcclxuXHJcbnZhciBjb21wdXRlUGFyc2VyID0gL14oKFtePV0rKVxcPSk/KFteJyhdKygnW14nXSsnKT9bXicoXSspKFxcKChbXigpXSopP1xcKSk/JC87XHJcbnZhciBicmFja2V0c1BhcnNlciA9IC9eXFwoKFteKCldKilcXCkkLztcclxudmFyIGRhdGFmbG93UGFyc2VyID0gL15kYXRhZmxvd1xcWycoW14nXSspJ1xcXSQvO1xyXG5cclxuLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXHJcbi8qKlxyXG4gKiBJZiB0aGUgY29tcHV0ZSBzdHJpbmcgY29udGFpbnMgYSByZWZlcmVuY2UgdG8gYW4gZXh0ZXJuYWwgZGF0YWZsb3csXHJcbiAqIHRoZSBwYXJzZXIgcmV0dXJucyBpdHMgVVJMLiBOdWxsLCBvdGhlcndpc2VcclxuICogQHBhcmFtIGNvbXB1dGVTdHJpbmdcclxuICogQHJldHVybnMge3N0cmluZ3xudWxsfVxyXG4gKi9cclxudmFyIGdldENvbXB1dGVEYXRhZmxvd1VybCA9IGZ1bmN0aW9uKGNvbXB1dGVTdHJpbmcpe1xyXG4gICAgY29tcHV0ZVN0cmluZyA9IGNvbXB1dGVTdHJpbmcgfHwgXCJcIjtcclxuICAgIHZhciByZXN1bHQgPSBjb21wdXRlU3RyaW5nLnRyaW0oKS5tYXRjaChjb21wdXRlUGFyc2VyKTtcclxuICAgIGlmKHJlc3VsdCl7XHJcbiAgICAgICAgaWYocmVzdWx0ID0gcmVzdWx0WzNdLnRyaW0oKS5tYXRjaChkYXRhZmxvd1BhcnNlcikpe1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCBjb21wdXRlIGJ5IHN0cmluZ1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcHV0ZVN0cmluZ1xyXG4gKi9cclxuRGF0YU5vZGUucHJvdG90eXBlLnNldENvbXB1dGUgPSBmdW5jdGlvbihjb21wdXRlU3RyaW5nKXtcclxuICAgIGNvbXB1dGVTdHJpbmcgPSBjb21wdXRlU3RyaW5nIHx8IFwiXCI7XHJcbiAgICB2YXIgbmV3T3BlcmF0b3IgPSBcIlwiO1xyXG4gICAgdmFyIGlucHV0TWFwcGluZyA9IG51bGwsIG91dHB1dE1hcHBpbmcgPSBudWxsO1xyXG4gICAgdmFyIHJlc3VsdCA9IGNvbXB1dGVTdHJpbmcudHJpbSgpLm1hdGNoKGNvbXB1dGVQYXJzZXIpO1xyXG4gICAgaWYocmVzdWx0KXtcclxuICAgICAgICB2YXIgb3V0cHV0ID0gcmVzdWx0WzJdID8gcmVzdWx0WzJdLnRyaW0oKSA6IFwiXCI7XHJcbiAgICAgICAgbmV3T3BlcmF0b3IgPSByZXN1bHRbM10udHJpbSgpO1xyXG4gICAgICAgIHZhciBpbnB1dCA9IHJlc3VsdFs2XSA/IHJlc3VsdFs2XS50cmltKCkgOiBcIlwiO1xyXG4gICAgICAgIGlmKHJlc3VsdCA9IG91dHB1dC5tYXRjaChicmFja2V0c1BhcnNlcikpe1xyXG4gICAgICAgICAgICBvdXRwdXQgPSByZXN1bHRbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGlucHV0KVxyXG4gICAgICAgICAgICBpbnB1dE1hcHBpbmcgPSBNYXBwaW5nLk1hcHBpbmcucGFyc2UoaW5wdXQsIHRoaXMpO1xyXG4gICAgICAgIGlmKG91dHB1dClcclxuICAgICAgICAgICAgb3V0cHV0TWFwcGluZyA9IE1hcHBpbmcuTWFwcGluZy5wYXJzZShvdXRwdXQsIHRoaXMpO1xyXG5cclxuICAgICAgICBpZihyZXN1bHQgPSBuZXdPcGVyYXRvci5tYXRjaChkYXRhZmxvd1BhcnNlcikpe1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wdXRlVXNlc0RhdGFmbG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgbmV3T3BlcmF0b3IgPSByZXN1bHRbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVVc2VzRGF0YWZsb3cgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGF0YWZsb3dOb2RlID0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYoY29tcHV0ZVN0cmluZyl7XHJcbiAgICAgICAgQmFzZS5ub3RpZnlFcnJvcihcIkVycm9yIHBhcnNpbmcgQ29tcHV0ZSB2YWx1ZSAnXCIgKyBjb21wdXRlU3RyaW5nICsgXCInXCIsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgc3dhcE1hcHBpbmcodGhpcywgXCJfY29tcHV0ZUlucHV0TWFwcGluZ1wiLCBpbnB1dE1hcHBpbmcpO1xyXG4gICAgc3dhcE1hcHBpbmcodGhpcywgXCJfY29tcHV0ZU91dHB1dE1hcHBpbmdcIiwgb3V0cHV0TWFwcGluZyk7XHJcbiAgICB0aGlzLl9jb21wdXRlT3BlcmF0b3IgPSBuZXdPcGVyYXRvcjtcclxuICAgIHRoaXMubm90aWZ5KCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5vdGlmaWVzIERhdGFOb2RlIGFib3V0IGEgY2hhbmdlLiBOb3RpZmljYXRpb24gd2lsbCBiZSBmb3J3YXJkZWQgdG8gcGFyZW50cywgaWYgbmVjZXNzYXJ5XHJcbiAqIEBwYXJhbSB7Qy5SRVNVTFRfU1RBVEV9IGNoYW5nZVR5cGVcclxuICogQHBhcmFtIHtHcmFwaE5vZGU/fSBzZW5kZXJOb2RlXHJcbiAqL1xyXG5EYXRhTm9kZS5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24oY2hhbmdlVHlwZSwgc2VuZGVyTm9kZSl7XHJcbiAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcclxuICAgIHN3aXRjaChjaGFuZ2VUeXBlKSB7XHJcbiAgICAgICAgY2FzZSBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRTpcclxuICAgICAgICAgICAgdGhpcy5fcGFyYW1OYW1lcyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsb2JhbFBhcmFtTmFtZXMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9jaGFubmVsTm9kZS5zZXRTdHJ1Y3R1cmVPdXRPZlN5bmMoKTtcclxuICAgICAgICAgICAgY2xlYXJTdWJzdGl0dXRpb25Ob2Rlcyh0aGlzKTtcclxuICAgICAgICAgICAgbm90aWZ5UGFyZW50c09uQ2hhbmdlZCh0aGlzLCBjaGFuZ2VUeXBlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgQy5SRVNVTFRfU1RBVEUuSU1BR0VfTE9BRF9TVEFSVDpcclxuICAgICAgICBjYXNlIEMuUkVTVUxUX1NUQVRFLklNQUdFX0xPQURfRU5EOlxyXG4gICAgICAgICAgICB1cGRhdGVQcm9ncmVzc0xldmVsKHRoaXMpO1xyXG4gICAgICAgICAgICBpZihzZW5kZXJOb2RlKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5uZWxOb2RlLm5vdGlmeURhdGFDaGFuZ2Uoc2VuZGVyTm9kZSwgY2hhbmdlVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9EQVRBX1ZBTFVFOlxyXG4gICAgICAgIGNhc2UgQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9EQVRBX1NJWkU6XHJcbiAgICAgICAgICAgIGlmKHNlbmRlck5vZGUpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbm5lbE5vZGUubm90aWZ5RGF0YUNoYW5nZShzZW5kZXJOb2RlLCBjaGFuZ2VUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIC8vIEluZm9ybSBsaXN0ZW5lcnMgKGUuZy4gUmVxdWVzdHMpXHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2ldKGNoYW5nZVR5cGUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRGF0YU5vZGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpe1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpXHJcbn07XHJcblxyXG5EYXRhTm9kZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xyXG4gICAgQXJyYXkuZXJhc2UodGhpcy5fbGlzdGVuZXJzLCBsaXN0ZW5lcik7XHJcbn07XHJcblxyXG5EYXRhTm9kZS5wcm90b3R5cGUuYWRkTG9hZExpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpe1xyXG4gICAgdGhpcy5fbG9hZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxufTtcclxuXHJcbi8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xyXG5EYXRhTm9kZS5wcm90b3R5cGUucmVtb3ZlTG9hZExpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpe1xyXG4gICAgQXJyYXkuZXJhc2UodGhpcy5fbG9hZExpc3RlbmVycywgbGlzdGVuZXIpO1xyXG59O1xyXG5cclxuRGF0YU5vZGUucHJvdG90eXBlLl9jYWxsTG9hZExpc3RlbmVycyA9IGZ1bmN0aW9uKG5ld0xldmVsLCBvbGRMZXZlbCl7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5fbG9hZExpc3RlbmVycy5sZW5ndGg7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpe1xyXG4gICAgICAgIHRoaXMuX2xvYWRMaXN0ZW5lcnNbaV0odGhpcywgbmV3TGV2ZWwsIG9sZExldmVsKTtcclxuICAgIH1cclxufTtcclxuXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5nZXRPdXRwdXROYW1lcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gZ2V0Rm9yd2FyZE5vZGUodGhpcykuX2NoYW5uZWxOb2RlLmdldE91dHB1dE5hbWVzKCk7XHJcbn07XHJcblxyXG5EYXRhTm9kZS5wcm90b3R5cGUuZ2V0T3V0cHV0Q2hhbm5lbEluZm8gPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHJldHVybiBnZXRGb3J3YXJkTm9kZSh0aGlzKS5fY2hhbm5lbE5vZGUuZ2V0T3V0cHV0Q2hhbm5lbEluZm8obmFtZSk7XHJcbn07XHJcblxyXG4vL25vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcclxuRGF0YU5vZGUucHJvdG90eXBlLmdldFBhcmFtTmFtZXMgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuX2dldFBhcmFtTmFtZXMoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZWxlZ2F0ZSBjb21wdXRhdGlvbiBvZiB0aGUgcmVzdWx0IHRvIHRoZSBjaGFubmVsIG5vZGVcclxuICogb2YgdGhlIGZpcnN0IGNvbnRyaWJ1dGluZyBEYXRhTm9kZS5cclxuICogQHBhcmFtIHR5cGVcclxuICogQHBhcmFtIGZpbHRlclxyXG4gKiBAcmV0dXJucyB7UmVzdWx0fVxyXG4gKi9cclxuRGF0YU5vZGUucHJvdG90eXBlLl9nZXRSZXN1bHQgPSBmdW5jdGlvbih0eXBlLCBmaWx0ZXIpe1xyXG4gICAgcmV0dXJuIGdldEZvcndhcmROb2RlKHRoaXMsIGZpbHRlcikuX2NoYW5uZWxOb2RlLmdldFJlc3VsdCh0eXBlLCBmaWx0ZXIpO1xyXG59O1xyXG5cclxuRGF0YU5vZGUucHJvdG90eXBlLl9nZXRGb3J3YXJkTm9kZSA9IGZ1bmN0aW9uKGZpbHRlcil7XHJcbiAgICByZXR1cm4gZ2V0Rm9yd2FyZE5vZGUodGhpcywgZmlsdGVyKTtcclxufTtcclxuXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5fZ2V0UGFyYW1OYW1lcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICBpZighdGhpcy5fcGFyYW1OYW1lcyl7XHJcbiAgICAgICAgdGhpcy5fcGFyYW1OYW1lcyA9IFtdO1xyXG4gICAgICAgIGlmKHRoaXMuX3NvdXJjZU5vZGUpXHJcbiAgICAgICAgICAgIFV0aWxzLm5hbWVzZXQuYWRkKHRoaXMuX3BhcmFtTmFtZXMsIHRoaXMuX3NvdXJjZU5vZGUuX2dldFBhcmFtTmFtZXMoKSk7XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIFV0aWxzLm5hbWVzZXQuYWRkKHRoaXMuX3BhcmFtTmFtZXMsIHRoaXMuX2NoaWxkcmVuW2ldLl9nZXRQYXJhbU5hbWVzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX3BhcmFtTmFtZXM7XHJcbn07XHJcblxyXG5EYXRhTm9kZS5wcm90b3R5cGUuX2dldEdsb2JhbFBhcmFtTmFtZXMgPSBmdW5jdGlvbigpe1xyXG4gICAgaWYoIXRoaXMuX2dsb2JhbFBhcmFtTmFtZXMpe1xyXG4gICAgICAgIHRoaXMuX2dsb2JhbFBhcmFtTmFtZXMgPSBbXTtcclxuICAgICAgICBpZih0aGlzLl9kYXRhZmxvd05vZGUpXHJcbiAgICAgICAgICAgIFV0aWxzLm5hbWVzZXQuYWRkKHRoaXMuX2dsb2JhbFBhcmFtTmFtZXMsIHRoaXMuX2RhdGFmbG93Tm9kZS5fZ2V0R2xvYmFsUGFyYW1OYW1lcygpKTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5fc291cmNlTm9kZSlcclxuICAgICAgICAgICAgVXRpbHMubmFtZXNldC5hZGQodGhpcy5fZ2xvYmFsUGFyYW1OYW1lcywgdGhpcy5fc291cmNlTm9kZS5fZ2V0R2xvYmFsUGFyYW1OYW1lcygpKTtcclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgVXRpbHMubmFtZXNldC5hZGQodGhpcy5fZ2xvYmFsUGFyYW1OYW1lcywgdGhpcy5fY2hpbGRyZW5baV0uX2dldEdsb2JhbFBhcmFtTmFtZXMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fZ2xvYmFsUGFyYW1OYW1lcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N1YnN0aXR1dGlvbn0gc3Vic3RpdHV0aW9uXHJcbiAqIEByZXR1cm5zIHtDaGFubmVsTm9kZX1cclxuICovXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVDaGFubmVsTm9kZSA9IGZ1bmN0aW9uKHN1YnN0aXR1dGlvbil7XHJcbiAgICBpZighc3Vic3RpdHV0aW9uKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFubmVsTm9kZTtcclxuICAgIGVsc2V7XHJcbiAgICAgICAgdmFyIGtleSA9IHN1YnN0aXR1dGlvbi5nZXRLZXkodGhpcyk7XHJcbiAgICAgICAgaWYoIXRoaXMuX3N1YnN0aXR1dGlvbk5vZGVzW2tleV0pIHtcclxuICAgICAgICAgICAgdGhpcy5fc3Vic3RpdHV0aW9uTm9kZXNba2V5XSA9IG5ldyBDaGFubmVsTm9kZSh0aGlzLCBzdWJzdGl0dXRpb24pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1YnN0aXR1dGlvbk5vZGVzW2tleV0uaW5jcmVhc2VSZWYoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnN0aXR1dGlvbk5vZGVzW2tleV07XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIENoYW5uZWxOb2RlIHBhc3NlZCBhcyBhcmd1bWVudCBmcm9tIGludGVybmFsIHN1YnN0aXR1dGlvbiBub2Rlc1xyXG4gKiBEZWNyZWFzZXMgcmVmZXJlbmNlIGNvdW50ZXIgb2Ygc3Vic3RpdHV0aW9uIG5vZGUgYW5kIGRlbGV0ZXMgaXQgaWYgbm90XHJcbiAqIHVzZWQgYnkgYW55IG90aGVyIG5vZGUuXHJcbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IHN1YnN0aXR1dGlvbk5vZGVcclxuICovXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5fcmVtb3ZlU3Vic3RpdHV0aW9uTm9kZSA9IGZ1bmN0aW9uKHN1YnN0aXR1dGlvbk5vZGUpe1xyXG4gICAgdmFyIGtleSA9IHN1YnN0aXR1dGlvbk5vZGUuc3Vic3RpdHV0aW9uLmdldEtleSh0aGlzKTtcclxuICAgIGlmKHRoaXMuX3N1YnN0aXR1dGlvbk5vZGVzW2tleV0gJiYgdGhpcy5fc3Vic3RpdHV0aW9uTm9kZXNba2V5XS5kZWNyZWFzZVJlZigpKVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzdGl0dXRpb25Ob2Rlc1trZXldO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGxzIGNsZWFyIG9mIGFsbCBzdWJzdGl0dXRpb25Ob2RlcyBhbmQgY2xlYXJzIHRoZSBtYXBcclxuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YU5vZGVcclxuICovXHJcbmZ1bmN0aW9uIGNsZWFyU3Vic3RpdHV0aW9uTm9kZXMoZGF0YU5vZGUpe1xyXG4gICAgZm9yKHZhciBuYW1lIGluIGRhdGFOb2RlLl9zdWJzdGl0dXRpb25Ob2Rlcyl7XHJcbiAgICAgICAgZGF0YU5vZGUuX3N1YnN0aXR1dGlvbk5vZGVzW25hbWVdLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICBkYXRhTm9kZS5fc3Vic3RpdHV0aW9uTm9kZXMgPSB7fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNraXBzIG5vZGVzLCBpZiBpdCBkb2VzIG5vdCBjb250cmlidXRlIHRvIHRoZSByZXN1bHQgKG9wdGltaXphdGlvbilcclxuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YU5vZGVcclxuICogQHBhcmFtIHthcnJheS48c3RyaW5nPj99IGZpbHRlclxyXG4gKiBAcmV0dXJucyB7RGF0YU5vZGV9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRGb3J3YXJkTm9kZShkYXRhTm9kZSwgZmlsdGVyKXtcclxuICAgIHZhciBoYXNGaWx0ZXIgPSAoZGF0YU5vZGUuX2ZpbHRlck1hcHBpbmcgJiYgIWRhdGFOb2RlLl9maWx0ZXJNYXBwaW5nLmlzRW1wdHkoKSk7XHJcbiAgICBpZihoYXNGaWx0ZXIpXHJcbiAgICAgICAgcmV0dXJuIGRhdGFOb2RlO1xyXG5cclxuICAgIGlmKCFkYXRhTm9kZS5fY29tcHV0ZU9wZXJhdG9yICl7XHJcbiAgICAgICAgaWYoZGF0YU5vZGUuX3NvdXJjZU5vZGUgJiYgZGF0YU5vZGUuX2NoaWxkcmVuLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Rm9yd2FyZE5vZGUoZGF0YU5vZGUuX3NvdXJjZU5vZGUpO1xyXG4gICAgICAgIGlmKGRhdGFOb2RlLl9jaGlsZHJlbi5sZW5ndGggPT0gMSAmJiBkYXRhTm9kZS5fY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBEYXRhTm9kZSlcclxuICAgICAgICAgICAgcmV0dXJuIGdldEZvcndhcmROb2RlKGRhdGFOb2RlLl9jaGlsZHJlblswXSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlkeCA9IGRhdGFOb2RlLl9jaGFubmVsTm9kZS5nZXRDaGlsZERhdGFJbmRleChmaWx0ZXIpO1xyXG4gICAgaWYoaWR4ICE9IC0xICYmIGlkeCAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgIGlmKGRhdGFOb2RlLl9zb3VyY2VOb2RlKVxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Rm9yd2FyZE5vZGUoZGF0YU5vZGUuX3NvdXJjZU5vZGUpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGdldEZvcndhcmROb2RlKGRhdGFOb2RlLl9jaGlsZHJlbltpZHhdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhTm9kZTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgcHJvZ3Jlc3MgbGV2ZWxcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtEYXRhTm9kZX0gbm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlUHJvZ3Jlc3NMZXZlbChub2RlKXtcclxuICAgIHZhciBwcm9ncmVzc0xldmVsID0gbm9kZS5fbG9hZGluZyA/IG5vZGUuX2xvYWRMZXZlbCA6IEluZmluaXR5O1xyXG4gICAgdmFyIGk7XHJcblxyXG4gICAgZm9yKGkgPSAwOyBwcm9ncmVzc0xldmVsICYmIGkgPCBub2RlLl9jaGlsZHJlbi5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5fY2hpbGRyZW5baV07XHJcbiAgICAgICAgaWYoY2hpbGQgaW5zdGFuY2VvZiBEYXRhTm9kZSl7XHJcbiAgICAgICAgICAgIHByb2dyZXNzTGV2ZWwgPSBNYXRoLm1pbihwcm9ncmVzc0xldmVsLCBNYXRoLm1heChjaGlsZC5fbG9hZExldmVsLCBjaGlsZC5fcHJvZ3Jlc3NMZXZlbCkgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihjaGlsZC5fZGF0YSAmJiBjaGlsZC5fZGF0YS5pc0xvYWRpbmcgJiYgY2hpbGQuX2RhdGEuaXNMb2FkaW5nKCkpe1xyXG4gICAgICAgICAgICBwcm9ncmVzc0xldmVsID0gTWF0aC5taW4ocHJvZ3Jlc3NMZXZlbCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYocHJvZ3Jlc3NMZXZlbCAmJiBub2RlLl9zb3VyY2VOb2RlKXtcclxuICAgICAgICBwcm9ncmVzc0xldmVsID0gTWF0aC5taW4ocHJvZ3Jlc3NMZXZlbCwgTWF0aC5tYXgobm9kZS5fc291cmNlTm9kZS5fbG9hZExldmVsLCBub2RlLl9zb3VyY2VOb2RlLl9wcm9ncmVzc0xldmVsKSk7XHJcbiAgICB9XHJcbiAgICBpZihwcm9ncmVzc0xldmVsICYmIG5vZGUuX2RhdGFmbG93Tm9kZSl7XHJcbiAgICAgICAgcHJvZ3Jlc3NMZXZlbCA9IE1hdGgubWluKHByb2dyZXNzTGV2ZWwsIE1hdGgubWF4KG5vZGUuX2RhdGFmbG93Tm9kZS5fbG9hZExldmVsLCBub2RlLl9kYXRhZmxvd05vZGUuX3Byb2dyZXNzTGV2ZWwpKTtcclxuICAgIH1cclxuICAgIHZhciBvbGRMZXZlbCA9IG5vZGUuX3Byb2dyZXNzTGV2ZWw7XHJcbiAgICBub2RlLl9wcm9ncmVzc0xldmVsID0gcHJvZ3Jlc3NMZXZlbDtcclxuXHJcbiAgICBpZihvbGRMZXZlbCAhPSBub2RlLl9wcm9ncmVzc0xldmVsKXtcclxuICAgICAgICBub2RlLl9jYWxsTG9hZExpc3RlbmVycyhub2RlLl9wcm9ncmVzc0xldmVsLCBvbGRMZXZlbCk7XHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbm9kZS5fcGFyZW50cy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgdXBkYXRlUHJvZ3Jlc3NMZXZlbChub2RlLl9wYXJlbnRzW2ldKTtcclxuICAgIH1cclxufVxyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIEhlbHBlcnNcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IHBhcmVudFxyXG4gKiBAcGFyYW0ge0dyYXBoTm9kZX0gY2hpbGRcclxuICovXHJcbmZ1bmN0aW9uIGFkZFBhcmVudChwYXJlbnQsIGNoaWxkKXtcclxuICAgIGNoaWxkLl9wYXJlbnRzLnB1c2gocGFyZW50KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IHBhcmVudFxyXG4gKiBAcGFyYW0ge0dyYXBoTm9kZX0gY2hpbGRcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZVBhcmVudChwYXJlbnQsIGNoaWxkKXtcclxuICAgIEFycmF5LmVyYXNlKGNoaWxkLl9wYXJlbnRzLCBwYXJlbnQpO1xyXG59XHJcblxyXG4vKipcclxuICogTm90aWZ5IGFsbCBwYXJlbnQgbm9kZXMgYWJvdXQgYSBjaGFuZ2VcclxuICogQHBhcmFtIHtHcmFwaE5vZGV9IG5vZGVcclxuICogQHBhcmFtIHtleHBvcnRzLkMuUkVTVUxUX1NUQVRFfSBjaGFuZ2VUeXBlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBub3RpZnlQYXJlbnRzT25DaGFuZ2VkKG5vZGUsIGNoYW5nZVR5cGUpe1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGUuX3BhcmVudHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIG5vZGUuX3BhcmVudHNbaV0ubm90aWZ5KGNoYW5nZVR5cGUsIG5vZGUpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIHRoZSBvd25lcnMgb2YgdGhlIG1hcHBpbmdzXHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcclxuICogQHBhcmFtIHtNYXBwaW5nfSBtYXBwaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBzd2FwTWFwcGluZyhkYXRhTm9kZSwga2V5LCBtYXBwaW5nKXtcclxuICAgIGRhdGFOb2RlW2tleV0gJiYgZGF0YU5vZGVba2V5XS5fcmVtb3ZlT3duZXIoZGF0YU5vZGUpO1xyXG4gICAgZGF0YU5vZGVba2V5XSA9IG1hcHBpbmc7XHJcbiAgICBkYXRhTm9kZVtrZXldICYmIGRhdGFOb2RlW2tleV0uX2FkZE93bmVyKGRhdGFOb2RlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVwbGFjZU5vZGVJbkhpZXJhcmNoeShub2RlLCBmaWVsZCwgbmV3Q2hpbGQpIHtcclxuICAgIHZhciBvbGRDaGlsZCA9IG5vZGVbZmllbGRdO1xyXG4gICAgaWYob2xkQ2hpbGQpIHtcclxuICAgICAgICByZW1vdmVQYXJlbnQobm9kZSwgb2xkQ2hpbGQpO1xyXG4gICAgfVxyXG4gICAgbm9kZVtmaWVsZF0gPSBuZXdDaGlsZDtcclxuICAgIGlmKG5ld0NoaWxkKSB7XHJcbiAgICAgICAgYWRkUGFyZW50KG5vZGUsIG5ld0NoaWxkKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBJbnB1dE5vZGU6IElucHV0Tm9kZSxcclxuICAgIERhdGFOb2RlOiBEYXRhTm9kZSxcclxuICAgIGdldENvbXB1dGVEYXRhZmxvd1VybDogZ2V0Q29tcHV0ZURhdGFmbG93VXJsXHJcbn07XHJcbiIsInZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XHJcbnZhciBDID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgRGF0YU5vZGUgPSByZXF1aXJlKFwiLi9ncmFwaC5qc1wiKS5EYXRhTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBDb250ZW50IG9mIHRoaXMgZmlsZTpcclxuICogQ2xhc3NlcyB0byByZXF1ZXN0IHJlc3VsdHMgZnJvbSBhbiBYZmxvdyBncmFwaC5cclxuICovXHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgUmVxdWVzdCBjbGFzcy5cclxuICogQW55IFJlcXVlc3QgaXMgY3JlYXRlZCBmcm9tIGEgRGF0YU5vZGUgdG8gcmVjZWl2ZSB0aGUgcmVzdWx0IG9mIHRoYXQgRGF0YU5vZGUuXHJcbiAqIFRvIGFsbG93IGVmZmVjdGl2ZSBvcHRpbWl6YXRpb24sIGl0IGlzIHJlY29tbWVuZGVkIHRvIGNyZWF0ZSBvbmx5IG9uZSBSZXF1ZXN0IHBlciBEYXRhTm9kZSBhbmQgcmVjZWl2ZSBhbGxcclxuICogcmVzdWx0cyB0aHJvdWdoIHRoYXQgUmVxdWVzdC5cclxuICogQGFic3RyYWN0XHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlIFRoZSBEYXRhTm9kZSBmcm9tIHdoaWNoIHRvIHJlcXVlc3QgcmVzdWx0c1xyXG4gKiBAcGFyYW0gez9BcnJheS48c3RyaW5nPn0gZmlsdGVyIEEgbGlzdCBvZiBuYW1lcyBmaWx0ZXJpbmcgdGhlIHZhbHVlcyB0byBiZSByZWNlaXZlZCAob25seSByZXR1cm4gdmFsdWVzIHdpdGggbmFtZXMgaW5zaWRlIHRoZSBmaWx0ZXIpXHJcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHJlc3VsdCBvZiB0aGUgUmVxdWVzdCBjaGFuZ2VzXHJcbiAqL1xyXG52YXIgUmVxdWVzdCA9IGZ1bmN0aW9uKGRhdGFOb2RlLCBmaWx0ZXIsIGNhbGxiYWNrKXtcclxuICAgIHRoaXMuX2RhdGFOb2RlID0gZGF0YU5vZGU7XHJcbiAgICB0aGlzLl9maWx0ZXIgPSBmaWx0ZXIgPyBmaWx0ZXIuc2xpY2UoKS5zb3J0KCkgOiBudWxsO1xyXG4gICAgdGhpcy5fbGlzdGVuZXIgPSBjYWxsYmFjaztcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhY2hlZCByZXN1bHQgb2YgdGhpcyByZXF1ZXN0XHJcbiAgICAgKiBAdHlwZSB7UmVzdWx0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9yZXN1bHQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FjaGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGF0dGFjaGVkIHRvIGRhdGEgbm9kZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fZGF0YU5vZGVMaXN0ZW5lciA9IHRoaXMuX29uRGF0YU5vZGVDaGFuZ2UuYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLl9kYXRhTm9kZS5hZGRMaXN0ZW5lcih0aGlzLl9kYXRhTm9kZUxpc3RlbmVyKTtcclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXF1ZXN0LnByb3RvdHlwZSwgXCJkYXRhTm9kZVwiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkYXRhTm9kZSBpcyByZWFkb25seVwiKTtcclxuICAgIH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9kYXRhTm9kZTsgfVxyXG59KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXF1ZXN0LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZpbHRlciBpcyByZWFkLW9ubHlcIik7XHJcbiAgICB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fZmlsdGVyOyB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENhbGwgdGhpcyBmdW5jdGlvbiwgd2hlbmV2ZXIgdGhlIHJlcXVlc3QgaXMgbm90IHJlcXVpcmVkIGFueW1vcmUuXHJcbiAqIENsZWFucyB1cCBjYWNoZWQgZGF0YSBhbmQgbGlzdGVuZXJzXHJcbiAqL1xyXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLl9saXN0ZW5lciA9IG51bGw7XHJcbiAgICBpZih0aGlzLl9yZXN1bHQpIHRoaXMuX3Jlc3VsdC5fcmVtb3ZlUmVxdWVzdCh0aGlzKTtcclxuICAgIHRoaXMuX2RhdGFOb2RlLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2RhdGFOb2RlTGlzdGVuZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7Qy5SRVNVTFRfU1RBVEV9IGRhdGFcclxuICogQHByaXZhdGVcclxuICovXHJcblJlcXVlc3QucHJvdG90eXBlLl9vblBvc3Rwb25lZFJlc3VsdENoYW5nZWQgPSBmdW5jdGlvbihkYXRhKXtcclxuICAgIHRoaXMuX2xpc3RlbmVyICYmIHRoaXMuX2xpc3RlbmVyKHRoaXMsIGRhdGEpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoYW5nZSB0aGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0IGFuZCB1cGRhdGUgcmVxdWVzdCBsaXN0IG9mIG9sZCBhbmQgbmV3XHJcbiAqIHJlc3VsdC5cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XHJcbiAqIEBwYXJhbSB7UmVzdWx0P30gbmV3UmVzdWx0XHJcbiAqIEByZXR1cm5zIHtSZXN1bHR9XHJcbiAqL1xyXG5mdW5jdGlvbiBzd2FwUmVzdWx0UmVxdWVzdChyZXF1ZXN0LCBuZXdSZXN1bHQpe1xyXG4gICAgaWYocmVxdWVzdC5fcmVzdWx0KSByZXF1ZXN0Ll9yZXN1bHQuX3JlbW92ZVJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICByZXF1ZXN0Ll9yZXN1bHQgPSBuZXdSZXN1bHQ7XHJcbiAgICBpZihuZXdSZXN1bHQpIG5ld1Jlc3VsdC5fYWRkUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgIHJldHVybiBuZXdSZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcclxuICogQHBhcmFtIHtDLlJFU1VMVF9TVEFURX0gbm90aWZpY2F0aW9uXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMocmVxdWVzdCwgbm90aWZpY2F0aW9uKXtcclxuICAgIEJhc2UuX3F1ZXVlUmVzdWx0Q2FsbGJhY2socmVxdWVzdCwgbm90aWZpY2F0aW9uKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7Qy5SRVNVTFRfU1RBVEV9IG5vdGlmaWNhdGlvblxyXG4gKi9cclxuUmVxdWVzdC5wcm90b3R5cGUuX29uRGF0YU5vZGVDaGFuZ2UgPSBmdW5jdGlvbihub3RpZmljYXRpb24pe1xyXG4gICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIG5vdGlmaWNhdGlvbik7XHJcbn07XHJcblxyXG4vKipcclxuICogQSBDb21wdXRlUmVxdWVzdCBpcyBhIFJlcXVlc3QgZm9yIGEgQ29tcHV0ZVJlc3VsdCwgd2hpY2ggY29udGFpbnMgYSBuYW1lZCBtYXAgb2YgdHlwZWQgdmFsdWVzLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMge1JlcXVlc3R9XHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlIFRoZSBEYXRhTm9kZSBmcm9tIHdoaWNoIHRvIHJlcXVlc3QgcmVzdWx0c1xyXG4gKiBAcGFyYW0gez9BcnJheS48c3RyaW5nPn0gZmlsdGVyIEEgbGlzdCBvZiBuYW1lcyBmaWx0ZXJpbmcgdGhlIHZhbHVlcyB0byBiZSByZWNlaXZlZCAob25seSByZXR1cm4gdmFsdWVzIHdpdGggbmFtZXMgaW5zaWRlIHRoZSBmaWx0ZXIpXHJcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHJlc3VsdCBvZiB0aGUgUmVxdWVzdCBjaGFuZ2VzXHJcbiAqL1xyXG52YXIgQ29tcHV0ZVJlcXVlc3QgPSBmdW5jdGlvbihkYXRhTm9kZSwgZmlsdGVyLCBjYWxsYmFjayl7XHJcbiAgICBSZXF1ZXN0LmNhbGwodGhpcywgZGF0YU5vZGUsIGZpbHRlciwgY2FsbGJhY2spO1xyXG59O1xyXG5CYXNlLmNyZWF0ZUNsYXNzKENvbXB1dGVSZXF1ZXN0LCBSZXF1ZXN0KTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7UmVzdWx0fVxyXG4gKi9cclxuQ29tcHV0ZVJlcXVlc3QucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uKCl7XHJcbiAgICAvLyBzd2FwUmVzdWx0UmVxdWVzdCBpcyBjYWxsZWQgaGVyZSBiZWNhdXNlIHRoZSByZXN1bHQgb2JqZWN0IG9mIHRoZSByZXF1ZXN0IG1heSBjaGFuZ2UsIGUuZy5cclxuICAgIC8vIGRpZmZlcmVudCBmb3J3YXJkIG5vZGUuXHJcbiAgICByZXR1cm4gc3dhcFJlc3VsdFJlcXVlc3QodGhpcywgdGhpcy5fZGF0YU5vZGUuX2dldFJlc3VsdChDLlJFU1VMVF9UWVBFLkNPTVBVVEUsIHRoaXMuX2ZpbHRlcikpO1xyXG59O1xyXG5cclxuQ29tcHV0ZVJlcXVlc3QucHJvdG90eXBlLl9vblJlc3VsdENoYW5nZWQgPSBmdW5jdGlvbihub3RpZmljYXRpb24pe1xyXG4gICAgdGhpcy5fb25EYXRhTm9kZUNoYW5nZShub3RpZmljYXRpb24pO1xyXG59O1xyXG5cclxuXHJcbnZhciBjX3ZzQ29ubmVjdE5vZGVDb3VudCA9IHt9LFxyXG4gICAgY192c0Nvbm5lY3ROb2RlS2V5ID0ge30sXHJcbiAgICBjX3ZzQ29ubmVjdE5vZGVDYWNoZSA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEEgVmVydGV4U2hhZGVyUmVxdWVzdCBpcyBhIFJlcXVlc3QgZm9yIGEgVlNEYXRhUmVzdWx0LCB1c2VkIHRvIGdlbmVyYXRlIGEgVmVydGV4U2hhZGVyIHRoYXQgaW5jbHVkZXNcclxuICogZGF0YWZsb3cgcHJvY2Vzc2luZy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIHtSZXF1ZXN0fVxyXG4gKiBAcGFyYW0ge0RhdGFOb2RlfSBkYXRhTm9kZVxyXG4gKiBAcGFyYW0ge1ZTQ29uZmlnfSB2c0NvbmZpZyBDb25maWd1cmF0aW9uIGZvciB0aGUgb3V0cHV0IG9mIHRoZSBnZW5lcmF0ZWQgdmVydGV4IHNoYWRlclxyXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW5ldmVyIHRoZSByZXN1bHQgb2YgdGhlIFJlcXVlc3QgY2hhbmdlc1xyXG4gKi9cclxudmFyIFZlcnRleFNoYWRlclJlcXVlc3QgPSBmdW5jdGlvbihkYXRhTm9kZSwgdnNDb25maWcsIGNhbGxiYWNrKXtcclxuICAgIHZhciBmaWx0ZXIgPSB2c0NvbmZpZy5nZXRGaWx0ZXIoKTtcclxuICAgIGlmKGZpbHRlci5sZW5ndGggPT0gMClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2c0NvbmZpZyByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXR0cmlidXRlIGVudHJ5LlwiKTtcclxuICAgIFJlcXVlc3QuY2FsbCh0aGlzLCBkYXRhTm9kZSwgZmlsdGVyLCBjYWxsYmFjayk7XHJcbiAgICB0aGlzLl92c0NvbmZpZyA9IHZzQ29uZmlnO1xyXG4gICAgdGhpcy5fdnNDb25uZWN0Tm9kZSA9IGdldFZzQ29ubmVjdE5vZGUoZGF0YU5vZGUsIHZzQ29uZmlnKTtcclxufTtcclxuQmFzZS5jcmVhdGVDbGFzcyhWZXJ0ZXhTaGFkZXJSZXF1ZXN0LCBSZXF1ZXN0KTtcclxuXHJcblZlcnRleFNoYWRlclJlcXVlc3QucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5fdnNDb25maWc7XHJcbn07XHJcblxyXG4vKipcclxuICogQHNlZSBDb21wdXRlUmVxdWVzdC5nZXRSZXN1bHRcclxuICogQHJldHVybnMge1Jlc3VsdH1cclxuICovXHJcblZlcnRleFNoYWRlclJlcXVlc3QucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gc3dhcFJlc3VsdFJlcXVlc3QodGhpcywgdGhpcy5fdnNDb25uZWN0Tm9kZS5fZ2V0UmVzdWx0KEMuUkVTVUxUX1RZUEUuVlMsIHRoaXMuX2ZpbHRlcikpO1xyXG59O1xyXG5cclxuVmVydGV4U2hhZGVyUmVxdWVzdC5wcm90b3R5cGUuX29uRGF0YU5vZGVDaGFuZ2UgPSBmdW5jdGlvbihub3RpZmljYXRpb24pe1xyXG4gICAgaWYobm90aWZpY2F0aW9uID09IEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKXtcclxuICAgICAgICB2YXIgbmV3VlNDb25uZWN0ZWROb2RlID0gZ2V0VnNDb25uZWN0Tm9kZSh0aGlzLl9kYXRhTm9kZSwgdGhpcy5fdnNDb25maWcsIHRoaXMuX2ZpbHRlcik7XHJcbiAgICAgICAgaWYobmV3VlNDb25uZWN0ZWROb2RlICE9IHRoaXMuX3ZzQ29ubmVjdE5vZGUpe1xyXG4gICAgICAgICAgICBjbGVhclZzQ29ubmVjdE5vZGUodGhpcy5fdnNDb25uZWN0Tm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZzQ29ubmVjdE5vZGUgPSBuZXdWU0Nvbm5lY3RlZE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgUmVxdWVzdC5wcm90b3R5cGUuX29uRGF0YU5vZGVDaGFuZ2UuY2FsbCh0aGlzLCBub3RpZmljYXRpb24pO1xyXG59O1xyXG5cclxuVmVydGV4U2hhZGVyUmVxdWVzdC5wcm90b3R5cGUuZ2V0VmVydGV4U2hhZGVyID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuZ2V0UmVzdWx0KCk7IC8vIFVwZGF0ZSB0aGUgcmVzdWx0IGZpcnN0XHJcbiAgICBpZighdGhpcy5fdmVydGV4U2hhZGVyKXtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhTaGFkZXIgPSB0aGlzLl9yZXN1bHQuZ2V0VmVydGV4U2hhZGVyKHRoaXMuX3ZzQ29uZmlnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl92ZXJ0ZXhTaGFkZXI7XHJcbn07XHJcblxyXG5WZXJ0ZXhTaGFkZXJSZXF1ZXN0LnByb3RvdHlwZS5fb25SZXN1bHRDaGFuZ2VkID0gZnVuY3Rpb24ocmVzdWx0LCBub3RpZmljYXRpb24pe1xyXG4gICAgdGhpcy5fb25EYXRhTm9kZUNoYW5nZShub3RpZmljYXRpb24pO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0VnNDb25uZWN0Tm9kZShkYXRhTm9kZSwgdnNDb25maWcsIGZpbHRlcil7XHJcbiAgICB2YXIgZm9yd2FyZE5vZGUgPSBkYXRhTm9kZS5fZ2V0Rm9yd2FyZE5vZGUoZmlsdGVyKTtcclxuXHJcbiAgICB2YXIga2V5ID0gZ2V0RGF0YU5vZGVTaGFkZXJLZXkoZm9yd2FyZE5vZGUsIHZzQ29uZmlnKTtcclxuICAgIHZhciBjb25uZWN0Tm9kZTtcclxuICAgIGlmKCEoY29ubmVjdE5vZGUgPSBjX3ZzQ29ubmVjdE5vZGVDYWNoZVtrZXldKSl7XHJcbiAgICAgICAgY29ubmVjdE5vZGUgPSBuZXcgRGF0YU5vZGUoZmFsc2UpO1xyXG4gICAgICAgIGNvbm5lY3ROb2RlLmFwcGVuZENoaWxkKGZvcndhcmROb2RlKTtcclxuXHJcbiAgICAgICAgY29ubmVjdE5vZGUuY29tcHV0ZU9wZXJhdG9yID0gdnNDb25maWcuZ2V0T3BlcmF0b3IoKTtcclxuICAgICAgICBjb25uZWN0Tm9kZS5jb21wdXRlSW5wdXRNYXBwaW5nID0gbnVsbDtcclxuICAgICAgICBjb25uZWN0Tm9kZS5jb21wdXRlT3V0cHV0TWFwcGluZyA9IG51bGw7XHJcblxyXG4gICAgICAgIGNfdnNDb25uZWN0Tm9kZUNhY2hlW2tleV0gPSBjb25uZWN0Tm9kZTtcclxuICAgICAgICBjX3ZzQ29ubmVjdE5vZGVDb3VudFtjb25uZWN0Tm9kZS5pZF0gPSAxO1xyXG4gICAgICAgIGNfdnNDb25uZWN0Tm9kZUtleVtjb25uZWN0Tm9kZS5pZF0gPSBrZXk7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIGNfdnNDb25uZWN0Tm9kZUNvdW50W2Nvbm5lY3ROb2RlLmlkXSsrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb25uZWN0Tm9kZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2xlYXJWc0Nvbm5lY3ROb2RlKGNvbm5lY3ROb2RlKXtcclxuICAgIGNfdnNDb25uZWN0Tm9kZUNvdW50W2Nvbm5lY3ROb2RlLmlkXS0tO1xyXG4gICAgaWYoIWNfdnNDb25uZWN0Tm9kZUNvdW50W2Nvbm5lY3ROb2RlLmlkXSl7XHJcbiAgICAgICAgdmFyIGtleSA9IGNfdnNDb25uZWN0Tm9kZUtleVtjb25uZWN0Tm9kZS5pZF07XHJcbiAgICAgICAgY192c0Nvbm5lY3ROb2RlQ2FjaGVba2V5XSA9IG51bGw7XHJcbiAgICAgICAgY29ubmVjdE5vZGUuY2xlYXJDaGlsZHJlbigpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0RGF0YU5vZGVTaGFkZXJLZXkoZGF0YU5vZGUsIHZzQ29uZmlnKXtcclxuICAgIHJldHVybiBkYXRhTm9kZS5pZCArIFwifFwiICsgdnNDb25maWcuZ2V0S2V5KCk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgQ29tcHV0ZVJlcXVlc3Q6ICBDb21wdXRlUmVxdWVzdCxcclxuICAgIFZlcnRleFNoYWRlclJlcXVlc3Q6IFZlcnRleFNoYWRlclJlcXVlc3RcclxufTtcclxuIiwidmFyIEMgPXJlcXVpcmUoXCIuLi9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIENMUHJvZ3JhbSBpbXBsZW1lbnRzIGF1dG9tYXRpYyBYZmxvdyBpbnB1dC9vdXRwdXQgYWRhcHRpdmUgV2ViQ0wga2VybmVsIGFuZCBhcHBsaWNhdGlvbiBjb2RlIGdlbmVyYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBvcGVyYXRvckxpc3RcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5cclxudmFyIENMUHJvZ3JhbSA9IGZ1bmN0aW9uIChvcGVyYXRvckxpc3QpIHtcclxuICAgIHRoaXMuY2wgPSBYTUwzRC53ZWJjbC5jbDsgLy8gQ0wgd3JhcHBlclxyXG5cclxuICAgIGlmICghdGhpcy5jbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxpc3QgPSBvcGVyYXRvckxpc3Q7XHJcbiAgICB0aGlzLmVudHJ5ID0gb3BlcmF0b3JMaXN0LmVudHJpZXNbMF07XHJcbiAgICB0aGlzLm9wZXJhdG9yID0gdGhpcy5lbnRyeS5vcGVyYXRvcjtcclxuXHJcbiAgICB0aGlzLmtlcm5lbFBhcmFtTWFwID0ge2lucHV0czogW10sIG91dHB1dHM6IFtdfTsgLy8gU3RvcmVzIGluaXRpYWxpc2VkIEtlcm5lbFBhcmFtIG9iamVjdHNcclxuICAgIHRoaXMua2VybmVsRnVuY3Rpb25QYXJhbXMgPSBbXTsgLy8gU3RvcmVzIGdlbmVyYXRlZCBmdW5jdGlvbiBwYXJhbWV0ZXJzIGZvciBrZXJuZWwgZnVuY3Rpb24gaGVhZGVyLlxyXG4gICAgdGhpcy5rZXJuZWxDb2RlID0gbnVsbDsgLy8gR2VuZXJhdGVkIGtlcm5lbCBjb2RlXHJcbiAgICB0aGlzLmtlcm5lbFByb2dyYW0gPSBudWxsOyAvLyBDb21waWxlZCBrZXJuZWwgcHJvZ3JhbVxyXG4gICAgdGhpcy5tYWluUHJvZ3JhbSA9IG51bGw7IC8vIE1haW4gV2ViQ0wgYXBwbGljYXRpb24gY29kZVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYXAgb2YgaGVscGVyIGtlcm5lbCBwYXJhbWV0ZXJzIHJlcXVpcmVkIGZvciBjZXJ0YWluIGlucHV0IGRhdGEgdHlwZXMuXHJcbiAqXHJcbiAqIEB0eXBlIE9iamVjdFxyXG4gKi9cclxudmFyIGhlbHBlclBhcmFtTWFwID0ge1xyXG4gICAgJ3RleHR1cmUnOiB7dHlwZTogXCJ1aW50XCIsIHBhcmFtczogW1wid2lkdGhcIiwgXCJoZWlnaHRcIl19LCAnYnVmZmVyJzoge3R5cGU6IFwidWludFwiLCBwYXJhbXM6IFtcImxlbmd0aFwiXX1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVdGlsaXR5IHByb3RvdHlwZSBvYmplY3QgZm9yIG1hcHBpbmcgWGZsb3cgaW5wdXRzIHRvIGtlcm5lbCBwYXJhbWV0ZXJzIGFuZCBmb3IgZ2VuZXJhdGluZyBrZXJuZWwgY29kZS5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHByb2dyYW1cclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICogQHBhcmFtIHtDLkRBVEFfVFlQRX0geGZsb3dUeXBlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbFR5cGVcclxuICogQHBhcmFtIGVudHJ5VmFsdWVcclxuICogQHBhcmFtIHtCb29sZWFuP30gaXNJbnB1dFxyXG4gKiBAbmFtZSBLZXJuZWxQYXJhbVxyXG4gKiBAY29uc3RydWN0b3IgS2VybmVsUGFyYW1cclxuICovXHJcblxyXG5mdW5jdGlvbiBLZXJuZWxQYXJhbShwcm9ncmFtLCBuYW1lLCB4Zmxvd1R5cGUsIGNsVHlwZSwgZW50cnlWYWx1ZSwgaXNJbnB1dCkge1xyXG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcclxuICAgIHRoaXMuY2wgPSBwcm9ncmFtLmNsO1xyXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgIHRoaXMudHlwZSA9IGNsVHlwZSB8fCBudWxsO1xyXG4gICAgdGhpcy5pc0lucHV0ID0gISFpc0lucHV0O1xyXG4gICAgdGhpcy5uZWVkc01lbU9iamVjdCA9IGZhbHNlO1xyXG4gICAgdGhpcy5oYXNNZW1PYmplY3QgPSBmYWxzZTtcclxuICAgIHRoaXMuYnl0ZVNpemUgPSBudWxsO1xyXG4gICAgdGhpcy5tZW1PYmplY3RTaXplID0gbnVsbDtcclxuICAgIHRoaXMuYXJnID0gbnVsbDtcclxuICAgIHRoaXMuY2xGdW5jdGlvblBhcmFtID0gbnVsbDtcclxuICAgIHRoaXMueGZsb3dUeXBlID0geGZsb3dUeXBlO1xyXG4gICAgdGhpcy5oZWxwZXJNYXAgPSBudWxsO1xyXG4gICAgdGhpcy5oZWxwZXJzID0gW107XHJcbiAgICB0aGlzLmVudHJ5VmFsdWUgPSBlbnRyeVZhbHVlIHx8IG51bGw7XHJcbiAgICB0aGlzLnZhbCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5wcmVwYXJlUGFyYW0oKTtcclxuICAgIHRoaXMuaW5pdEhlbHBlclBhcmFtcygpO1xyXG4gICAgdGhpcy5pbml0S2VybmVsQXJnKCk7XHJcbiAgICB0aGlzLnVwZGF0ZVZhbHVlKHRoaXMuZW50cnlWYWx1ZSk7XHJcblxyXG59XHJcblxyXG5LZXJuZWxQYXJhbS5wcm90b3R5cGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIFByZXBhcmVzIHRoZSBrZXJuZWwgcGFyYW1ldGVyIGRhdGEuXHJcbiAgICAgKiBNYXBzIHRoZSBpbnB1dCB4ZmxvdyBkYXRhIHR5cGUgdG8gd2ViY2wgZGF0YSB0eXBlIGFuZCBjcmVhdGVzIGEga2VybmVsIGZ1bmN0aW9uIGhlYWRlciBwYXJhbWV0ZXIgd2l0aCBwcm9wZXJcclxuICAgICAqIGRlY2xhcmF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgcHJlcGFyZVBhcmFtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhlbHBlck1hcDtcclxuICAgICAgICB2YXIgeGZsb3dEYXRhVHlwZXMgPSBDLkRBVEFfVFlQRTtcclxuICAgICAgICB2YXIga2VybmVsRnVuY1BhcmFtID0gW107XHJcbiAgICAgICAgdmFyIGFkZHJlc3NTcGFjZSA9ICcnO1xyXG4gICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSAnJztcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnhmbG93VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSB4Zmxvd0RhdGFUeXBlcy5URVhUVVJFOlxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlck1hcCA9IGhlbHBlclBhcmFtTWFwLnRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJ1Y2hhcjQqXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1NwYWNlID0gXCJfX2dsb2JhbFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVlZHNNZW1PYmplY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSB4Zmxvd0RhdGFUeXBlcy5JTlQ6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJpbnRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgeGZsb3dEYXRhVHlwZXMuSU5UNDpcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWxwZXJNYXAgPSBoZWxwZXJQYXJhbU1hcC5idWZmZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJpbnQ0KlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NTcGFjZSA9IFwiX19nbG9iYWxcIjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzTWVtT2JqZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgeGZsb3dEYXRhVHlwZXMuRkxPQVQ6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJmbG9hdFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSB4Zmxvd0RhdGFUeXBlcy5GTE9BVDI6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyTWFwID0gaGVscGVyUGFyYW1NYXAuYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiZmxvYXQyKlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NTcGFjZSA9IFwiX19nbG9iYWxcIjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzTWVtT2JqZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgeGZsb3dEYXRhVHlwZXMuRkxPQVQzOlxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlck1hcCA9IGhlbHBlclBhcmFtTWFwLmJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImZsb2F0KlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NTcGFjZSA9IFwiX19nbG9iYWxcIjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzTWVtT2JqZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgeGZsb3dEYXRhVHlwZXMuRkxPQVQ0OlxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlck1hcCA9IGhlbHBlclBhcmFtTWFwLmJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImZsb2F0NCpcIjtcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzU3BhY2UgPSBcIl9fZ2xvYmFsXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkc01lbU9iamVjdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHhmbG93RGF0YVR5cGVzLkZMT0FUNFg0OlxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlck1hcCA9IGhlbHBlclBhcmFtTWFwLmJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImZsb2F0MTYqXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1NwYWNlID0gXCJfX2dsb2JhbFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVlZHNNZW1PYmplY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuaGVscGVyTWFwID0gaGVscGVyTWFwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXJyYW5naW5nIHBhcmFtZXRlciBwYXJ0c1xyXG4gICAgICAgIGlmIChhZGRyZXNzU3BhY2UpIHtcclxuICAgICAgICAgICAga2VybmVsRnVuY1BhcmFtLnB1c2goYWRkcmVzc1NwYWNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzSW5wdXQpIHtcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zID0gJ2NvbnN0JztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZWNsYXJhdGlvbnMpIHtcclxuICAgICAgICAgICAga2VybmVsRnVuY1BhcmFtLnB1c2goZGVjbGFyYXRpb25zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGtlcm5lbEZ1bmNQYXJhbS5wdXNoKHRoaXMudHlwZSk7XHJcbiAgICAgICAga2VybmVsRnVuY1BhcmFtLnB1c2godGhpcy5uYW1lKTtcclxuICAgICAgICB0aGlzLmNsRnVuY3Rpb25QYXJhbSA9IGtlcm5lbEZ1bmNQYXJhbS5qb2luKCcgJyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGlzZXMgaGVscGVyIHBhcmFtZXRlcnMgZm9yIGFuIGlucHV0IHBhcmFtZXRlciBpZiBuZWVkZWQuXHJcbiAgICAgKlxyXG4gICAgICovXHJcblxyXG4gICAgaW5pdEhlbHBlclBhcmFtczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoZWxwZXJWYWw7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBoZWxwZXJNYXAgPSB0aGlzLmhlbHBlck1hcDtcclxuXHJcbiAgICAgICAgaWYgKGhlbHBlck1hcCAmJiB0aGlzLmlzSW5wdXQpIHtcclxuICAgICAgICAgICAgaGVscGVyTWFwLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcE5hbWUgPSBzZWxmLm5hbWUgKyAnXycgKyBwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHAgPT09IFwid2lkdGhcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlclZhbCA9IHNlbGYuZW50cnlWYWx1ZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJoZWlnaHRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlclZhbCA9IHNlbGYuZW50cnlWYWx1ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwibGVuZ3RoXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWxwZXJWYWwgPSBzZWxmLmVudHJ5VmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gc2VsZi54Zmxvd1R5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJWYWwgPSBoZWxwZXJWYWwgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlclZhbCA9IGhlbHBlclZhbCAvIDM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5JTlQ0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJWYWwgPSBoZWxwZXJWYWwgLyA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDRYNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyVmFsID0gaGVscGVyVmFsIC8gMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWxwZXJzLnB1c2gobmV3IEtlcm5lbFBhcmFtKHNlbGYucHJvZ3JhbSwgcE5hbWUsIG51bGwsIGhlbHBlck1hcC50eXBlLCBuZXcgVWludDMyQXJyYXkoW2hlbHBlclZhbF0pKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXNlcyBrZXJuZWwgYXJndW1lbnQgdGhhdCB3aWxsIGJlIHBhc3NlZCBkaXJlY3RseSBpbnRvIHRoZSBjb21waWxlZCBrZXJuZWwuXHJcbiAgICAgKiBDcmVhdGVzIGEgV2ViQ0wgbWVtb3J5IG9iamVjdCBpZiBuZWVkZWQgKGUuZy4gZm9yIHRleHR1cmUpLlxyXG4gICAgICovXHJcblxyXG4gICAgaW5pdEtlcm5lbEFyZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm5lZWRzTWVtT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWxsb2NhdGVNZW1PYmplY3QoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmFyZyA9IHRoaXMuZW50cnlWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFsbG9jYXRlTWVtT2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNsQVBJID0gdGhpcy5jbC5BUEk7XHJcbiAgICAgICAgdmFyIGNsQ3R4ID0gdGhpcy5jbC5jdHg7XHJcbiAgICAgICAgdmFyIHBhcmFtVHlwZSA9IHRoaXMudHlwZTtcclxuICAgICAgICB2YXIgYnl0ZVNpemUgPSBwYXJzZUludChwYXJhbVR5cGUuc3Vic3RyaW5nKHBhcmFtVHlwZS5sZW5ndGggLSAyLCBwYXJhbVR5cGUubGVuZ3RoIC0gMSksIDEwKTtcclxuICAgICAgICB2YXIgbWVtT2JqZWN0TW9kZSA9IHRoaXMuaXNJbnB1dCA/ICdyJyA6ICd3JztcclxuICAgICAgICB2YXIgZW50cnlWYWx1ZSA9IHRoaXMuZW50cnlWYWx1ZTtcclxuICAgICAgICB2YXIgbWVtT2JqZWN0U2l6ZSwgbWVtT2JqZWN0O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5oYXNNZW1PYmplY3QpIHtcclxuICAgICAgICAgICAgdGhpcy5hcmcucmVsZWFzZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5ieXRlU2l6ZSA9IGlzTmFOKGJ5dGVTaXplKSA/IDEgOiBieXRlU2l6ZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMueGZsb3dUeXBlID09PSBDLkRBVEFfVFlQRS5URVhUVVJFKSB7IC8vIFRleHR1cmUgaXMgYSBzcGVjaWFsIGNhc2VcclxuICAgICAgICAgICAgbWVtT2JqZWN0U2l6ZSA9IGVudHJ5VmFsdWUud2lkdGggKiBlbnRyeVZhbHVlLmhlaWdodCAqIGJ5dGVTaXplO1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVTaXplID0gNDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMueGZsb3dUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLklOVDQ6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVtT2JqZWN0U2l6ZSA9IGVudHJ5VmFsdWUubGVuZ3RoICogSW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQyOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDM6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUNDpcclxuICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQ0eDQ6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVtT2JqZWN0U2l6ZSA9IGVudHJ5VmFsdWUubGVuZ3RoICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBtZW1PYmplY3RTaXplID0gZW50cnlWYWx1ZS5sZW5ndGggKiA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtZW1PYmplY3QgPSBjbEFQSS5jcmVhdGVCdWZmZXIobWVtT2JqZWN0U2l6ZSwgbWVtT2JqZWN0TW9kZSwgY2xDdHgpO1xyXG5cclxuICAgICAgICB0aGlzLm1lbU9iamVjdFNpemUgPSBtZW1PYmplY3RTaXplO1xyXG4gICAgICAgIHRoaXMuYXJnID0gbWVtT2JqZWN0O1xyXG5cclxuICAgICAgICB0aGlzLmhhc01lbU9iamVjdCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5uZWVkc01lbU9iamVjdCA9IGZhbHNlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlVmFsdWU6IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGlmICh0aGlzLmhhc01lbU9iamVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbCA9IGVudHJ5LmRhdGEgPT09IHVuZGVmaW5lZCA/IGVudHJ5IDogZW50cnkuZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5lbnRyeVZhbHVlID0gZW50cnk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tFbnRyeVNpemUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmFyZyA9IHRoaXMuZW50cnlWYWx1ZSA9IGVudHJ5O1xyXG4gICAgICAgIH1cclxuICAgIH0sIHVwZGF0ZUhlbHBlcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaGVscGVycyA9IHRoaXMuaGVscGVycztcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIGhlbHBlcnMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHAubmFtZTtcclxuICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZihcIndpZHRoXCIpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcC51cGRhdGVWYWx1ZShuZXcgVWludDMyQXJyYXkoW3NlbGYuZW50cnlWYWx1ZS53aWR0aF0pKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lLmluZGV4T2YoXCJoZWlnaHRcIikgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBwLnVwZGF0ZVZhbHVlKG5ldyBVaW50MzJBcnJheShbc2VsZi5lbnRyeVZhbHVlLmhlaWdodF0pKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lLmluZGV4T2YoXCJsZW5ndGhcIikgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gc2VsZi5lbnRyeVZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnhmbG93VHlwZSA9PT0gQy5EQVRBX1RZUEUuRkxPQVQ0IHx8IHNlbGYueGZsb3dUeXBlID09PSBDLkRBVEFfVFlQRS5JTlQ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gbGVuIC8gNDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi54Zmxvd1R5cGUgPT09IEMuREFUQV9UWVBFLkZMT0FUNFg0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gbGVuIC8gMTY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwLnVwZGF0ZVZhbHVlKG5ldyBVaW50MzJBcnJheShbbGVuXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBjaGVja0VudHJ5U2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBuZXdTaXplO1xyXG4gICAgICAgIHZhciBlbnRyeVZhbCA9IHRoaXMuZW50cnlWYWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMueGZsb3dUeXBlID09PSBDLkRBVEFfVFlQRS5URVhUVVJFKSB7XHJcbiAgICAgICAgICAgIG5ld1NpemUgPSBlbnRyeVZhbC53aWR0aCAqIGVudHJ5VmFsLmhlaWdodCAqIHRoaXMuYnl0ZVNpemU7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnhmbG93VHlwZSA9PT0gQy5EQVRBX1RZUEUuRkxPQVQyIHx8IHRoaXMueGZsb3dUeXBlID09PSBDLkRBVEFfVFlQRS5GTE9BVDMgfHwgdGhpcy54Zmxvd1R5cGUgPT09IEMuREFUQV9UWVBFLkZMT0FUNCB8fCB0aGlzLnhmbG93VHlwZSA9PT0gQy5EQVRBX1RZUEUuRkxPQVQ0WDQpIHtcclxuICAgICAgICAgICAgbmV3U2l6ZSA9IGVudHJ5VmFsLmxlbmd0aCAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMueGZsb3dUeXBlID09PSBDLkRBVEFfVFlQRS5JTlQ0KSB7XHJcbiAgICAgICAgICAgIG5ld1NpemUgPSBlbnRyeVZhbC5sZW5ndGggKiBJbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1NpemUgPSBlbnRyeVZhbC5sZW5ndGggKiB0aGlzLmJ5dGVTaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tZW1PYmplY3RTaXplICE9PSBuZXdTaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWxsb2NhdGVNZW1PYmplY3QoKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVIZWxwZXJzKCk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS5tYWluUHJvZ3JhbSA9IG51bGw7IC8vIEZvcmNpbmcgQ0wgYXBwbGljYXRpb24gcHJvZ3JhbSB1cGRhdGVcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJ1bnMgQ0xQcm9ncmFtLiBXZWJDTCByZWxhdGVkIGNvZGUgaW5pdGlhbGlzZWQgaW4gdGhlIGZpcnN0IHJ1bi5cclxuICpcclxuICogQHBhcmFtIHByb2dyYW1EYXRhXHJcbiAqL1xyXG5cclxuQ0xQcm9ncmFtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAocHJvZ3JhbURhdGEpIHtcclxuICAgIHZhciBvcGVyYXRvckRhdGEgPSBwcmVwYXJlT3BlcmF0b3JEYXRhKHRoaXMubGlzdCwgMCwgcHJvZ3JhbURhdGEpO1xyXG5cclxuICAgIGFwcGx5RGVmYXVsdE9wZXJhdGlvbih0aGlzLmVudHJ5LCBwcm9ncmFtRGF0YSwgb3BlcmF0b3JEYXRhLCB0aGlzKTtcclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBwcmVwYXJlT3BlcmF0b3JEYXRhKGxpc3QsIGlkeCwgcHJvZ3JhbURhdGEpIHtcclxuICAgIHZhciBkb0l0ZXJhdGUsIGk7XHJcbiAgICB2YXIgZGF0YSA9IHByb2dyYW1EYXRhLm9wZXJhdG9yRGF0YVswXTtcclxuICAgIHZhciBlbnRyeSA9IGxpc3QuZW50cmllc1tpZHhdO1xyXG4gICAgdmFyIG1hcHBpbmcgPSBlbnRyeS5vcGVyYXRvci5tYXBwaW5nO1xyXG5cclxuICAgIGRhdGEuaXRlckZsYWcgPSB7fTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWFwcGluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGRvSXRlcmF0ZSA9IChlbnRyeS5pc1RyYW5zZmVySW5wdXQoaSkgfHwgbGlzdC5pc0lucHV0SXRlcmF0ZShlbnRyeS5nZXREaXJlY3RJbnB1dEluZGV4KGkpKSk7XHJcbiAgICAgICAgZGF0YS5pdGVyRmxhZ1tpXSA9IGRvSXRlcmF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBkYXRhLml0ZXJhdGVDb3VudCA9IGxpc3QuZ2V0SXRlcmF0ZUNvdW50KHByb2dyYW1EYXRhKTtcclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlEZWZhdWx0T3BlcmF0aW9uKGVudHJ5LCBwcm9ncmFtRGF0YSwgb3BlcmF0b3JEYXRhLCBwcm9ncmFtKSB7XHJcbiAgICBpZiAocHJvZ3JhbS5vcGVyYXRvci5ldmFsdWF0ZSAmJiBwcm9ncmFtLm9wZXJhdG9yLmV2YWx1YXRlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICBhc3NlbWJsZUZ1bmN0aW9uQXJncyhlbnRyeSwgcHJvZ3JhbURhdGEsIHByb2dyYW0pO1xyXG5cclxuICAgICAgICBpZiAocHJvZ3JhbS5rZXJuZWxDb2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHByZXBhcmVXZWJDTEtlcm5lbChwcm9ncmFtRGF0YSwgcHJvZ3JhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vY29uc29sZS50aW1lKCdDTFByb2dyYW0gKCcgKyBwcm9ncmFtLm9wZXJhdG9yLm5hbWUgKyAnKScpO1xyXG4gICAgICAgIGlmIChwcm9ncmFtLm1haW5Qcm9ncmFtID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHByb2dyYW0ubWFpblByb2dyYW0gPSBjcmVhdGVNYWluV2ViQ0xQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9ncmFtLm1haW5Qcm9ncmFtKCk7XHJcbiAgICAgICAgLy9jb25zb2xlLnRpbWVFbmQoJ0NMUHJvZ3JhbSAoJyArIHByb2dyYW0ub3BlcmF0b3IubmFtZSArICcpJyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYXBzIFhmbG93IGlucHV0cyBhbmQgb3V0cHV0cyBpbnRvIFdlYkNMIGtlcm5lbCBpbnB1dHMgYW5kIG91dHB1dHMuXHJcbiAqXHJcbiAqIEBmdW5jdGlvbiBhc3NlbWJsZUZ1bmN0aW9uQXJnc1xyXG4gKiBAcGFyYW0gZW50cnlcclxuICogQHBhcmFtIHByb2dyYW1EYXRhXHJcbiAqIEBwYXJhbSBwcm9ncmFtXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gYXNzZW1ibGVGdW5jdGlvbkFyZ3MoZW50cnksIHByb2dyYW1EYXRhLCBwcm9ncmFtKSB7XHJcbiAgICB2YXIgZCwgZGF0YUVudHJ5LCBpO1xyXG4gICAgdmFyIGtlcm5lbEZ1bmN0aW9uUGFyYW1zID0gcHJvZ3JhbS5rZXJuZWxGdW5jdGlvblBhcmFtcztcclxuICAgIHZhciBvdXRwdXRzID0gcHJvZ3JhbS5vcGVyYXRvci5vdXRwdXRzO1xyXG5cclxuICAgIGtlcm5lbEZ1bmN0aW9uUGFyYW1zLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBkID0gb3V0cHV0c1tpXTtcclxuICAgICAgICBkYXRhRW50cnkgPSBwcm9ncmFtRGF0YS5vdXRwdXRzW2VudHJ5LmdldE91dHB1dEluZGV4KGkpXS5kYXRhRW50cnk7XHJcblxyXG4gICAgICAgIHByZXBhcmVLZXJuZWxQYXJhbWV0ZXIoZCwgISEoZC5zb3VyY2UpLCBwcm9ncmFtLCBrZXJuZWxGdW5jdGlvblBhcmFtcywgZGF0YUVudHJ5LCBpKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRJbnB1dFRvQXJncyhlbnRyeSwgcHJvZ3JhbURhdGEsIHByb2dyYW0sIGtlcm5lbEZ1bmN0aW9uUGFyYW1zKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGFkZElucHV0VG9BcmdzKGVudHJ5LCBwcm9ncmFtRGF0YSwgcHJvZ3JhbSwga2VybmVsRnVuY3Rpb25QYXJhbXMpIHtcclxuICAgIHZhciBtYXBFbnRyeSwgZGF0YUVudHJ5LCBpO1xyXG4gICAgdmFyIG1hcHBpbmcgPSBlbnRyeS5vcGVyYXRvci5tYXBwaW5nO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXBwaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgbWFwRW50cnkgPSBtYXBwaW5nW2ldO1xyXG4gICAgICAgIGRhdGFFbnRyeSA9IHByb2dyYW1EYXRhLmdldERhdGFFbnRyeShlbnRyeS5nZXREaXJlY3RJbnB1dEluZGV4KGkpKTtcclxuXHJcbiAgICAgICAgcHJlcGFyZUtlcm5lbFBhcmFtZXRlcihtYXBFbnRyeSwgISEobWFwRW50cnkuc291cmNlKSwgcHJvZ3JhbSwga2VybmVsRnVuY3Rpb25QYXJhbXMsIGRhdGFFbnRyeSwgaSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IEtlcm5lbFBhcmFtIHV0aWxpdHkgb2JqZWN0IG9yIHVwZGF0ZXMgdGhlIGV4aXN0aW5nIG9iamVjdCBpZiBpbnB1dCB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkLlxyXG4gKiBBZGRpdGlvbmFsbHksIHRoaXMgaXMgdXNlZCBmb3IgZ2VuZXJhdGluZyB0aGUgV2ViQ0wga2VybmVsIGZ1bmN0aW9uIGhlYWRlci5cclxuICpcclxuICogQGZ1bmN0aW9uIHByZXBhcmVLZXJuZWxQYXJhbWV0ZXJcclxuICogQHBhcmFtIHBhcmFtXHJcbiAqIEBwYXJhbSBpbnB1dFxyXG4gKiBAcGFyYW0gcHJvZ3JhbVxyXG4gKiBAcGFyYW0gZnVuY3Rpb25QYXJhbXNcclxuICogQHBhcmFtIGFyZ1xyXG4gKiBAcGFyYW0gaVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHByZXBhcmVLZXJuZWxQYXJhbWV0ZXIocGFyYW0sIGlucHV0LCBwcm9ncmFtLCBmdW5jdGlvblBhcmFtcywgYXJnLCBpKSB7XHJcbiAgICB2YXIga2VybmVsUGFyYW1zO1xyXG4gICAgdmFyIGVudHJ5VmFsID0gYXJnID8gYXJnLmdldFZhbHVlKCkgOiBudWxsO1xyXG5cclxuICAgIGlmIChpbnB1dCkge1xyXG4gICAgICAgIGtlcm5lbFBhcmFtcyA9IHByb2dyYW0ua2VybmVsUGFyYW1NYXAuaW5wdXRzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBrZXJuZWxQYXJhbXMgPSBwcm9ncmFtLmtlcm5lbFBhcmFtTWFwLm91dHB1dHM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGtlcm5lbFBhcmFtc1tpXSkge1xyXG4gICAgICAgIGtlcm5lbFBhcmFtc1tpXS51cGRhdGVWYWx1ZShlbnRyeVZhbCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGtlcm5lbFBhcmFtc1tpXSA9IG5ldyBLZXJuZWxQYXJhbShwcm9ncmFtLCBwYXJhbS5uYW1lLCBwYXJhbS50eXBlLCBudWxsLCBlbnRyeVZhbCwgaW5wdXQpO1xyXG5cclxuICAgIC8vIFB1c2hpbmcgZ2VuZXJhdGVkIGtlcm5lbCBmdW5jdGlvbiBwYXJhbXMgaW50byBhcnJheS5cclxuICAgIC8vIFRoaXMgYXJyYXkgaXMgbGF0ZXIgdXNlZCBpbiBnZW5lcmF0aW5nIHRoZSBXZWJDTCBrZXJuZWwgZnVuY3Rpb24gaGVhZGVyLlxyXG4gICAgZnVuY3Rpb25QYXJhbXMucHVzaChrZXJuZWxQYXJhbXNbaV0uY2xGdW5jdGlvblBhcmFtKTtcclxuXHJcbiAgICBrZXJuZWxQYXJhbXNbaV0uaGVscGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgZnVuY3Rpb25QYXJhbXMucHVzaChwLmNsRnVuY3Rpb25QYXJhbSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuXHJcbi8qKiBLRVJORUwgQ09ERSBQUkVQQVJBVElPTiAqKi9cclxuXHJcblxyXG4vKipcclxuICogQ29tcGlsZXMgYW5kIHJlZ2lzdGVycyB0aGUgcHJlcGFyZWQgV2ViQ0wga2VybmVsIGNvZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvbiBwcmVwYXJlV2ViQ0xLZXJuZWxcclxuICogQHBhcmFtIHByb2dyYW1EYXRhXHJcbiAqIEBwYXJhbSBwcm9ncmFtXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHByZXBhcmVXZWJDTEtlcm5lbChwcm9ncmFtRGF0YSwgcHJvZ3JhbSkge1xyXG4gICAgdmFyIGtlcm5lbENvZGU7XHJcbiAgICB2YXIga2VybmVsTWFuYWdlciA9IHByb2dyYW0uY2wua2VybmVsTWFuYWdlcjtcclxuICAgIHZhciBpbnB1dEtlcm5lbCA9IHByb2dyYW0ub3BlcmF0b3IuZXZhbHVhdGU7XHJcbiAgICB2YXIga2VybmVsTmFtZSA9IHByb2dyYW0ua2VybmVsTmFtZSA9IHByb2dyYW0ub3BlcmF0b3IubmFtZS5zcGxpdCgneGZsb3cuJylbMV07XHJcblxyXG4gICAgaWYgKCFpbnB1dEtlcm5lbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBrZXJuZWxDb2RlID0gcHJvZ3JhbS5rZXJuZWxDb2RlID0gcHJlcGFyZUtlcm5lbENvZGUoa2VybmVsTmFtZSwgaW5wdXRLZXJuZWwsIHByb2dyYW0pO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgICAga2VybmVsTWFuYWdlci5yZWdpc3RlcihrZXJuZWxOYW1lLCBrZXJuZWxDb2RlKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvZ3JhbS5rZXJuZWxQcm9ncmFtID0ga2VybmVsTWFuYWdlci5nZXRLZXJuZWwocHJvZ3JhbS5rZXJuZWxOYW1lKTtcclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEdlbmVyYXRlcyBrZXJuZWwgZnVuY3Rpb24gaGVhZGVyIGFuZCBoZWxwZXIga2VybmVsIGNvZGUgYW5kIGNvbWJpbmVzIGl0IHdpdGggdXNlcidzIGlucHV0IGtlcm5lbCBjb2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb24gcHJlcGFyZUtlcm5lbENvZGVcclxuICogQHBhcmFtIHtTdHJpbmd9IGtlcm5lbE5hbWVcclxuICogQHBhcmFtIHtBcnJheX0gaW5wdXRLZXJuZWxcclxuICogQHBhcmFtIHByb2dyYW1cclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcblxyXG5mdW5jdGlvbiBwcmVwYXJlS2VybmVsQ29kZShrZXJuZWxOYW1lLCBpbnB1dEtlcm5lbCwgcHJvZ3JhbSkge1xyXG4gICAgdmFyIHJlc3VsdCwgaW5uZXJLZXJuZWxDb2RlO1xyXG5cclxuICAgIHJlc3VsdCA9IGNyZWF0ZUtlcm5lbEhlYWRlcihrZXJuZWxOYW1lLCBwcm9ncmFtKTtcclxuXHJcbiAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXN1bHQgKz0gJ3tcXG4nO1xyXG5cclxuICAgIGlubmVyS2VybmVsQ29kZSA9IGNyZWF0ZUlubmVyS2VybmVsQ29kZShwcm9ncmFtKTtcclxuXHJcbiAgICBpZiAoIWlubmVyS2VybmVsQ29kZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXN1bHQgKz0gaW5uZXJLZXJuZWxDb2RlO1xyXG4gICAgcmVzdWx0ICs9IGlucHV0S2VybmVsLmpvaW4oJ1xcbicpO1xyXG4gICAgcmVzdWx0ICs9ICdcXG59JztcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEga2VybmVsIGZ1bmN0aW9uIGhlYWRlciBmcm9tIGFzc2VtYmxlZCBrZXJuZWwgcGFyYW1ldGVycy5cclxuICpcclxuICogQGZ1bmN0aW9uIGNyZWF0ZUtlcm5lbEhlYWRlclxyXG4gKiBAcGFyYW0ga2VybmVsTmFtZVxyXG4gKiBAcGFyYW0gcHJvZ3JhbVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUtlcm5lbEhlYWRlcihrZXJuZWxOYW1lLCBwcm9ncmFtKSB7XHJcbiAgICB2YXIgZnVuY3Rpb25IZWFkZXIgPSBbXTtcclxuXHJcbiAgICBmdW5jdGlvbkhlYWRlci5wdXNoKFwiX19rZXJuZWwgdm9pZFwiKTtcclxuICAgIGZ1bmN0aW9uSGVhZGVyLnB1c2goa2VybmVsTmFtZSArICcoJyk7XHJcbiAgICBmdW5jdGlvbkhlYWRlci5wdXNoKHByb2dyYW0ua2VybmVsRnVuY3Rpb25QYXJhbXMuam9pbignLCAnKSk7XHJcbiAgICBmdW5jdGlvbkhlYWRlci5wdXNoKCcpJyk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uSGVhZGVyLmpvaW4oJyAnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBoZWxwZXIga2VybmVsIGNvZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvbiBjcmVhdGVJbm5lcktlcm5lbENvZGVcclxuICogQHBhcmFtIHByb2dyYW1cclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVJbm5lcktlcm5lbENvZGUocHJvZ3JhbSkge1xyXG4gICAgdmFyIGNvZGVMaW5lcyA9IFtdO1xyXG5cclxuICAgIHZhciBmaXJzdElucHV0ID0gcHJvZ3JhbS5rZXJuZWxQYXJhbU1hcC5pbnB1dHNbMF07XHJcblxyXG4gICAgaWYgKGZpcnN0SW5wdXQudHlwZSA9PT0gXCJ1Y2hhcjQqXCIpIHtcclxuICAgICAgICAvLyBBZGQgXCJpdGVyYXRvcnNcIlxyXG4gICAgICAgIGNvZGVMaW5lcy5wdXNoKFwiaW50IHggPSBnZXRfZ2xvYmFsX2lkKDApO1wiKTtcclxuICAgICAgICBjb2RlTGluZXMucHVzaChcImludCB5ID0gZ2V0X2dsb2JhbF9pZCgxKTtcIik7XHJcblxyXG4gICAgICAgIC8vIEFkZCBib3VuZHMgY2hlY2tlcnNcclxuICAgICAgICBjb2RlTGluZXMucHVzaChcImlmICh4ID49IFwiICsgZmlyc3RJbnB1dC5uYW1lICsgXCJfd2lkdGggfHwgeSA+PSBcIiArIGZpcnN0SW5wdXQubmFtZSArIFwiX2hlaWdodCkgcmV0dXJuO1wiKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGlucHV0IGl0ZXJhdG9yXHJcbiAgICAgICAgY29kZUxpbmVzLnB1c2goXCJpbnQgXCIgKyBmaXJzdElucHV0Lm5hbWUgKyBcIl9pID0geSAqIFwiICsgZmlyc3RJbnB1dC5uYW1lICsgXCJfd2lkdGggKyB4O1wiKTtcclxuXHJcbiAgICB9IGVsc2UgeyAvLyBFbHNlLCBhc3N1bWluZyB0aGF0IHRoZSBmaXJzdCBpbnB1dCBpcyBhbiAxLWRpbWVuc2lvbmFsIGJ1ZmZlclxyXG5cclxuICAgICAgICBjb2RlTGluZXMucHVzaChcImludCBcIiArIGZpcnN0SW5wdXQubmFtZSArIFwiX2kgPSBnZXRfZ2xvYmFsX2lkKDApO1wiKTtcclxuXHJcbiAgICAgICAgY29kZUxpbmVzLnB1c2goXCJpZiAoXCIgKyBmaXJzdElucHV0Lm5hbWUgKyBcIl9pID49IFwiICsgZmlyc3RJbnB1dC5uYW1lICsgXCJfbGVuZ3RoKSByZXR1cm47XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb2RlTGluZXMuam9pbignXFxuJyk7XHJcblxyXG59XHJcblxyXG5cclxuLyoqIE1BSU4gV0VCQ0wgUFJPR1JBTSBJTklUSUFMSVNBVElPTiAqKi9cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXNlcyB0aGUgbWFpbiBXZWJDTCBhcHBsaWNhdGlvbiBjb2RlIHRoYXQgZXhlY3V0ZXMgdGhlIFdlYkNMIGtlcm5lbFxyXG4gKlxyXG4gKiBAZnVuY3Rpb24gY3JlYXRlTWFpbldlYkNMUHJvZ3JhbVxyXG4gKiBAcGFyYW0gcHJvZ3JhbVxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlTWFpbldlYkNMUHJvZ3JhbShwcm9ncmFtKSB7XHJcbiAgICB2YXIgY2wgPSBwcm9ncmFtLmNsO1xyXG4gICAgdmFyIGtlcm5lbE1hbmFnZXIgPSBjbC5rZXJuZWxNYW5hZ2VyO1xyXG4gICAgdmFyIGNtZFF1ZXVlID0gY2wuY21kUXVldWU7XHJcbiAgICB2YXIgbWVtT2JqZWN0cyA9IHtpbnB1dHM6IFtdLCBvdXRwdXRzOiBbXX07XHJcbiAgICB2YXIgYXNzZW1ibGVkQXJncyA9IGFzc2VtYmxlS2VybmVsQXJndW1lbnRzKHByb2dyYW0ua2VybmVsUGFyYW1NYXAsIG1lbU9iamVjdHMpO1xyXG4gICAgdmFyIFdTU2l6ZXMgPSBjb21wdXRlV29ya0dyb3VwU2l6ZShwcm9ncmFtLmtlcm5lbFBhcmFtTWFwLmlucHV0c1swXSk7XHJcbiAgICB2YXIga2VybmVsID0gcHJvZ3JhbS5rZXJuZWxQcm9ncmFtO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGksIGxlbiwgbWVtT2JqLCBhcmdzO1xyXG4gICAgICAgIHZhciBpbnB1dE1lbU9ianMgPSBtZW1PYmplY3RzLmlucHV0cztcclxuICAgICAgICB2YXIgb3V0cHV0TWVtT2JqcyA9IG1lbU9iamVjdHMub3V0cHV0cztcclxuXHJcbiAgICAgICAgaWYgKCFrZXJuZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXJncyA9IGFzc2VtYmxlZEFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmFyZztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAga2VybmVsTWFuYWdlci5zZXRBcmdzLmFwcGx5KG51bGwsIFtrZXJuZWxdLmNvbmNhdChhcmdzKSk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBidWZmZXIgdG8gT3BlbkNMIGRldmljZSBtZW1vcnlcclxuICAgICAgICAgICAgbGVuID0gaW5wdXRNZW1PYmpzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBtZW1PYmogPSBpbnB1dE1lbU9ianNbaV07XHJcbiAgICAgICAgICAgICAgICBjbWRRdWV1ZS5lbnF1ZXVlV3JpdGVCdWZmZXIobWVtT2JqLmFyZywgZmFsc2UsIDAsIC8qbWVtT2JqLmFyZy5nZXRJbmZvKFdlYkNMLk1FTV9TSVpFKSovbWVtT2JqLm1lbU9iamVjdFNpemUsIG1lbU9iai52YWwsIFtdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRXhlY3V0ZSAoZW5xdWV1ZSkga2VybmVsXHJcbiAgICAgICAgICAgIGNtZFF1ZXVlLmVucXVldWVORFJhbmdlS2VybmVsKGtlcm5lbCwgV1NTaXplc1sxXS5sZW5ndGgsIFtdLCBXU1NpemVzWzFdLCBXU1NpemVzWzBdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlYWQgdGhlIHJlc3VsdCBidWZmZXIgZnJvbSBPcGVuQ0wgZGV2aWNlXHJcbiAgICAgICAgICAgIGxlbiA9IG91dHB1dE1lbU9ianMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG1lbU9iaiA9IG91dHB1dE1lbU9ianNbaV07XHJcbiAgICAgICAgICAgICAgICBjbWRRdWV1ZS5lbnF1ZXVlUmVhZEJ1ZmZlcihtZW1PYmouYXJnLCBmYWxzZSwgMCwgLyptZW1PYmouYXJnLmdldEluZm8oV2ViQ0wuTUVNX1NJWkUpKi9tZW1PYmoubWVtT2JqZWN0U2l6ZSwgbWVtT2JqLnZhbCwgW10pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjbWRRdWV1ZS5maW5pc2goKTsgLy9GaW5pc2ggYWxsIHRoZSBvcGVyYXRpb25zXHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEFycmFuZ2VzIGluaXRpYWxpc2VkIGtlcm5lbCBhcmd1bWVudHMgaW50byBoZWxwZXIgYXJyYXlzIHNvIHRoZXkgYXJlIG1vcmUgZWFzaWx5IGF2YWlsYWJsZSBpblxyXG4gKiB0aGUgbWFpbiBXZWJDTCBhcHBsaWNhdGlvbi5cclxuICpcclxuICogQGZ1bmN0aW9uIGFzc2VtYmxlS2VybmVsQXJndW1lbnRzXHJcbiAqIEBwYXJhbSBwYXJhbU1hcFxyXG4gKiBAcGFyYW0gbWVtT2JqZWN0c1xyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gYXNzZW1ibGVLZXJuZWxBcmd1bWVudHMocGFyYW1NYXAsIG1lbU9iamVjdHMpIHtcclxuICAgIHZhciBvdXRwdXRzID0gcGFyYW1NYXAub3V0cHV0cztcclxuICAgIHZhciBpbnB1dHMgPSBwYXJhbU1hcC5pbnB1dHM7XHJcbiAgICB2YXIga2VybmVsQXJncyA9IFtdO1xyXG5cclxuICAgIG91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIG1hcEtlcm5lbEFyZ3VtZW50KHAsIGtlcm5lbEFyZ3MsIG1lbU9iamVjdHMub3V0cHV0cyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIG1hcEtlcm5lbEFyZ3VtZW50KHAsIGtlcm5lbEFyZ3MsIG1lbU9iamVjdHMuaW5wdXRzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBrZXJuZWxBcmdzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXBLZXJuZWxBcmd1bWVudChwYXJhbSwga2VybmVsQXJncywgbWVtT2JqZWN0cykge1xyXG4gICAga2VybmVsQXJncy5wdXNoKHBhcmFtKTtcclxuXHJcbiAgICBpZiAocGFyYW0uaGFzTWVtT2JqZWN0KSB7XHJcbiAgICAgICAgbWVtT2JqZWN0cy5wdXNoKHBhcmFtKTtcclxuICAgICAgICBwYXJhbS5oZWxwZXJzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAga2VybmVsQXJncy5wdXNoKHApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgYSBwcm9wZXIgV2ViQ0wga2VybmVsIHdvcmtncm91cCBzaXplIGZvciB0YXJnZXQgaW5wdXQgYnVmZmVyXHJcbiAqXHJcbiAqIEBmdW5jdGlvbiBjb21wdXRlV29ya0dyb3VwU2l6ZVxyXG4gKiBAcGFyYW0gdGFyZ2V0SW5wdXRcclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGNvbXB1dGVXb3JrR3JvdXBTaXplKHRhcmdldElucHV0KSB7XHJcbiAgICB2YXIgbG9jYWxXUywgZ2xvYmFsV1M7XHJcbiAgICB2YXIgZW50cnlWYWwgPSB0YXJnZXRJbnB1dC5lbnRyeVZhbHVlO1xyXG5cclxuICAgIGlmICh0YXJnZXRJbnB1dC54Zmxvd1R5cGUgPT09IEMuREFUQV9UWVBFLlRFWFRVUkUpIHtcclxuICAgICAgICBsb2NhbFdTID0gWzE2LCA0XTtcclxuICAgICAgICBnbG9iYWxXUyA9IFtNYXRoLmNlaWwoZW50cnlWYWwud2lkdGggLyBsb2NhbFdTWzBdKSAqIGxvY2FsV1NbMF0sIE1hdGguY2VpbChlbnRyeVZhbC5oZWlnaHQgLyBsb2NhbFdTWzFdKSAqIGxvY2FsV1NbMV1dO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgayA9IDE7XHJcbiAgICAgICAgc3dpdGNoICh0YXJnZXRJbnB1dC54Zmxvd1R5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5JTlQ0OlxyXG4gICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUNDpcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgayA9IDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUMzpcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgayA9IDM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUNFg0OlxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrID0gMTY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2NhbFdTID0gWzE2XTtcclxuICAgICAgICBnbG9iYWxXUyA9IFtNYXRoLmNlaWwoZW50cnlWYWwubGVuZ3RoIC8gKGxvY2FsV1NbMF0gKiBrKSkgKiBsb2NhbFdTWzBdXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW2xvY2FsV1MsIGdsb2JhbFdTXTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDTFByb2dyYW07XHJcbiIsIlhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5hZGRcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd2YWx1ZTEnfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAndmFsdWUyJ31dLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUxLCB2YWx1ZTIsIGluZm8pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgdXNlZCFcIik7XHJcbiAgICB9LFxyXG4gICAgZXZhbHVhdGVfY29yZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZTEsIHZhbHVlMil7XHJcbiAgICAgICAgcmVzdWx0WzBdID0gdmFsdWUxWzBdICsgdmFsdWUyWzBdO1xyXG4gICAgICAgIHJlc3VsdFsxXSA9IHZhbHVlMVsxXSArIHZhbHVlMlsxXTtcclxuICAgICAgICByZXN1bHRbMl0gPSB2YWx1ZTFbMl0gKyB2YWx1ZTJbMl07XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuYnVmZmVyU2VsZWN0XCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQzJywgbmFtZTogJ3Jlc3VsdCcsIG5vQWxsb2M6IHRydWV9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAndHJ1ZU9wdGlvbicsIGFycmF5OiB0cnVlfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAnZmFsc2VPcHRpb24nLCBhcnJheTogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Jvb2wnLCBzb3VyY2U6ICd2YWx1ZScsIGFycmF5OiB0cnVlfV0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBmYWxzZU9wdGlvbiwgdHJ1ZU9wdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICByZXN1bHQuYXNzaWduID0gdmFsdWVbMF0gPyB0cnVlT3B0aW9uIDogZmFsc2VPcHRpb247XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59KTtcclxuIiwiWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmNsYW1wSW1hZ2VcIiwge1xyXG4gICAgb3V0cHV0czogWyB7dHlwZTogJ3RleHR1cmUnLCBuYW1lIDogJ3Jlc3VsdCcsIHNpemVvZiA6ICdpbWFnZScsIGZvcm1hdFR5cGU6ICdJbWFnZURhdGEnfSBdLFxyXG4gICAgcGFyYW1zOiAgWyB7dHlwZTogJ3RleHR1cmUnLCBzb3VyY2UgOiAnaW1hZ2UnfSxcclxuICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZSA6ICdtaW4nfSxcclxuICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZSA6ICdtYXgnfVxyXG4gICAgICAgICAgICAgXSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGltYWdlLCBtaW4sIG1heCkge1xyXG4gICAgICAgIHZhciBpbnBpeCA9IGltYWdlLmRhdGE7XHJcbiAgICAgICAgdmFyIG91dHBpeCA9IHJlc3VsdC5kYXRhO1xyXG4gICAgICAgIHZhciBtaW52ID0gbWluWzBdO1xyXG4gICAgICAgIHZhciBtYXh2ID0gbWF4WzBdO1xyXG4gICAgICAgIHZhciBsZW4gPSBpbWFnZS5kYXRhLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gaW5waXhbaV07XHJcbiAgICAgICAgICAgIGlmICh2YWwgPCBtaW52KSB2YWwgPSBtaW52O1xyXG4gICAgICAgICAgICBpZiAodmFsID4gbWF4dikgdmFsID0gbWF4djtcclxuICAgICAgICAgICAgb3V0cGl4W2ldID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufSk7XHJcbiIsIi8vIENvZGUgcG9ydGlvbnMgZnJvbSBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9jYW52YXMvaW1hZ2VmaWx0ZXJzL1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnZvbHV0ZShpbnBpeGVscywgb3V0cGl4ZWxzLCB3ZWlnaHRzLCBvcGFxdWUpIHtcclxuICAgICAgICB2YXIgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSk7XHJcbiAgICAgICAgdmFyIGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlLzIpO1xyXG4gICAgICAgIHZhciBzcmMgPSBpbnBpeGVscy5kYXRhO1xyXG4gICAgICAgIHZhciBzdyA9IGlucGl4ZWxzLndpZHRoO1xyXG4gICAgICAgIHZhciBzaCA9IGlucGl4ZWxzLmhlaWdodDtcclxuICAgICAgICAvLyBwYWQgb3V0cHV0IGJ5IHRoZSBjb252b2x1dGlvbiBtYXRyaXhcclxuICAgICAgICB2YXIgdyA9IHN3O1xyXG4gICAgICAgIHZhciBoID0gc2g7XHJcbiAgICAgICAgdmFyIGRzdCA9IG91dHBpeGVscy5kYXRhO1xyXG4gICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIGRlc3RpbmF0aW9uIGltYWdlIHBpeGVsc1xyXG4gICAgICAgIHZhciBhbHBoYUZhYyA9IG9wYXF1ZSA/IDEgOiAwO1xyXG4gICAgICAgIGZvciAodmFyIHk9MDsgeTxoOyB5KyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgeD0wOyB4PHc7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN5ID0geTtcclxuICAgICAgICAgICAgICAgIHZhciBzeCA9IHg7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHN0T2ZmID0gKHkqdyt4KSo0O1xyXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSB3ZWlnaGVkIHN1bSBvZiB0aGUgc291cmNlIGltYWdlIHBpeGVscyB0aGF0XHJcbiAgICAgICAgICAgICAgICAvLyBmYWxsIHVuZGVyIHRoZSBjb252b2x1dGlvbiBtYXRyaXhcclxuICAgICAgICAgICAgICAgIHZhciByPTAsIGc9MCwgYj0wLCBhPTA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjeT0wOyBjeTxzaWRlOyBjeSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY3g9MDsgY3g8c2lkZTsgY3grKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2N5ID0gc3kgKyBjeSAtIGhhbGZTaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2N4ID0gc3ggKyBjeCAtIGhhbGZTaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcmNPZmYgPSAoc2N5KnN3K3NjeCkqNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3dCA9IHdlaWdodHNbY3kqc2lkZStjeF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByICs9IHNyY1tzcmNPZmZdICogd3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnICs9IHNyY1tzcmNPZmYrMV0gKiB3dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgKz0gc3JjW3NyY09mZisyXSAqIHd0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSArPSBzcmNbc3JjT2ZmKzNdICogd3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkc3RbZHN0T2ZmXSA9IHI7XHJcbiAgICAgICAgICAgICAgICBkc3RbZHN0T2ZmKzFdID0gZztcclxuICAgICAgICAgICAgICAgIGRzdFtkc3RPZmYrMl0gPSBiO1xyXG4gICAgICAgICAgICAgICAgZHN0W2RzdE9mZiszXSA9IGEgKyBhbHBoYUZhYyooMjU1LWEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRwaXhlbHM7XHJcbiAgICB9O1xyXG5cclxuICAgIFhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5jb252b2x1dGVJbWFnZVwiLCB7XHJcbiAgICAgICAgb3V0cHV0czogWyB7dHlwZTogJ3RleHR1cmUnLCBuYW1lIDogJ3Jlc3VsdCcsIHNpemVvZiA6ICdpbWFnZSd9IF0sXHJcbiAgICAgICAgcGFyYW1zOiAgW1xyXG4gICAgICAgICAgICB7dHlwZTogJ3RleHR1cmUnLCBzb3VyY2UgOiAnaW1hZ2UnfSxcclxuICAgICAgICAgICAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZSA6ICdrZXJuZWwnfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW1hZ2UsIGtlcm5lbCkge1xyXG4gICAgICAgICAgICBjb252b2x1dGUoaW1hZ2UsIHJlc3VsdCwga2VybmVsLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmNvbnZvbHV0ZUltYWdlVG9GbG9hdFwiLCB7XHJcbiAgICAgICAgb3V0cHV0czogWyB7dHlwZTogJ3RleHR1cmUnLCBuYW1lIDogJ3Jlc3VsdCcsIHNpemVvZjogJ2ltYWdlJywgZm9ybWF0VHlwZSA6ICdmbG9hdDMyJ30gXSxcclxuICAgICAgICBwYXJhbXM6ICBbXHJcbiAgICAgICAgICAgIHt0eXBlOiAndGV4dHVyZScsIHNvdXJjZSA6ICdpbWFnZSd9LFxyXG4gICAgICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlIDogJ2tlcm5lbCd9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBpbWFnZSwga2VybmVsKSB7XHJcbiAgICAgICAgICAgIGNvbnZvbHV0ZShpbWFnZSwgcmVzdWx0LCBrZXJuZWwsIHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbn0pKCk7XHJcbiIsIlhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5jcmVhdGVJR0luZGV4XCIsIHtcclxuICAgIG91dHB1dHM6W1xyXG4gICAgICAgIC8ve3R5cGU6J2ludCcsIG5hbWU6J2luZGV4JywgY3VzdG9tQWxsb2M6dHJ1ZSB9LFxyXG4gICAgICAgIHt0eXBlOidmbG9hdDInLCBuYW1lOid0ZXhjb29yZCcsIGN1c3RvbUFsbG9jOnRydWUgfVxyXG4gICAgXSxcclxuICAgIHBhcmFtczpbXHJcbiAgICAgICAge3R5cGU6J2ludCcsIHNvdXJjZTondmVydGV4Q291bnQnLCBvcHRpb25hbDpmYWxzZX0sXHJcbiAgICAgICAge3R5cGU6J3RleHR1cmUnLCBzb3VyY2U6J3Bvc2l0aW9uVGV4Jywgb3B0aW9uYWw6IGZhbHNlfVxyXG4gICAgXSxcclxuICAgIGFsbG9jOmZ1bmN0aW9uIChzaXplcywgdmVydGV4Q291bnQsIGltYWdlKSB7XHJcbiAgICAgICAgc2l6ZXNbJ3RleGNvb3JkJ10gPSBpbWFnZS53aWR0aCAqIGltYWdlLmhlaWdodDtcclxuICAgICAgICAvL3NpemVzWydpbmRleCddID0gdmVydGV4Q291bnRbMF07XHJcbiAgICB9LFxyXG4gICAgZXZhbHVhdGU6ZnVuY3Rpb24gKHRleGNvb3JkLCB2ZXJ0ZXhDb3VudCwgaW1hZ2UsIGluZm8pIHtcclxuICAgICAgICAvLyB0ZXggY29vcmRzXHJcbiAgICAgICAgdmFyIGhhbGZQaXhlbCA9IHtcclxuICAgICAgICAgICAgeDogMC41IC8gaW1hZ2Uud2lkdGgsXHJcbiAgICAgICAgICAgIHk6IDAuNSAvIGltYWdlLmhlaWdodFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIHkgPSAwLCB5bGVuZ3RoID0gaW1hZ2UuaGVpZ2h0OyB5IDwgeWxlbmd0aDsgeSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHhsZW5ndGggPSBpbWFnZS53aWR0aDsgeCA8IHhsZW5ndGg7IHgrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGV4Y29vcmRbaSsrXSA9ICh4IC8geGxlbmd0aCkgKyBoYWxmUGl4ZWwueDtcclxuICAgICAgICAgICAgICAgIHRleGNvb3JkW2krK10gPSAxIC0gKCh5IC8geWxlbmd0aCkgKyBoYWxmUGl4ZWwueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGluZGV4IGNyZWF0aW9uXHJcbiAgICAgICAgLypmb3IodmFyIGkgPSAwOyBpIDwgdmVydGV4Q291bnRbMF07IGkrKykge1xyXG4gICAgICAgICAgICBpbmRleFtpXSA9IGk7XHJcbiAgICAgICAgfSovXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuY3JlYXRlVHJhbnNmb3JtXCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQ0eDQnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd0cmFuc2xhdGlvbicsIG9wdGlvbmFsOiB0cnVlfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQ0Jywgc291cmNlOiAncm90YXRpb24nLCBvcHRpb25hbDogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0MycsIHNvdXJjZTogJ3NjYWxlJywgb3B0aW9uYWw6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICdjZW50ZXInLCBvcHRpb25hbDogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0NCcsIHNvdXJjZTogJ3NjYWxlT3JpZW50YXRpb24nLCBvcHRpb25hbDogdHJ1ZX1dLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdHJhbnNsYXRpb24scm90YXRpb24sc2NhbGUsY2VudGVyLHNjYWxlT3JpZW50YXRpb24sIGluZm8pIHtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW5mby5pdGVyYXRlQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubWFrZVRyYW5zZm9ybVhmbG93KFxyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb24gPyB0cmFuc2xhdGlvbi5zdWJhcnJheShpbmZvLml0ZXJGbGFnWzBdID8gaSozIDogMCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcm90YXRpb24gPyByb3RhdGlvbi5zdWJhcnJheShpbmZvLml0ZXJGbGFnWzFdID8gaSo0IDogMCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgc2NhbGUgPyBzY2FsZS5zdWJhcnJheShpbmZvLml0ZXJGbGFnWzJdID8gaSozIDogMCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgY2VudGVyID8gY2VudGVyLnN1YmFycmF5KGluZm8uaXRlckZsYWdbM10gPyBpKjMgOiAwKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzY2FsZU9yaWVudGF0aW9uID8gc2NhbGVPcmllbnRhdGlvbi5zdWJhcnJheShpbmZvLml0ZXJGbGFnWzRdID8gaSo0IDogMCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnN1YmFycmF5KGkqMTYpXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuY3JlYXRlVHJhbnNmb3JtSW52XCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQ0eDQnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd0cmFuc2xhdGlvbicsIG9wdGlvbmFsOiB0cnVlfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQ0Jywgc291cmNlOiAncm90YXRpb24nLCBvcHRpb25hbDogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0MycsIHNvdXJjZTogJ3NjYWxlJywgb3B0aW9uYWw6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICdjZW50ZXInLCBvcHRpb25hbDogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0NCcsIHNvdXJjZTogJ3NjYWxlT3JpZW50YXRpb24nLCBvcHRpb25hbDogdHJ1ZX1dLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdHJhbnNsYXRpb24scm90YXRpb24sc2NhbGUsY2VudGVyLHNjYWxlT3JpZW50YXRpb24sIGluZm8pIHtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW5mby5pdGVyYXRlQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubWFrZVRyYW5zZm9ybUludlhmbG93KFxyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb24gPyB0cmFuc2xhdGlvbi5zdWJhcnJheShpbmZvLml0ZXJGbGFnWzBdID8gaSozIDogMCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcm90YXRpb24gPyByb3RhdGlvbi5zdWJhcnJheShpbmZvLml0ZXJGbGFnWzFdID8gaSo0IDogMCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgc2NhbGUgPyBzY2FsZS5zdWJhcnJheShpbmZvLml0ZXJGbGFnWzJdID8gaSozIDogMCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgY2VudGVyID8gY2VudGVyLnN1YmFycmF5KGluZm8uaXRlckZsYWdbM10gPyBpKjMgOiAwKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzY2FsZU9yaWVudGF0aW9uID8gc2NhbGVPcmllbnRhdGlvbi5zdWJhcnJheShpbmZvLml0ZXJGbGFnWzRdID8gaSo0IDogMCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnN1YmFycmF5KGkqMTYpXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCIoZnVuY3Rpb24oKXtcclxuXHJcbnZhciBjX0N1YmVQb3NpdGlvbnMgPSAgW1xyXG4gICAgWy0xLC0xLC0xXSwgWzEsLTEsLTFdLCBbLTEsMSwtMV0sIFsxLDEsLTFdLCAvLyBmcm9udFxyXG4gICAgWy0xLC0xLC0xXSwgWy0xLC0xLDFdLCBbLTEsMSwtMV0sIFstMSwxLDFdLCAvLyBsZWZ0XHJcbiAgICBbLTEsLTEsLTFdLCBbMSwtMSwtMV0sIFstMSwtMSwxXSwgWzEsLTEsMV0sIC8vIHRvcFxyXG4gICAgWzEsLTEsLTFdLCBbMSwxLC0xXSwgWzEsLTEsMV0sIFsxLDEsMV0sICAgICAvLyByaWdodFxyXG4gICAgWy0xLDEsLTFdLCBbMSwxLC0xXSwgWy0xLDEsMV0sIFsxLDEsMV0sICAgICAvLyBib3R0b21cclxuICAgIFstMSwtMSwxXSwgWzEsLTEsMV0sIFstMSwxLDFdLCBbMSwxLDFdICAgICAgLy8gYmFja1xyXG5dO1xyXG52YXIgY19DdWJlTm9ybWFscyA9ICBbXHJcbiAgICBbMCwwLC0xXSwgWzAsMCwtMV0sIFswLDAsLTFdLCBbMCwwLC0xXSwgLy8gZnJvbnRcclxuICAgIFstMSwwLDBdLCBbLTEsMCwwXSwgWy0xLDAsMF0sIFstMSwwLDBdLCAvLyBsZWZ0XHJcbiAgICBbMCwtMSwwXSwgWzAsLTEsMF0sIFswLC0xLDBdLCBbMCwtMSwwXSwgLy8gdG9wXHJcbiAgICBbMSwwLDBdLCBbMSwwLDBdLCBbMSwwLDBdLCBbMSwwLDBdLCAgICAgLy8gcmlnaHRcclxuICAgIFswLDEsMF0sIFswLDEsMF0sIFswLDEsMF0sIFswLDEsMF0sICAgICAvLyBib3R0b21cclxuICAgIFswLDAsMV0sIFswLDAsMV0sIFswLDAsMV0sIFswLDAsMV0gICAgICAvLyBiYWNrXHJcbl07XHJcbnZhciBjX0N1YmVJbmRleCA9IFtcclxuICAgIFswLDEsMiwxLDIsM10sXHJcbiAgICBbNCw1LDYsNSw2LDddLFxyXG4gICAgWzgsOSwxMCw5LDEwLDExXSxcclxuICAgIFsxMiwxMywxNCwxMywxNCwxNV0sXHJcbiAgICBbMTYsMTcsMTgsMTcsMTgsMTldLFxyXG4gICAgWzIwLDIxLDIyLDIxLDIyLDIzXVxyXG5dXHJcblxyXG4vKipcclxuICogR3JpZCBHZW5lcmF0aW9uXHJcbiAqL1xyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZGVidWcuY3JlYXRlU2tpbkN1YmVzXCIsIHtcclxuICAgIG91dHB1dHM6IFtcdHt0eXBlOiAnaW50JywgbmFtZTogJ2luZGV4JywgY3VzdG9tQWxsb2M6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncG9zaXRpb24nLCBjdXN0b21BbGxvYzogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdub3JtYWwnLCBjdXN0b21BbGxvYzogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2ludDQnLCBuYW1lOiAnYm9uZUluZGljZXMnLCBjdXN0b21BbGxvYzogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0NCcsIG5hbWU6ICdib25lV2VpZ2h0cycsIGN1c3RvbUFsbG9jOiB0cnVlfV0sXHJcbiAgICBwYXJhbXM6ICBbe3R5cGU6ICdmbG9hdDR4NCcsIHNvdXJjZTogJ2JpbmRUcmFuc2Zvcm1zJywgYXJyYXk6IHRydWV9LFxyXG4gICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2U6ICdzaXplJywgYXJyYXk6IHRydWUsIG9wdGlvbmFsOiB0cnVlfV0sXHJcbiAgICBhbGxvYzogZnVuY3Rpb24oc2l6ZXMsIGJpbmRUcmFuc2Zvcm1zKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzID0gYmluZFRyYW5zZm9ybXMubGVuZ3RoIC8gMTY7XHJcbiAgICAgICAgc2l6ZXNbJ3Bvc2l0aW9uJ10gPSBzICogNCAqIDY7XHJcbiAgICAgICAgc2l6ZXNbJ25vcm1hbCddID0gcyAqIDQgKiA2O1xyXG4gICAgICAgIHNpemVzWydib25lSW5kaWNlcyddID0gcyAqIDQgKiA2O1xyXG4gICAgICAgIHNpemVzWydib25lV2VpZ2h0cyddID0gcyAqIDQgKiA2O1xyXG4gICAgICAgIHNpemVzWydpbmRleCddID0gcyAqIDYgKiA2O1xyXG4gICAgfSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihpbmRleCwgcG9zaXRpb24sIG5vcm1hbCwgYm9uZUlkeCwgYm9uZVdlaWdodCwgYmluZFRyYW5zZm9ybXMsIHNpemUpIHtcclxuICAgICAgICB2YXIgY3ViZUNvdW50ID0gYmluZFRyYW5zZm9ybXMubGVuZ3RoIC8gMTY7XHJcbiAgICAgICAgdmFyIHNpemUgPSAoc2l6ZSAmJiBzaXplWzBdIHx8IDEpIC8gMjtcclxuXHJcbiAgICAgICAgdmFyIHRtcFBvc2l0aW9uID0gWE1MM0QubWF0aC52ZWMzLmNyZWF0ZSgpLFxyXG4gICAgICAgICAgICB0bXBOb3JtYWwgPSBYTUwzRC5tYXRoLnZlYzMuY3JlYXRlKCk7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjdWJlQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCA2OyArK2ope1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IDQ7IGsrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsSWR4ID0gaio0KyBrLCBnbG9iYWxJZHggPSBpKjYqNCArIGxvY2FsSWR4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLnZlYzMuY29weSh0bXBQb3NpdGlvbiwgY19DdWJlUG9zaXRpb25zW2xvY2FsSWR4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QubWF0aC52ZWMzLnNjYWxlKHRtcFBvc2l0aW9uLCB0bXBQb3NpdGlvbiwgc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0VmVjMyhiaW5kVHJhbnNmb3JtcywgaSoxNiwgdG1wUG9zaXRpb24sIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELm1hdGgudmVjMy5jb3B5KHRtcE5vcm1hbCwgY19DdWJlTm9ybWFsc1tsb2NhbElkeF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseU9mZnNldERpcmVjdGlvbihiaW5kVHJhbnNmb3JtcywgaSoxNiwgdG1wTm9ybWFsLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25bZ2xvYmFsSWR4KjMrMF0gPSB0bXBQb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbltnbG9iYWxJZHgqMysxXSA9IHRtcFBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uW2dsb2JhbElkeCozKzJdID0gdG1wUG9zaXRpb25bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsW2dsb2JhbElkeCozKzBdID0gdG1wTm9ybWFsWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFtnbG9iYWxJZHgqMysxXSA9IHRtcE5vcm1hbFsxXTtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxbZ2xvYmFsSWR4KjMrMl0gPSB0bXBOb3JtYWxbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZUlkeFtnbG9iYWxJZHgqNCswXSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZUlkeFtnbG9iYWxJZHgqNCsxXSA9IGJvbmVJZHhbZ2xvYmFsSWR4KjQrMl0gPSBib25lSWR4W2dsb2JhbElkeCo0KzNdPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvbmVXZWlnaHRbZ2xvYmFsSWR4KjQrMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvbmVXZWlnaHRbZ2xvYmFsSWR4KjQrMV0gPSBib25lV2VpZ2h0W2dsb2JhbElkeCo0KzJdID0gYm9uZVdlaWdodFtnbG9iYWxJZHgqNCszXT0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBnbG9iYWxJbmRleElkeCA9IGkqNio2ICsgaio2O1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IDY7ICsrayl7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhbZ2xvYmFsSW5kZXhJZHgra10gPSBpKjYqNCArIGNfQ3ViZUluZGV4W2pdW2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIGFyZSBkb25lIVxyXG4gICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICB9XHJcbn0pO1xyXG5cclxufSgpKTtcclxuIiwiWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmZsaXBOb3JtYWxcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd2YWx1ZSd9XSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBpbmZvKSB7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaTxpbmZvLml0ZXJhdGVDb3VudCozOyBpKyspXHJcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IC12YWx1ZVtpXTtcclxuICAgIH1cclxufSk7XHJcbiIsIlhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5mbGlwVmVydGljYWxJbWFnZVwiLCB7XHJcbiAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAncmVzdWx0Jywgc2l6ZW9mIDogJ2ltYWdlJ30gXSxcclxuICAgIHBhcmFtczogIFsge3R5cGU6ICd0ZXh0dXJlJywgc291cmNlIDogJ2ltYWdlJ30gXSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGltYWdlKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuXHJcbiAgICAgICAgdmFyIGRlc3RwaXggPSByZXN1bHQuZGF0YTtcclxuICAgICAgICB2YXIgc3JjcGl4ID0gaW1hZ2UuZGF0YTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3dPZmZzZXQgPSB5ICogd2lkdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3JjT2Zmc2V0ID0gKHJvd09mZnNldCArIHgpICogNDtcclxuICAgICAgICAgICAgICAgIHZhciBkc3RPZmZzZXQgPSAocm93T2Zmc2V0ICsgKCh3aWR0aC0xKSAtIHgpKSAqIDQ7XHJcbiAgICAgICAgICAgICAgICBkZXN0cGl4W2RzdE9mZnNldF0gPSAgc3JjcGl4W3NyY09mZnNldF07XHJcbiAgICAgICAgICAgICAgICBkZXN0cGl4W2RzdE9mZnNldCsxXSA9IHNyY3BpeFtzcmNPZmZzZXQrMV07XHJcbiAgICAgICAgICAgICAgICBkZXN0cGl4W2RzdE9mZnNldCsyXSA9IHNyY3BpeFtzcmNPZmZzZXQrMl07XHJcbiAgICAgICAgICAgICAgICBkZXN0cGl4W2RzdE9mZnNldCszXSA9IHNyY3BpeFtzcmNPZmZzZXQrM107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZm9yd2FyZEtpbmVtYXRpY3NcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDR4NCcsICBuYW1lOiAncmVzdWx0JywgY3VzdG9tQWxsb2M6IHRydWV9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnaW50JywgICAgICAgc291cmNlOiAncGFyZW50JywgYXJyYXk6IHRydWUgfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQ0eDQnLCAgc291cmNlOiAneGZvcm0nLCBhcnJheTogdHJ1ZSB9XSxcclxuICAgIGFsbG9jOiBmdW5jdGlvbihzaXplcywgcGFyZW50LCB4Zm9ybSlcclxuICAgIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4ocGFyZW50Lmxlbmd0aCwgeGZvcm0ubGVuZ3RoIC8gMTYpO1xyXG4gICAgICAgIHNpemVzWydyZXN1bHQnXSA9IGxlbmd0aDtcclxuICAgIH0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBwYXJlbnQseGZvcm0sIGluZm8pIHtcclxuXHJcbiAgICAgICAgdmFyIGJvbmVDb3VudCA9IHJlc3VsdC5sZW5ndGggLyAxNjtcclxuXHJcbiAgICAgICAgdmFyIGNvbXB1dGVkID0gW107XHJcbiAgICAgICAgLy9Gb3IgZWFjaCBib25lIGRvOlxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBib25lQ291bnQ7KXtcclxuICAgICAgICAgICAgaWYoIWNvbXB1dGVkW2ldKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBhcmVudFtpXTtcclxuICAgICAgICAgICAgICAgIGlmKHAgPj0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGJvbmUgaGFzIGEgcGFyZW50IGJvbmVcclxuICAgICAgICAgICAgICAgICAgICBpZighY29tcHV0ZWRbcF0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RoZSBwYXJlbnQgYm9uZSdzIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBoYXNuJ3QgYmVlbiBjb21wdXRlZCB5ZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUocGFyZW50W3BdID49IDAgJiYgIWNvbXB1dGVkW3BhcmVudFtwXV0pIHAgPSBwYXJlbnRbcF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwYXJlbnRbcF0gPj0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseU9mZnNldChyZXN1bHQsIHAqMTYsIHhmb3JtLCBwKjE2LCByZXN1bHQsIHBhcmVudFtwXSoxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCAxNjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3AqMTYral0gPSB4Zm9ybVtwKjE2K2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZFtwXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0KHJlc3VsdCwgaSoxNiwgeGZvcm0sIGkqMTYsIHJlc3VsdCwgIHAqMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDE2OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2kqMTYral0gPSB4Zm9ybVtpKjE2K2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbXB1dGVkW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwiWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmZvcndhcmRLaW5lbWF0aWNzSW52XCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQ0eDQnLCAgbmFtZTogJ3Jlc3VsdCcsIGN1c3RvbUFsbG9jOiB0cnVlfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2ludCcsICAgICAgIHNvdXJjZTogJ3BhcmVudCcsIGFycmF5OiB0cnVlIH0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0NHg0JywgIHNvdXJjZTogJ3hmb3JtJywgYXJyYXk6IHRydWUgfV0sXHJcbiAgICBhbGxvYzogZnVuY3Rpb24oc2l6ZXMsIHBhcmVudCwgeGZvcm0pXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHBhcmVudC5sZW5ndGgsIHhmb3JtLmxlbmd0aCAvIDE2KTtcclxuICAgICAgICBzaXplc1sncmVzdWx0J10gPSBsZW5ndGg7XHJcbiAgICB9LFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgcGFyZW50LHhmb3JtLCBpbmZvKSB7XHJcbiAgICAgICAgdmFyIGJvbmVDb3VudCA9IHhmb3JtLmxlbmd0aCAvIDE2O1xyXG5cclxuICAgICAgICB2YXIgY29tcHV0ZWQgPSBbXTtcclxuICAgICAgICAvL0ZvciBlYWNoIGJvbmUgZG86XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGJvbmVDb3VudDspe1xyXG4gICAgICAgICAgICBpZighY29tcHV0ZWRbaV0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gcGFyZW50W2ldO1xyXG4gICAgICAgICAgICAgICAgaWYocCA+PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAvL1RoaXMgYm9uZSBoYXMgYSBwYXJlbnQgYm9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFjb21wdXRlZFtwXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhlIHBhcmVudCBib25lJ3MgdHJhbnNmb3JtYXRpb24gbWF0cml4IGhhc24ndCBiZWVuIGNvbXB1dGVkIHlldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShwYXJlbnRbcF0gPj0gMCAmJiAhY29tcHV0ZWRbcGFyZW50W3BdXSkgcCA9IHBhcmVudFtwXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UaGUgY3VycmVudCBib25lIGhhcyBhIHBhcmVudCBhbmQgaXRzIHRyYW5zZm9ybSBoYXNuJ3QgYmVlbiBjb21wdXRlZCB5ZXRcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBhcmVudFtwXSA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0KHJlc3VsdCwgcCoxNiwgcmVzdWx0LCBwYXJlbnRbcF0qMTYsIHhmb3JtLCBwKjE2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDE2OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcCoxNitqXSA9IHhmb3JtW3AqMTYral07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkW3BdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0KHJlc3VsdCwgaSoxNiwgIHJlc3VsdCwgIHAqMTYsIHhmb3JtLCBpKjE2KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCAxNjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpKjE2K2pdID0geGZvcm1baSoxNitqXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb21wdXRlZFtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsIi8vIEJhc2VkIG9uOiBodHRwOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMxMDA2MzkyNS9odHRwOi8vZGVtLm9jcmFjeS5vcmcvbGliZXJvL3Bob3RvYm9vdGgvXHJcblxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZnVuTWlycm9ySW1hZ2VcIiwge1xyXG4gICAgb3V0cHV0czogWyB7dHlwZTogJ3RleHR1cmUnLCBuYW1lIDogJ3Jlc3VsdCcsIHNpemVvZiA6ICdpbWFnZSd9IF0sXHJcbiAgICBwYXJhbXM6ICBbIHt0eXBlOiAndGV4dHVyZScsIHNvdXJjZSA6ICdpbWFnZSd9LFxyXG4gICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlIDogJ3RpbWUnfSBdLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW1hZ2UsIHRpbWUpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSByZXN1bHQud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlc3VsdC5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHRpbWUgPSB0aW1lWzBdO1xyXG5cclxuICAgICAgICB2YXIgcyA9IGltYWdlLmRhdGE7XHJcbiAgICAgICAgdmFyIGQgPSByZXN1bHQuZGF0YTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvKm9yaWdpbmFsIGNvb3JkaW5hdGVzKi9cclxuICAgICAgICAgICAgICAgIC8vIFswLjAgLDEuMF0geCBbMC4wLCAxLjBdXHJcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRYID0geCAvIHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkWSA9IHkgLyBoZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gWy0xLjAgLDEuMF0geCBbLTEuMCwgMS4wXVxyXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1Db29yZFggPSAyLjAgKiBjb29yZFggLSAxLjA7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9ybUNvb3JkWSA9IDIuMCAqIGNvb3JkWSAtIDEuMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvKmdvIHRvIHBvbGFyIGNvb3JkaW5hdGVzKi9cclxuICAgICAgICAgICAgICAgIHZhciByID0gTWF0aC5zcXJ0KG5vcm1Db29yZFgqbm9ybUNvb3JkWCArIG5vcm1Db29yZFkqbm9ybUNvb3JkWSk7IC8vIGxlbmd0aChub3JtQ29vcmQpXHJcbiAgICAgICAgICAgICAgICB2YXIgcGhpID0gTWF0aC5hdGFuMihub3JtQ29vcmRZLCBub3JtQ29vcmRYKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKnNxdWVlemUgYW5kIHZhcnkgaXQgb3ZlciB0aW1lKi9cclxuICAgICAgICAgICAgICAgIHIgPSBNYXRoLnBvdyhyLCAxLjAvMS44KSAqIHRpbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLypiYWNrIHRvIGNhcnRlc2lhbiBjb29yZGluYXRlcyovXHJcbiAgICAgICAgICAgICAgICBub3JtQ29vcmRYID0gciAqIE1hdGguY29zKHBoaSk7XHJcbiAgICAgICAgICAgICAgICBub3JtQ29vcmRZID0gciAqIE1hdGguc2luKHBoaSk7XHJcbiAgICAgICAgICAgICAgICAvLyBbMC4wICwxLjBdIHggWzAuMCwgMS4wXVxyXG4gICAgICAgICAgICAgICAgY29vcmRYID0gbm9ybUNvb3JkWCAvIDIuMCArIDAuNTtcclxuICAgICAgICAgICAgICAgIGNvb3JkWSA9IG5vcm1Db29yZFkgLyAyLjAgKyAwLjU7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNYID0gTWF0aC5yb3VuZChjb29yZFggKiB3aWR0aCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc1kgPSBNYXRoLnJvdW5kKGNvb3JkWSAqIGhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAoc1kgKiB3aWR0aCArIHNYKSo0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGcgPSBzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gc1tpICsgMl07XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHNbaSArIDNdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qY29sb3IgdGhlIGZyYWdtZW50IHdpdGggY2FsY3VsYXRlZCB0ZXh0dXJlKi9cclxuICAgICAgICAgICAgICAgIHZhciBpID0gKHkgKiB3aWR0aCArIHgpKjQ7XHJcbiAgICAgICAgICAgICAgICBkW2ldID0gcjtcclxuICAgICAgICAgICAgICAgIGRbaSArIDFdID0gZztcclxuICAgICAgICAgICAgICAgIGRbaSArIDJdID0gYjtcclxuICAgICAgICAgICAgICAgIGRbaSArIDNdID0gYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufSk7XHJcbiIsIlxyXG5mdW5jdGlvbiBmZXRjaChyZXN1bHQsIHZhbHVlLCBpbmRleCwgY29tcG9uZW50cyl7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW5kZXgubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gaW5kZXhbaV0gKiBjb21wb25lbnRzO1xyXG4gICAgICAgIHZhciBqID0gY29tcG9uZW50cztcclxuICAgICAgICB3aGlsZShqLS0pIHtcclxuICAgICAgICAgICAgcmVzdWx0W2kqY29tcG9uZW50cyArIGpdID0gdmFsdWVbb2Zmc2V0ICsgal07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZ2V0XCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZTogJ3ZhbHVlJywgYXJyYXk6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICdpbmRleCd9XSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBpbmRleCwgaW5mbykge1xyXG4gICAgICAgIGZldGNoKHJlc3VsdCwgdmFsdWUsIGluZGV4LCAxKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZ2V0XCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQyJywgbmFtZTogJ3Jlc3VsdCd9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQyJywgc291cmNlOiAndmFsdWUnLCBhcnJheTogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2ludCcsIHNvdXJjZTogJ2luZGV4J31dLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZGV4LCBpbmZvKSB7XHJcbiAgICAgICAgZmV0Y2gocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIDIpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5nZXRcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd2YWx1ZScsIGFycmF5OiB0cnVlfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnaW50Jywgc291cmNlOiAnaW5kZXgnfV0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIGluZm8pIHtcclxuICAgICAgICBmZXRjaChyZXN1bHQsIHZhbHVlLCBpbmRleCwgNCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5nZXRcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDQnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDQnLCBzb3VyY2U6ICd2YWx1ZScsIGFycmF5OiB0cnVlfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnaW50Jywgc291cmNlOiAnaW5kZXgnfV0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIGluZm8pIHtcclxuICAgICAgICBmZXRjaChyZXN1bHQsIHZhbHVlLCBpbmRleCwgNCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmdldFwiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0NHg0JywgbmFtZTogJ3Jlc3VsdCd9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQ0eDQnLCBzb3VyY2U6ICd2YWx1ZScsIGFycmF5OiB0cnVlfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnaW50Jywgc291cmNlOiAnaW5kZXgnfV0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIGluZm8pIHtcclxuICAgICAgICBmZXRjaChyZXN1bHQsIHZhbHVlLCBpbmRleCwgMTYpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcblxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZ2V0XCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnaW50JywgbmFtZTogJ3Jlc3VsdCd9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnaW50Jywgc291cmNlOiAndmFsdWUnLCBhcnJheTogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2ludCcsIHNvdXJjZTogJ2luZGV4J31dLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZGV4LCBpbmZvKSB7XHJcbiAgICAgICAgZmV0Y2gocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIDEpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5nZXRcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdib29sJywgbmFtZTogJ3Jlc3VsdCd9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnYm9vbCcsIHNvdXJjZTogJ3ZhbHVlJywgYXJyYXk6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICdpbmRleCd9XSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBpbmRleCwgaW5mbykge1xyXG4gICAgICAgIGZldGNoKHJlc3VsdCwgdmFsdWUsIGluZGV4LCAxKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZ2V0XCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnYnl0ZScsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2J5dGUnLCBzb3VyY2U6ICd2YWx1ZScsIGFycmF5OiB0cnVlfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnaW50Jywgc291cmNlOiAnaW5kZXgnfV0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIGluZm8pIHtcclxuICAgICAgICBmZXRjaChyZXN1bHQsIHZhbHVlLCBpbmRleCwgMSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuXHJcblxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZ2V0XCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAndWJ5dGUnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICd1Ynl0ZScsIHNvdXJjZTogJ3ZhbHVlJywgYXJyYXk6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICdpbmRleCd9XSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBpbmRleCwgaW5mbykge1xyXG4gICAgICAgIGZldGNoKHJlc3VsdCwgdmFsdWUsIGluZGV4LCAxKTtcclxuICAgIH1cclxufSk7XHJcbiIsIlhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5ncmF5c2NhbGVJbWFnZVwiLCB7XHJcbiAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAncmVzdWx0Jywgc2l6ZW9mIDogJ2ltYWdlJ30gXSxcclxuICAgIHBhcmFtczogIFsge3R5cGU6ICd0ZXh0dXJlJywgc291cmNlIDogJ2ltYWdlJ30gXSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGltYWdlKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuXHJcbiAgICAgICAgdmFyIHMgPSBpbWFnZS5kYXRhO1xyXG4gICAgICAgIHZhciBkID0gcmVzdWx0LmRhdGE7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgIHZhciByID0gc1tpXTtcclxuICAgICAgICAgICAgdmFyIGcgPSBzW2kgKyAxXTtcclxuICAgICAgICAgICAgdmFyIGIgPSBzW2kgKyAyXTtcclxuICAgICAgICAgICAgdmFyIGEgPSBzW2kgKyAzXTtcclxuICAgICAgICAgICAgLy8gQ0lFIGx1bWluYW5jZSBmb3IgdGhlIFJHQlxyXG4gICAgICAgICAgICAvLyBUaGUgaHVtYW4gZXllIGlzIGJhZCBhdCBzZWVpbmcgcmVkIGFuZCBibHVlLCBzbyB3ZSBkZS1lbXBoYXNpemUgdGhlbS5cclxuICAgICAgICAgICAgdmFyIHYgPSAwLjIxMjYgKiByICsgMC43MTUyICogZyArIDAuMDcyMiAqIGI7XHJcbiAgICAgICAgICAgIGRbaV0gPSBkW2kgKyAxXSA9IGRbaSArIDJdID0gdlxyXG4gICAgICAgICAgICBkW2kgKyAzXSA9IGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59KTtcclxuIiwicmVxdWlyZShcIi4vYWRkLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9idWZmZXJTZWxlY3QuanNcIik7XHJcbnJlcXVpcmUoXCIuL2NsYW1wSW1hZ2UuanNcIik7XHJcbnJlcXVpcmUoXCIuL2NvbnZvbHV0ZUltYWdlLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9jcmVhdGVJR0luZGV4LmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9jcmVhdGVUcmFuc2Zvcm0uanNcIik7XHJcbnJlcXVpcmUoXCIuL2NyZWF0ZVRyYW5zZm9ybUludi5qc1wiKTtcclxucmVxdWlyZShcIi4vZGVidWcuanNcIik7XHJcbnJlcXVpcmUoXCIuL2ZsaXBOb3JtYWwuanNcIik7XHJcbnJlcXVpcmUoXCIuL2ZsaXBWZXJ0aWNhbEltYWdlLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9mb3J3YXJkS2luZW1hdGljcy5qc1wiKTtcclxucmVxdWlyZShcIi4vZm9yd2FyZEtpbmVtYXRpY3NJbnYuanNcIik7XHJcbnJlcXVpcmUoXCIuL2Z1bk1pcnJvckltYWdlLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9nZXQuanNcIik7XHJcbnJlcXVpcmUoXCIuL2dyYXlzY2FsZUltYWdlLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9sZXJwM3NlcS5qc1wiKTtcclxucmVxdWlyZShcIi4vbWFnbml0dWRlSW1hZ2UuanNcIik7XHJcbnJlcXVpcmUoXCIuL21lcmdlMy5qc1wiKTtcclxucmVxdWlyZShcIi4vbW9ycGgzLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9tdWw0eDQuanNcIik7XHJcbnJlcXVpcmUoXCIuL25vaXNlSW1hZ2UuanNcIik7XHJcbnJlcXVpcmUoXCIuL25vcm1hbGl6ZTMuanNcIik7XHJcbnJlcXVpcmUoXCIuL3BvcGFydEltYWdlLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9yZ2JlUE5HdG9GbG9hdC5qc1wiKTtcclxucmVxdWlyZShcIi4vc2VsZWN0Qm9vbC5qc1wiKTtcclxucmVxdWlyZShcIi4vc2VsZWN0VHJhbnNmb3JtLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9zZXBpYUltYWdlLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9za2luRGlyZWN0aW9uLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9za2luUG9zaXRpb24uanNcIik7XHJcbnJlcXVpcmUoXCIuL3NsZXJwc2VxLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9zb2JlbEltYWdlLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9zdWIzLmpzXCIpO1xyXG4iLCJ2YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL3V0aWxzXCIpLmJpbmFyeVNlYXJjaDtcclxudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcblxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cubGVycFNlcVwiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0MycsIHNvdXJjZTogJ3NlcXVlbmNlJ30sXHJcbiAgICAgICAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZTogJ2tleSd9XSxcclxuICAgIG1hcHBpbmc6IFsgIHsgbmFtZTogJ3ZhbHVlMScsIHNvdXJjZTogJ3NlcXVlbmNlJywgc2VxdWVuY2U6IFhDLlNFUVVFTkNFLlBSRVZfQlVGRkVSLCBrZXlTb3VyY2U6ICdrZXknfSxcclxuICAgICAgICB7IG5hbWU6ICd2YWx1ZTInLCBzb3VyY2U6ICdzZXF1ZW5jZScsIHNlcXVlbmNlOiBYQy5TRVFVRU5DRS5ORVhUX0JVRkZFUiwga2V5U291cmNlOiAna2V5J30sXHJcbiAgICAgICAgeyBuYW1lOiAnd2VpZ2h0Jywgc291cmNlOiAnc2VxdWVuY2UnLCBzZXF1ZW5jZTogWEMuU0VRVUVOQ0UuTElORUFSX1dFSUdIVCwga2V5U291cmNlOiAna2V5J31dLFxyXG4gICAgZXZhbHVhdGVfY29yZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZTEsIHZhbHVlMiwgd2VpZ2h0KXtcclxuICAgICAgICB2YXIgaW52V2VpZ2h0ID0gMSAtIHdlaWdodFswXTtcclxuICAgICAgICByZXN1bHRbMF0gPSBpbnZXZWlnaHQqdmFsdWUxWzBdICsgd2VpZ2h0WzBdKnZhbHVlMlswXTtcclxuICAgICAgICByZXN1bHRbMV0gPSBpbnZXZWlnaHQqdmFsdWUxWzFdICsgd2VpZ2h0WzBdKnZhbHVlMlsxXTtcclxuICAgICAgICByZXN1bHRbMl0gPSBpbnZXZWlnaHQqdmFsdWUxWzJdICsgd2VpZ2h0WzBdKnZhbHVlMlsyXTtcclxuICAgIH1cclxufSk7XHJcblxyXG5cclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmxlcnBTZXFBc3luY1wiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0MycsIHNvdXJjZTogJ3NlcXVlbmNlJ30sXHJcbiAgICAgICAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZTogJ2tleSd9XSxcclxuICAgIG1hcHBpbmc6IFsgIHsgbmFtZTogJ3ZhbHVlMScsIHNvdXJjZTogJ3NlcXVlbmNlJywgc2VxdWVuY2U6IFhDLlNFUVVFTkNFLlBSRVZfQlVGRkVSLCBrZXlTb3VyY2U6ICdrZXknfSxcclxuICAgICAgICB7IG5hbWU6ICd2YWx1ZTInLCBzb3VyY2U6ICdzZXF1ZW5jZScsIHNlcXVlbmNlOiBYQy5TRVFVRU5DRS5ORVhUX0JVRkZFUiwga2V5U291cmNlOiAna2V5J30sXHJcbiAgICAgICAgeyBuYW1lOiAnd2VpZ2h0Jywgc291cmNlOiAnc2VxdWVuY2UnLCBzZXF1ZW5jZTogWEMuU0VRVUVOQ0UuTElORUFSX1dFSUdIVCwga2V5U291cmNlOiAna2V5J31dLFxyXG4gICAgZXZhbHVhdGVfYXN5bmM6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUxLCB2YWx1ZTIsIHdlaWdodCwgaW5mbywgY2FsbGJhY2spe1xyXG4gICAgICAgIHZhciBpID0gaW5mby5pdGVyYXRlQ291bnQsIG9mZjAsIG9mZjEsIG9mZjI7XHJcbiAgICAgICAgd2hpbGUoaS0tKXtcclxuICAgICAgICAgICAgb2ZmMCA9IChpbmZvLml0ZXJGbGFnWzBdID8gaSA6IDApKjM7XHJcbiAgICAgICAgICAgIG9mZjEgPSAoaW5mby5pdGVyRmxhZ1sxXSA/IGkgOiAwKSozO1xyXG4gICAgICAgICAgICBvZmYyID0gaW5mby5pdGVyRmxhZ1syXSA/IGkgOiAwO1xyXG4gICAgICAgICAgICB2YXIgaW52V2VpZ2h0ID0gMSAtIHdlaWdodFtvZmYyXTtcclxuICAgICAgICAgICAgcmVzdWx0W2kqM10gPSBpbnZXZWlnaHQqdmFsdWUxW29mZjBdICsgd2VpZ2h0W29mZjJdKnZhbHVlMltvZmYxXTtcclxuICAgICAgICAgICAgcmVzdWx0W2kqMysxXSA9IGludldlaWdodCp2YWx1ZTFbb2ZmMCsxXSArIHdlaWdodFtvZmYyXSp2YWx1ZTJbb2ZmMSsxXTtcclxuICAgICAgICAgICAgcmVzdWx0W2kqMysyXSA9IGludldlaWdodCp2YWx1ZTFbb2ZmMCsyXSArIHdlaWdodFtvZmYyXSp2YWx1ZTJbb2ZmMSsyXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDIwMCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5sZXJwS2V5c1wiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlOiAna2V5cycsIGFycmF5OiB0cnVlfSxcclxuICAgICAgICB7dHlwZTogJ2Zsb2F0MycsIHNvdXJjZTogJ3ZhbHVlcycsIGFycmF5OiB0cnVlfSxcclxuICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlOiAna2V5J31dLFxyXG4gICAgYWxsb2M6IGZ1bmN0aW9uKHNpemVzLCBrZXlzLCB2YWx1ZXMsIGtleSlcclxuICAgIHtcclxuICAgICAgICBzaXplc1sncmVzdWx0J10gPSAzO1xyXG4gICAgfSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGtleXMsIHZhbHVlcywga2V5KSB7XHJcbiAgICAgICAgdmFyIG1heElkeCA9IE1hdGgubWluKGtleXMubGVuZ3RoLCBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAzKSk7XHJcbiAgICAgICAgdmFyIGlkeCA9IGJpbmFyeVNlYXJjaChrZXlzLCBrZXlbMF0sIG1heElkeCk7XHJcblxyXG4gICAgICAgIGlmKGlkeCA8IDAgfHwgaWR4ID09IG1heElkeCAtIDEpe1xyXG4gICAgICAgICAgICBpZHggPSBNYXRoLm1heCgwLGlkeCk7XHJcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHZhbHVlc1szKmlkeF07XHJcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHZhbHVlc1szKmlkeCsxXTtcclxuICAgICAgICAgICAgcmVzdWx0WzJdID0gdmFsdWVzWzMqaWR4KzJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB2YXIgd2VpZ2h0ID0gKGtleVswXSAtIGtleXNbaWR4XSkgLyAoa2V5c1tpZHgrMV0gLSBrZXlzW2lkeF0pO1xyXG4gICAgICAgICAgICB2YXIgaW52V2VpZ2h0ID0gMSAtIHdlaWdodDtcclxuICAgICAgICAgICAgcmVzdWx0WzBdID0gaW52V2VpZ2h0KnZhbHVlc1szKmlkeF0gKyB3ZWlnaHQqdmFsdWVzWzMqaWR4ICsgM107XHJcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IGludldlaWdodCp2YWx1ZXNbMyppZHgrMV0gKyB3ZWlnaHQqdmFsdWVzWzMqaWR4ICsgNF07XHJcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IGludldlaWdodCp2YWx1ZXNbMyppZHgrMl0gKyB3ZWlnaHQqdmFsdWVzWzMqaWR4ICsgNV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcblxyXG5cclxuXHJcblxyXG4iLCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cubWFnbml0dWRlSW1hZ2VcIiwge1xyXG4gICAgb3V0cHV0czogWyB7dHlwZTogJ3RleHR1cmUnLCBuYW1lIDogJ3Jlc3VsdCcsIHNpemVvZiA6ICdpbWFnZTEnfSBdLFxyXG4gICAgcGFyYW1zOiAgW1xyXG4gICAgICAgIHt0eXBlOiAndGV4dHVyZScsIHNvdXJjZSA6ICdpbWFnZTEnfSxcclxuICAgICAgICB7dHlwZTogJ3RleHR1cmUnLCBzb3VyY2UgOiAnaW1hZ2UyJ31cclxuICAgIF0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBpbWFnZTEsIGltYWdlMikge1xyXG4gICAgICAgIHZhciBpbnBpeDEgPSBpbWFnZTEuZGF0YTtcclxuICAgICAgICB2YXIgaW5waXgyID0gaW1hZ2UyLmRhdGE7XHJcbiAgICAgICAgdmFyIG91dHBpeCA9IHJlc3VsdC5kYXRhO1xyXG5cclxuICAgICAgICB2YXIgbGVuID0gaW5waXgxLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBsZW47IGkrPTEpIHtcclxuICAgICAgICAgICAgdmFyIHZhbDEgPSBpbnBpeDFbaV07XHJcbiAgICAgICAgICAgIHZhciB2YWwyID0gaW5waXgyW2ldO1xyXG4gICAgICAgICAgICBvdXRwaXhbaV0gPSBNYXRoLnNxcnQodmFsMSp2YWwxICsgdmFsMip2YWwyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJcclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93Lm1lcmdlM1wiLCB7XHJcbiAgICBvdXRwdXRzOiBbe25hbWU6ICdyZXN1bHQnLCB0dXBsZVNpemU6ICcxNid9XSxcclxuICAgIHBhcmFtczogIFsndmFsdWUxJywndmFsdWUyJywndmFsdWUzJ10sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24odmFsdWUxLCB2YWx1ZTIsIHZhbHVlMykge1xyXG4gICAgICAgIGlmKCEodmFsdWUxICYmIHZhbHVlMiAmJiB2YWx1ZTMpKVxyXG4gICAgICAgICAgICB0aHJvdyBcIlhmbG93Ojptb3JwaDM6IE5vdCBhbGwgcGFyYW1ldGVycyBhcmUgc2V0XCI7XHJcblxyXG4gICAgICAgIHZhciBvdmVyYWxsTGVuZ3RoID0gdmFsdWUxLmxlbmd0aCArIHZhbHVlMi5sZW5ndGggKyB2YWx1ZTMubGVuZ3RoO1xyXG4gICAgICAgIGlmICghdGhpcy50bXAgfHwgdGhpcy50bXAubGVuZ3RoICE9IG92ZXJhbGxMZW5ndGgpXHJcbiAgICAgICAgICAgIHRoaXMudG1wID0gbmV3IEZsb2F0MzJBcnJheShvdmVyYWxsTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdGhpcy50bXAuc2V0KHZhbHVlMSk7XHJcbiAgICAgICAgdGhpcy50bXAuc2V0KHZhbHVlMiwgdmFsdWUxLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy50bXAuc2V0KHZhbHVlMywgdmFsdWUxLmxlbmd0aCArIHZhbHVlMi5sZW5ndGgpO1xyXG4gICAgICAgIHRoaXMucmVzdWx0LnJlc3VsdCA9IHRoaXMudG1wO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59KTtcclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93Lm1lcmdlOFwiLCB7XHJcbiAgICBvdXRwdXRzOiBbe25hbWU6ICdyZXN1bHQnLCB0dXBsZVNpemU6ICcxNid9XSxcclxuICAgIHBhcmFtczogIFsndmFsdWUxJywndmFsdWUyJywndmFsdWUzJywndmFsdWU0JywndmFsdWU1JywndmFsdWU2JywndmFsdWU3JywndmFsdWU4J10sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24odmFsdWUxLCB2YWx1ZTIsIHZhbHVlMyx2YWx1ZTQsdmFsdWU1LHZhbHVlNix2YWx1ZTcsdmFsdWU4KSB7XHJcbiAgICAgICAgaWYoISh2YWx1ZTEgJiYgdmFsdWUyICYmIHZhbHVlMyAmJiB2YWx1ZTQgJiYgdmFsdWU1ICYmIHZhbHVlNiAmJiB2YWx1ZTcgJiYgdmFsdWU4KSlcclxuICAgICAgICAgICAgdGhyb3cgXCJYZmxvdzo6bW9ycGgzOiBOb3QgYWxsIHBhcmFtZXRlcnMgYXJlIHNldFwiO1xyXG5cclxuICAgICAgICB2YXIgb3ZlcmFsbExlbmd0aCA9IHZhbHVlMS5sZW5ndGggKyB2YWx1ZTIubGVuZ3RoICsgdmFsdWUzLmxlbmd0aCArIHZhbHVlNC5sZW5ndGggKyB2YWx1ZTUubGVuZ3RoICsgdmFsdWU2Lmxlbmd0aCArIHZhbHVlNy5sZW5ndGggKyB2YWx1ZTgubGVuZ3RoO1xyXG4gICAgICAgIGlmICghdGhpcy50bXAgfHwgdGhpcy50bXAubGVuZ3RoICE9IG92ZXJhbGxMZW5ndGgpXHJcbiAgICAgICAgICAgIHRoaXMudG1wID0gbmV3IEZsb2F0MzJBcnJheShvdmVyYWxsTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy50bXAuc2V0KHZhbHVlMSwgb2Zmc2V0KTtcclxuICAgICAgICB0aGlzLnRtcC5zZXQodmFsdWUyLCAob2Zmc2V0Kz12YWx1ZTEubGVuZ3RoKSk7XHJcbiAgICAgICAgdGhpcy50bXAuc2V0KHZhbHVlMywgKG9mZnNldCs9dmFsdWUyLmxlbmd0aCkpO1xyXG4gICAgICAgIHRoaXMudG1wLnNldCh2YWx1ZTQsIChvZmZzZXQrPXZhbHVlMy5sZW5ndGgpKTtcclxuICAgICAgICB0aGlzLnRtcC5zZXQodmFsdWU1LCAob2Zmc2V0Kz12YWx1ZTQubGVuZ3RoKSk7XHJcbiAgICAgICAgdGhpcy50bXAuc2V0KHZhbHVlNiwgKG9mZnNldCs9dmFsdWU1Lmxlbmd0aCkpO1xyXG4gICAgICAgIHRoaXMudG1wLnNldCh2YWx1ZTcsIChvZmZzZXQrPXZhbHVlNi5sZW5ndGgpKTtcclxuICAgICAgICB0aGlzLnRtcC5zZXQodmFsdWU4LCAob2Zmc2V0Kz12YWx1ZTcubGVuZ3RoKSk7XHJcbiAgICAgICAgdGhpcy5yZXN1bHQucmVzdWx0ID0gdGhpcy50bXA7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJcclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93Lm1vcnBoXCIsIHtcclxuICAgIG91dHB1dHM6IFt7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbXHJcbiAgICAgICAgeyB0eXBlOiAnZmxvYXQzJywgc291cmNlOiAndmFsdWUnIH0sXHJcbiAgICAgICAgeyB0eXBlOiAnZmxvYXQzJywgc291cmNlOiAndmFsdWVBZGQnfSxcclxuICAgICAgICB7IHR5cGU6ICdmbG9hdCcsIHNvdXJjZTogJ3dlaWdodCd9XHJcbiAgICBdLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIHZhbHVlQWRkLCB3ZWlnaHQsIGluZm8pIHtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW5mby5pdGVyYXRlQ291bnQ7IGkrKyl7XHJcbiAgICAgICAgICAgIHZhciB3ID0gd2VpZ2h0W2luZm8uaXRlckZsYWdbMl0gPyBpIDogMF07XHJcbiAgICAgICAgICAgIHJlc3VsdFszKmldID0gdmFsdWVbIGluZm8uaXRlckZsYWdbMF0gPyAzKmkgOiAwXSArIHcgKiB2YWx1ZUFkZFtpbmZvLml0ZXJGbGFnWzFdID8gMyppIDogMF07XHJcbiAgICAgICAgICAgIHJlc3VsdFszKmkrMV0gPSB2YWx1ZVsgaW5mby5pdGVyRmxhZ1swXSA/IDMqaSsxIDogMV0gKyB3ICogdmFsdWVBZGRbaW5mby5pdGVyRmxhZ1sxXSA/IDMqaSsxIDogMV07XHJcbiAgICAgICAgICAgIHJlc3VsdFszKmkrMl0gPSB2YWx1ZVsgaW5mby5pdGVyRmxhZ1swXSA/IDMqaSsyIDogMl0gKyB3ICogdmFsdWVBZGRbaW5mby5pdGVyRmxhZ1sxXSA/IDMqaSsyIDogMl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGV2YWx1YXRlX2NvcmU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIHZhbHVlQWRkLCB3ZWlnaHQpe1xyXG4gICAgICAgIHJlc3VsdFswXSA9IHZhbHVlWzBdICsgd2VpZ2h0WzBdICogdmFsdWVBZGRbMF07XHJcbiAgICAgICAgcmVzdWx0WzFdID0gdmFsdWVbMV0gKyB3ZWlnaHRbMF0gKiB2YWx1ZUFkZFsxXTtcclxuICAgICAgICByZXN1bHRbMl0gPSB2YWx1ZVsyXSArIHdlaWdodFswXSAqIHZhbHVlQWRkWzJdO1xyXG4gICAgfVxyXG59KTtcclxuIiwiWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93Lm11bFwiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0NHg0JywgbmFtZTogJ3Jlc3VsdCd9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQ0eDQnLCBzb3VyY2U6ICd2YWx1ZTEnfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQ0eDQnLCBzb3VyY2U6ICd2YWx1ZTInfV0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZTEsIHZhbHVlMiwgaW5mbykge1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbmZvLml0ZXJhdGVDb3VudDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0KHJlc3VsdCwgaSoxNixcclxuICAgICAgICAgICAgICAgIHZhbHVlMSwgIGluZm8uaXRlckZsYWdbMF0gPyBpKjE2IDogMCxcclxuICAgICAgICAgICAgICAgIHZhbHVlMiwgaW5mby5pdGVyRmxhZ1sxXSA/IGkqMTYgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJcclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93Lm5vaXNlSW1hZ2VcIiwge1xyXG4gICAgb3V0cHV0czogWyB7dHlwZTogJ3RleHR1cmUnLCBuYW1lIDogJ2ltYWdlJywgY3VzdG9tQWxsb2M6IHRydWV9IF0sXHJcbiAgICBwYXJhbXM6ICBbIHt0eXBlOiAnaW50Jywgc291cmNlOiAnd2lkdGgnfSxcclxuICAgICAgICAgICAgICAge3R5cGU6ICdpbnQnLCBzb3VyY2U6J2hlaWdodCd9LFxyXG4gICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0MicsIHNvdXJjZTogJ3NjYWxlJ30sXHJcbiAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2U6ICdtaW5GcmVxJ30sXHJcbiAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2U6ICdtYXhGcmVxJ30gXSxcclxuICAgIGFsbG9jOiBmdW5jdGlvbihzaXplcywgd2lkdGgsIGhlaWdodCwgc2NhbGUsIG1pbkZyZXEsIG1heEZyZXEpIHtcclxuICAgICAgICB2YXIgc2FtcGxlckNvbmZpZyA9IG5ldyBYZmxvdy5TYW1wbGVyQ29uZmlnO1xyXG4gICAgICAgIHNhbXBsZXJDb25maWcuc2V0RGVmYXVsdHMoKTtcclxuICAgICAgICBzaXplc1snaW1hZ2UnXSA9IHtcclxuICAgICAgICAgICAgaW1hZ2VGb3JtYXQgOiB7d2lkdGg6IHdpZHRoWzBdLCBoZWlnaHQgOmhlaWdodFswXX0sXHJcbiAgICAgICAgICAgIHNhbXBsZXJDb25maWcgOiBzYW1wbGVyQ29uZmlnXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24oaW1hZ2UsIHdpZHRoLCBoZWlnaHQsIHNjYWxlLCBtaW5GcmVxLCBtYXhGcmVxKSB7XHJcbiAgICAgICAgd2lkdGggPSB3aWR0aFswXTtcclxuICAgICAgICBoZWlnaHQgPSBoZWlnaHRbMF07XHJcbiAgICAgICAgbWluRnJlcSA9IG1pbkZyZXFbMF07XHJcbiAgICAgICAgbWF4RnJlcSA9IG1heEZyZXFbMF07XHJcblxyXG4gICAgICAgIHZhciBpZCA9IGltYWdlO1xyXG4gICAgICAgIHZhciBwaXggPSBpZC5kYXRhO1xyXG4gICAgICAgIHRoaXMubm9pc2UgPSB0aGlzLm5vaXNlIHx8IG5ldyBTaW1wbGV4Tm9pc2UoKTtcclxuICAgICAgICB2YXIgbm9pc2UgPSB0aGlzLm5vaXNlO1xyXG5cclxuICAgICAgICB2YXIgdXNlVHVyYnVsZW5jZSA9IG1pbkZyZXEgIT0gMC4wICYmIG1heEZyZXEgIT0gMC4wICYmIG1pbkZyZXEgPCBtYXhGcmVxO1xyXG5cclxuICAgICAgICB2YXIgc25vaXNlID0gZnVuY3Rpb24oeCx5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2lzZS5ub2lzZSh4LCB5KTsgLy8gbm9pc2Uubm9pc2UgcmV0dXJucyB2YWx1ZXMgaW4gcmFuZ2UgWy0xLDFdXHJcbiAgICAgICAgICAgIC8vcmV0dXJuIDIuMCAqIG5vaXNlLm5vaXNlKHgsIHkpIC0gMS4wOyAvLyB0aGlzIGNvZGUgaXMgZm9yIG5vaXNlIHZhbHVlIGluIHJhbmdlIFswLDFdXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHR1cmJ1bGVuY2UgPSBmdW5jdGlvbihtaW5GcmVxLCBtYXhGcmVxLCBzLCB0KSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGYgPSBtaW5GcmVxOyBmIDwgbWF4RnJlcTsgZiAqPSAyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBNYXRoLmFicyhzbm9pc2UocyAqIGYsIHQgKiBmKSkvZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB0ID0geSAvIGhlaWdodCAqIHNjYWxlWzFdO1xyXG4gICAgICAgICAgICB2YXIgaW52V2lkdGggPSAxLjAgLyB3aWR0aDtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7ICsreClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSB4ICogaW52V2lkdGggKiBzY2FsZVswXTtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gdXNlVHVyYnVsZW5jZSA/IHR1cmJ1bGVuY2UobWluRnJlcSwgbWF4RnJlcSwgcywgdCkgOiBzbm9pc2UocywgdCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gKHggKiB3aWR0aCArIHkpICogNDtcclxuICAgICAgICAgICAgICAgIHBpeFtvZmZzZXRdID0gIE1hdGguZmxvb3IodiAqIDI1NSk7XHJcbiAgICAgICAgICAgICAgICBwaXhbb2Zmc2V0KzFdID0gTWF0aC5mbG9vcih2ICogMjU1KTtcclxuICAgICAgICAgICAgICAgIHBpeFtvZmZzZXQrMl0gPSBNYXRoLmZsb29yKHYgKiAyNTUpO1xyXG4gICAgICAgICAgICAgICAgcGl4W29mZnNldCszXSA9IDI1NTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogRmlsbCB3aXRoIGdyZWVuIGNvbG9yXHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7ICsreClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9ICh4ICogd2lkdGggKyB5KSAqIDQ7XHJcbiAgICAgICAgICAgICAgICBwaXhbb2Zmc2V0XSA9ICAwXHJcbiAgICAgICAgICAgICAgICBwaXhbb2Zmc2V0KzFdID0gMjU1O1xyXG4gICAgICAgICAgICAgICAgcGl4W29mZnNldCsyXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBwaXhbb2Zmc2V0KzNdID0gMjU1O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgICovXHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59KTtcclxuIiwiXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5ub3JtYWxpemVcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd2YWx1ZSd9XSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBpbmZvKSB7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGluZm8uaXRlcmF0ZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDMqaTtcclxuICAgICAgICAgICAgdmFyIHggPSB2YWx1ZVtvZmZzZXRdO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHZhbHVlW29mZnNldCsxXTtcclxuICAgICAgICAgICAgdmFyIHogPSB2YWx1ZVtvZmZzZXQrMl07XHJcbiAgICAgICAgICAgIHZhciBsID0gMS4wL01hdGguc3FydCh4KngreSp5K3oqeik7XHJcbiAgICAgICAgICAgIHJlc3VsdFtvZmZzZXRdID0geCpsO1xyXG4gICAgICAgICAgICByZXN1bHRbb2Zmc2V0KzFdID0geSpsO1xyXG4gICAgICAgICAgICByZXN1bHRbb2Zmc2V0KzJdID0geipsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsIlxyXG4vLyBCYXNlZCBvbiBodHRwOi8va29kZW1vbmdraS5ibG9nc3BvdC5kZS8yMDExLzA2L2thbWVyYWt1LWN1c3RvbS1zaGFkZXItZWZmZWN0cy1leGFtcGxlLmh0bWxcclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LnBvcGFydEltYWdlXCIsIHtcclxuICAgIG91dHB1dHM6IFsge3R5cGU6ICd0ZXh0dXJlJywgbmFtZSA6ICdyZXN1bHQnLCBzaXplb2YgOiAnaW1hZ2UnfSBdLFxyXG4gICAgcGFyYW1zOiAgWyB7dHlwZTogJ3RleHR1cmUnLCBzb3VyY2UgOiAnaW1hZ2UnfSxcclxuICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlIDogJ3RpbWUnfSBdLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW1hZ2UsIHRpbWUpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG5cclxuICAgICAgICB2YXIgcyA9IGltYWdlLmRhdGE7XHJcbiAgICAgICAgdmFyIGQgPSByZXN1bHQuZGF0YTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgdmFyIHIgPSBzW2ldIC8gMjU1O1xyXG4gICAgICAgICAgICB2YXIgZyA9IHNbaSArIDFdIC8gMjU1O1xyXG4gICAgICAgICAgICB2YXIgYiA9IHNbaSArIDJdIC8gMjU1O1xyXG4gICAgICAgICAgICB2YXIgYSA9IHNbaSArIDNdIC8gMjU1O1xyXG5cclxuICAgICAgICAgICAgdmFyIHkgPSAwLjMgKiByICsgMC41OSAqIGcgKyAwLjExICogYjtcclxuICAgICAgICAgICAgeSA9IHkgPCAwLjMgPyAwLjAgOiAoeSA8IDAuNiA/IDAuNSA6IDEuMCk7XHJcbiAgICAgICAgICAgIGlmICh5ID09IDAuNSkge1xyXG4gICAgICAgICAgICAgICAgZFtpXSAgID0gMC44ICogMjU1O1xyXG4gICAgICAgICAgICAgICAgZFtpKzFdID0gMDtcclxuICAgICAgICAgICAgICAgIGRbaSsyXSA9IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeSA9PSAxLjApIHtcclxuICAgICAgICAgICAgICAgIGRbaV0gICA9IDAuOSAqIDI1NTtcclxuICAgICAgICAgICAgICAgIGRbaSsxXSA9IDAuOSAqIDI1NTtcclxuICAgICAgICAgICAgICAgIGRbaSsyXSA9IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkW2ldID0gMDtcclxuICAgICAgICAgICAgICAgIGRbaSsxXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBkW2krMl0gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRbaSszXSA9IHNbaSszXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJ2YXIgU2FtcGxlckNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2UvZGF0YS5qc1wiKS5TYW1wbGVyQ29uZmlnO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5yZ2JlUE5HdG9GbG9hdFwiLCB7XHJcbiAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAncmVzdWx0JywgY3VzdG9tQWxsb2M6IHRydWUgfSBdLFxyXG4gICAgcGFyYW1zOiAgW1xyXG4gICAgICAgIHt0eXBlOiAndGV4dHVyZScsIHNvdXJjZSA6ICdpbWFnZSd9XHJcbiAgICBdLFxyXG4gICAgYWxsb2M6IGZ1bmN0aW9uIChzaXplcywgaW1hZ2UpIHtcclxuICAgICAgICB2YXIgc2FtcGxlckNvbmZpZyA9IG5ldyBTYW1wbGVyQ29uZmlnO1xyXG4gICAgICAgIHNhbXBsZXJDb25maWcuc2V0RGVmYXVsdHMoKTtcclxuICAgICAgICBzYW1wbGVyQ29uZmlnLm1pbkZpbHRlciA9IFhDLlRFWF9GSUxURVJfVFlQRS5ORUFSRVNUO1xyXG4gICAgICAgIHNhbXBsZXJDb25maWcubWFnRmlsdGVyID0gWEMuVEVYX0ZJTFRFUl9UWVBFLk5FQVJFU1Q7XHJcbiAgICAgICAgc2l6ZXNbXCJyZXN1bHRcIl0gPSB7XHJcbiAgICAgICAgICAgIGltYWdlRm9ybWF0IDoge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGltYWdlLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBpbWFnZS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICB0ZXhlbFR5cGU6IFhDLlRFWFRVUkVfVFlQRS5GTE9BVCxcclxuICAgICAgICAgICAgICAgIHRleGVsRm9ybWF0OiBYQy5URVhUVVJFX0ZPUk1BVC5SR0JcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2FtcGxlckNvbmZpZzogc2FtcGxlckNvbmZpZ1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW1hZ2UpIHtcclxuICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBpbWFnZS5kYXRhLmxlbmd0aDsgaWR4ICs9IDQpIHtcclxuICAgICAgICAgICAgdmFyIHJnYmUgPSBpbWFnZS5kYXRhLnN1YmFycmF5KGlkeCwgaWR4ICsgNCk7XHJcbiAgICAgICAgICAgIHZhciBmID0gMC4wO1xyXG4gICAgICAgICAgICB2YXIgZSA9IHJnYmVbM107XHJcblxyXG4gICAgICAgICAgICBpZiAoZSA+IDAuMClcclxuICAgICAgICAgICAgICAgIGYgPSBNYXRoLnBvdygyLjAsIGUgLSAoMTI4LjAgKyA4LjApKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZ2IgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xyXG4gICAgICAgICAgICByZ2JbMF0gPSByZ2JlWzBdICogZjtcclxuICAgICAgICAgICAgcmdiWzFdID0gcmdiZVsxXSAqIGY7XHJcbiAgICAgICAgICAgIHJnYlsyXSA9IHJnYmVbMl0gKiBmO1xyXG4gICAgICAgICAgICByZXN1bHQuZGF0YS5zZXQocmdiLCBpZHggLyA0ICogMyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59KTtcclxuIiwiXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5zZWxlY3RCb29sXCIsIHtcclxuICAgIG91dHB1dHM6IFsge3R5cGU6ICdib29sJywgbmFtZSA6ICdyZXN1bHQnLCBjdXN0b21BbGxvYzogdHJ1ZX0gXSxcclxuICAgIHBhcmFtczogIFsge3R5cGU6ICdpbnQnLCBzb3VyY2UgOiAnaW5kZXgnfSxcclxuICAgICAgICAgICAgICAge3R5cGU6ICdib29sJywgc291cmNlOiAndmFsdWUnfSBdLFxyXG4gICAgYWxsb2M6IGZ1bmN0aW9uKHNpemVzLCBpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICBzaXplc1sncmVzdWx0J10gPSAxO1xyXG4gICAgfSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBpID0gaW5kZXhbMF07XHJcbiAgICAgICAgaWYgKGkgPCB2YWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVzdWx0WzBdID0gdmFsdWVbaV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0WzBdID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwiXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5zZWxlY3RUcmFuc2Zvcm1cIiwge1xyXG4gICAgb3V0cHV0czogWyB7dHlwZTogJ2Zsb2F0NHg0JywgbmFtZSA6ICdyZXN1bHQnLCBjdXN0b21BbGxvYzogdHJ1ZX0gXSxcclxuICAgIHBhcmFtczogIFsge3R5cGU6ICdpbnQnLCBzb3VyY2UgOiAnaW5kZXgnfSxcclxuICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDR4NCcsIHNvdXJjZTogJ3RyYW5zZm9ybSd9IF0sXHJcbiAgICBhbGxvYzogZnVuY3Rpb24oc2l6ZXMsIGluZGV4LCB0cmFuc2Zvcm0pIHtcclxuICAgICAgICBzaXplc1sncmVzdWx0J10gPSAxO1xyXG4gICAgfSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGluZGV4LCB0cmFuc2Zvcm0pIHtcclxuICAgICAgICB2YXIgaSA9IDE2ICogaW5kZXhbMF07XHJcbiAgICAgICAgaWYgKGkgPCB0cmFuc2Zvcm0ubGVuZ3RoICYmIGkrMTUgPCB0cmFuc2Zvcm0ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRyYW5zZm9ybVtpKzBdO1xyXG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0cmFuc2Zvcm1baSsxXTtcclxuICAgICAgICAgICAgcmVzdWx0WzJdID0gdHJhbnNmb3JtW2krMl07XHJcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRyYW5zZm9ybVtpKzNdO1xyXG4gICAgICAgICAgICByZXN1bHRbNF0gPSB0cmFuc2Zvcm1baSs0XTtcclxuICAgICAgICAgICAgcmVzdWx0WzVdID0gdHJhbnNmb3JtW2krNV07XHJcbiAgICAgICAgICAgIHJlc3VsdFs2XSA9IHRyYW5zZm9ybVtpKzZdO1xyXG4gICAgICAgICAgICByZXN1bHRbN10gPSB0cmFuc2Zvcm1baSs3XTtcclxuICAgICAgICAgICAgcmVzdWx0WzhdID0gdHJhbnNmb3JtW2krOF07XHJcbiAgICAgICAgICAgIHJlc3VsdFs5XSA9IHRyYW5zZm9ybVtpKzldO1xyXG4gICAgICAgICAgICByZXN1bHRbMTBdID0gdHJhbnNmb3JtW2krMTBdO1xyXG4gICAgICAgICAgICByZXN1bHRbMTFdID0gdHJhbnNmb3JtW2krMTFdO1xyXG4gICAgICAgICAgICByZXN1bHRbMTJdID0gdHJhbnNmb3JtW2krMTJdO1xyXG4gICAgICAgICAgICByZXN1bHRbMTNdID0gdHJhbnNmb3JtW2krMTNdO1xyXG4gICAgICAgICAgICByZXN1bHRbMTRdID0gdHJhbnNmb3JtW2krMTRdO1xyXG4gICAgICAgICAgICByZXN1bHRbMTVdID0gdHJhbnNmb3JtW2krMTVdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IDE7XHJcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IDA7XHJcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IDA7XHJcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IDA7XHJcbiAgICAgICAgICAgIHJlc3VsdFs0XSA9IDA7XHJcbiAgICAgICAgICAgIHJlc3VsdFs1XSA9IDE7XHJcbiAgICAgICAgICAgIHJlc3VsdFs2XSA9IDA7XHJcbiAgICAgICAgICAgIHJlc3VsdFs3XSA9IDA7XHJcbiAgICAgICAgICAgIHJlc3VsdFs4XSA9IDA7XHJcbiAgICAgICAgICAgIHJlc3VsdFs5XSA9IDA7XHJcbiAgICAgICAgICAgIHJlc3VsdFsxMF0gPSAxO1xyXG4gICAgICAgICAgICByZXN1bHRbMTFdID0gMDtcclxuICAgICAgICAgICAgcmVzdWx0WzEyXSA9IDA7XHJcbiAgICAgICAgICAgIHJlc3VsdFsxM10gPSAwO1xyXG4gICAgICAgICAgICByZXN1bHRbMTRdID0gMDtcclxuICAgICAgICAgICAgcmVzdWx0WzE1XSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwiXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5zZXBpYUltYWdlXCIsIHtcclxuICAgIG91dHB1dHM6IFsge3R5cGU6ICd0ZXh0dXJlJywgbmFtZSA6ICdyZXN1bHQnLCBzaXplb2YgOiAnaW1hZ2UnfSBdLFxyXG4gICAgcGFyYW1zOiAgWyB7dHlwZTogJ3RleHR1cmUnLCBzb3VyY2UgOiAnaW1hZ2UnfSBdLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW1hZ2UpIHtcclxuICAgICAgICB2YXIgcyA9IGltYWdlLmRhdGE7XHJcbiAgICAgICAgdmFyIGQgPSByZXN1bHQuZGF0YTtcclxuICAgICAgICB2YXIgciA9IDAsIGcgPSAwLCBiID0gMDtcclxuICAgICAgICBmb3IodmFyIGkgPSAwIDsgaSA8IHMubGVuZ3RoOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgciA9IChzW2ldICogMC4zOTMgKyBzW2krMV0gKiAwLjc2OSArIHNbaSsyXSAqIDAuMTg5KTtcclxuICAgICAgICAgICAgZyA9IChzW2ldICogMC4zNDkgKyBzW2krMV0gKiAwLjY4NiArIHNbaSsyXSAqIDAuMTY4KTtcclxuICAgICAgICAgICAgYiA9IChzW2ldICogMC4yNzIgKyBzW2krMV0gKiAwLjUzNCArIHNbaSsyXSAqIDAuMTMxKTtcclxuICAgICAgICAgICAgaWYgKHI+MjU1KSByID0gMjU1O1xyXG4gICAgICAgICAgICBpZiAoZz4yNTUpIGcgPSAyNTU7XHJcbiAgICAgICAgICAgIGlmIChiPjI1NSkgYiA9IDI1NTtcclxuICAgICAgICAgICAgaWYgKHI8MCkgciA9IDA7XHJcbiAgICAgICAgICAgIGlmIChnPDApIGcgPSAwO1xyXG4gICAgICAgICAgICBpZiAoYjwwKSBiID0gMDtcclxuICAgICAgICAgICAgZFtpXSA9IHI7XHJcbiAgICAgICAgICAgIGRbaSsxXSA9IGc7XHJcbiAgICAgICAgICAgIGRbaSsyXSA9IGI7XHJcbiAgICAgICAgICAgIGRbaSszXSA9IDI1NTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJcclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LnNraW5EaXJlY3Rpb25cIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncmVzdWx0JyB9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAnZGlyJyB9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdpbnQ0Jywgc291cmNlOiAnYm9uZUlkeCcgfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQ0Jywgc291cmNlOiAnYm9uZVdlaWdodCcgfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQ0eDQnLCBzb3VyY2U6ICdib25lWGZvcm0nLCBhcnJheTogdHJ1ZSB9IF0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBkaXIsYm9uZUlkeCxib25lV2VpZ2h0LGJvbmVYZm9ybSwgaW5mbykge1xyXG4gICAgICAgIHZhciB2ZWMzID0gWE1MM0QubWF0aC52ZWMzLFxyXG4gICAgICAgICAgICBtYXQ0ID0gWE1MM0QubWF0aC5tYXQ0O1xyXG4gICAgICAgIHZhciByID0gdmVjMy5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgdG1wID0gIHZlYzMuY3JlYXRlKCk7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGk8IGluZm8uaXRlcmF0ZUNvdW50OysraSkge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSozO1xyXG4gICAgICAgICAgICByWzBdID0gclsxXSA9IHJbMl0gPSArMDtcclxuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IGJvbmVXZWlnaHRbaW5mby5pdGVyRmxhZ1syXSA/IGkqNCtqIDogal07XHJcbiAgICAgICAgICAgICAgICBpZiAod2VpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vID0gYm9uZUlkeFtpbmZvLml0ZXJGbGFnWzFdID8gaSo0K2ogOiBqXSoxNjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0NC5tdWx0aXBseU9mZnNldERpcmVjdGlvbihib25lWGZvcm0sIG1vLCBkaXIsIG9mZnNldCwgdG1wKTtcclxuICAgICAgICAgICAgICAgICAgICB2ZWMzLnNjYWxlKHRtcCwgdG1wLCB3ZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYzMuYWRkKHIsIHIsIHRtcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmVjMy5ub3JtYWxpemUociwgcik7XHJcbiAgICAgICAgICAgIHJlc3VsdFtvZmZzZXRdID0gclswXTtcclxuICAgICAgICAgICAgcmVzdWx0W29mZnNldCsxXSA9IHJbMV07XHJcbiAgICAgICAgICAgIHJlc3VsdFtvZmZzZXQrMl0gPSByWzJdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsIlxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuc2tpblBvc2l0aW9uXCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQzJywgbmFtZTogJ3Jlc3VsdCcgfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0MycsIHNvdXJjZTogJ3BvcycgfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnaW50NCcsIHNvdXJjZTogJ2JvbmVJZHgnIH0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0NCcsIHNvdXJjZTogJ2JvbmVXZWlnaHQnIH0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0NHg0Jywgc291cmNlOiAnYm9uZVhmb3JtJywgYXJyYXk6IHRydWUgfSBdLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgcG9zLGJvbmVJZHgsYm9uZVdlaWdodCxib25lWGZvcm0sIGluZm8pIHtcclxuICAgICAgICB2YXIgdmVjMyA9IFhNTDNELm1hdGgudmVjMyxcclxuICAgICAgICAgICAgbWF0NCA9IFhNTDNELm1hdGgubWF0NDtcclxuICAgICAgICB2YXIgciA9IHZlYzMuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIHRtcCA9ICB2ZWMzLmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpPCBpbmZvLml0ZXJhdGVDb3VudDsrK2kpIHtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkqMztcclxuICAgICAgICAgICAgclswXSA9IHJbMV0gPSByWzJdID0gKzA7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCA0OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBib25lV2VpZ2h0W2luZm8uaXRlckZsYWdbMl0gPyBpKjQraiA6IGpdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtbyA9IGJvbmVJZHhbaW5mby5pdGVyRmxhZ1sxXSA/IGkqNCtqIDogal0qMTY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG1hdDQubXVsdGlwbHlPZmZzZXRWZWMzKGJvbmVYZm9ybSwgbW8sIHBvcywgb2Zmc2V0LCB0bXApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYzMuc2NhbGUodG1wLCB0bXAsIHdlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMy5hZGQociwgciwgdG1wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHRbb2Zmc2V0XSA9IHJbMF07XHJcbiAgICAgICAgICAgIHJlc3VsdFtvZmZzZXQrMV0gPSByWzFdO1xyXG4gICAgICAgICAgICByZXN1bHRbb2Zmc2V0KzJdID0gclsyXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJ2YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL3V0aWxzXCIpLmJpbmFyeVNlYXJjaDtcclxudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcblxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuc2xlcnBTZXFcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDQnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDQnLCBzb3VyY2U6ICdzZXF1ZW5jZSd9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZTogJ2tleSd9XSxcclxuICAgIG1hcHBpbmc6IFsgIHtuYW1lOiAndmFsdWUxJywgc291cmNlOiAnc2VxdWVuY2UnLCBzZXF1ZW5jZTogWEMuU0VRVUVOQ0UuUFJFVl9CVUZGRVIsIGtleVNvdXJjZTogJ2tleSd9LFxyXG4gICAgICAgICAgICAgICAge25hbWU6ICd2YWx1ZTInLCAgc291cmNlOiAnc2VxdWVuY2UnLCBzZXF1ZW5jZTogWEMuU0VRVUVOQ0UuTkVYVF9CVUZGRVIsIGtleVNvdXJjZTogJ2tleSd9LFxyXG4gICAgICAgICAgICAgICAge25hbWU6ICd3ZWlnaHQnLCAgc291cmNlOiAnc2VxdWVuY2UnLCBzZXF1ZW5jZTogWEMuU0VRVUVOQ0UuTElORUFSX1dFSUdIVCwga2V5U291cmNlOiAna2V5J31dLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUxLCB2YWx1ZTIsIHdlaWdodCwgaW5mbykge1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbmZvLml0ZXJhdGVDb3VudDsgKytpKXtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC5xdWF0LnNsZXJwT2Zmc2V0KCAgdmFsdWUxLGluZm8uaXRlckZsYWdbMF0gPyBpKjQgOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTIsaW5mby5pdGVyRmxhZ1sxXSA/IGkqNCA6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LCBpKjQsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5cclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LnNsZXJwS2V5c1wiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0NCcsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlOiAna2V5cycsIGFycmF5OiB0cnVlfSxcclxuICAgICAgICB7dHlwZTogJ2Zsb2F0NCcsIHNvdXJjZTogJ3ZhbHVlcycsIGFycmF5OiB0cnVlfSxcclxuICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlOiAna2V5J31dLFxyXG4gICAgYWxsb2M6IGZ1bmN0aW9uKHNpemVzLCBrZXlzLCB2YWx1ZXMsIGtleSlcclxuICAgIHtcclxuICAgICAgICBzaXplc1sncmVzdWx0J10gPSA0O1xyXG4gICAgfSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGtleXMsIHZhbHVlcywga2V5KSB7XHJcbiAgICAgICAgdmFyIG1heElkeCA9IE1hdGgubWluKGtleXMubGVuZ3RoLCBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyA0KSk7XHJcbiAgICAgICAgdmFyIGlkeCA9IGJpbmFyeVNlYXJjaChrZXlzLCBrZXlbMF0sIG1heElkeCk7XHJcblxyXG4gICAgICAgIGlmKGlkeCA8IDAgfHwgaWR4ID09IG1heElkeCAtIDEpe1xyXG4gICAgICAgICAgICBpZHggPSBNYXRoLm1heCgwLGlkeCk7XHJcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHZhbHVlc1s0KmlkeF07XHJcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHZhbHVlc1s0KmlkeCsxXTtcclxuICAgICAgICAgICAgcmVzdWx0WzJdID0gdmFsdWVzWzQqaWR4KzJdO1xyXG4gICAgICAgICAgICByZXN1bHRbM10gPSB2YWx1ZXNbNCppZHgrM107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHZhciB3ZWlnaHQgPSAoa2V5WzBdIC0ga2V5c1tpZHhdKSAvIChrZXlzW2lkeCsxXSAtIGtleXNbaWR4XSk7XHJcbiAgICAgICAgICAgIFhNTDNELm1hdGgucXVhdC5zbGVycE9mZnNldCggIHZhbHVlcywgaWR4KjQsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMsKGlkeCsxKSo0LCB3ZWlnaHQsXHJcbiAgICAgICAgICAgICAgICByZXN1bHQsIDAsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsIlxyXG4vLyBDb2RlIHBvcnRpb25zIGZyb20gaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY2FudmFzL2ltYWdlZmlsdGVycy9cclxuKGZ1bmN0aW9uKCkge1xyXG4gICAgWGZsb3cuRmlsdGVycyA9IHt9O1xyXG5cclxuICAgIHZhciB0bXBDYW52YXMgPSBudWxsO1xyXG4gICAgdmFyIHRtcEN0eCA9IG51bGw7XHJcblxyXG4gICAgWGZsb3cuRmlsdGVycy5jcmVhdGVJbWFnZURhdGEgPSBmdW5jdGlvbih3LGgpIHtcclxuICAgICAgICBpZiAoIXRtcENhbnZhcylcclxuICAgICAgICAgICAgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgaWYgKCF0bXBDdHgpXHJcbiAgICAgICAgICAgIHRtcEN0eCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIHJldHVybiB0bXBDdHguY3JlYXRlSW1hZ2VEYXRhKHcsIGgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBYZmxvdy5GaWx0ZXJzLmNyZWF0ZUltYWdlRGF0YUZsb2F0MzIgPSBmdW5jdGlvbih3LCBoKSB7XHJcbiAgICAgICAgcmV0dXJuIHt3aWR0aDogdywgaGVpZ2h0OiBoLCBkYXRhOiBuZXcgRmxvYXQzMkFycmF5KHcgKiBoICogNCl9O1xyXG4gICAgfTtcclxuXHJcbiAgICBYZmxvdy5GaWx0ZXJzLmdyYXlzY2FsZSA9IGZ1bmN0aW9uKGlucGl4ZWxzLCBvdXRwaXhlbHMsIGFyZ3MpIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBpbnBpeGVscy5kYXRhO1xyXG4gICAgICAgICAgICB2YXIgZCA9IG91dHBpeGVscy5kYXRhO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8cy5sZW5ndGg7IGkrPTQpIHtcclxuICAgICAgICAgICAgICAgIHZhciByID0gc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBnID0gc1tpKzFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBzW2krMl07XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHNbaSszXTtcclxuICAgICAgICAgICAgICAgIC8vIENJRSBsdW1pbmFuY2UgZm9yIHRoZSBSR0JcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBodW1hbiBleWUgaXMgYmFkIGF0IHNlZWluZyByZWQgYW5kIGJsdWUsIHNvIHdlIGRlLWVtcGhhc2l6ZSB0aGVtLlxyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSAwLjIxMjYqciArIDAuNzE1MipnICsgMC4wNzIyKmI7XHJcbiAgICAgICAgICAgICAgICBkW2ldID0gZFtpKzFdID0gZFtpKzJdID0gdlxyXG4gICAgICAgICAgICAgICAgZFtpKzNdID0gYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaW5waXhlbHM7XHJcbiAgICB9O1xyXG5cclxuICAgIFhmbG93LkZpbHRlcnMuY29udm9sdXRlID0gZnVuY3Rpb24oaW5waXhlbHMsIG91dHBpeGVscywgd2VpZ2h0cywgb3BhcXVlKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKTtcclxuICAgICAgICAgICAgdmFyIGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlLzIpO1xyXG4gICAgICAgICAgICB2YXIgc3JjID0gaW5waXhlbHMuZGF0YTtcclxuICAgICAgICAgICAgdmFyIHN3ID0gaW5waXhlbHMud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBzaCA9IGlucGl4ZWxzLmhlaWdodDtcclxuICAgICAgICAgICAgLy8gcGFkIG91dHB1dCBieSB0aGUgY29udm9sdXRpb24gbWF0cml4XHJcbiAgICAgICAgICAgIHZhciB3ID0gc3c7XHJcbiAgICAgICAgICAgIHZhciBoID0gc2g7XHJcbiAgICAgICAgICAgIHZhciBkc3QgPSBvdXRwaXhlbHMuZGF0YTtcclxuICAgICAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgZGVzdGluYXRpb24gaW1hZ2UgcGl4ZWxzXHJcbiAgICAgICAgICAgIHZhciBhbHBoYUZhYyA9IG9wYXF1ZSA/IDEgOiAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB5PTA7IHk8aDsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4PTA7IHg8dzsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0geTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkc3RPZmYgPSAoeSp3K3gpKjQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSB3ZWlnaGVkIHN1bSBvZiB0aGUgc291cmNlIGltYWdlIHBpeGVscyB0aGF0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbCB1bmRlciB0aGUgY29udm9sdXRpb24gbWF0cml4XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHI9MCwgZz0wLCBiPTAsIGE9MDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjeT0wOyBjeTxzaWRlOyBjeSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGN4PTA7IGN4PHNpZGU7IGN4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3kgPSBzeSArIGN5IC0gaGFsZlNpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2N4ID0gc3ggKyBjeCAtIGhhbGZTaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjeSA+PSAwICYmIHNjeSA8IHNoICYmIHNjeCA+PSAwICYmIHNjeCA8IHN3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNyY09mZiA9IChzY3kqc3crc2N4KSo0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3dCA9IHdlaWdodHNbY3kqc2lkZStjeF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciArPSBzcmNbc3JjT2ZmXSAqIHd0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgKz0gc3JjW3NyY09mZisxXSAqIHd0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgKz0gc3JjW3NyY09mZisyXSAqIHd0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgKz0gc3JjW3NyY09mZiszXSAqIHd0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdFtkc3RPZmZdID0gcjtcclxuICAgICAgICAgICAgICAgICAgICBkc3RbZHN0T2ZmKzFdID0gZztcclxuICAgICAgICAgICAgICAgICAgICBkc3RbZHN0T2ZmKzJdID0gYjtcclxuICAgICAgICAgICAgICAgICAgICBkc3RbZHN0T2ZmKzNdID0gYSArIGFscGhhRmFjKigyNTUtYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dHBpeGVscztcclxuICAgICAgICB9O1xyXG4vKlxyXG4gICAgWGZsb3cuRmlsdGVycy5jb252b2x1dGVGbG9hdDMyID0gZnVuY3Rpb24ocGl4ZWxzLCB3ZWlnaHRzLCBvcGFxdWUpIHtcclxuICAgICAgICB2YXIgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSk7XHJcbiAgICAgICAgdmFyIGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlIC8gMik7XHJcblxyXG4gICAgICAgIHZhciBzcmMgPSBwaXhlbHMuZGF0YTtcclxuICAgICAgICB2YXIgc3cgPSBwaXhlbHMud2lkdGg7XHJcbiAgICAgICAgdmFyIHNoID0gcGl4ZWxzLmhlaWdodDtcclxuXHJcbiAgICAgICAgdmFyIHcgPSBzdztcclxuICAgICAgICB2YXIgaCA9IHNoO1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSB7XHJcbiAgICAgICAgICAgIHdpZHRoOiB3LCBoZWlnaHQ6IGgsIGRhdGE6IG5ldyBGbG9hdDMyQXJyYXkodyAqIGggKiA0KVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGRzdCA9IG91dHB1dC5kYXRhO1xyXG5cclxuICAgICAgICB2YXIgYWxwaGFGYWMgPSBvcGFxdWUgPyAxIDogMDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoOyB5KyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzeSA9IHk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ggPSB4O1xyXG4gICAgICAgICAgICAgICAgdmFyIGRzdE9mZiA9ICh5ICogdyArIHgpICogNDtcclxuICAgICAgICAgICAgICAgIHZhciByID0gMCwgZyA9IDAsIGIgPSAwLCBhID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGN5ID0gMDsgY3kgPCBzaWRlOyBjeSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjeSA9IE1hdGgubWluKHNoIC0gMSwgTWF0aC5tYXgoMCwgc3kgKyBjeSAtIGhhbGZTaWRlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3ggPSBNYXRoLm1pbihzdyAtIDEsIE1hdGgubWF4KDAsIHN4ICsgY3ggLSBoYWxmU2lkZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3JjT2ZmID0gKHNjeSAqIHN3ICsgc2N4KSAqIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByICs9IHNyY1tzcmNPZmZdICogd3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgKz0gc3JjW3NyY09mZiArIDFdICogd3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgKz0gc3JjW3NyY09mZiArIDJdICogd3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgKz0gc3JjW3NyY09mZiArIDNdICogd3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZHN0W2RzdE9mZl0gPSByO1xyXG4gICAgICAgICAgICAgICAgZHN0W2RzdE9mZiArIDFdID0gZztcclxuICAgICAgICAgICAgICAgIGRzdFtkc3RPZmYgKyAyXSA9IGI7XHJcbiAgICAgICAgICAgICAgICBkc3RbZHN0T2ZmICsgM10gPSBhICsgYWxwaGFGYWMgKiAoMjU1IC0gYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxuKi9cclxufSgpKTtcclxuXHJcbmZ1bmN0aW9uIGZsb2F0NCh4LHkseix3KSB7XHJcbiAgICB2YXIgdiA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgIHZbMF0gPSAwO1xyXG4gICAgICAgICAgICB2WzFdID0gMDtcclxuICAgICAgICAgICAgdlsyXSA9IDA7XHJcbiAgICAgICAgICAgIHZbM10gPSAwO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHZbMF0gPSB4O1xyXG4gICAgICAgICAgICB2WzFdID0geDtcclxuICAgICAgICAgICAgdlsyXSA9IHg7XHJcbiAgICAgICAgICAgIHZbM10gPSB4O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHZbMF0gPSB4O1xyXG4gICAgICAgICAgICB2WzFdID0geTtcclxuICAgICAgICAgICAgdlsyXSA9IDA7XHJcbiAgICAgICAgICAgIHZbM10gPSAwO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIHZbMF0gPSB4O1xyXG4gICAgICAgICAgICB2WzFdID0geTtcclxuICAgICAgICAgICAgdlsyXSA9IHo7XHJcbiAgICAgICAgICAgIHZbM10gPSAwO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB2WzBdID0geDtcclxuICAgICAgICAgICAgdlsxXSA9IHk7XHJcbiAgICAgICAgICAgIHZbMl0gPSB6O1xyXG4gICAgICAgICAgICB2WzNdID0gdztcclxuICAgIH1cclxuICAgIHJldHVybiB2O1xyXG59XHJcblxyXG5mdW5jdGlvbiBoeXBvdChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGEqYSArIGIqYik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGh5cG90NChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gZmxvYXQ0KGh5cG90KGFbMF0sIGJbMF0pLFxyXG4gICAgICAgICAgICAgICAgICBoeXBvdChhWzFdLCBiWzFdKSxcclxuICAgICAgICAgICAgICAgICAgaHlwb3QoYVsyXSwgYlsyXSksXHJcbiAgICAgICAgICAgICAgICAgIGh5cG90KGFbM10sIGJbM10pKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaHlwb3Q0VG8ociwgYSwgYilcclxue1xyXG4gICAgclswXSA9IGh5cG90KGFbMF0sIGJbMF0pO1xyXG4gICAgclsxXSA9IGh5cG90KGFbMV0sIGJbMV0pO1xyXG4gICAgclsyXSA9IGh5cG90KGFbMl0sIGJbMl0pO1xyXG4gICAgclszXSA9IGh5cG90KGFbM10sIGJbM10pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUZXhlbDJEKGltYWdlZGF0YSwgeCwgeSkge1xyXG4gICAgdmFyIG9mZnNldCA9ICh5ICogaW1hZ2VkYXRhLndpZHRoICsgeCkgKiA0O1xyXG4gICAgdmFyIGRhdGEgPSBpbWFnZWRhdGEuZGF0YTtcclxuICAgIHZhciBjb2xvciA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XHJcbiAgICBjb2xvclswXSA9IGRhdGFbb2Zmc2V0XSAvIDI1NS4wO1xyXG4gICAgY29sb3JbMV0gPSBkYXRhW29mZnNldCsxXSAvIDI1NS4wO1xyXG4gICAgY29sb3JbMl0gPSBkYXRhW29mZnNldCsyXSAvIDI1NS4wO1xyXG4gICAgY29sb3JbM10gPSBkYXRhW29mZnNldCszXSAvIDI1NS4wO1xyXG4gICAgcmV0dXJuIGNvbG9yO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUZXhlbDJEVG8oY29sb3IsIGltYWdlZGF0YSwgeCwgeSkge1xyXG4gICAgdmFyIG9mZnNldCA9ICh5ICogaW1hZ2VkYXRhLndpZHRoICsgeCkgKiA0O1xyXG4gICAgdmFyIGRhdGEgPSBpbWFnZWRhdGEuZGF0YTtcclxuICAgIGNvbG9yWzBdID0gZGF0YVtvZmZzZXRdIC8gMjU1LjA7XHJcbiAgICBjb2xvclsxXSA9IGRhdGFbb2Zmc2V0KzFdIC8gMjU1LjA7XHJcbiAgICBjb2xvclsyXSA9IGRhdGFbb2Zmc2V0KzJdIC8gMjU1LjA7XHJcbiAgICBjb2xvclszXSA9IGRhdGFbb2Zmc2V0KzNdIC8gMjU1LjA7XHJcbiAgICByZXR1cm4gY29sb3I7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFRleGVsMkQoaW1hZ2VkYXRhLCB4LCB5LCBjb2xvcikge1xyXG4gICAgdmFyIG9mZnNldCA9ICh5ICogaW1hZ2VkYXRhLndpZHRoICsgeCkgKiA0O1xyXG4gICAgdmFyIGRhdGEgPSBpbWFnZWRhdGEuZGF0YTtcclxuICAgIGRhdGFbb2Zmc2V0XSA9IGNvbG9yWzBdICogMjU1LjAgO1xyXG4gICAgZGF0YVtvZmZzZXQrMV0gPSBjb2xvclsxXSAqIDI1NS4wO1xyXG4gICAgZGF0YVtvZmZzZXQrMl0gPSBjb2xvclsyXSAqIDI1NS4wO1xyXG4gICAgZGF0YVtvZmZzZXQrM10gPSBjb2xvclszXSAqIDI1NS4wO1xyXG59XHJcblxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuc29iZWxJbWFnZVwiLCB7XHJcbiAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAncmVzdWx0Jywgc2l6ZW9mIDogJ2ltYWdlJ30gXSxcclxuICAgIHBhcmFtczogIFsge3R5cGU6ICd0ZXh0dXJlJywgc291cmNlIDogJ2ltYWdlJ30gXSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGltYWdlKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gU29iZWwgZmlsdGVyLCBBbnlTTCBtZXRob2RcclxuICAgICAgICB2YXIgZ3ggPSBmbG9hdDQoMC4wKTtcclxuICAgICAgICB2YXIgZ3kgPSBmbG9hdDQoMC4wKTtcclxuICAgICAgICB2YXIgaTAwID0gZmxvYXQ0KCk7XHJcbiAgICAgICAgdmFyIGkwMCA9IGZsb2F0NCgpO1xyXG4gICAgICAgIHZhciBpMTAgPSBmbG9hdDQoKTtcclxuICAgICAgICB2YXIgaTIwID0gZmxvYXQ0KCk7XHJcbiAgICAgICAgdmFyIGkwMSA9IGZsb2F0NCgpO1xyXG4gICAgICAgIHZhciBpMTEgPSBmbG9hdDQoKTtcclxuICAgICAgICB2YXIgaTIxID0gZmxvYXQ0KCk7XHJcbiAgICAgICAgdmFyIGkwMiA9IGZsb2F0NCgpO1xyXG4gICAgICAgIHZhciBpMTIgPSBmbG9hdDQoKTtcclxuICAgICAgICB2YXIgaTIyID0gZmxvYXQ0KCk7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gZmxvYXQ0KCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyArK3kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyArK3gpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8qIFJlYWQgZWFjaCB0ZXhlbCBjb21wb25lbnQgYW5kIGNhbGN1bGF0ZSB0aGUgZmlsdGVyZWQgdmFsdWUgdXNpbmcgbmVpZ2hib3VyaW5nIHRleGVsIGNvbXBvbmVudHMgKi9cclxuICAgICAgICAgICAgICAgIGlmICggeCA+PSAxICYmIHggPCAod2lkdGgtMSkgJiYgeSA+PSAxICYmIHkgPCBoZWlnaHQgLSAxKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGdldFRleGVsMkRUbyhpMDAsIGltYWdlLCB4LTEsIHktMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0VGV4ZWwyRFRvKGkxMCwgaW1hZ2UsIHgsIHktMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0VGV4ZWwyRFRvKGkyMCwgaW1hZ2UsIHgrMSwgeS0xKTtcclxuICAgICAgICAgICAgICAgICAgICBnZXRUZXhlbDJEVG8oaTAxLCBpbWFnZSwgeC0xLCB5KTtcclxuICAgICAgICAgICAgICAgICAgICBnZXRUZXhlbDJEVG8oaTExLCBpbWFnZSwgeCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0VGV4ZWwyRFRvKGkyMSwgaW1hZ2UsIHgrMSwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0VGV4ZWwyRFRvKGkwMiwgaW1hZ2UsIHgtMSwgeSsxKTtcclxuICAgICAgICAgICAgICAgICAgICBnZXRUZXhlbDJEVG8oaTEyLCBpbWFnZSwgeCwgeSsxKTtcclxuICAgICAgICAgICAgICAgICAgICBnZXRUZXhlbDJEVG8oaTIyLCBpbWFnZSwgeCsxLCB5KzEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBneFswXSA9IGkwMFswXSArIDIgKiBpMTBbMF0gKyBpMjBbMF0gLSBpMDJbMF0gIC0gMiAqIGkxMlswXSAtIGkyMlswXTtcclxuICAgICAgICAgICAgICAgICAgICBneFsxXSA9IGkwMFsxXSArIDIgKiBpMTBbMV0gKyBpMjBbMV0gLSBpMDJbMV0gIC0gMiAqIGkxMlsxXSAtIGkyMlsxXTtcclxuICAgICAgICAgICAgICAgICAgICBneFsyXSA9IGkwMFsyXSArIDIgKiBpMTBbMl0gKyBpMjBbMl0gLSBpMDJbMl0gIC0gMiAqIGkxMlsyXSAtIGkyMlsyXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ3lbMF0gPSBpMDBbMF0gLSBpMjBbMF0gICsgMippMDFbMF0gLSAyKmkyMVswXSArIGkwMlswXSAgLSAgaTIyWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGd5WzFdID0gaTAwWzFdIC0gaTIwWzFdICArIDIqaTAxWzFdIC0gMippMjFbMV0gKyBpMDJbMV0gIC0gIGkyMlsxXTtcclxuICAgICAgICAgICAgICAgICAgICBneVsyXSA9IGkwMFsyXSAtIGkyMFsyXSAgKyAyKmkwMVsyXSAtIDIqaTIxWzJdICsgaTAyWzJdICAtICBpMjJbMl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qIHRha2luZyByb290IG9mIHN1bXMgb2Ygc3F1YXJlcyBvZiBHeCBhbmQgR3kgKi9cclxuICAgICAgICAgICAgICAgICAgICBoeXBvdDRUbyhjb2xvciwgZ3gsIGd5KTtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvclswXS89MjtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvclsxXS89MjtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvclsyXS89MjtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvclszXT0xLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGV4ZWwyRChyZXN1bHQsIHgsIHksIGNvbG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuLy8gU29iZWwgZmlsdGVyIHdpdGggc2VwYXJhdGUgc3RlcHNcclxuLy9cclxuLy8gICAgICAgIHZhciB2ZXJ0aWNhbCA9IFhmbG93LkZpbHRlcnMuY3JlYXRlSW1hZ2VEYXRhRmxvYXQzMih3aWR0aCwgaGVpZ2h0KTtcclxuLy8gICAgICAgIFhmbG93LkZpbHRlcnMuY29udm9sdXRlKHJlc3VsdCwgdmVydGljYWwsXHJcbi8vICAgICAgICAgICAgWyAtMSwgMCwgMSxcclxuLy8gICAgICAgICAgICAgIC0yLCAwLCAyLFxyXG4vLyAgICAgICAgICAgICAgLTEsIDAsIDEgXSk7XHJcbi8vICAgICAgICB2YXIgaG9yaXpvbnRhbCA9IFhmbG93LkZpbHRlcnMuY3JlYXRlSW1hZ2VEYXRhRmxvYXQzMih3aWR0aCwgaGVpZ2h0KTtcclxuLy8gICAgICAgIFhmbG93LkZpbHRlcnMuY29udm9sdXRlKHJlc3VsdCwgaG9yaXpvbnRhbCxcclxuLy8gICAgICAgICAgICBbIC0xLCAtMiwgLTEsXHJcbi8vICAgICAgICAgICAgICAgMCwgIDAsICAwLFxyXG4vLyAgICAgICAgICAgICAgIDEsICAyLCAgMSBdKTtcclxuLy9cclxuLy8gICAgICAgIGZvciAodmFyIGk9MDsgaTxyZXN1bHQuZGF0YS5sZW5ndGg7IGkrPTQpIHtcclxuLy8gICAgICAgICAgICAvLyBtYWtlIHRoZSB2ZXJ0aWNhbCBncmFkaWVudCByZWRcclxuLy8gICAgICAgICAgICB2YXIgdiA9IE1hdGguYWJzKHZlcnRpY2FsLmRhdGFbaV0pO1xyXG4vLyAgICAgICAgICAgIHJlc3VsdC5kYXRhW2ldID0gdjtcclxuLy8gICAgICAgICAgICAvLyBtYWtlIHRoZSBob3Jpem9udGFsIGdyYWRpZW50IGdyZWVuXHJcbi8vICAgICAgICAgICAgdmFyIGggPSBNYXRoLmFicyhob3Jpem9udGFsLmRhdGFbaV0pO1xyXG4vLyAgICAgICAgICAgIHJlc3VsdC5kYXRhW2krMV0gPSBoO1xyXG4vLyAgICAgICAgICAgIC8vIGFuZCBtaXggaW4gc29tZSBibHVlIGZvciBhZXN0aGV0aWNzXHJcbi8vICAgICAgICAgICAgcmVzdWx0LmRhdGFbaSsyXSA9ICh2K2gpLzQ7XHJcbi8vICAgICAgICAgICAgcmVzdWx0LmRhdGFbaSszXSA9IDI1NTsgLy8gb3BhcXVlIGFscGhhXHJcbi8vICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIENvcHkgaW1hZ2VcclxuICAgICAgICB2YXIgZGVzdHBpeCA9IHJlc3VsdC5kYXRhO1xyXG4gICAgICAgIHZhciBzcmNwaXggPSBpbWFnZS5kYXRhO1xyXG5cclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gKHkgKiB3aWR0aCArIHgpICogNDtcclxuICAgICAgICAgICAgICAgIGRlc3RwaXhbb2Zmc2V0XSA9ICBzcmNwaXhbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgIGRlc3RwaXhbb2Zmc2V0KzFdID0gc3JjcGl4W29mZnNldCsxXTtcclxuICAgICAgICAgICAgICAgIGRlc3RwaXhbb2Zmc2V0KzJdID0gc3JjcGl4W29mZnNldCsyXTtcclxuICAgICAgICAgICAgICAgIGRlc3RwaXhbb2Zmc2V0KzNdID0gc3JjcGl4W29mZnNldCszXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAqL1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59KTtcclxuIiwiXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5zdWJcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd2YWx1ZTEnfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAndmFsdWUyJ31dLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUxLCB2YWx1ZTIsIGluZm8pIHtcclxuICAgICAgICB0aHJvdyBcIk5vdCB1c2VkIVwiO1xyXG5cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpPCBpbmZvLml0ZXJhdGVDb3VudCozOyBpKyspXHJcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHZhbHVlMVtpXSAtIHZhbHVlMltpXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGV2YWx1YXRlX2NvcmU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUxLCB2YWx1ZTIpe1xyXG4gICAgICAgIHJlc3VsdFswXSA9IHZhbHVlMVswXSAtIHZhbHVlMlswXTtcclxuICAgICAgICByZXN1bHRbMV0gPSB2YWx1ZTFbMV0gLSB2YWx1ZTJbMV07XHJcbiAgICAgICAgcmVzdWx0WzJdID0gdmFsdWUxWzJdIC0gdmFsdWUyWzJdO1xyXG4gICAgfVxyXG59KTtcclxuIiwiLyoqXHJcbiAqIE9uZSBvcGVyYXRvciBleGVjdXRpb24gd2l0aGluIHRoZSBAc2Vle09wZXJhdG9yTGlzdH0uXHJcbiAqIEBwYXJhbSBvcGVyYXRvclxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBPcGVyYXRvckVudHJ5ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XHJcbiAgICAvKipcclxuICAgICAqIFBvc2l0aW9uIGluIE9wZXJhdG9yTGlzdFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbmRleCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVyYXRvciBvYmplY3RcclxuICAgICAqIEB0eXBlIHt7fX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogb3BlcmF0b3JJbmRleDogUG9zaXRpb24gb2YgdGhlIGlucHV0J3Mgb3BlcmF0b3IgaW4gdGhlIE9wZXJhdG9yTGlzdCBpZiB0aGUgaW5wdXQgY29tZXMgZnJvbVxyXG4gICAgICogcHJldmlvdXNseSBleGVjdXRlZCBvcGVyYXRvciBvdGhlcndpc2UgdW5kZWZpbmVkXHJcbiAgICAgKiBvdXRwdXRJbmRleDogUmVmZXJlbmNlcyB0aGUgb3V0cHV0cyBvZiB0aGUgb3BlcmF0b3Igb2JqZWN0IGRlZmluZWQgYnkgdGhlIG9wZXJhdG9ySW5kZXhcclxuICAgICAqIG1hcHBlZE5hbWU6IE9yaWdpbmFsIG5hbWUgYXMgZGVmaW5lZCBpbiBvcGVyYXRvciBpbnZvY2F0aW9uIGluIERhdGFOb2RlIChjdXJyZW50bHkgbm90IHVzZWQpXHJcbiAgICAgKiBpbnB1dEluZGV4OiBPbmx5IHNldCBpZiB0aGlzIGlzIGRpcmVjdCBpbnB1dCBhbmQgcmVmZXJlbmNlcyBpbnRvIHRoZSBpbnB1dHMgZGVmaW5lZCBpbiBAc2Vle1Byb2dyYW1EYXRhfVxyXG4gICAgICogQHR5cGUge0FycmF5Ljx7b3BlcmF0b3JJbmRleDogbnVtYmVyPywgb3V0cHV0SW5kZXg6IG51bWJlcj8sIG1hcHBlZE5hbWU6IHN0cmluZz8sIGlucHV0SW5kZXg6IG51bWJlcj99Pn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbnB1dEluZm8gPSBbXTtcclxuICAgIC8qKlxyXG4gICAgICogZmluYWxPdXQ6IHtudW1iZXJ9IElzIHNldCwgaWYgdGhpcyBvdXRwdXQgYSBmaW5hbCBvdXRwdXQgKGUuZy4gYSB2YXJ5aW5nIGluIGEgdmVydGV4IHNoYWRlcikuIFJlZmVyZW5jZXMgdGhlIG91dHB1dHMgb2YgdGhlIFByb2dyYW1EYXRhLlxyXG4gICAgICogdHJhbnNmZXI6IHtib29sZWFufSBJcyB0cnVlIGlmIHRoaXMgaXMgYSB0cmFuc2ZlciBvdXRwdXQgaS5lLiB0aGlzIG91dHB1dCBpcyB1c2VkIGFzIGlucHV0IGJ5IGFub3RoZXIgb3BlcmF0b3IsXHJcbiAgICAgKiBsb3N0OiBEYXRhIHRoYXQgaXMgbG9zdCwgaS5lLiBub3QgdXNlZCBpbiBuZXh0IGV4ZWN1dG9yLiBSZWZlcmVuY2UgdG8gUHJvZ3JhbURhdGEncyBvdXRwdXRzXHJcbiAgICAgKiBAdHlwZSB7QXJyYXkuPHtmaW5hbE91dDogbnVtYmVyPywgdHJhbnNmZXI6IGJvb2xlYW4/LCBsb3N0OiBudW1iZXI/fT59XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3V0cHV0SW5mbyA9IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIElzIHRoZSBpbnB1dCB0aGUgcmVzdWx0IG9mIGEgcHJldmlvdXNseSBleGVjdXRlZCBvcGVyYXRvclxyXG4gKiBAcGFyYW0gbWFwcGluZ0luZGV4IElucHV0IGluZGV4IG9mIHRoZSBvcGVyYXRvciAoY2FuIGJlIG1hcHBlZCB1c2luZyBhIG1hcHBpbmcgZGVjbGFyYXRpb24pXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuaXNUcmFuc2ZlcklucHV0ID0gZnVuY3Rpb24gKG1hcHBpbmdJbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmZvW21hcHBpbmdJbmRleF0ub3BlcmF0b3JJbmRleCAhPT0gdW5kZWZpbmVkO1xyXG59O1xyXG5cclxuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuZ2V0VHJhbnNmZXJJbnB1dE9wZXJhdG9ySW5kZXggPSBmdW5jdGlvbiAobWFwcGluZ0luZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnB1dEluZm9bbWFwcGluZ0luZGV4XS5vcGVyYXRvckluZGV4O1xyXG59O1xyXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5nZXRUcmFuc2ZlcklucHV0T3V0cHV0SW5kZXggPSBmdW5jdGlvbiAobWFwcGluZ0luZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnB1dEluZm9bbWFwcGluZ0luZGV4XS5vdXRwdXRJbmRleDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSB1bmlxdWUgbmFtZSBmb3IgYSBzcGVjaWZpZWQgdHJhbnNmZXIgaW5wdXRcclxuICogQHBhcmFtIG1hcHBpbmdJZHhcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbk9wZXJhdG9yRW50cnkucHJvdG90eXBlLmdldFRyYW5zZmVySW5wdXRJZCA9IGZ1bmN0aW9uIChtYXBwaW5nSWR4KSB7XHJcbiAgICB2YXIgaW5mbyA9IHRoaXMuaW5wdXRJbmZvW21hcHBpbmdJZHhdO1xyXG4gICAgcmV0dXJuIGluZm8ub3BlcmF0b3JJbmRleCArIFwiX1wiICsgaW5mby5vdXRwdXRJbmRleDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSB1bmlxdWUgbmFtZSBmb3IgdHJhbnNmZXIgb3V0cHV0XHJcbiAqIEBwYXJhbSBvdXRwdXRJbmRleFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuZ2V0VHJhbnNmZXJPdXRwdXRJZCA9IGZ1bmN0aW9uIChvdXRwdXRJbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5kZXggKyBcIl9cIiArIG91dHB1dEluZGV4O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRPRE86IHJlbW92ZSBvciBpbnRlZ3JhdGUgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xyXG4gKiBAdW51c2VkXHJcbiAqIEBwYXJhbSBtYXBwaW5nSWR4XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd8Kn1cclxuICovXHJcbk9wZXJhdG9yRW50cnkucHJvdG90eXBlLmdldElucHV0TWFwcGluZ05hbWUgPSBmdW5jdGlvbiAobWFwcGluZ0lkeCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmZvW21hcHBpbmdJZHhdLm1hcHBlZE5hbWU7XHJcbn07XHJcbk9wZXJhdG9yRW50cnkucHJvdG90eXBlLmdldERpcmVjdElucHV0SW5kZXggPSBmdW5jdGlvbiAobWFwcGluZ0lkeCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmZvW21hcHBpbmdJZHhdLmlucHV0SW5kZXg7XHJcbn07XHJcblxyXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5nZXRPdXRwdXRJbmRleCA9IGZ1bmN0aW9uIChvcGVyYXRvck91dHB1dElkeCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3V0cHV0SW5mb1tvcGVyYXRvck91dHB1dElkeF0uZmluYWxPdXQgfHwgdGhpcy5vdXRwdXRJbmZvW29wZXJhdG9yT3V0cHV0SWR4XS5sb3N0IHx8IDA7XHJcbn07XHJcblxyXG5cclxuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuaXNGaW5hbE91dHB1dCA9IGZ1bmN0aW9uIChvdXRwdXRJbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3V0cHV0SW5mb1tvdXRwdXRJbmRleF0gJiYgdGhpcy5vdXRwdXRJbmZvW291dHB1dEluZGV4XS5maW5hbE91dCAhPT0gdW5kZWZpbmVkO1xyXG59O1xyXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5pc1RyYW5zZmVyT3V0cHV0ID0gZnVuY3Rpb24gKG91dHB1dEluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRJbmZvW291dHB1dEluZGV4XSAmJiB0aGlzLm91dHB1dEluZm9bb3V0cHV0SW5kZXhdLnRyYW5zZmVyO1xyXG59O1xyXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5pc0xvc3RPdXRwdXQgPSBmdW5jdGlvbiAob3V0cHV0SW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLm91dHB1dEluZm9bb3V0cHV0SW5kZXhdICYmIHRoaXMub3V0cHV0SW5mb1tvdXRwdXRJbmRleF0ubG9zdCAhPT0gdW5kZWZpbmVkO1xyXG59O1xyXG5cclxuXHJcbk9wZXJhdG9yRW50cnkucHJvdG90eXBlLnNldFRyYW5zZmVySW5wdXQgPSBmdW5jdGlvbiAobWFwcGluZ0luZGV4LCBvcGVyYXRvckluZGV4LCBvdXRwdXRJbmRleCkge1xyXG4gICAgdGhpcy5pbnB1dEluZm9bbWFwcGluZ0luZGV4XSA9IHtvcGVyYXRvckluZGV4OiBvcGVyYXRvckluZGV4LCBvdXRwdXRJbmRleDogb3V0cHV0SW5kZXh9O1xyXG59O1xyXG5cclxuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuc2V0RGlyZWN0SW5wdXQgPSBmdW5jdGlvbiAobWFwcGluZ0luZGV4LCBpbnB1dEluZGV4LCBtYXBwZWROYW1lKSB7XHJcbiAgICB0aGlzLmlucHV0SW5mb1ttYXBwaW5nSW5kZXhdID0ge2lucHV0SW5kZXg6IGlucHV0SW5kZXgsIG1hcHBlZE5hbWU6IG1hcHBlZE5hbWV9O1xyXG59O1xyXG5cclxuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuc2V0RmluYWxPdXRwdXQgPSBmdW5jdGlvbiAob3BlcmF0b3JPdXRwdXRJbmRleCwgZ2xvYmFsT3V0cHV0SW5kZXgpIHtcclxuICAgIHRoaXMub3V0cHV0SW5mb1tvcGVyYXRvck91dHB1dEluZGV4XSA9IHtmaW5hbE91dDogZ2xvYmFsT3V0cHV0SW5kZXh9O1xyXG59O1xyXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5zZXRUcmFuc2Zlck91dHB1dCA9IGZ1bmN0aW9uIChvcGVyYXRvck91dHB1dEluZGV4KSB7XHJcbiAgICB0aGlzLm91dHB1dEluZm9bb3BlcmF0b3JPdXRwdXRJbmRleF0gPSB7dHJhbnNmZXI6IHRydWV9O1xyXG59O1xyXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5zZXRMb3N0T3V0cHV0ID0gZnVuY3Rpb24gKG9wZXJhdG9yT3V0cHV0SW5kZXgsIGdsb2JhbE91dHB1dEluZGV4KSB7XHJcbiAgICB0aGlzLm91dHB1dEluZm9bb3BlcmF0b3JPdXRwdXRJbmRleF0gPSB7bG9zdDogZ2xvYmFsT3V0cHV0SW5kZXh9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGhhc2gtYWJsZSBrZXkgZm9yIHRoZSBlbnRyeVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGtleSA9IHRoaXMub3BlcmF0b3IubmFtZSArIFwiKk9cIjtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRJbmZvLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGluZm8gPSB0aGlzLm91dHB1dEluZm9baV07XHJcbiAgICAgICAga2V5ICs9IFwiKlwiICsgKCBpbmZvLnRyYW5zZmVyID8gXCJfXCIgOiBpbmZvLmZpbmFsT3V0IHx8IChpbmZvLmxvc3QgKyBcIj9cIikpO1xyXG4gICAgfVxyXG4gICAga2V5ICs9ICtcIipJXCI7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5pbnB1dEluZm8ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpbmZvID0gdGhpcy5pbnB1dEluZm9baV07XHJcbiAgICAgICAga2V5ICs9IFwiKlwiICsgKGluZm8uaW5wdXRJbmRleCA/IGluZm8uaW5wdXRJbmZvIDogaW5mby5vcGVyYXRvckluZGV4ICsgXCI+XCIgKyBpbmZvLm91dHB1dEluZGV4KTtcclxuICAgIH1cclxuICAgIHJldHVybiBrZXk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9wZXJhdG9yRW50cnk7XHJcbiIsInZhciBDID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcbnZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XHJcblxyXG5cclxuLyoqXHJcbiAqIExpc3Qgb2YgcGxhdGZvcm0tc3BlY2lmaWMgb3BlcmF0b3JzLCBvcmRlcmVkIGJ5IGV4ZWN1dGlvbiAobGFzdCBlbnRyeSBpcyBsYXN0IG9wZXJhdG9yXHJcbiAqIGV4ZWN1dGVkKS5cclxuICpcclxuICogQHBhcmFtIHtDLlBMQVRGT1JNfSBwbGF0Zm9ybVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBPcGVyYXRvckxpc3QgPSBmdW5jdGlvbiAocGxhdGZvcm0pIHtcclxuICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0FycmF5LjxPcGVyYXRvckVudHJ5Pn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5lbnRyaWVzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgZnJvbSBwb3NpdGlvbiBvZiBpbnB1dCBwYXJhbWV0ZXIgdG8gc2l6ZSBhbmQgaXRlcmF0b3IgdHlwZSBvZiBwYXJhbWV0ZXJzLlxyXG4gICAgICogU2l6ZSBpcyBvbmx5IHNwZWNpZmllZCBmb3IgdW5pZm9ybSBhcnJheSBpbnB1dCwgcmVxdWlyZWQgZm9yIHByb2dyYW1zIHRoYXRcclxuICAgICAqIGhhdmUgdGhlIGFycmF5IHNpemUgc3BlY2lmaWVkLlxyXG4gICAgICogQHR5cGUge09iamVjdC48bnVtYmVyLHtzaXplOiBudW1iZXIsIGl0ZXJhdGU6IEMuSVRFUkFUSU9OX1RZUEV9Pn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbnB1dEluZm8gPSB7fTtcclxufTtcclxuXHJcbk9wZXJhdG9yTGlzdC5wcm90b3R5cGUuYWRkRW50cnkgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgIGVudHJ5LmluZGV4ID0gdGhpcy5lbnRyaWVzLmxlbmd0aDtcclxuICAgIHRoaXMuZW50cmllcy5wdXNoKGVudHJ5KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIYXNoYWJsZSBrZXkgZm9yIHdob2xlIGxpc3RcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbk9wZXJhdG9yTGlzdC5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGtleXMgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbnRyaWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAga2V5cy5wdXNoKHRoaXMuZW50cmllc1tpXS5nZXRLZXkoKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5wbGF0Zm9ybSArIFwiPlwiICsga2V5cy5qb2luKFwiIVwiKSArIFwifFwiO1xyXG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLmlucHV0SW5mbykge1xyXG4gICAgICAgIHJlc3VsdCArPSBpICsgXCI+XCIgKyAodGhpcy5pbnB1dEluZm9baV0uaXRlcmF0ZSB8fCAwKSArIFwieFwiICsgKHRoaXMuaW5wdXRJbmZvW2ldLnNpemUgfHwgMCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5zZXRJbnB1dEl0ZXJhdGVUeXBlID0gZnVuY3Rpb24gKGlucHV0SW5kZXgsIHR5cGUpIHtcclxuICAgIGlmICghdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0pIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdID0ge307XHJcbiAgICB0aGlzLmlucHV0SW5mb1tpbnB1dEluZGV4XS5pdGVyYXRlID0gdHlwZTtcclxufTtcclxuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5zZXRJbnB1dFNpemUgPSBmdW5jdGlvbiAoaW5wdXRJbmRleCwgc2l6ZSkge1xyXG4gICAgaWYgKCF0aGlzLmlucHV0SW5mb1tpbnB1dEluZGV4XSkgdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0gPSB7fTtcclxuICAgIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdLnNpemUgPSBzaXplO1xyXG59O1xyXG5cclxuXHJcbk9wZXJhdG9yTGlzdC5wcm90b3R5cGUuaXNJbnB1dEl0ZXJhdGUgPSBmdW5jdGlvbiAoaW5wdXRJbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdICYmIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdLml0ZXJhdGUgPT0gQy5JVEVSQVRJT05fVFlQRS5NQU5ZO1xyXG59O1xyXG5PcGVyYXRvckxpc3QucHJvdG90eXBlLmlzSW5wdXRVbmlmb3JtID0gZnVuY3Rpb24gKGlucHV0SW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLmlucHV0SW5mb1tpbnB1dEluZGV4XSAmJiB0aGlzLmlucHV0SW5mb1tpbnB1dEluZGV4XS5pdGVyYXRlID09IEMuSVRFUkFUSU9OX1RZUEUuT05FO1xyXG59O1xyXG5PcGVyYXRvckxpc3QucHJvdG90eXBlLmlzSW5wdXROdWxsID0gZnVuY3Rpb24gKGlucHV0SW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLmlucHV0SW5mb1tpbnB1dEluZGV4XSAmJiB0aGlzLmlucHV0SW5mb1tpbnB1dEluZGV4XS5pdGVyYXRlID09IEMuSVRFUkFUSU9OX1RZUEUuTlVMTDtcclxufTtcclxuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5nZXRJbnB1dEl0ZXJhdGVUeXBlID0gZnVuY3Rpb24gKGlucHV0SW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLmlucHV0SW5mb1tpbnB1dEluZGV4XSAmJiB0aGlzLmlucHV0SW5mb1tpbnB1dEluZGV4XS5pdGVyYXRlO1xyXG59O1xyXG5cclxuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5nZXRJbnB1dFNpemUgPSBmdW5jdGlvbiAoaW5wdXRJbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdICYmIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdLnNpemUgfHwgMDtcclxufTtcclxuXHJcbk9wZXJhdG9yTGlzdC5wcm90b3R5cGUuZ2V0SXRlcmF0ZUNvdW50ID0gZnVuY3Rpb24gKHByb2dyYW1EYXRhKSB7XHJcbiAgICB2YXIgY291bnQgPSAtMTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZ3JhbURhdGEuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNJbnB1dEl0ZXJhdGUoaSkpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGFFbnRyeSA9IHByb2dyYW1EYXRhLmdldERhdGFFbnRyeShpKTtcclxuICAgICAgICAgICAgaWYgKGRhdGFFbnRyeSAmJiBkYXRhRW50cnkuZ2V0SXRlcmF0ZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGRhdGFFbnRyeS5nZXRJdGVyYXRlQ291bnQoKTtcclxuICAgICAgICAgICAgICAgIGNvdW50ID0gY291bnQgPCAwID8gc2l6ZSA6IE1hdGgubWluKHNpemUsIGNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjb3VudCA8IDAgPyAxIDogY291bnQ7XHJcbn07XHJcblxyXG52YXIgY19zaXplcyA9IHt9O1xyXG5cclxuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5hbGxvY2F0ZU91dHB1dCA9IGZ1bmN0aW9uIChwcm9ncmFtRGF0YSwgYXN5bmMpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbnRyaWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5lbnRyaWVzW2ldO1xyXG4gICAgICAgIHZhciBvcGVyYXRvciA9IGVudHJ5Lm9wZXJhdG9yO1xyXG4gICAgICAgIHZhciBvcGVyYXRvckRhdGEgPSBwcm9ncmFtRGF0YS5vcGVyYXRvckRhdGFbaV07XHJcbiAgICAgICAgdmFyIGl0ZXJhdGVDb3VudCA9IHRoaXMuZ2V0SXRlcmF0ZUNvdW50KHByb2dyYW1EYXRhKTtcclxuICAgICAgICBpZiAob3BlcmF0b3IuYWxsb2MpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbY19zaXplc107XHJcbiAgICAgICAgICAgIGFkZElucHV0VG9BcmdzKGFyZ3MsIGVudHJ5LCBwcm9ncmFtRGF0YSk7XHJcbiAgICAgICAgICAgIGFyZ3MucHVzaChpdGVyYXRlQ291bnQpO1xyXG4gICAgICAgICAgICBvcGVyYXRvci5hbGxvYy5hcHBseShvcGVyYXRvckRhdGEsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9wZXJhdG9yLm91dHB1dHMubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgdmFyIGQgPSBvcGVyYXRvci5vdXRwdXRzW2pdO1xyXG4gICAgICAgICAgICB2YXIgZGF0YVNsb3QgPSBwcm9ncmFtRGF0YS5vdXRwdXRzW2VudHJ5LmdldE91dHB1dEluZGV4KGopXSwgZGF0YUVudHJ5O1xyXG4gICAgICAgICAgICBkYXRhRW50cnkgPSBhc3luYyA/IGRhdGFTbG90LmFzeW5jRGF0YUVudHJ5IDogZGF0YVNsb3QuZGF0YUVudHJ5O1xyXG5cclxuICAgICAgICAgICAgaWYgKGQubm9BbGxvYylcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGFFbnRyeS50eXBlID09IEMuREFUQV9UWVBFLlRFWFRVUkUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRleHR1cmUgZW50cnlcclxuICAgICAgICAgICAgICAgIGlmIChkLmN1c3RvbUFsbG9jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleFBhcmFtcyA9IGNfc2l6ZXNbZC5uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3V2lkdGggPSB0ZXhQYXJhbXMuaW1hZ2VGb3JtYXQud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0hlaWdodCA9IHRleFBhcmFtcy5pbWFnZUZvcm1hdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1R5cGUgPSB0ZXhQYXJhbXMuaW1hZ2VGb3JtYXQudGV4ZWxUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdGb3JtYXQgPSB0ZXhQYXJhbXMuaW1hZ2VGb3JtYXQudGV4ZWxGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1NhbXBsZXJDb25maWcgPSB0ZXhQYXJhbXMuc2FtcGxlckNvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICBkYXRhRW50cnkuX2NyZWF0ZUltYWdlKG5ld1dpZHRoLCBuZXdIZWlnaHQsIG5ld0Zvcm1hdCwgbmV3VHlwZSwgbmV3U2FtcGxlckNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGQuc2l6ZW9mKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNyY0VudHJ5ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG9wZXJhdG9yLm1hcHBpbmcubGVuZ3RoOyArK2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yLm1hcHBpbmdba10uc291cmNlID09IGQuc2l6ZW9mKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNFbnRyeSA9IHByb2dyYW1EYXRhLmdldERhdGFFbnRyeShlbnRyeS5nZXREaXJlY3RJbnB1dEluZGV4KGspKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBNYXRoLm1heChzcmNFbnRyeS53aWR0aCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdIZWlnaHQgPSBNYXRoLm1heChzcmNFbnRyeS5oZWlnaHQsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Rm9ybWF0ID0gZC50ZXhlbEZvcm1hdCB8fCBzcmNFbnRyeS50ZXhlbEZvcm1hdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1R5cGUgPSBkLnRleGVsVHlwZSB8fCBzcmNFbnRyeS50ZXhlbFR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTYW1wbGVyQ29uZmlnID0gZC5zYW1wbGVyQ29uZmlnIHx8IHNyY0VudHJ5LmdldFNhbXBsZXJDb25maWcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUVudHJ5Ll9jcmVhdGVJbWFnZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBuZXdGb3JtYXQsIG5ld1R5cGUsIG5ld1NhbXBsZXJDb25maWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRleHR1cmUgaW5wdXQgcGFyYW1ldGVyICdcIiArIGQuc2l6ZW9mICsgXCInIGluIG9wZXJhdG9yICdcIiArIG9wZXJhdG9yLm5hbWUgKyBcIidcIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIHRleHR1cmUuIFVzZSBjdXN0b21BbGxvYyBvciBzaXplb2YgcGFyYW1ldGVyIGF0dHJpYnV0ZVwiKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IChkLmN1c3RvbUFsbG9jID8gY19zaXplc1tkLm5hbWVdIDogaXRlcmF0ZUNvdW50KSAqIGRhdGFFbnRyeS5nZXRUdXBsZVNpemUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGFFbnRyeS5fdmFsdWUgfHwgZGF0YUVudHJ5Ll92YWx1ZS5sZW5ndGggIT0gc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZGF0YUVudHJ5LnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDRYNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFFbnRyeS5fc2V0VmFsdWUobmV3IEZsb2F0MzJBcnJheShzaXplKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5JTlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuSU5UNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5CT09MOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUVudHJ5Ll9zZXRWYWx1ZShuZXcgSW50MzJBcnJheShzaXplKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJDb3VsZCBub3QgYWxsb2NhdGUgb3V0cHV0IGJ1ZmZlciBvZiBUWVBFOiBcIiArIGRhdGFFbnRyeS50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFFbnRyeS5fbm90aWZ5Q2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLypcclxuIE9wZXJhdG9yTGlzdC5wcm90b3R5cGUuY2hlY2tJbnB1dCA9IGZ1bmN0aW9uKHByb2dyYW1EYXRhKXtcclxuIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyArK2kpe1xyXG4gdmFyIGVudHJ5ID0gdGhpcy5lbnRyaWVzW2ldO1xyXG4gdmFyIG1hcHBpbmcgPSBlbnRyeS5vcGVyYXRvci5tYXBwaW5nO1xyXG4gZm9yKHZhciBqID0gMDsgaiA8IG1hcHBpbmcubGVuZ3RoOyArK2ope1xyXG4gaWYoZW50cnkuaXNUcmFuc2ZlcklucHV0KGopKXtcclxuIHZhciBvdXRwdXRUeXBlID0gdGhpcy5lbnRyaWVzW2VudHJ5LmdldFRyYW5zZmVySW5wdXRPcGVyYXRvckluZGV4KGopXS5vcGVyYXRvci5vdXRwdXRzW1xyXG4gZW50cnkuZ2V0VHJhbnNmZXJJbnB1dE91dHB1dEluZGV4KGopXS50eXBlO1xyXG5cclxuIGlmKG91dHB1dFR5cGUgIT0gZW50cnkudHlwZSl7XHJcbiBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlhmbG93OiBvcGVyYXRvciBcIiArIGVudHJ5Lm9wZXJhdG9yLm5hbWUgKyBcIjogSW5wdXQgZm9yIFwiICsgZW50cnkuc291cmNlICtcclxuIFwiIGhhcyB3cm9uZyB0eXBlLiBFeHBlY3RlZDogXCIgKyBDLmdldFR5cGVOYW1lKGVudHJ5LnR5cGUpXHJcbiArIFwiLCBidXQgZ290OiBcIiArICBDLmdldFR5cGVOYW1lKG91dHB1dFR5cGUpICk7XHJcbiByZXR1cm4gZmFsc2U7XHJcbiB9XHJcblxyXG4gfVxyXG4gZWxzZXtcclxuIHZhciBtYXBwaW5nTmFtZSA9IGVudHJ5LmdldElucHV0TWFwcGluZ05hbWUoaik7XHJcbiBpZighZW50cnkub3B0aW9uYWwgJiYgIW1hcHBpbmdOYW1lKXtcclxuIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiWGZsb3c6IG9wZXJhdG9yIFwiICsgZW50cnkub3BlcmF0b3IubmFtZSArIFwiOiBNaXNzaW5nIGlucHV0IGFyZ3VtZW50IGZvciBcIlxyXG4gKyBlbnRyeS5zb3VyY2UpO1xyXG4gcmV0dXJuIGZhbHNlO1xyXG4gfVxyXG4gaWYobWFwcGluZ05hbWUpe1xyXG4gdmFyIGNoYW5uZWwgPSBwcm9ncmFtRGF0YS5nZXRDaGFubmVsKGVudHJ5LmdldERpcmVjdElucHV0SW5kZXgoaikpO1xyXG4gaWYoIWNoYW5uZWwpe1xyXG4gWE1MM0QuZGVidWcubG9nRXJyb3IoXCJYZmxvdzogb3BlcmF0b3IgXCIgKyBlbnRyeS5vcGVyYXRvci5uYW1lICsgXCI6IElucHV0IG9mIG5hbWUgJ1wiICsgbWFwcGluZ05hbWUgK1xyXG4gXCInIG5vdCBmb3VuZC4gVXNlZCBmb3IgcGFyYW1ldGVyIFwiICsgZW50cnkuc291cmNlKTtcclxuIHJldHVybiBmYWxzZTtcclxuIH1cclxuIHZhciBkYXRhRW50cnkgPSBjaGFubmVsLmdldERhdGFFbnRyeSgpO1xyXG4gaWYoIWVudHJ5Lm9wdGlvbmFsICYmICghZGF0YUVudHJ5IHx8IGRhdGFFbnRyeS5nZXRMZW5ndGgoKSA9PSAwKSl7XHJcbiBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlhmbG93OiBvcGVyYXRvciBcIiArIGVudHJ5Lm9wZXJhdG9yLm5hbWUgKyBcIjogSW5wdXQgZm9yIFwiICsgZW50cnkuc291cmNlICtcclxuICcgY29udGFpbnMgbm8gZGF0YS4nKTtcclxuIHJldHVybiBmYWxzZTtcclxuIH1cclxuIGlmKGRhdGFFbnRyeSAmJiBkYXRhRW50cnkudHlwZSAhPSBlbnRyeS50eXBlKXtcclxuIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiWGZsb3c6IG9wZXJhdG9yIFwiICsgZW50cnkub3BlcmF0b3IubmFtZSArIFwiOiBJbnB1dCBmb3IgXCIgKyBlbnRyeS5zb3VyY2UgK1xyXG4gXCIgaGFzIHdyb25nIHR5cGUuIEV4cGVjdGVkOiBcIiArIEMuZ2V0VHlwZU5hbWUoZW50cnkudHlwZSlcclxuICsgXCIsIGJ1dCBnb3Q6IFwiICsgIEMuZ2V0VHlwZU5hbWUoZGF0YUVudHJ5LnR5cGUpICk7XHJcbiByZXR1cm4gZmFsc2U7XHJcbiB9XHJcbiB9XHJcbiB9XHJcbiB9XHJcbiB9XHJcbiB9XHJcbiAqL1xyXG5cclxuICAgIC8vIFRPRE86IFRoaXMgZnVuY3Rpb24gYXBwZWFycyBpbiBtdWx0aXBsZSB1bml0c1xyXG4gICAgZnVuY3Rpb24gYWRkSW5wdXRUb0FyZ3MoYXJncywgZW50cnksIHByb2dyYW1EYXRhKXtcclxuICAgICAgICB2YXIgbWFwcGluZyA9IGVudHJ5Lm9wZXJhdG9yLm1hcHBpbmc7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1hcHBpbmcubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbWFwRW50cnkgPSBtYXBwaW5nW2ldO1xyXG4gICAgICAgICAgICB2YXIgZGF0YUVudHJ5ID0gcHJvZ3JhbURhdGEuZ2V0RGF0YUVudHJ5KGVudHJ5LmdldERpcmVjdElucHV0SW5kZXgoaSkpO1xyXG4gICAgICAgICAgICBhcmdzLnB1c2goZGF0YUVudHJ5ID8gZGF0YUVudHJ5LmdldFZhbHVlKCkgOiBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPcGVyYXRvckxpc3Q7XHJcbiIsInZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XHJcbnZhciBDID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gcmVnaXN0ZXJPcGVyYXRvciAmJiBnZXRPcGVyYXRvclxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbnZhciBvcGVyYXRvcnMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBYZmxvdyBvcGVyYXRvci5cclxuICAgICAqIFRoZSBvcGVyYXRvcnMgYXJlIHN0b3JlZCBpbiBjb2xsZWN0aW9ucyB1c2luZyB0aGVpciBwbGF0Zm9ybSBhcyBhIGtleS4gSWYgbm8gcGxhdGZvcm0gaXMgZGVmaW5lZCwgdGhlIG9wZXJhdG9yXHJcbiAgICAgKiB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgYSBKYXZhU2NyaXB0LWJhc2VkIG9wZXJhdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gZGF0YVxyXG4gICAgICovXHJcblxyXG52YXIgcmVnaXN0ZXJPcGVyYXRvciA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEpe1xyXG4gICAgdmFyIG9wQ29sbGVjdGlvbiwgcGxhdGZvcm07XHJcblxyXG4gICAgaW5pdE9wZXJhdG9yKGRhdGEpO1xyXG4gICAgaWYoIW9wZXJhdG9yc1tuYW1lXSkge1xyXG4gICAgICAgIG9wZXJhdG9yc1tuYW1lXSA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHBsYXRmb3JtID0gZGF0YVsncGxhdGZvcm0nXSB8fCBDLlBMQVRGT1JNLkpBVkFTQ1JJUFQ7XHJcblxyXG4gICAgb3BDb2xsZWN0aW9uID0gb3BlcmF0b3JzW25hbWVdO1xyXG5cclxuICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgIFhNTDNELmxvZ1dhcm5pbmcoXCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yOiBPcGVyYXRvciBuYW1lIHVuZGVmaW5lZC5cIik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgIFhNTDNELmxvZ1dhcm5pbmcoXCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yOiBPcGVyYXRvciBkYXRhIHVuZGVmaW5lZC5cIik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGRhdGEubmFtZSA9IG5hbWU7XHJcbiAgICBpZighb3BDb2xsZWN0aW9uW3BsYXRmb3JtXSlcclxuICAgICAgICBvcENvbGxlY3Rpb25bcGxhdGZvcm1dID0gW107XHJcblxyXG4gICAgb3BDb2xsZWN0aW9uW3BsYXRmb3JtXS5wdXNoKGRhdGEpO1xyXG59O1xyXG5cclxudmFyIGluaXRBbm9ueW1vdXNPcGVyYXRvciA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEpe1xyXG4gICAgaW5pdE9wZXJhdG9yKGRhdGEpO1xyXG4gICAgZGF0YS5uYW1lID0gbmFtZTtcclxuICAgIHJldHVybiBkYXRhO1xyXG59O1xyXG5cclxudmFyIGlzT3BlcmF0b3JBc3luYyA9IGZ1bmN0aW9uKG9wZXJhdG9yKXtcclxuICAgIHJldHVybiAhIW9wZXJhdG9yLmV2YWx1YXRlX2FzeW5jO1xyXG59O1xyXG5cclxudmFyIGdldE9wZXJhdG9ycyA9IGZ1bmN0aW9uKG5hbWUsIHBsYXRmb3JtKXtcclxuICAgIHBsYXRmb3JtID0gcGxhdGZvcm0gfHwgQy5QTEFURk9STS5KQVZBU0NSSVBUO1xyXG5cclxuICAgIGlmIChuYW1lICYmICFvcGVyYXRvcnNbbmFtZV0pIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZighb3BlcmF0b3JzW25hbWVdW3BsYXRmb3JtXSB8fCBvcGVyYXRvcnNbbmFtZV1bcGxhdGZvcm1dLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9wZXJhdG9yc1tuYW1lXVtwbGF0Zm9ybV07XHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0T3BlcmF0b3Iob3BlcmF0b3Ipe1xyXG4gICAgdmFyIGluZGV4TWFwID0ge307XHJcbiAgICAvLyBJbml0IHR5cGVzIG9mIG91dHB1dHMgYW5kIHBhcmFtc1xyXG4gICAgZm9yKHZhciBpPSAwOyBpIDwgb3BlcmF0b3Iub3V0cHV0cy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgb3BlcmF0b3Iub3V0cHV0c1tpXS50eXBlID0gQy5EQVRBX1RZUEVfTUFQW29wZXJhdG9yLm91dHB1dHNbaV0udHlwZV07XHJcbiAgICB9XHJcbiAgICBmb3IodmFyIGk9IDA7IGkgPCBvcGVyYXRvci5wYXJhbXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIG9wZXJhdG9yLnBhcmFtc1tpXS50eXBlID0gQy5EQVRBX1RZUEVfTUFQW29wZXJhdG9yLnBhcmFtc1tpXS50eXBlXTtcclxuICAgICAgICBpbmRleE1hcFtvcGVyYXRvci5wYXJhbXNbaV0uc291cmNlXSA9IGk7XHJcbiAgICB9XHJcbiAgICBpZighb3BlcmF0b3IubWFwcGluZylcclxuICAgICAgICBvcGVyYXRvci5tYXBwaW5nID0gb3BlcmF0b3IucGFyYW1zO1xyXG5cclxuICAgIC8vIEluaXQgaW50ZXJUeXBlcyBvZiBtYXBwaW5nXHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3BlcmF0b3IubWFwcGluZy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBvcGVyYXRvci5tYXBwaW5nW2ldO1xyXG4gICAgICAgIHZhciBwYXJhbUlkeCA9IGluZGV4TWFwW21hcHBpbmcuc291cmNlXTtcclxuICAgICAgICBtYXBwaW5nLnBhcmFtSWR4ID0gcGFyYW1JZHg7XHJcbiAgICAgICAgdmFyIHR5cGUgPSBvcGVyYXRvci5wYXJhbXNbcGFyYW1JZHhdLnR5cGU7XHJcbiAgICAgICAgaWYobWFwcGluZy5zZXF1ZW5jZSlcclxuICAgICAgICAgICAgbWFwcGluZy5rZXlQYXJhbUlkeCA9IGluZGV4TWFwW21hcHBpbmcua2V5U291cmNlXTtcclxuICAgICAgICBpZihtYXBwaW5nLnNlcXVlbmNlID09IEMuU0VRVUVOQ0UuTElORUFSX1dFSUdIVClcclxuICAgICAgICAgICAgdHlwZSA9IEMuREFUQV9UWVBFLkZMT0FUO1xyXG4gICAgICAgIG1hcHBpbmcuaW50ZXJuYWxUeXBlID0gdHlwZTtcclxuICAgICAgICBtYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWUgfHwgbWFwcGluZy5zb3VyY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy9DaGVjay9pbml0IHBsYXRmb3JtXHJcbiAgICBvcGVyYXRvci5wbGF0Zm9ybSA9IG9wZXJhdG9yLnBsYXRmb3JtIHx8IEMuUExBVEZPUk0uSkFWQVNDUklQVDtcclxufVxyXG5cclxuLy93aW5kb3cuWGZsb3cucmVnaXN0ZXJPcGVyYXRvciA9IHJlZ2lzdGVyT3BlcmF0b3I7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHJlZ2lzdGVyT3BlcmF0b3I6IHJlZ2lzdGVyT3BlcmF0b3IsXHJcbiAgICBpbml0QW5vbnltb3VzT3BlcmF0b3I6IGluaXRBbm9ueW1vdXNPcGVyYXRvcixcclxuICAgIGlzT3BlcmF0b3JBc3luYzogaXNPcGVyYXRvckFzeW5jLFxyXG4gICAgZ2V0T3BlcmF0b3JzOiBnZXRPcGVyYXRvcnNcclxufTtcclxuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcclxudmFyIEMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIFZTUHJvZ3JhbSA9IHJlcXVpcmUoXCIuL3ZzLXByb2dyYW0uanNcIik7XHJcbnZhciBDTFByb2dyYW0gPSByZXF1aXJlKFwiLi9jbC1wcm9ncmFtLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIERhdGEgZm9yIGEgT3BlcmF0b3JMaXN0LCBnZW5lcmF0ZWQgYnkgYW4gRXhlY3V0b3JcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgUHJvZ3JhbURhdGEgPSBmdW5jdGlvbigpe1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7QXJyYXkuPFByb2dyYW1JbnB1dENvbm5lY3Rpb24+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmlucHV0cyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtBcnJheS48RGF0YVNsb3Q+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm91dHB1dHMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGl0ZXJhdGVDb3VudDogSG93IG9mdGVuIHdlIGl0ZXJhdGUgd2l0aCB0aGUgZGVmYXVsdCBleGVjdXRpb24gbW9kZWxcclxuICAgICAqIGl0ZXJGbGFnOiBQZXIgaW5wdXQ6IHRydWUgaWYgdGhlIGlucHV0IGNhbiBiZSBpdGVyYXRlZCwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKiBjdXN0b21EYXRhOiBQZXIgaW5zdGFuY2UgZGF0YSB0aGF0IHVzZXJzIGNhbiBwZXJzaXN0IGJldHdlZW4gb3BlcmF0b3IgaW52b2NhdGlvbnNcclxuICAgICAqIEB0eXBlIHtBcnJheS48e2l0ZXJhdGVDb3VudDogbnVtYmVyLCBpdGVyRmxhZzogQXJyYXksIGN1c3RvbURhdGE6IHt9fT59XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3BlcmF0b3JEYXRhID0gW107XHJcbn07XHJcblxyXG5Qcm9ncmFtRGF0YS5wcm90b3R5cGUuZ2V0Q2hhbm5lbCA9IGZ1bmN0aW9uKGluZGV4KXtcclxuICAgIHJldHVybiB0aGlzLmlucHV0c1tpbmRleF0uY2hhbm5lbDtcclxufTtcclxuXHJcblByb2dyYW1EYXRhLnByb3RvdHlwZS5nZXREYXRhRW50cnkgPSBmdW5jdGlvbihpbmRleCl7XHJcbiAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0c1tpbmRleF07XHJcbiAgICB2YXIgY2hhbm5lbCA9IGVudHJ5LmNoYW5uZWw7XHJcbiAgICBpZighY2hhbm5lbCkgcmV0dXJuIG51bGw7XHJcbiAgICB2YXIga2V5ID0gMDtcclxuICAgIGlmKGVudHJ5LnNlcXVlbmNlS2V5U291cmNlQ2hhbm5lbCl7XHJcbiAgICAgICAgdmFyIGtleURhdGFFbnRyeSA9IGVudHJ5LnNlcXVlbmNlS2V5U291cmNlQ2hhbm5lbC5nZXREYXRhRW50cnkoKTtcclxuICAgICAgICBrZXkgPSBrZXlEYXRhRW50cnkgJiYga2V5RGF0YUVudHJ5Ll92YWx1ZSA/IGtleURhdGFFbnRyeS5fdmFsdWVbMF0gOiAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjaGFubmVsLmdldERhdGFFbnRyeShlbnRyeS5zZXF1ZW5jZUFjY2Vzc1R5cGUsIGtleSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgUHJvZ3JhbUlucHV0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKCl7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtDaGFubmVsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNoYW5uZWwgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhpcyBpbnB1dCBhIHVuaWZvcm0gYXJyYXlcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmFycmF5QWNjZXNzID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7Qy5TRVFVRU5DRX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZXF1ZW5jZUFjY2Vzc1R5cGUgPSBDLlNFUVVFTkNFLk5PX0FDQ0VTUztcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Q2hhbm5lbHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlcXVlbmNlS2V5U291cmNlQ2hhbm5lbCA9IG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogSGFzaC1hYmxlIGtleSB0byBpZGVudGlmeSBlcXVhbCBpbnB1dHMgd2l0aGluIGV4ZWN1dG9yXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5Qcm9ncmFtSW5wdXRDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuICh0aGlzLmNoYW5uZWwgPyB0aGlzLmNoYW5uZWwuaWQgOiBcIk5VTExcIikgKyBcIjtcIiArIHRoaXMuYXJyYXlBY2Nlc3MgKyBcIjtcIiArIHRoaXMuc2VxdWVuY2VBY2Nlc3NUeXBlICsgXCI7XCIgK1xyXG4gICAgKCB0aGlzLnNlcXVlbmNlS2V5U291cmNlQ2hhbm5lbCA/IHRoaXMuc2VxdWVuY2VLZXlTb3VyY2VDaGFubmVsLmlkIDogXCJcIik7XHJcbn07XHJcblxyXG5cclxudmFyIGNfcHJvZ3JhbV9jYWNoZSA9IHt9O1xyXG5cclxudmFyIGNyZWF0ZVByb2dyYW0gPSBmdW5jdGlvbihvcGVyYXRvckxpc3Qpe1xyXG4gICAgdmFyIGZpcnN0T3BlcmF0b3I7XHJcblxyXG4gICAgaWYob3BlcmF0b3JMaXN0LmVudHJpZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZmlyc3RPcGVyYXRvciA9IG9wZXJhdG9yTGlzdC5lbnRyaWVzWzBdLm9wZXJhdG9yO1xyXG5cclxuICAgIHZhciBrZXkgPSBvcGVyYXRvckxpc3QuZ2V0S2V5KCk7XHJcbiAgICBpZighY19wcm9ncmFtX2NhY2hlW2tleV0pe1xyXG4gICAgICAgIC8vIEdMU0wgb3BlcmF0b3JzIGFyZSBpbXBsZW1lbnRlZCBpbiBhIGRpZmZlcmVudCB3YXksIHNvIHBsYXRmb3JtIGluZm9ybWF0aW9uIGlzIGZldGNoZWQgZnJvbSB0aGUgb3BlcmF0b3JMaXN0XHJcbiAgICAgICAgLy8gYXMgYSBmYWxsYmFjayBtb2RlIHRvIG5vdCBicmVhayB0aGUgb2xkIGltcGxlbWVudGF0aW9uc1xyXG4gICAgICAgIGlmKG9wZXJhdG9yTGlzdC5wbGF0Zm9ybSA9PT0gQy5QTEFURk9STS5HTFNMKXtcclxuICAgICAgICAgICAgY19wcm9ncmFtX2NhY2hlW2tleV0gPSBuZXcgVlNQcm9ncmFtKG9wZXJhdG9yTGlzdCk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3RPcGVyYXRvci5wbGF0Zm9ybSA9PT0gQy5QTEFURk9STS5DTCkge1xyXG4gICAgICAgICAgICBjX3Byb2dyYW1fY2FjaGVba2V5XSA9IG5ldyBDTFByb2dyYW0ob3BlcmF0b3JMaXN0KTtcclxuXHJcbiAgICAgICAgfWVsc2UgaWYoZmlyc3RPcGVyYXRvci5wbGF0Zm9ybSA9PT0gQy5QTEFURk9STS5KQVZBU0NSSVBUICYmIG9wZXJhdG9yTGlzdC5lbnRyaWVzLmxlbmd0aCA9PT0gMSApIHtcclxuICAgICAgICAgICAgY19wcm9ncmFtX2NhY2hlW2tleV0gPSBuZXcgU2luZ2xlUHJvZ3JhbShvcGVyYXRvckxpc3QpO1xyXG5cclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIEJhc2Uubm90aWZ5RXJyb3IoXCJDb3VsZCBub3QgY3JlYXRlIHByb2dyYW0gZnJvbSBvcGVyYXRvckxpc3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNfcHJvZ3JhbV9jYWNoZVtrZXldO1xyXG59O1xyXG5cclxuXHJcblxyXG52YXIgU2luZ2xlUHJvZ3JhbSA9IGZ1bmN0aW9uKG9wZXJhdG9yTGlzdCl7XHJcbiAgICB0aGlzLmxpc3QgPSBvcGVyYXRvckxpc3Q7XHJcbiAgICB0aGlzLmVudHJ5ID0gb3BlcmF0b3JMaXN0LmVudHJpZXNbMF07XHJcbiAgICB0aGlzLm9wZXJhdG9yID0gdGhpcy5lbnRyeS5vcGVyYXRvcjtcclxuICAgIHRoaXMuX2lubGluZUxvb3AgPSBudWxsO1xyXG59O1xyXG5cclxuU2luZ2xlUHJvZ3JhbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24ocHJvZ3JhbURhdGEsIGFzeW5jQ2FsbGJhY2spe1xyXG4gICAgdmFyIG9wZXJhdG9yRGF0YSA9IHByZXBhcmVPcGVyYXRvckRhdGEodGhpcy5saXN0LCAwLCBwcm9ncmFtRGF0YSk7XHJcblxyXG4gICAgaWYoYXN5bmNDYWxsYmFjaylcclxuICAgICAgICBhcHBseUFzeW5jT3BlcmF0b3IodGhpcy5lbnRyeSwgcHJvZ3JhbURhdGEsIG9wZXJhdG9yRGF0YSwgYXN5bmNDYWxsYmFjayk7XHJcbiAgICBlbHNlIGlmKHRoaXMub3BlcmF0b3IuZXZhbHVhdGVfY29yZSl7XHJcbiAgICAgICAgYXBwbHlDb3JlT3BlcmF0aW9uKHRoaXMsIHByb2dyYW1EYXRhLCBvcGVyYXRvckRhdGEpO1xyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICBhcHBseURlZmF1bHRPcGVyYXRpb24odGhpcy5lbnRyeSwgcHJvZ3JhbURhdGEsIG9wZXJhdG9yRGF0YSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBhcHBseURlZmF1bHRPcGVyYXRpb24oZW50cnksIHByb2dyYW1EYXRhLCBvcGVyYXRvckRhdGEpe1xyXG4gICAgdmFyIGFyZ3MgPSBhc3NlbWJsZUZ1bmN0aW9uQXJncyhlbnRyeSwgcHJvZ3JhbURhdGEpO1xyXG4gICAgYXJncy5wdXNoKG9wZXJhdG9yRGF0YSk7XHJcbiAgICBlbnRyeS5vcGVyYXRvci5ldmFsdWF0ZS5hcHBseShvcGVyYXRvckRhdGEsIGFyZ3MpO1xyXG4gICAgaGFuZGxlUG9zdFByb2Nlc3NPdXRwdXQoZW50cnksIHByb2dyYW1EYXRhLCBhcmdzLCBmYWxzZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5QXN5bmNPcGVyYXRvcihlbnRyeSwgcHJvZ3JhbURhdGEsIG9wZXJhdG9yRGF0YSwgYXN5bmNDYWxsYmFjayl7XHJcbiAgICB2YXIgYXJncyA9IGFzc2VtYmxlRnVuY3Rpb25BcmdzKGVudHJ5LCBwcm9ncmFtRGF0YSwgdHJ1ZSk7XHJcbiAgICBhcmdzLnB1c2gob3BlcmF0b3JEYXRhKTtcclxuICAgIGFyZ3MucHVzaChmdW5jdGlvbigpe1xyXG4gICAgICAgIGhhbmRsZVBvc3RQcm9jZXNzT3V0cHV0KGVudHJ5LCBwcm9ncmFtRGF0YSwgYXJncywgdHJ1ZSk7XHJcbiAgICAgICAgYXN5bmNDYWxsYmFjaygpO1xyXG4gICAgfSk7XHJcbiAgICBlbnRyeS5vcGVyYXRvci5ldmFsdWF0ZV9hc3luYy5hcHBseShvcGVyYXRvckRhdGEsIGFyZ3MpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseUNvcmVPcGVyYXRpb24ocHJvZ3JhbSwgcHJvZ3JhbURhdGEsIG9wZXJhdG9yRGF0YSl7XHJcbiAgICB2YXIgYXJncyA9IGFzc2VtYmxlRnVuY3Rpb25BcmdzKHByb2dyYW0uZW50cnksIHByb2dyYW1EYXRhKTtcclxuICAgIGFyZ3MucHVzaChvcGVyYXRvckRhdGEuaXRlcmF0ZUNvdW50KTtcclxuXHJcbiAgICBpZighcHJvZ3JhbS5faW5saW5lTG9vcCl7XHJcbiAgICAgICAgcHJvZ3JhbS5faW5saW5lTG9vcCA9IGNyZWF0ZU9wZXJhdG9ySW5saW5lTG9vcChwcm9ncmFtLm9wZXJhdG9yLCBvcGVyYXRvckRhdGEpO1xyXG4gICAgfVxyXG4gICAgcHJvZ3JhbS5faW5saW5lTG9vcC5hcHBseShvcGVyYXRvckRhdGEsIGFyZ3MpO1xyXG59XHJcblxyXG52YXIgY19WYXJQYXR0ZXJuID0gL3ZhclxccysoLikrWztcXG5dLztcclxudmFyIGNfSW5uZXJWYXJQYXR0ZXJuID0gL1tePSxcXHNdK1xccyooPVteLF0rKT8oLCk/LztcclxuZnVuY3Rpb24gY3JlYXRlT3BlcmF0b3JJbmxpbmVMb29wKG9wZXJhdG9yLCBvcGVyYXRvckRhdGEpe1xyXG5cclxuICAgIHZhciBjb2RlID0gXCJmdW5jdGlvbiAoXCI7XHJcbiAgICB2YXIgZnVuY0RhdGEgPSBwYXJzZUZ1bmN0aW9uKG9wZXJhdG9yLmV2YWx1YXRlX2NvcmUpO1xyXG4gICAgY29kZSArPSBmdW5jRGF0YS5hcmdzLmpvaW4oXCIsXCIpICsgXCIsX194Zmxvd01heCkge1xcblwiO1xyXG4gICAgY29kZSArPSBcIiAgICB2YXIgX194Zmxvd0kgPSBfX3hmbG93TWF4XFxuXCIgK1xyXG4gICAgICAgIFwiICAgIHdoaWxlKF9feGZsb3dJLS0pe1xcblwiO1xyXG5cclxuICAgIHZhciBib2R5ID0gZnVuY0RhdGEuYm9keTtcclxuICAgIGJvZHkgPSByZXBsYWNlQXJyYXlBY2Nlc3MoYm9keSwgZnVuY0RhdGEuYXJncywgb3BlcmF0b3IsIG9wZXJhdG9yRGF0YSk7XHJcbiAgICBjb2RlICs9IGJvZHkgKyBcIlxcbiAgfVxcbn1cIjtcclxuXHJcbiAgICB2YXIgaW5saW5lRnVuYyA9IGV2YWwoXCIoXCIgKyBjb2RlICsgXCIpXCIpO1xyXG4gICAgcmV0dXJuIGlubGluZUZ1bmM7XHJcbn1cclxuXHJcbiAgICB2YXIgY19GdW5jdGlvblBhdHRlcm4gPSAvZnVuY3Rpb25cXHMqKFteKF0qKVxcKChbXildKilcXClcXHMqXFx7KFtcXHNcXFNdKilcXH0vO1xyXG5cclxuZnVuY3Rpb24gcGFyc2VGdW5jdGlvbihmdW5jKXtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIHZhciBtYXRjaGVzID0gZnVuYy50b1N0cmluZygpLm1hdGNoKGNfRnVuY3Rpb25QYXR0ZXJuKTtcclxuICAgIGlmKCFtYXRjaGVzKXtcclxuICAgICAgICBCYXNlLm5vdGlmeUVycm9yKFwiWGZsb3cgSW50ZXJuYWw6IENvdWxkIG5vdCBwYXJzZSBmdW5jdGlvbjogXCIgKyBmdW5jKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJlc3VsdC5hcmdzID0gbWF0Y2hlc1syXS5zcGxpdChcIixcIik7XHJcbiAgICBmb3IodmFyIGkgaW4gcmVzdWx0LmFyZ3MpIHJlc3VsdC5hcmdzW2ldID0gcmVzdWx0LmFyZ3NbaV0udHJpbSgpO1xyXG4gICAgcmVzdWx0LmJvZHkgPSBtYXRjaGVzWzNdO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxudmFyIGNfYnJhY2tldFBhdHRlcm4gPSAvKFthLXpBLVpfJF1bXFx3JF0qKShcXFspLztcclxuXHJcbmZ1bmN0aW9uIHJlcGxhY2VBcnJheUFjY2Vzcyhjb2RlLCBhcmdzLCBvcGVyYXRvciwgb3BlcmF0b3JEYXRhKXtcclxuICAgIHZhciByZXN1bHQgPSBcIlwiO1xyXG4gICAgdmFyIGluZGV4ID0gMCwgYnJhY2tldEluZGV4ID0gY29kZS5pbmRleE9mKFwiW1wiLCBpbmRleCk7XHJcbiAgICB3aGlsZShicmFja2V0SW5kZXggIT0gLTEpe1xyXG4gICAgICAgIHZhciBrZXkgPSBjb2RlLnN1YnN0cihpbmRleCkubWF0Y2goY19icmFja2V0UGF0dGVybilbMV07XHJcblxyXG4gICAgICAgIHZhciBhcmdJZHggPSBhcmdzLmluZGV4T2Yoa2V5KTtcclxuICAgICAgICB2YXIgYWRkSW5kZXggPSBmYWxzZSwgdHVwbGVDbnQgPSAwO1xyXG4gICAgICAgIGlmKGFyZ0lkeCAhPSAtMSl7XHJcbiAgICAgICAgICAgIGlmKGFyZ0lkeCA8IG9wZXJhdG9yLm91dHB1dHMubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgIGFkZEluZGV4ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHR1cGxlQ250ID0gQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtbb3BlcmF0b3Iub3V0cHV0c1thcmdJZHhdLnR5cGVdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSBhcmdJZHggLSBvcGVyYXRvci5vdXRwdXRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGFkZEluZGV4ID0gb3BlcmF0b3JEYXRhLml0ZXJGbGFnW2ldO1xyXG4gICAgICAgICAgICAgICAgdHVwbGVDbnQgPSBDLkRBVEFfVFlQRV9UVVBMRV9TSVpFW29wZXJhdG9yLm1hcHBpbmdbaV0uaW50ZXJuYWxUeXBlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0ICs9IGNvZGUuc3Vic3RyaW5nKGluZGV4LCBicmFja2V0SW5kZXgpICsgXCJbXCI7XHJcbiAgICAgICAgaWYoYWRkSW5kZXgpe1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gdHVwbGVDbnQgKyBcIipfX3hmbG93SSArIFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmRleCA9IGJyYWNrZXRJbmRleCArIDE7XHJcbiAgICAgICAgYnJhY2tldEluZGV4ID0gY29kZS5pbmRleE9mKFwiW1wiLCBpbmRleCk7XHJcbiAgICB9XHJcbiAgICByZXN1bHQgKz0gIGNvZGUuc3Vic3RyaW5nKGluZGV4KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBwcmVwYXJlT3BlcmF0b3JEYXRhKGxpc3QsIGlkeCwgcHJvZ3JhbURhdGEpe1xyXG4gICAgdmFyIGRhdGEgPSBwcm9ncmFtRGF0YS5vcGVyYXRvckRhdGFbMF07XHJcbiAgICB2YXIgZW50cnkgPSBsaXN0LmVudHJpZXNbaWR4XTtcclxuICAgIHZhciBtYXBwaW5nID0gZW50cnkub3BlcmF0b3IubWFwcGluZztcclxuICAgIGRhdGEuaXRlckZsYWcgPSB7fTtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXBwaW5nLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgZG9JdGVyYXRlID0gKGVudHJ5LmlzVHJhbnNmZXJJbnB1dChpKSB8fCBsaXN0LmlzSW5wdXRJdGVyYXRlKGVudHJ5LmdldERpcmVjdElucHV0SW5kZXgoaSkpKTtcclxuICAgICAgICBkYXRhLml0ZXJGbGFnW2ldID0gZG9JdGVyYXRlO1xyXG4gICAgfVxyXG4gICAgZGF0YS5pdGVyYXRlQ291bnQgPSBsaXN0LmdldEl0ZXJhdGVDb3VudChwcm9ncmFtRGF0YSk7XHJcbiAgICBpZighZGF0YS5jdXN0b21EYXRhKVxyXG4gICAgICAgIGRhdGEuY3VzdG9tRGF0YSA9IHt9O1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFzc2VtYmxlRnVuY3Rpb25BcmdzKGVudHJ5LCBwcm9ncmFtRGF0YSwgYXN5bmMpe1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIHZhciBvdXRwdXRzID0gZW50cnkub3BlcmF0b3Iub3V0cHV0cztcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvdXRwdXRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICBpZihvdXRwdXRzW2ldLm5vQWxsb2Mpe1xyXG4gICAgICAgICAgICBhcmdzLnB1c2goe2Fzc2lnbjogbnVsbH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB2YXIgZGF0YVNsb3QgPSBwcm9ncmFtRGF0YS5vdXRwdXRzW2VudHJ5LmdldE91dHB1dEluZGV4KGkpXTtcclxuICAgICAgICAgICAgdmFyIGRhdGFFbnRyeSA9IGFzeW5jID8gZGF0YVNsb3QuYXN5bmNEYXRhRW50cnkgOiBkYXRhU2xvdC5kYXRhRW50cnk7XHJcbiAgICAgICAgICAgIGFyZ3MucHVzaChkYXRhRW50cnkgPyBkYXRhRW50cnkuZ2V0VmFsdWUoKSA6IG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZElucHV0VG9BcmdzKGFyZ3MsIGVudHJ5LCBwcm9ncmFtRGF0YSk7XHJcbiAgICByZXR1cm4gYXJncztcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVQb3N0UHJvY2Vzc091dHB1dChlbnRyeSwgcHJvZ3JhbURhdGEsIHBhcmFtZXRlcnMsIGFzeW5jKXtcclxuICAgIHZhciBvdXRwdXRzID0gZW50cnkub3BlcmF0b3Iub3V0cHV0cztcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvdXRwdXRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgZGF0YVNsb3QgPSBwcm9ncmFtRGF0YS5vdXRwdXRzW2VudHJ5LmdldE91dHB1dEluZGV4KGkpXTtcclxuICAgICAgICBpZihvdXRwdXRzW2ldLm5vQWxsb2Mpe1xyXG4gICAgICAgICAgICB2YXIgZGF0YUVudHJ5ID0gYXN5bmMgPyBkYXRhU2xvdC5hc3luY0RhdGFFbnRyeSA6IGRhdGFTbG90LmRhdGFFbnRyeTtcclxuICAgICAgICAgICAgaWYoZGF0YUVudHJ5LnR5cGUgPT0gQy5EQVRBX1RZUEUuVEVYVFVSRSApe1xyXG4gICAgICAgICAgICAgICAgZGF0YUVudHJ5Ll9zZXRJbWFnZShwYXJhbWV0ZXJzW2ldLmFzc2lnbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGRhdGFFbnRyeS5fc2V0VmFsdWUocGFyYW1ldGVyc1tpXS5hc3NpZ24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGFzeW5jKXtcclxuICAgICAgICAgICAgZGF0YVNsb3Quc3dhcEFzeW5jKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gYWRkSW5wdXRUb0FyZ3MoYXJncywgZW50cnksIHByb2dyYW1EYXRhKXtcclxuICAgIHZhciBtYXBwaW5nID0gZW50cnkub3BlcmF0b3IubWFwcGluZztcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXBwaW5nLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgbWFwRW50cnkgPSBtYXBwaW5nW2ldO1xyXG4gICAgICAgIHZhciBkYXRhRW50cnkgPSBwcm9ncmFtRGF0YS5nZXREYXRhRW50cnkoZW50cnkuZ2V0RGlyZWN0SW5wdXRJbmRleChpKSk7XHJcbiAgICAgICAgYXJncy5wdXNoKGRhdGFFbnRyeSA/IGRhdGFFbnRyeS5nZXRWYWx1ZSgpIDogbnVsbCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY3JlYXRlUHJvZ3JhbTogY3JlYXRlUHJvZ3JhbSxcclxuICAgIFByb2dyYW1EYXRhOiBQcm9ncmFtRGF0YSxcclxuICAgIFByb2dyYW1JbnB1dENvbm5lY3Rpb246IFByb2dyYW1JbnB1dENvbm5lY3Rpb25cclxufTtcclxuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcclxudmFyIEMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL3V0aWxzLmpzXCIpO1xyXG52YXIgVmVydGV4U2hhZGVyID0gcmVxdWlyZShcIi4uL3Byb2Nlc3NpbmcvdnMtY29ubmVjdC5qc1wiKS5WZXJ0ZXhTaGFkZXI7XHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gT3BlcmF0b3JMaXN0XHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxudmFyIGNfU0hBREVSX0NPTlNUQU5UX1RZUEVTID0ge307XHJcbmNfU0hBREVSX0NPTlNUQU5UX1RZUEVTW0MuU0hBREVSX0NPTlNUQU5UX0tFWS5PQkpFQ1RfSURdID0gJ2ludCc7XHJcbmNfU0hBREVSX0NPTlNUQU5UX1RZUEVTW0MuU0hBREVSX0NPTlNUQU5UX0tFWS5TQ1JFRU5fVFJBTlNGT1JNXSA9ICdtYXQ0JztcclxuY19TSEFERVJfQ09OU1RBTlRfVFlQRVNbQy5TSEFERVJfQ09OU1RBTlRfS0VZLlNDUkVFTl9UUkFOU0ZPUk1fTk9STUFMXSA9ICdtYXQzJztcclxuY19TSEFERVJfQ09OU1RBTlRfVFlQRVNbQy5TSEFERVJfQ09OU1RBTlRfS0VZLlZJRVdfVFJBTlNGT1JNXSA9ICdtYXQ0JztcclxuY19TSEFERVJfQ09OU1RBTlRfVFlQRVNbQy5TSEFERVJfQ09OU1RBTlRfS0VZLlZJRVdfVFJBTlNGT1JNX05PUk1BTF0gPSAnbWF0Myc7XHJcbmNfU0hBREVSX0NPTlNUQU5UX1RZUEVTW0MuU0hBREVSX0NPTlNUQU5UX0tFWS5XT1JMRF9UUkFOU0ZPUk1dID0gJ21hdDQnO1xyXG5jX1NIQURFUl9DT05TVEFOVF9UWVBFU1tDLlNIQURFUl9DT05TVEFOVF9LRVkuV09STERfVFJBTlNGT1JNX05PUk1BTF0gPSAnbWF0Myc7XHJcblxyXG52YXIgVlNQcm9ncmFtID0gZnVuY3Rpb24ob3BlcmF0b3JMaXN0KXtcclxuICAgIHRoaXMubGlzdCA9IG9wZXJhdG9yTGlzdDtcclxuICAgIHRoaXMuX291dHB1dEluZm8gPSB7fTtcclxuICAgIHNldE91dHB1dEl0ZXJhdGUodGhpcyk7XHJcbn07XHJcblxyXG5WU1Byb2dyYW0ucHJvdG90eXBlLmdldE91dHB1dE5hbWVzID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9vdXRwdXRJbmZvKTtcclxufTtcclxuXHJcblZTUHJvZ3JhbS5wcm90b3R5cGUuZ2V0T3V0cHV0VHlwZSA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgcmV0dXJuIHRoaXMuX291dHB1dEluZm9bbmFtZV0udHlwZTtcclxufTtcclxuXHJcblZTUHJvZ3JhbS5wcm90b3R5cGUuaXNPdXRwdXRVbmlmb3JtID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0SW5mb1tuYW1lXS5pdGVyYXRpb24gPT0gQy5JVEVSQVRJT05fVFlQRS5PTkU7XHJcbn07XHJcblxyXG5WU1Byb2dyYW0ucHJvdG90eXBlLmlzT3V0cHV0TnVsbCA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgcmV0dXJuIHRoaXMuX291dHB1dEluZm9bbmFtZV0uaXRlcmF0aW9uID09IEMuSVRFUkFUSU9OX1RZUEUuTlVMTDtcclxufTtcclxuXHJcblZTUHJvZ3JhbS5wcm90b3R5cGUuY3JlYXRlVmVydGV4U2hhZGVyID0gZnVuY3Rpb24ocHJvZ3JhbURhdGEsIHZzQ29uZmlnKXtcclxuICAgIHZhciByZXN1bHQgPSBuZXcgVmVydGV4U2hhZGVyKHByb2dyYW1EYXRhKTtcclxuICAgIGNvbnN0cnVjdFZTKHJlc3VsdCwgdGhpcywgdnNDb25maWcpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHNldE91dHB1dEl0ZXJhdGUocHJvZ3JhbSl7XHJcbiAgICB2YXIgb3BlcmF0b3JMaXN0ID0gcHJvZ3JhbS5saXN0LCBlbnRyaWVzID0gb3BlcmF0b3JMaXN0LmVudHJpZXM7XHJcblxyXG4gICAgdmFyIGJhc2VFbnRyeSA9IGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXSwgYmFzZU9wZXJhdG9yID0gYmFzZUVudHJ5Lm9wZXJhdG9yO1xyXG5cclxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYmFzZU9wZXJhdG9yLnBhcmFtcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gYmFzZU9wZXJhdG9yLnBhcmFtc1tpXSxcclxuICAgICAgICAgICAgbmFtZSA9IGVudHJ5LnNvdXJjZSxcclxuICAgICAgICAgICAgaW5wdXRJbmRleCA9IGksXHJcbiAgICAgICAgICAgIGRpcmVjdElucHV0SW5kZXggPSBiYXNlRW50cnkuZ2V0RGlyZWN0SW5wdXRJbmRleChpbnB1dEluZGV4KTtcclxuICAgICAgICBwcm9ncmFtLl9vdXRwdXRJbmZvW25hbWVdID0ge3R5cGU6IGVudHJ5LnR5cGV9O1xyXG4gICAgICAgIGlmKCBiYXNlRW50cnkuaXNUcmFuc2ZlcklucHV0KGlucHV0SW5kZXgpIHx8XHJcbiAgICAgICAgICAgIG9wZXJhdG9yTGlzdC5pc0lucHV0SXRlcmF0ZShkaXJlY3RJbnB1dEluZGV4KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHByb2dyYW0uX291dHB1dEluZm9bbmFtZV0uaXRlcmF0aW9uID0gQy5JVEVSQVRJT05fVFlQRS5NQU5ZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKG9wZXJhdG9yTGlzdC5pc0lucHV0VW5pZm9ybShkaXJlY3RJbnB1dEluZGV4KSl7XHJcbiAgICAgICAgICAgIHByb2dyYW0uX291dHB1dEluZm9bbmFtZV0uaXRlcmF0aW9uID0gQy5JVEVSQVRJT05fVFlQRS5PTkU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHByb2dyYW0uX291dHB1dEluZm9bbmFtZV0uaXRlcmF0aW9uID0gQy5JVEVSQVRJT05fVFlQRS5OVUxMO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY29uc3RydWN0VlModnMsIHByb2dyYW0sIHZzQ29uZmlnKXtcclxuICAgIHZhciBvcGVyYXRvckxpc3QgPSBwcm9ncmFtLmxpc3QsIGVudHJpZXMgPSBvcGVyYXRvckxpc3QuZW50cmllcztcclxuXHJcbiAgICB2YXIgdXNlZE5hbWVzID0gW10sXHJcbiAgICAgICAgZGlyZWN0SW5wdXROYW1lcyA9IHt9LFxyXG4gICAgICAgIHRyYW5zZmVyTmFtZXMgPSB7fTtcclxuXHJcbiAgICB2YXIgYmFzZUVudHJ5ID0gZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLCBhY2NlcHRlZEJhc2VTaGFkZXJJbnB1dCA9IFtdLCBiYXNlT3BlcmF0b3IgPSBiYXNlRW50cnkub3BlcmF0b3I7XHJcblxyXG4gICAgaWYoIXZzQ29uZmlnKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHZzQ29uZmlnISBBdHRlbXB0IHRvIGNyZWF0ZSB2ZXJ0ZXggc2hhZGVyIHByb2dyYW1tIHdpdGhvdXQgVlMgb3BlcmF0b3I/XCIpO1xyXG5cclxuICAgIFV0aWxzLm5hbWVzZXQuYWRkKHVzZWROYW1lcywgdnNDb25maWcuZ2V0QmxvY2tlZE5hbWVzKCkpO1xyXG5cclxuICAgIHZhciBjb2RlID0gXCJcIjtcclxuICAgIGNvZGUgKz0gXCIvLyBPVVRQVVRcXG5cIjtcclxuICAgIC8vIEZpcnN0OiBjb2xsZWN0IG91dHB1dCBuYW1lc1xyXG4gICAgZm9yKHZhciBuYW1lIGluIHZzQ29uZmlnLl9hZGRPdXRwdXQpe1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHZzQ29uZmlnLl9hZGRPdXRwdXRbbmFtZV07XHJcbiAgICAgICAgY29kZSArPSBcInZhcnlpbmcgXCIgKyBnZXRHTFNMVHlwZShlbnRyeS50eXBlKSArIFwiIFwiICsgbmFtZSArIFwiO1xcblwiO1xyXG4gICAgICAgIFV0aWxzLm5hbWVzZXQuYWRkKHVzZWROYW1lcywgbmFtZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgaW5wdXRJbmRleCA9IDA7XHJcbiAgICBmb3IoIHZhciBuYW1lIGluIHZzQ29uZmlnLl9hdHRyaWJ1dGVzKXtcclxuICAgICAgICB2YXIgY29uZmlnQXR0ciA9IHZzQ29uZmlnLl9hdHRyaWJ1dGVzW25hbWVdLFxyXG4gICAgICAgICAgICBkaXJlY3RJbnB1dEluZGV4ID0gYmFzZUVudHJ5LmdldERpcmVjdElucHV0SW5kZXgoaW5wdXRJbmRleCk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNvbmZpZ0F0dHIuY2hhbm5lbGluZy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBjaGFubmVsaW5nID0gY29uZmlnQXR0ci5jaGFubmVsaW5nW2ldO1xyXG4gICAgICAgICAgICB2YXIgb3V0cHV0SW5mbyA9IHt0eXBlOiBjb25maWdBdHRyLnR5cGUsIGl0ZXJhdGlvbjogMCwgaW5kZXg6IDAsIHNvdXJjZU5hbWU6IG5hbWV9LFxyXG4gICAgICAgICAgICAgICAgb3V0cHV0TmFtZSA9IGNoYW5uZWxpbmcub3V0cHV0TmFtZTtcclxuICAgICAgICAgICAgaWYoIGNoYW5uZWxpbmcuY29kZSB8fFxyXG4gICAgICAgICAgICAgICAgYmFzZUVudHJ5LmlzVHJhbnNmZXJJbnB1dChpbnB1dEluZGV4KSB8fFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3JMaXN0LmlzSW5wdXRJdGVyYXRlKGRpcmVjdElucHV0SW5kZXgpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhY2NlcHRlZEJhc2VTaGFkZXJJbnB1dFtpbnB1dEluZGV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXRJbmZvLml0ZXJhdGlvbiA9IEMuSVRFUkFUSU9OX1RZUEUuTUFOWTtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gYmFzZU9wZXJhdG9yLm91dHB1dHNbaW5wdXRJbmRleF0udHlwZTtcclxuICAgICAgICAgICAgICAgIGNvZGUgKz0gXCJ2YXJ5aW5nIFwiICsgZ2V0R0xTTFR5cGUodHlwZSkgKyBcIiBcIiArIG91dHB1dE5hbWUgKyBcIjtcXG5cIjtcclxuICAgICAgICAgICAgICAgIFV0aWxzLm5hbWVzZXQuYWRkKHVzZWROYW1lcywgb3V0cHV0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zlck5hbWVzW2Jhc2VFbnRyeS5nZXRUcmFuc2Zlck91dHB1dElkKGkpXSA9IG91dHB1dE5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihvcGVyYXRvckxpc3QuaXNJbnB1dFVuaWZvcm0oZGlyZWN0SW5wdXRJbmRleCkpe1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0SW5mby5pdGVyYXRpb24gPSBDLklURVJBVElPTl9UWVBFLk9ORTtcclxuICAgICAgICAgICAgICAgIG91dHB1dEluZm8uaW5kZXggPSBkaXJlY3RJbnB1dEluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXRJbmZvLml0ZXJhdGlvbiA9IEMuSVRFUkFUSU9OX1RZUEUuTlVMTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBVdGlscy5uYW1lc2V0LmFkZCh2cy5fb3V0cHV0TmFtZXMsIG91dHB1dE5hbWUpO1xyXG4gICAgICAgICAgICB2cy5fb3V0cHV0SW5mb1tvdXRwdXROYW1lXSA9IG91dHB1dEluZm87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlucHV0SW5kZXgrKztcclxuICAgIH1cclxuICAgIGNvZGUgKz0gXCJcXG5cIjtcclxuICAgIGNvZGUgKz0gXCIvLyBJTlBVVFxcblwiO1xyXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgaW5wdXRcclxuICAgIGZvcih2YXIgbmFtZSBpbiB2c0NvbmZpZy5fYWRkSW5wdXQpe1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHZzQ29uZmlnLl9hZGRJbnB1dFtuYW1lXTtcclxuICAgICAgICBjb2RlICs9IChlbnRyeS51bmlmb3JtID8gXCJ1bmlmb3JtIFwiIDogXCJhdHRyaWJ1dGUgXCIgKSArIGdldEdMU0xUeXBlKGVudHJ5LnR5cGUpICsgXCIgXCIgKyBuYW1lICsgXCI7XFxuXCI7XHJcbiAgICAgICAgVXRpbHMubmFtZXNldC5hZGQodXNlZE5hbWVzLCBuYW1lKTtcclxuICAgIH1cclxuICAgIC8vIFNlY29uZDogY29sbGVjdCBpbnB1dCBuYW1lc1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaV0sIG9wZXJhdG9yID0gZW50cnkub3BlcmF0b3I7XHJcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IG9wZXJhdG9yLm1hcHBpbmcubGVuZ3RoOyArK2ope1xyXG4gICAgICAgICAgICBpZiggKGkgPCBlbnRyaWVzLmxlbmd0aCAtIDEgfHwgYWNjZXB0ZWRCYXNlU2hhZGVySW5wdXRbal0pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWVudHJ5LmlzVHJhbnNmZXJJbnB1dChqKSAmJiAhZGlyZWN0SW5wdXROYW1lc1tlbnRyeS5nZXREaXJlY3RJbnB1dEluZGV4KGopXSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hcEVudHJ5ID0gb3BlcmF0b3IubWFwcGluZ1tqXTtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZ2V0RnJlZU5hbWUobWFwRW50cnkubmFtZSwgdXNlZE5hbWVzKSwgaW5wdXRJbmRleCA9IGVudHJ5LmdldERpcmVjdElucHV0SW5kZXgoaiksXHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSA9ICFvcGVyYXRvckxpc3QuaXNJbnB1dEl0ZXJhdGUoaW5wdXRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB2cy5faW5wdXRJbmZvW25hbWVdID0geyBpbmRleDogaW5wdXRJbmRleCwgdW5pZm9ybTogdW5pZm9ybSB9O1xyXG4gICAgICAgICAgICAgICAgVXRpbHMubmFtZXNldC5hZGQodnMuX2lucHV0TmFtZXMsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0SW5wdXROYW1lc1tpbnB1dEluZGV4XSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICBjb2RlICs9ICh1bmlmb3JtID8gXCJ1bmlmb3JtIFwiIDogXCJhdHRyaWJ1dGUgXCIpICsgZ2V0R0xTTFR5cGUobWFwRW50cnkuaW50ZXJuYWxUeXBlKSArIFwiIFwiICsgbmFtZTtcclxuICAgICAgICAgICAgICAgIGlmKG1hcEVudHJ5LmFycmF5KVxyXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgKz0gXCJbXCIgKyBvcGVyYXRvckxpc3QuZ2V0SW5wdXRTaXplKGlucHV0SW5kZXgpICsgXCJdXCI7XHJcbiAgICAgICAgICAgICAgICBjb2RlICs9IFwiO1xcblwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXJ0IG1haW5cclxuICAgIGNvZGUgKz0gXCJcXG4vLyBDT0RFXFxuXCI7XHJcbiAgICBjb2RlICs9IFwidm9pZCBtYWluKHZvaWQpe1xcblwiO1xyXG5cclxuICAgIC8vIENyZWF0ZSBDb2RlXHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXSwgb3BlcmF0b3IgPSBlbnRyeS5vcGVyYXRvcjtcclxuICAgICAgICAvLyBEZWNsYXJlIHRyYW5zZmVyIG91dHB1dCBuYW1lc1xyXG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBvcGVyYXRvci5vdXRwdXRzLmxlbmd0aDsgKytqKXtcclxuICAgICAgICAgICAgaWYoIWVudHJ5LmlzRmluYWxPdXRwdXQoaikpe1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBnZXRGcmVlTmFtZShvcGVyYXRvci5vdXRwdXRzW2pdLm5hbWUsIHVzZWROYW1lcyk7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zlck5hbWVzW2VudHJ5LmdldFRyYW5zZmVyT3V0cHV0SWQoaildID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIGNvZGUgKz0gXCJcXHRcIiArIGdldEdMU0xUeXBlKG9wZXJhdG9yLm91dHB1dHNbal0udHlwZSkgKyBcIiBcIiArIG5hbWUgKyBcIjtcXG5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUYWtlIENvZGUgRnJhZ21lbnRcclxuICAgICAgICB2YXIgY29kZUZyYWdtZW50ID0gY29udmVydENvZGVGcmFnbWVudChvcGVyYXRvci5ldmFsdWF0ZV9nbHNsLCBlbnRyeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zlck5hbWVzLCBkaXJlY3RJbnB1dE5hbWVzLCB1c2VkTmFtZXMpO1xyXG4gICAgICAgIGNvZGUgKz0gY29kZUZyYWdtZW50ICsgXCJcXG5cIjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgYXR0cmlidXRlIGNoYW5uZWxpbmcgY29kZVxyXG4gICAgdmFyIG1hcHBpbmdJbmRleCA9IDAsIGNvbnZlcnNpb25Db2RlID0gXCJcIjtcclxuICAgIGZvciggdmFyIG5hbWUgaW4gdnNDb25maWcuX2F0dHJpYnV0ZXMpe1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHZzQ29uZmlnLl9hdHRyaWJ1dGVzW25hbWVdO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlbnRyeS5jaGFubmVsaW5nLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIGNoYW5uZWxpbmcgPSBlbnRyeS5jaGFubmVsaW5nW2ldLCBvdXRwdXROYW1lID0gY2hhbm5lbGluZy5vdXRwdXROYW1lO1xyXG4gICAgICAgICAgICBpZih2cy5fb3V0cHV0SW5mb1tvdXRwdXROYW1lXS5pdGVyYXRpb24gPT0gQy5JVEVSQVRJT05fVFlQRS5NQU5ZKXtcclxuICAgICAgICAgICAgICAgIGlmKGNoYW5uZWxpbmcuY29kZSlcclxuICAgICAgICAgICAgICAgICAgICBjb252ZXJzaW9uQ29kZSArPSBcIlxcdFwiICsgY2hhbm5lbGluZy5jb2RlICsgXCJcXG5cIjtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBjb252ZXJzaW9uQ29kZSArPSBcIlxcdFwiICsgb3V0cHV0TmFtZSArIFwiID0gI0l7XCIgKyBuYW1lICsgXCJ9O1xcblwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcHBpbmdJbmRleCsrO1xyXG4gICAgfVxyXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2c0NvbmZpZy5fY29kZUZyYWdtZW50cy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgY29udmVyc2lvbkNvZGUgKz0gXCJcXHRcIiArIHZzQ29uZmlnLl9jb2RlRnJhZ21lbnRzW2ldICsgXCJcXG5cIjtcclxuICAgIH1cclxuICAgIGNvZGUgKz0gY29udmVydENvZGVGcmFnbWVudChjb252ZXJzaW9uQ29kZSwgYmFzZUVudHJ5LCB0cmFuc2Zlck5hbWVzLCBkaXJlY3RJbnB1dE5hbWVzLCB1c2VkTmFtZXMpICsgXCJcXG5cIjtcclxuXHJcbiAgICBjb2RlICs9IFwifVxcblwiO1xyXG4gICAgdnMuX2dsc2xDb2RlID0gY29kZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29udmVydENvZGVGcmFnbWVudChjb2RlRnJhZ21lbnQsIGVudHJ5LCB0cmFuc2Zlck5hbWVzLCBkaXJlY3RJbnB1dE5hbWVzLCB1c2VkTmFtZXMpe1xyXG4gICAgdmFyIGluZGV4LCBvcGVyYXRvciA9IGVudHJ5Lm9wZXJhdG9yO1xyXG4gICAgd2hpbGUoKGluZGV4ID0gY29kZUZyYWdtZW50LmluZGV4T2YoXCIjSXtcIikpICE9IC0xKXtcclxuICAgICAgICB2YXIgZW5kID0gY29kZUZyYWdtZW50LmluZGV4T2YoXCJ9XCIsaW5kZXgpO1xyXG4gICAgICAgIHZhciBtYXBwaW5nSW5kZXggPSBnZXRNYXBwaW5nSW5kZXgob3BlcmF0b3IsIGNvZGVGcmFnbWVudC5zdWJzdHJpbmcoaW5kZXgrMyxlbmQpKTtcclxuICAgICAgICB2YXIgcmVwbGFjZU5hbWUgPSBlbnRyeS5pc1RyYW5zZmVySW5wdXQobWFwcGluZ0luZGV4KSA/XHJcbiAgICAgICAgICAgIHRyYW5zZmVyTmFtZXNbZW50cnkuZ2V0VHJhbnNmZXJJbnB1dElkKG1hcHBpbmdJbmRleCldIDpcclxuICAgICAgICAgICAgZGlyZWN0SW5wdXROYW1lc1tlbnRyeS5nZXREaXJlY3RJbnB1dEluZGV4KG1hcHBpbmdJbmRleCldO1xyXG4gICAgICAgIGNvZGVGcmFnbWVudCA9IGNvZGVGcmFnbWVudC5zdWJzdHJpbmcoMCwgaW5kZXgpICsgcmVwbGFjZU5hbWUgKyBjb2RlRnJhZ21lbnQuc3Vic3RyaW5nKGVuZCsxKTtcclxuICAgIH1cclxuICAgIHdoaWxlKChpbmRleCA9IGNvZGVGcmFnbWVudC5pbmRleE9mKFwiI097XCIpKSAhPSAtMSl7XHJcbiAgICAgICAgdmFyIGVuZCA9IGNvZGVGcmFnbWVudC5pbmRleE9mKFwifVwiLGluZGV4KTtcclxuICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSBnZXRPdXRwdXRJbmRleChvcGVyYXRvciwgY29kZUZyYWdtZW50LnN1YnN0cmluZyhpbmRleCszLGVuZCkpO1xyXG4gICAgICAgIHZhciByZXBsYWNlTmFtZSA9IHRyYW5zZmVyTmFtZXNbZW50cnkuZ2V0VHJhbnNmZXJPdXRwdXRJZChvdXRwdXRJbmRleCldO1xyXG4gICAgICAgIGNvZGVGcmFnbWVudCA9IGNvZGVGcmFnbWVudC5zdWJzdHJpbmcoMCwgaW5kZXgpICsgcmVwbGFjZU5hbWUgKyBjb2RlRnJhZ21lbnQuc3Vic3RyaW5nKGVuZCsxKTtcclxuICAgIH1cclxuICAgIHZhciBsb2NhbE5hbWVzID0gW107XHJcbiAgICB3aGlsZSgoaW5kZXggPSBjb2RlRnJhZ21lbnQuaW5kZXhPZihcIiNMe1wiKSkgIT0gLTEpe1xyXG4gICAgICAgIHZhciBlbmQgPSBjb2RlRnJhZ21lbnQuaW5kZXhPZihcIn1cIixpbmRleCk7XHJcbiAgICAgICAgdmFyIGtleSA9IGNvZGVGcmFnbWVudC5zdWJzdHJpbmcoaW5kZXgrMyxlbmQpO1xyXG4gICAgICAgIGlmKCFsb2NhbE5hbWVzW2tleV0pe1xyXG4gICAgICAgICAgICBsb2NhbE5hbWVzW2tleV0gPSBnZXRGcmVlTmFtZShrZXksIHVzZWROYW1lcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXBsYWNlTmFtZSA9IGxvY2FsTmFtZXNba2V5XTtcclxuICAgICAgICBjb2RlRnJhZ21lbnQgPSBjb2RlRnJhZ21lbnQuc3Vic3RyaW5nKDAsIGluZGV4KSArIHJlcGxhY2VOYW1lICsgY29kZUZyYWdtZW50LnN1YnN0cmluZyhlbmQrMSk7XHJcbiAgICB9XHJcbiAgICB3aGlsZSgoaW5kZXggPSBjb2RlRnJhZ21lbnQuaW5kZXhPZihcIiNHe1wiKSkgIT0gLTEpe1xyXG4gICAgICAgIHZhciBlbmQgPSBjb2RlRnJhZ21lbnQuaW5kZXhPZihcIn1cIixpbmRleCk7XHJcbiAgICAgICAgdmFyIHJlcGxhY2VOYW1lID0gY29kZUZyYWdtZW50LnN1YnN0cmluZyhpbmRleCszLGVuZCk7XHJcbiAgICAgICAgY29kZUZyYWdtZW50ID0gY29kZUZyYWdtZW50LnN1YnN0cmluZygwLCBpbmRleCkgKyByZXBsYWNlTmFtZSArIGNvZGVGcmFnbWVudC5zdWJzdHJpbmcoZW5kKzEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvZGVGcmFnbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RnJlZU5hbWUobmFtZSwgdXNlZE5hbWVzKXtcclxuICAgIHZhciByZXN1bHQgPSBuYW1lLCBpID0gMTtcclxuICAgIHdoaWxlKHVzZWROYW1lcy5pbmRleE9mKHJlc3VsdCkgIT0gLTEpe1xyXG4gICAgICAgIHJlc3VsdCA9IG5hbWUgKyBcIl9cIiArICgrK2kpO1xyXG4gICAgfVxyXG4gICAgVXRpbHMubmFtZXNldC5hZGQodXNlZE5hbWVzLCByZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TWFwcGluZ0luZGV4KG9wZXJhdG9yLCBuYW1lKXtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvcGVyYXRvci5tYXBwaW5nLmxlbmd0aDsgKytpKXtcclxuICAgICAgICBpZihvcGVyYXRvci5tYXBwaW5nW2ldLm5hbWUgPT0gbmFtZSlcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IG5hbWUgJ1wiICsgbmFtZSAgKyBcIicgaW5zaWRlIG9mIGNvZGUgZnJhZ21lbnRcIiApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRPdXRwdXRJbmRleChvcGVyYXRvciwgbmFtZSl7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3BlcmF0b3Iub3V0cHV0cy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgaWYob3BlcmF0b3Iub3V0cHV0c1tpXS5uYW1lID09IG5hbWUpXHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRHTFNMVHlwZSh4Zmxvd1R5cGUpe1xyXG4gICAgc3dpdGNoKHhmbG93VHlwZSl7XHJcbiAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5CT09MIDogcmV0dXJuICdib29sJztcclxuICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkJZVEUgOiByZXR1cm4gJ3VpbnQnO1xyXG4gICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQgOiByZXR1cm4gJ2Zsb2F0JztcclxuICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUMiA6IHJldHVybiAndmVjMic7XHJcbiAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDMgOiByZXR1cm4gJ3ZlYzMnO1xyXG4gICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQ0IDogcmV0dXJuICd2ZWM0JztcclxuICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUM1gzIDogcmV0dXJuICdtYXQzJztcclxuICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUNFg0IDogcmV0dXJuICdtYXQ0JztcclxuICAgICAgICBjYXNlIEMuREFUQV9UWVBFLklOVCA6IHJldHVybiAnaW50JztcclxuICAgICAgICBjYXNlIEMuREFUQV9UWVBFLklOVDQgOiByZXR1cm4gJ2l2ZWM0JztcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGUgbm90IHN1cHBvcnRlZCBmb3IgR0xTTCBcIiArIEMuZ2V0VHlwZU5hbWUoeGZsb3dUeXBlKSApO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZTUHJvZ3JhbTtcclxuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcclxudmFyIEMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIENoYW5uZWxzID0gcmVxdWlyZShcIi4vY2hhbm5lbC5qc1wiKTtcclxudmFyIFJlcXVlc3ROb2RlID0gcmVxdWlyZShcIi4vcHJvY2Vzcy1ub2RlLmpzXCIpLlJlcXVlc3ROb2RlO1xyXG52YXIgUHJvY2Vzc05vZGUgPSByZXF1aXJlKFwiLi9wcm9jZXNzLW5vZGUuanNcIikuUHJvY2Vzc05vZGU7XHJcbnZhciBEYXRhU2xvdCA9IHJlcXVpcmUoXCIuL2RhdGEtc2xvdC5qc1wiKTtcclxudmFyIE9wZXJhdG9yID0gcmVxdWlyZShcIi4uL29wZXJhdG9yL29wZXJhdG9yLmpzXCIpO1xyXG5cclxudmFyIENoYW5uZWxNYXAgPSBDaGFubmVscy5DaGFubmVsTWFwO1xyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIENoYW5uZWxOb2RlXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLyoqXHJcbiAqIElzIGNyZWF0ZWQgZm9yIGVhY2ggc3Vic3RpdHV0aW9uICh2aWEgZGF0YWZsb3cpIG9mIGEgRGF0YU5vZGUuXHJcbiAqIFN0b3JlcyBhbiBvcHRpbWl6ZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRhdGEgd2l0aCBDaGFubmVsTWFwcyBhbmQgQ2hhbm5lbHNcclxuICogT24gY29uc3RydWN0aW9uIGEgQ2hhbm5lbE5vZGUgaXMgbWFya2VkIG91dE9mU3luYyBhbmQgc3luY2hyb25pemVkIG9ubHkgb25jZSBkYXRhIGlzIHJlcXVlc3RlZC5cclxuICogV2hlbiB0aGUgc3RydWN0dXJlIG9mIGEgRGF0YU5vZGUgaXMgY2hhbmdlZCBpbiBhbnkgd2F5IChlLmcuIHJlbmFtZSBJbnB1dE5vZGUsIGFkZC9yZW1vdmUgY2hpbGRyZW4pIGEgY2hhbm5lbE5vZGVcclxuICogaXMgbWFya2VkIG91dE9mU3luYy5cclxuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YU5vZGVcclxuICogQHBhcmFtIHtTdWJzdGl0dXRpb259IHN1YnN0aXR1dGlvblxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBDaGFubmVsTm9kZSA9IGZ1bmN0aW9uKGRhdGFOb2RlLCBzdWJzdGl0dXRpb24pe1xyXG4gICAgdGhpcy5vd25lciA9IGRhdGFOb2RlO1xyXG4gICAgdGhpcy5wbGF0Zm9ybSA9IEMuUExBVEZPUk0uSkFWQVNDUklQVDtcclxuICAgIHRoaXMuc3Vic3RpdHV0aW9uID0gc3Vic3RpdHV0aW9uOyAgIC8vIFN1YnN0aXR1dGlvbiBpcyBkZWZpbmVkIGJ5IHRoZSBkYXRhZmxvdyBpbnN0YW5jZVxyXG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7ICAgLy8gaXMgdHJ1ZSBpZiBhbnkgdmFsdWUgaW4gdGhlIHN1YiB0cmVlIGlzIGxvYWRpbmcgYW5kIHRoZSByZXN1bHQgY2FuJ3QgYmUgY2FsY3VsYXRlZFxyXG4gICAgdGhpcy5pbnB1dFNsb3RzID0ge307ICAgLy8gRGF0YUVudHJpZXMgZnJvbSBkaXJlY3QgSW5wdXROb2RlIGNoaWxkcmVuIG9mIHRoZSBEYXRhTm9kZVxyXG4gICAgdGhpcy5pbnB1dENoYW5uZWxzID0gbmV3IENoYW5uZWxNYXAoKTsgICAgLy8gY2hhbm5lbCBtYXAgZm9yIGlucHV0IGRhdGEgcHJpbyB0byBvcGVyYXRvciBleGVjdXRpb25cclxuICAgIHRoaXMuY29tcHV0ZWRDaGFubmVscyA9IG5ldyBDaGFubmVsTWFwKCk7IC8vIGNoYW5uZWwgbWFwIGV4dGVuZCBieSBvcGVyYXRvciBvdXRwdXRcclxuICAgIHRoaXMub3V0cHV0Q2hhbm5lbHMgPSBuZXcgQ2hhbm5lbE1hcCgpOyAgIC8vIGNoYW5uZWwgbWFwIHdpdGggYXBwbGllZCBmaWx0ZXIgPT4gZmluYWwgb3V0cHV0XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVyYXRvciBhdHRhY2hlZCB0byBEYXRhTm9kZSAoZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZClcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3BlcmF0b3IgPSBudWxsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFubmVsIG5vZGUgb2YgdGhlIGRhdGFmbG93Tm9kZSAoYW5hbG9ndWUgdG8gZGF0YWZsb3dOb2RlIG9mIERhdGFOb2RlKVxyXG4gICAgICogQHR5cGUge0NoYW5uZWxOb2RlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRhdGFmbG93Q2hhbm5lbE5vZGUgPSBudWxsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzIG5vZGUgLSBvbmx5IGNvbnN0cnVjdGVkIGlmIGFuIG9wZXJhdG9yL2RhdGFmbG93IGlzIGRlZmluZWRcclxuICAgICAqIEB0eXBlIHtQcm9jZXNzTm9kZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5wcm9jZXNzTm9kZSA9IG51bGw7XHJcbiAgICAvKipcclxuICAgICAqIFJlcXVlc3QgTm9kZXMgY3JlYXRlZCBmb3IgZWFjaCByZXN1bHQgcmVxdWVzdCBvbiB0aGlzIGRhdGFOb2RlLlxyXG4gICAgICogQHR5cGUge09iamVjdC48U3RyaW5nLFJlcXVlc3ROb2RlPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXF1ZXN0Tm9kZXMgPSB7fTtcclxuICAgIC8qKlxyXG4gICAgICogTnVtYmVyIG9mIHVzZXMgb2YgY2hhbm5lbCBub2RlLiBUaGlzIGlzIG9ubHkgcmVsZXZhbnQgZm9yIGNoYW5uZWwgbm9kZXMgY3JlYXRlZCB3aXRoIHN1YnN0aXR1dGlvbi5cclxuICAgICAqIFRoZXNlIG5vZGVzIGFyZSBjYWNoZWQgYW5kIHRoZSB1c2VDb3VudCBpcyB1c2VkIHRvIGNsZWFuIHRoaXMgY2FjaGUuXHJcbiAgICAgKiBUT0RPOiBVc2Ugd2Vha21hcCBoZXJlIHRvIGF2b2lkIGV4cGxpY2l0IHJlZmVyZW5jZSBjb3VudFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy51c2VDb3VudCA9IDE7XHJcbiAgICAvKipcclxuICAgICAqIFRydWUgaWYgdGhlIGNoYW5uZWwgbm9kZSBpcyBvdXQgb2Ygc3luYyBhbmQgaW50ZXJuYWwgY2hhbm5lbCBtYXBzIG5lZWQgdG8gYmUgcmVjb25zdHJ1Y3RlZFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3V0T2ZTeW5jID0gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJZiBub2RlIGlzIG91dCBvZiBzeW5jLCByZWNvbnN0cnVjdCBhbGwgY2hhbm5lbHNcclxuICovXHJcbkNoYW5uZWxOb2RlLnByb3RvdHlwZS5zeW5jaHJvbml6ZSA9IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgaWYodGhpcy5vdXRPZlN5bmMpe1xyXG4gICAgICAgIHVwZGF0ZVBsYXRmb3JtKHRoaXMpO1xyXG4gICAgICAgIHN5bmNocm9uaXplQ2hpbGRyZW4odGhpcyk7XHJcbiAgICAgICAgdXBkYXRlSW5wdXRDaGFubmVscyh0aGlzKTtcclxuICAgICAgICB1cGRhdGVDb21wdXRlZENoYW5uZWxzKHRoaXMpO1xyXG4gICAgICAgIHVwZGF0ZU91dHB1dENoYW5uZWxzKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub3V0T2ZTeW5jID0gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcblxyXG5DaGFubmVsTm9kZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy51c2VDb3VudCA9IDA7XHJcbiAgICAgdGhpcy5pbnB1dENoYW5uZWxzLmNsZWFyKCk7XHJcbiAgICAgdGhpcy5vdXRwdXRDaGFubmVscy5jbGVhcigpO1xyXG4gICAgIC8vIFRPRE86IE1ha2Ugc3VyZSBldmVyeXRoaW5nIGlzIGNsZWFuZWQgdXAgdGhlcmUhXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbkNoYW5uZWxOb2RlLnByb3RvdHlwZS5pbmNyZWFzZVJlZiA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnVzZUNvdW50Kys7XHJcbn07XHJcblxyXG5DaGFubmVsTm9kZS5wcm90b3R5cGUuZGVjcmVhc2VSZWYgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy51c2VDb3VudC0tO1xyXG4gICAgaWYodGhpcy51c2VDb3VudCA9PSAwKXtcclxuICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5DaGFubmVsTm9kZS5wcm90b3R5cGUuZ2V0T3V0cHV0TmFtZXMgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5zeW5jaHJvbml6ZSgpO1xyXG4gICAgcmV0dXJuIHRoaXMub3V0cHV0Q2hhbm5lbHMuZ2V0TmFtZXMoKTtcclxufTtcclxuXHJcbkNoYW5uZWxOb2RlLnByb3RvdHlwZS5nZXRDaGlsZERhdGFJbmRleCA9IGZ1bmN0aW9uKGZpbHRlcil7XHJcbiAgICB0aGlzLnN5bmNocm9uaXplKCk7XHJcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRDaGFubmVscy5nZXRDaGlsZERhdGFJbmRleEZvckZpbHRlcihmaWx0ZXIpO1xyXG59O1xyXG5cclxuQ2hhbm5lbE5vZGUucHJvdG90eXBlLnNldFN0cnVjdHVyZU91dE9mU3luYyA9IGZ1bmN0aW9uKClcclxue1xyXG4gICAgaWYoIXRoaXMub3V0T2ZTeW5jKXtcclxuICAgICAgICB0aGlzLm91dE9mU3luYyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pbnB1dENoYW5uZWxzLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlZENoYW5uZWxzLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRDaGFubmVscy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc05vZGUgJiYgdGhpcy5wcm9jZXNzTm9kZS5jbGVhcigpO1xyXG4gICAgICAgIGZvcih2YXIga2V5IGluIHRoaXMucmVxdWVzdE5vZGVzKXtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Tm9kZXNba2V5XS5zZXRTdHJ1Y3R1cmVPdXRPZlN5bmMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5DaGFubmVsTm9kZS5wcm90b3R5cGUubm90aWZ5RGF0YUNoYW5nZSA9IGZ1bmN0aW9uKGlucHV0Tm9kZSwgY2hhbmdlVHlwZSl7XHJcbiAgICB2YXIga2V5ID0gaW5wdXROb2RlLl9uYW1lICsgXCI7XCIgKyBpbnB1dE5vZGUuX2tleTtcclxuICAgIGlmKHRoaXMuaW5wdXRTbG90c1trZXldKVxyXG4gICAgICAgIHRoaXMuaW5wdXRTbG90c1trZXldLnNldERhdGFFbnRyeShpbnB1dE5vZGUuX2RhdGEsIGNoYW5nZVR5cGUpO1xyXG59O1xyXG5cclxuQ2hhbm5lbE5vZGUucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uKHR5cGUsIGZpbHRlcikge1xyXG4gICAgdGhpcy5zeW5jaHJvbml6ZSgpO1xyXG5cclxuICAgIHZhciBrZXkgPSBmaWx0ZXIgPyBmaWx0ZXIuam9pbihcIjtcIikgOiBcIltudWxsXVwiO1xyXG4gICAgaWYoIXRoaXMucmVxdWVzdE5vZGVzW2tleV0pe1xyXG4gICAgICAgIHRoaXMucmVxdWVzdE5vZGVzW2tleV0gPSBuZXcgUmVxdWVzdE5vZGUodGhpcywgZmlsdGVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3ROb2Rlc1trZXldLmdldFJlc3VsdCh0eXBlKTtcclxufTtcclxuXHJcblxyXG5DaGFubmVsTm9kZS5wcm90b3R5cGUuZ2V0T3V0cHV0Q2hhbm5lbEluZm8gPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHRoaXMuc3luY2hyb25pemUoKTtcclxuXHJcbiAgICB2YXIgY2hhbm5lbCA9IHRoaXMub3V0cHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChuYW1lKTtcclxuICAgIGlmKCFjaGFubmVsKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICB0eXBlOiBjaGFubmVsLmdldFR5cGUoKSxcclxuICAgICAgICBzZXFMZW5ndGg6IGNoYW5uZWwuZ2V0U2VxdWVuY2VMZW5ndGgoKSxcclxuICAgICAgICBzZXFNaW5LZXk6IGNoYW5uZWwuZ2V0U2VxdWVuY2VNaW5LZXkoKSxcclxuICAgICAgICBzZXFNYXhLZXk6IGNoYW5uZWwuZ2V0U2VxdWVuY2VNYXhLZXkoKSxcclxuICAgICAgICBvcmlnaW46IDAsXHJcbiAgICAgICAgb3JpZ2luYWxOYW1lOiBcIlwiXHJcbiAgICB9O1xyXG4gICAgdmFyIHByZUZpbHRlck5hbWUgPSB0aGlzLm93bmVyLl9maWx0ZXJNYXBwaW5nID8gdGhpcy5vd25lci5fZmlsdGVyTWFwcGluZy5nZXRSZW5hbWVTcmNOYW1lKG5hbWUpIDogbmFtZTtcclxuICAgIHZhciBkYXRhRW50cnkgPSBjaGFubmVsLmdldERhdGFFbnRyeSgpO1xyXG4gICAgaWYodGhpcy5kYXRhZmxvd0NoYW5uZWxOb2RlKXtcclxuICAgICAgICB2YXIgcHJvdG9JbnB1dENoYW5uZWwgPSB0aGlzLmlucHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChwcmVGaWx0ZXJOYW1lKTtcclxuICAgICAgICBpZighcHJvdG9JbnB1dENoYW5uZWwgfHwgZGF0YUVudHJ5ICE9IHByb3RvSW5wdXRDaGFubmVsLmdldERhdGFFbnRyeSgpKXtcclxuICAgICAgICAgICAgcmVzdWx0Lm9yaWdpbiA9IEMuT1JJR0lOLlBST1RPO1xyXG4gICAgICAgICAgICByZXN1bHQub3JpZ2luYWxOYW1lID0gcHJlRmlsdGVyTmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZih0aGlzLm9wZXJhdG9yKXtcclxuICAgICAgICB2YXIgaW5wdXRDaGFubmVsID0gdGhpcy5pbnB1dENoYW5uZWxzLmdldENoYW5uZWwocHJlRmlsdGVyTmFtZSk7XHJcbiAgICAgICAgaWYoIWlucHV0Q2hhbm5lbCB8fCBkYXRhRW50cnkgIT0gaW5wdXRDaGFubmVsLmdldERhdGFFbnRyeSgpKXtcclxuICAgICAgICAgICAgcmVzdWx0Lm9yaWdpbiA9IEMuT1JJR0lOLkNPTVBVVEU7XHJcbiAgICAgICAgICAgIHJlc3VsdC5vcmlnaW5hbE5hbWUgPSB0aGlzLm93bmVyLl9jb21wdXRlT3V0cHV0TWFwcGluZy5nZXRTY3JpcHRPdXRwdXROYW1lSW52KHByZUZpbHRlck5hbWUsIHRoaXMub3BlcmF0b3Iub3V0cHV0cyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdWx0Lm9yaWdpbiA9IEMuT1JJR0lOLkNISUxEO1xyXG4gICAgcmVzdWx0Lm9yaWdpbmFsTmFtZSA9IHByZUZpbHRlck5hbWU7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNlbGVjdCB0aGUgcGxhdGZvcm0gdG8gY29tcHV0ZSB0aGUgYXR0YWNoZWQgcGxhdGZvcm1cclxuICogQHBhcmFtIHtDaGFubmVsTm9kZX0gY2hhbm5lbE5vZGVcclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZVBsYXRmb3JtKGNoYW5uZWxOb2RlKSB7XHJcbiAgICB2YXIgcGxhdGZvcm07XHJcbiAgICB2YXIgb3duZXIgPSBjaGFubmVsTm9kZS5vd25lcjtcclxuICAgIHZhciBncmFwaCA9IG93bmVyLl9ncmFwaDtcclxuXHJcbiAgICAvLyBQbGF0Zm9ybXMgb3RoZXIgdGhhbiBKYXZhU2NyaXB0IGFyZSBhdmFpbGFibGUgb25seSBmb3IgY29tcHV0aW5nIG9wZXJhdG9yc1xyXG4gICAgaWYoIWNoYW5uZWxOb2RlLm93bmVyLl9jb21wdXRlT3BlcmF0b3IpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy9UT0RPOiBJbXByb3ZlIHBsYXRmb3JtIHNlbGVjdGlvbiBsb2dpYy5cclxuICAgIC8vIEN1cnJlbnRseSB3ZSB1c2UgZm9yY2VkIHBsYXRmb3JtIGlmIGdyYXBoIHBsYXRmb3JtIGlzIHNvbWV0aGluZyBvdGhlciB0aGFuIEphdmFTY3JpcHRcclxuICAgIC8vIGFuZCBmb3JjZWQgcGxhdGZvcm0gKG93bmVyLl9wbGF0Zm9ybSkgaXMgZGVmaW5lZFxyXG4gICAgcGxhdGZvcm0gPSBvd25lci5fcGxhdGZvcm0gIT09IG51bGwgPyBvd25lci5fcGxhdGZvcm0gOiBDLlBMQVRGT1JNLkpBVkFTQ1JJUFQ7XHJcblxyXG4gICAgY2hhbm5lbE5vZGUucGxhdGZvcm0gPSBwbGF0Zm9ybTtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IGNoYW5uZWxOb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jaHJvbml6ZUNoaWxkcmVuKGNoYW5uZWxOb2RlKXtcclxuICAgIHZhciBkYXRhTm9kZSA9IGNoYW5uZWxOb2RlLm93bmVyO1xyXG4gICAgY2hhbm5lbE5vZGUubG9hZGluZyA9IGRhdGFOb2RlLmlzU3VidHJlZUxvYWRpbmcoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBjaGFubmVsIG5vZGUgcmVwcmVzZW50cyBhIHN1YnN0aXR1dGlvbiwgd2UgYWxzbyBuZWVkIHRvXHJcbiAgICAgKiBzeW5jaHJvbml6ZSB0aGUgbWFpbiBDaGFubmVsTm9kZSBvZiB0aGUgRGF0YU5vZGVcclxuICAgICAqL1xyXG4gICAgaWYoY2hhbm5lbE5vZGUuc3Vic3RpdHV0aW9uKSB7XHJcbiAgICAgICAgZGF0YU5vZGUuX2NoYW5uZWxOb2RlLnN5bmNocm9uaXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm93IHN5bmNocm9uaXplIGFsbCBjaGlsZHJlbiAoZWl0aGVyIHJlZmVyZW5jZWQgZGF0YSBub2RlLCBvciByZWFsIGNoaWxkcmVuKVxyXG4gICAgLy8gVE9ETzogQ2hhbmdlIGhlcmUgaWYgd2UgY2hhbmdlIGJlaGF2aW91ciBvZiBzcmMgYXR0cmlidXRlXHJcbiAgICBpZihkYXRhTm9kZS5fc291cmNlTm9kZSl7XHJcbiAgICAgICAgZGF0YU5vZGUuX3NvdXJjZU5vZGUuX2dldE9yQ3JlYXRlQ2hhbm5lbE5vZGUoY2hhbm5lbE5vZGUuc3Vic3RpdHV0aW9uKS5zeW5jaHJvbml6ZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0YU5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYoZGF0YU5vZGUuX2NoaWxkcmVuW2ldLl9nZXRPckNyZWF0ZUNoYW5uZWxOb2RlKXtcclxuICAgICAgICAgICAgICAgIGRhdGFOb2RlLl9jaGlsZHJlbltpXS5fZ2V0T3JDcmVhdGVDaGFubmVsTm9kZShjaGFubmVsTm9kZS5zdWJzdGl0dXRpb24pLnN5bmNocm9uaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NoYW5uZWxOb2RlfSBjaGFubmVsTm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlSW5wdXRDaGFubmVscyhjaGFubmVsTm9kZSl7XHJcbiAgICB2YXIgb3duZXIgPSBjaGFubmVsTm9kZS5vd25lcjtcclxuICAgIC8vIFRPRE86IENoYW5nZSBoZXJlIGlmIHdlIGNoYW5nZSBiZWhhdmlvdXIgb2Ygc3JjIGF0dHJpYnV0ZVxyXG4gICAgaWYob3duZXIuX3NvdXJjZU5vZGUpe1xyXG4gICAgICAgIGNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHMubWVyZ2Uob3duZXIuX3NvdXJjZU5vZGUuX2dldE9yQ3JlYXRlQ2hhbm5lbE5vZGUoY2hhbm5lbE5vZGUuc3Vic3RpdHV0aW9uKS5vdXRwdXRDaGFubmVscywgMCk7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG93bmVyLl9jaGlsZHJlbjtcclxuICAgICAgICAvLyBGaXJzdCB0aGUgRGF0YU5vZGVzIHRoYW4gdGhlIGlucHV0IG5vZGVzIGluIG9yZGVyIHRvIG92ZXJyaWRlIHRoZSBEYXRhTm9kZSBjaGFubmVsc1xyXG4gICAgICAgIG1lcmdlSW5wdXRDaGFubmVsRGF0YU5vZGVzKGNoYW5uZWxOb2RlLCBjaGlsZHJlbik7XHJcbiAgICAgICAgbWVyZ2VJbnB1dENoYW5uZWxJbnB1dE5vZGVzKGNoYW5uZWxOb2RlLCBjaGlsZHJlbik7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0NoYW5uZWxOb2RlfSBjaGFubmVsTm9kZVxyXG4gKiBAcGFyYW0ge0FycmF5LjxHcmFwaE5vZGU+fSBjaGlsZHJlblxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VJbnB1dENoYW5uZWxJbnB1dE5vZGVzKGNoYW5uZWxOb2RlLCBjaGlsZHJlbikge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmICghY2hpbGRyZW5baV0uX2dldE9yQ3JlYXRlQ2hhbm5lbE5vZGUpIHsgIC8vIENoaWxkIGlzIGFuIElucHV0Tm9kZVxyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGNoaWxkLl9uYW1lICsgXCI7XCIgKyBjaGlsZC5fa2V5O1xyXG4gICAgICAgICAgICBpZiAoIWNoYW5uZWxOb2RlLnN1YnN0aXR1dGlvbikgeyAgLy8gTm8gZGF0YWZsb3dcclxuICAgICAgICAgICAgICAgIHZhciBzbG90ID0gbmV3IERhdGFTbG90KGNoaWxkLl9kYXRhLCBjaGlsZC5fa2V5KTtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWxOb2RlLmlucHV0U2xvdHNba2V5XSA9IHNsb3Q7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsTm9kZS5pbnB1dENoYW5uZWxzLmFkZERhdGFFbnRyeShjaGlsZC5fbmFtZSwgc2xvdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuX3BhcmFtTmFtZSAmJiBjaGFubmVsTm9kZS5zdWJzdGl0dXRpb24uaGFzQ2hhbm5lbChjaGlsZC5fcGFyYW1OYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHMuYWRkQ2hhbm5lbChjaGlsZC5fbmFtZSwgY2hhbm5lbE5vZGUuc3Vic3RpdHV0aW9uLmdldENoYW5uZWwoY2hpbGQuX3BhcmFtTmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsTm9kZS5pbnB1dENoYW5uZWxzLmFkZERhdGFFbnRyeShjaGlsZC5fbmFtZSwgY2hhbm5lbE5vZGUub3duZXIuX2NoYW5uZWxOb2RlLmlucHV0U2xvdHNba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0NoYW5uZWxOb2RlfSBjaGFubmVsTm9kZVxyXG4gKiBAcGFyYW0ge0FycmF5LjxHcmFwaE5vZGU+fSBjaGlsZHJlblxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VJbnB1dENoYW5uZWxEYXRhTm9kZXMoY2hhbm5lbE5vZGUsIGNoaWxkcmVuKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLl9nZXRPckNyZWF0ZUNoYW5uZWxOb2RlKSB7ICAvLyBDaGlsZCBpcyBhIERhdGFOb2RlXHJcbiAgICAgICAgICAgIGNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHMubWVyZ2UoY2hpbGRyZW5baV0uX2dldE9yQ3JlYXRlQ2hhbm5lbE5vZGUoY2hhbm5lbE5vZGUuc3Vic3RpdHV0aW9uKS5vdXRwdXRDaGFubmVscywgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVDb21wdXRlZENoYW5uZWxzKGNoYW5uZWxOb2RlKXtcclxuICAgIHZhciBvd25lciA9IGNoYW5uZWxOb2RlLm93bmVyO1xyXG4gICAgY2hhbm5lbE5vZGUuY29tcHV0ZWRDaGFubmVscy5tZXJnZShjaGFubmVsTm9kZS5pbnB1dENoYW5uZWxzKTtcclxuXHJcbiAgICB2YXIgb2xkRGF0YWZsb3dDaGFubmVsTm9kZSA9IGNoYW5uZWxOb2RlLmRhdGFmbG93Q2hhbm5lbE5vZGU7XHJcblxyXG4gICAgaWYoIG93bmVyLl9jb21wdXRlVXNlc0RhdGFmbG93ICYmIG93bmVyLl9kYXRhZmxvd05vZGUpe1xyXG4gICAgICAgIGNoYW5uZWxOb2RlLm9wZXJhdG9yID0gbnVsbDtcclxuICAgICAgICB1cGRhdGVEYXRhZmxvd0NoYW5uZWxOb2RlKGNoYW5uZWxOb2RlKTtcclxuICAgICAgICB1cGRhdGVDb21wdXRlZENoYW5uZWxzRnJvbURhdGFmbG93KGNoYW5uZWxOb2RlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYoIW93bmVyLl9jb21wdXRlVXNlc0RhdGFmbG93ICYmIG93bmVyLl9jb21wdXRlT3BlcmF0b3Ipe1xyXG4gICAgICAgIGNoYW5uZWxOb2RlLmRhdGFmbG93Q2hhbm5lbE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHVwZGF0ZU9wZXJhdG9yKGNoYW5uZWxOb2RlKTtcclxuICAgICAgICB1cGRhdGVDb21wdXRlZENoYW5uZWxzRnJvbU9wZXJhdG9yKGNoYW5uZWxOb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZihvbGREYXRhZmxvd0NoYW5uZWxOb2RlICYmIG9sZERhdGFmbG93Q2hhbm5lbE5vZGUgIT0gY2hhbm5lbE5vZGUuZGF0YWZsb3dDaGFubmVsTm9kZSl7XHJcbiAgICAgICAgb2xkRGF0YWZsb3dDaGFubmVsTm9kZS5vd25lci5fcmVtb3ZlU3Vic3RpdHV0aW9uTm9kZShvbGREYXRhZmxvd0NoYW5uZWxOb2RlKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmQgYW5kIHNldCB0aGUgb3BlcmF0b3IgZm9yIHRoZSBnaXZlbiBDaGFubmVsTm9kZVxyXG4gKiBAcGFyYW0gY2hhbm5lbE5vZGVcclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZU9wZXJhdG9yKGNoYW5uZWxOb2RlKXtcclxuICAgIHZhciBvcGVyYXRvck5hbWUsIG9wZXJhdG9yO1xyXG4gICAgdmFyIG93bmVyID0gY2hhbm5lbE5vZGUub3duZXI7XHJcblxyXG4gICAgaWYoY2hhbm5lbE5vZGUubG9hZGluZyl7XHJcbiAgICAgICAgY2hhbm5lbE5vZGUub3BlcmF0b3IgPSBudWxsO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmKHR5cGVvZiBvd25lci5fY29tcHV0ZU9wZXJhdG9yID09IFwic3RyaW5nXCIpe1xyXG4gICAgICAgIG9wZXJhdG9yTmFtZSA9IG93bmVyLl9jb21wdXRlT3BlcmF0b3I7XHJcbiAgICAgICAgb3BlcmF0b3IgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBHZXR0aW5nIGEgY29ycmVjdCBvcGVyYXRvciBmb3IgdGhlIHNlbGVjdGVkIHBsYXRmb3JtLiBJZiBvcGVyYXRvciBpcyBub3QgYXZhaWxhYmxlLCB3ZSdsbCB0cnkgdG8gZ2V0XHJcbiAgICAgICAgLy8gdGhlIGRlZmF1bHQgSmF2YVNjcmlwdCBwbGF0Zm9ybSBvcGVyYXRvclxyXG4gICAgICAgIGlmKG9wZXJhdG9yTmFtZSl7XHJcbiAgICAgICAgICAgIG9wZXJhdG9yID0gZmluZE9wZXJhdG9yQnlOYW1lKGNoYW5uZWxOb2RlLCBvd25lcik7XHJcbiAgICAgICAgICAgIGlmKG9wZXJhdG9yKSB7IC8vIFRPRE86IElzIHRoaXMgZ29vZD8gV2UgY2FsY3VsYXRlZCB0aGUgcGxhdGZvcm0gYmVmb3JlLCBub3cgaXQganVzdCBnZXRzIG92ZXJyaWRlblxyXG4gICAgICAgICAgICAgICAgY2hhbm5lbE5vZGUucGxhdGZvcm0gPSBvcGVyYXRvci5wbGF0Zm9ybTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjaGFubmVsTm9kZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgY2hhbm5lbE5vZGUub3BlcmF0b3IgPSBvd25lci5fY29tcHV0ZU9wZXJhdG9yO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgY190eXBlQ29tcGFyaXNvbnMgPSBbXTtcclxuXHJcbi8qKlxyXG4gKiBGaW5kIG9wZXJhdG9yIGJhc2VkIG9uIG5hbWUgaW4gZGF0YU5vZGUsIHBsYXRmb3JtIGFuZCBpbnB1dCBtYXBwaW5nIChzaWduYXR1cmUpXHJcbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IGNoYW5uZWxOb2RlXHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlXHJcbiAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cclxuICovXHJcbmZ1bmN0aW9uIGZpbmRPcGVyYXRvckJ5TmFtZShjaGFubmVsTm9kZSwgZGF0YU5vZGUpe1xyXG4gICAgdmFyIG9wZXJhdG9yTmFtZSA9IGRhdGFOb2RlLl9jb21wdXRlT3BlcmF0b3IsXHJcbiAgICAgICAgaW5wdXRNYXBwaW5nID0gZGF0YU5vZGUuX2NvbXB1dGVJbnB1dE1hcHBpbmcsXHJcbiAgICAgICAgaW5wdXRDaGFubmVscyA9IGNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHM7XHJcblxyXG4gICAgdmFyIG9wZXJhdG9ycyA9IE9wZXJhdG9yLmdldE9wZXJhdG9ycyhvcGVyYXRvck5hbWUsIGNoYW5uZWxOb2RlLnBsYXRmb3JtKSB8fFxyXG4gICAgICAgICAgICAgICAgT3BlcmF0b3IuZ2V0T3BlcmF0b3JzKG9wZXJhdG9yTmFtZSwgQy5QTEFURk9STS5KQVZBU0NSSVBUKTtcclxuICAgIGlmKCFvcGVyYXRvcnMpe1xyXG4gICAgICAgIEJhc2Uubm90aWZ5RXJyb3IoXCJObyBvcGVyYXRvciB3aXRoIG5hbWUgJ1wiICsgb3BlcmF0b3JOYW1lK1wiJyBmb3VuZFwiLCBjaGFubmVsTm9kZS5vd25lcik7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGkgPSBvcGVyYXRvcnMubGVuZ3RoO1xyXG4gICAgd2hpbGUoaS0tKXtcclxuICAgICAgICBpZihjaGVja09wZXJhdG9yKG9wZXJhdG9yc1tpXSwgaW5wdXRNYXBwaW5nLCBpbnB1dENoYW5uZWxzKSl7XHJcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvcnNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY190eXBlQ29tcGFyaXNvbnMubGVuZ3RoID0gMDtcclxuICAgIGkgPSBvcGVyYXRvcnMubGVuZ3RoO1xyXG4gICAgd2hpbGUoaS0tKXtcclxuICAgICAgICBjaGVja09wZXJhdG9yKG9wZXJhdG9yc1tpXSwgaW5wdXRNYXBwaW5nLCBpbnB1dENoYW5uZWxzLCBjX3R5cGVDb21wYXJpc29ucyk7XHJcbiAgICB9XHJcbiAgICB2YXIgZXJyb3JNZXNzYWdlID0gXCJObyBvcGVyYXRvciAnXCIgKyBvcGVyYXRvck5hbWUrXCInIHdpdGggbWF0Y2hpbmcgdHlwZSBzaWduYXR1cmUgZm91bmQ6XFxuXFxuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyBjX3R5cGVDb21wYXJpc29ucy5qb2luKFwiXFxuXCIpO1xyXG4gICAgQmFzZS5ub3RpZnlFcnJvcihlcnJvck1lc3NhZ2UsIGNoYW5uZWxOb2RlLm93bmVyKTtcclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIG9wZXJhdG9yXHJcbiAqIEBwYXJhbSBpbnB1dE1hcHBpbmdcclxuICogQHBhcmFtIGlucHV0Q2hhbm5lbHNcclxuICogQHBhcmFtIHtBcnJheT99IHR5cGVDb21wYXJpc29uc091dHB1dCBJZiBhcnJheSBpcyBnaXZlLCBzYXZlIGVycm9yIGluZm9ybWF0aW9uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tPcGVyYXRvcihvcGVyYXRvciwgaW5wdXRNYXBwaW5nLCBpbnB1dENoYW5uZWxzLCB0eXBlQ29tcGFyaXNvbnNPdXRwdXQpe1xyXG4gICAgdmFyIGlucHV0cywgZXJyb3JzO1xyXG4gICAgaWYodHlwZUNvbXBhcmlzb25zT3V0cHV0KXtcclxuICAgICAgICBpbnB1dHMgPSBbXTsgZXJyb3JzID0gW107XHJcbiAgICB9XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3BlcmF0b3IucGFyYW1zLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgaW5wdXRFbnRyeSA9IG9wZXJhdG9yLnBhcmFtc1tpXSwgc291cmNlTmFtZSA9IGlucHV0RW50cnkuc291cmNlO1xyXG4gICAgICAgIHZhciBkYXRhTmFtZSA9IGlucHV0TWFwcGluZyA/IGlucHV0TWFwcGluZy5nZXRTY3JpcHRJbnB1dE5hbWUoaSwgc291cmNlTmFtZSkgOiBzb3VyY2VOYW1lO1xyXG4gICAgICAgIHZhciBlcnJvckhlYWRlcjtcclxuICAgICAgICBpZih0eXBlQ29tcGFyaXNvbnNPdXRwdXQpe1xyXG4gICAgICAgICAgICBlcnJvckhlYWRlciA9IFwiRm9yIFwiICsgKGkrMSkgKyBcIi4gYXJndW1lbnQgJ1wiICsgc291cmNlTmFtZSArIFwiJzogXCI7XHJcbiAgICAgICAgICAgIGlucHV0cy5wdXNoKCBDLmdldFR5cGVOYW1lKGlucHV0RW50cnkudHlwZSkgKyBcIiBcIiArIHNvdXJjZU5hbWUgKyAoaW5wdXRFbnRyeS5vcHRpb25hbCA/IFwiIFtvcHRpb25hbF1cIiA6IFwiXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZGF0YU5hbWUpe1xyXG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IGlucHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChkYXRhTmFtZSk7XHJcbiAgICAgICAgICAgIGlmKCFjaGFubmVsICYmICFpbnB1dEVudHJ5Lm9wdGlvbmFsKXtcclxuICAgICAgICAgICAgICAgIGlmKCF0eXBlQ29tcGFyaXNvbnNPdXRwdXQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvckhlYWRlciArIFwiRGF0YUVudHJ5ICdcIiArIGRhdGFOYW1lICsgXCInIGRvZXMgbm90IGV4aXN0XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGNoYW5uZWwgJiYgY2hhbm5lbC5nZXRUeXBlKCkgIT0gaW5wdXRFbnRyeS50eXBlKXtcclxuICAgICAgICAgICAgICAgIGlmKCF0eXBlQ29tcGFyaXNvbnNPdXRwdXQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvckhlYWRlciArIFwiRGF0YUVudHJ5ICdcIiArIGRhdGFOYW1lICsgXCInIGhhcyB3cm9uZyB0eXBlICdcIiArIEMuZ2V0VHlwZU5hbWUoY2hhbm5lbC5nZXRUeXBlKCkpICsgXCInXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYodHlwZUNvbXBhcmlzb25zT3V0cHV0KXtcclxuICAgICAgICB0eXBlQ29tcGFyaXNvbnNPdXRwdXQucHVzaChvcGVyYXRvci5uYW1lICsgXCIoXCIgKyBpbnB1dHMuam9pbihcIiwgXCIpICsgXCIpXFxuXFx0ICogXCIgKyBlcnJvcnMuam9pbihcIlxcblxcdCAqIFwiKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGFubmVsTm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlQ29tcHV0ZWRDaGFubmVsc0Zyb21PcGVyYXRvcihjaGFubmVsTm9kZSl7XHJcbiAgICB2YXIgb3duZXIgPSBjaGFubmVsTm9kZS5vd25lcjtcclxuICAgIGlmKGNoYW5uZWxOb2RlLm9wZXJhdG9yKXtcclxuICAgICAgICB2YXIgcHJvY05vZGUgPSBjaGFubmVsTm9kZS5wcm9jZXNzTm9kZSA9IG5ldyBQcm9jZXNzTm9kZShjaGFubmVsTm9kZSk7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICBmb3IodmFyIG5hbWUgaW4gcHJvY05vZGUub3V0cHV0RGF0YVNsb3RzKXtcclxuICAgICAgICAgICAgdmFyIGRlc3ROYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgaWYob3duZXIuX2NvbXB1dGVPdXRwdXRNYXBwaW5nKSBkZXN0TmFtZSA9IG93bmVyLl9jb21wdXRlT3V0cHV0TWFwcGluZy5nZXRTY3JpcHRPdXRwdXROYW1lKGluZGV4LCBuYW1lKTtcclxuICAgICAgICAgICAgaWYoZGVzdE5hbWUpe1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbE5vZGUuY29tcHV0ZWRDaGFubmVscy5hZGRPdXRwdXREYXRhU2xvdChkZXN0TmFtZSwgcHJvY05vZGUub3V0cHV0RGF0YVNsb3RzW25hbWVdLCBwcm9jTm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NoYW5uZWxOb2RlfSBjaGFubmVsTm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlRGF0YWZsb3dDaGFubmVsTm9kZShjaGFubmVsTm9kZSl7XHJcbiAgICB2YXIgb3duZXIgPSBjaGFubmVsTm9kZS5vd25lcjtcclxuICAgIHZhciBzdWJTdWJzdGl0dXRpb24gPSBuZXcgU3Vic3RpdHV0aW9uKG93bmVyLl9kYXRhZmxvd05vZGUsIGNoYW5uZWxOb2RlKTtcclxuICAgIGNoYW5uZWxOb2RlLmRhdGFmbG93Q2hhbm5lbE5vZGUgPSBvd25lci5fZGF0YWZsb3dOb2RlLl9nZXRPckNyZWF0ZUNoYW5uZWxOb2RlKHN1YlN1YnN0aXR1dGlvbik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0NoYW5uZWxOb2RlfSBjaGFubmVsTm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlQ29tcHV0ZWRDaGFubmVsc0Zyb21EYXRhZmxvdyhjaGFubmVsTm9kZSl7XHJcbiAgICB2YXIgb3duZXIgPSBjaGFubmVsTm9kZS5vd25lcjtcclxuICAgIGlmKGNoYW5uZWxOb2RlLmRhdGFmbG93Q2hhbm5lbE5vZGUpe1xyXG4gICAgICAgIHZhciBkYXRhZmxvd0NOb2RlID0gY2hhbm5lbE5vZGUuZGF0YWZsb3dDaGFubmVsTm9kZTtcclxuICAgICAgICBkYXRhZmxvd0NOb2RlLnN5bmNocm9uaXplKCk7XHJcbiAgICAgICAgLy8gVE9ETzogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdG8gZ2V0IG91dHB1dE5hbWVzIGluIHRoZSByaWdodCBvcmRlciB0byBhcHBseSBvdXRwdXQgbWFwcGluZyBjb3JyZWN0bHlcclxuICAgICAgICB2YXIgb3V0cHV0TmFtZXMgPSBkYXRhZmxvd0NOb2RlLm91dHB1dENoYW5uZWxzLmdldE5hbWVzKCk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG91dHB1dE5hbWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIHNyY05hbWUgPSBvdXRwdXROYW1lc1tpXSwgZGVzdE5hbWUgPSBzcmNOYW1lO1xyXG4gICAgICAgICAgICBpZihvd25lci5fY29tcHV0ZU91dHB1dE1hcHBpbmcpXHJcbiAgICAgICAgICAgICAgICBkZXN0TmFtZSA9IG93bmVyLl9jb21wdXRlT3V0cHV0TWFwcGluZy5nZXRTY3JpcHRPdXRwdXROYW1lKGksIHNyY05hbWUpO1xyXG4gICAgICAgICAgICBpZihkZXN0TmFtZSlcclxuICAgICAgICAgICAgICAgIGNoYW5uZWxOb2RlLmNvbXB1dGVkQ2hhbm5lbHMuYWRkQ2hhbm5lbChkZXN0TmFtZSwgZGF0YWZsb3dDTm9kZS5vdXRwdXRDaGFubmVscy5nZXRDaGFubmVsKHNyY05hbWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZU91dHB1dENoYW5uZWxzKGNoYW5uZWxOb2RlKXtcclxuICAgIHZhciBkYXRhTm9kZSA9IGNoYW5uZWxOb2RlLm93bmVyO1xyXG4gICAgaWYoZGF0YU5vZGUuX2ZpbHRlck1hcHBpbmcpIHtcclxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIHRoZSBvbmx5IGxvY2F0aW9uIHdoZXJlIGFwcGx5RmlsdGVyT25DaGFubmVsTWFwIGlzIHVzZWQuIENhbiBiZSBzaW1wbGlmaWVkIChlLmcuIHdpdGhvdXQgY2FsbGJhY2spXHJcbiAgICAgICAgZGF0YU5vZGUuX2ZpbHRlck1hcHBpbmcuYXBwbHlGaWx0ZXJPbkNoYW5uZWxNYXAoY2hhbm5lbE5vZGUub3V0cHV0Q2hhbm5lbHMsIGNoYW5uZWxOb2RlLmNvbXB1dGVkQ2hhbm5lbHMsIGRhdGFOb2RlLl9maWx0ZXJUeXBlLCBzZXRDaGFubmVsRmlsdGVyQ2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICAgIGNoYW5uZWxOb2RlLm91dHB1dENoYW5uZWxzLm1lcmdlKGNoYW5uZWxOb2RlLmNvbXB1dGVkQ2hhbm5lbHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRDaGFubmVsRmlsdGVyQ2FsbGJhY2soZGVzdE1hcCwgZGVzdE5hbWUsIHNyY01hcCwgc3JjTmFtZSl7XHJcbiAgICB2YXIgY2hhbm5lbCA9IHNyY01hcC5nZXRDaGFubmVsKHNyY05hbWUpO1xyXG4gICAgZGVzdE1hcC5hZGRDaGFubmVsKGRlc3ROYW1lLCBjaGFubmVsLCBzcmNNYXAuZ2V0Q2hpbGREYXRhSW5kZXgoc3JjTmFtZSkpO1xyXG59XHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gU3Vic3RpdHV0aW9uXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLyoqXHJcbiAqIFRPRE86IFRoaW5rIG9mIHJlcGxhY2luZyB0aGlzIHdpdGggYSBjaGFubmVsIG1hcFxyXG4gKiBAcGFyYW0gZGF0YWZsb3dOb2RlXHJcbiAqIEBwYXJhbSB1c2VyQ2hhbm5lbE5vZGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgU3Vic3RpdHV0aW9uID0gZnVuY3Rpb24oZGF0YWZsb3dOb2RlLCB1c2VyQ2hhbm5lbE5vZGUpe1xyXG4gICAgdGhpcy5tYXAgPSB7fTtcclxuXHJcbiAgICBjcmVhdGVTdWJzdGl0dXRpb24odGhpcywgZGF0YWZsb3dOb2RlLCB1c2VyQ2hhbm5lbE5vZGUpO1xyXG59O1xyXG5cclxuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5oYXNDaGFubmVsID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gISF0aGlzLm1hcFtuYW1lXTtcclxufTtcclxuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRDaGFubmVsID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gdGhpcy5tYXBbbmFtZV07XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgaGFzaGFibGUga2V5IGZvciB0aGUgc3Vic3RpdXRpb25cclxuICogQHBhcmFtIHN1YkRhdGFmbG93Tm9kZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbihzdWJEYXRhZmxvd05vZGUpe1xyXG4gICAgdmFyIGtleSA9IFwiXCI7XHJcbiAgICB2YXIgZ2xvYmFsUGFyYW1OYW1lcyA9IHN1YkRhdGFmbG93Tm9kZS5fZ2V0R2xvYmFsUGFyYW1OYW1lcygpO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGdsb2JhbFBhcmFtTmFtZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5tYXBbZ2xvYmFsUGFyYW1OYW1lc1tpXV07XHJcbiAgICAgICAga2V5Kz0gKGNoYW5uZWwgJiYgY2hhbm5lbC5pZCB8fCBcIi1cIikgKyBcIiFcIjtcclxuICAgIH1cclxuICAgIHZhciBwYXJhbU5hbWVzID0gc3ViRGF0YWZsb3dOb2RlLl9nZXRQYXJhbU5hbWVzKCk7XHJcbiAgICBmb3IoaSA9IDA7IGkgPCBwYXJhbU5hbWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICBjaGFubmVsID0gdGhpcy5tYXBbcGFyYW1OYW1lc1tpXV07XHJcbiAgICAgICAga2V5Kz0gKGNoYW5uZWwgJiYgY2hhbm5lbC5pZCB8fCBcIi1cIikgKyBcIi5cIjtcclxuICAgIH1cclxuICAgIHJldHVybiBrZXk7XHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtTdWJzdGl0dXRpb259IHN1YnN0aXR1dGlvblxyXG4gKiBAcGFyYW0ge0RhdGFOb2RlfSBkYXRhZmxvd05vZGVcclxuICogQHBhcmFtIHtDaGFubmVsTm9kZX0gdXNlckNoYW5uZWxOb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTdWJzdGl0dXRpb24oc3Vic3RpdHV0aW9uLCBkYXRhZmxvd05vZGUsIHVzZXJDaGFubmVsTm9kZSl7XHJcbiAgICB2YXIgdXNlck93bmVyID0gdXNlckNoYW5uZWxOb2RlLm93bmVyO1xyXG5cclxuICAgIC8vIEZpbmQgY2hhbm5lbHMgZm9yIGdsb2JhbCBwYXJhbWV0ZXJzXHJcbiAgICB2YXIgZ2xvYmFsUGFyYW1OYW1lcyA9IGRhdGFmbG93Tm9kZS5fZ2V0R2xvYmFsUGFyYW1OYW1lcygpO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGdsb2JhbFBhcmFtTmFtZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHN1YnN0aXR1dGlvbi5tYXBbZ2xvYmFsUGFyYW1OYW1lc1tpXV0gPSB1c2VyQ2hhbm5lbE5vZGUuaW5wdXRDaGFubmVscy5nZXRDaGFubmVsKGdsb2JhbFBhcmFtTmFtZXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbmQgY2hhbm5lbHMgZm9yIGxvY2FsIHBhcmFtZXRlcnMuIFRoZXNlIHdpbGwgb3ZlcnJpZGUgZXhpc3RpbmcgZ2xvYmFsIHBhcmFtZXRlcnNcclxuICAgIHZhciBwYXJhbU5hbWVzID0gZGF0YWZsb3dOb2RlLl9nZXRQYXJhbU5hbWVzKCk7XHJcbiAgICBmb3IoaSA9IDA7IGkgPCBwYXJhbU5hbWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgZGVzdE5hbWUgPSBwYXJhbU5hbWVzW2ldLCBzcmNOYW1lID0gZGVzdE5hbWU7XHJcbiAgICAgICAgaWYodXNlck93bmVyLl9jb21wdXRlSW5wdXRNYXBwaW5nKXtcclxuICAgICAgICAgICAgc3JjTmFtZSA9IHVzZXJPd25lci5fY29tcHV0ZUlucHV0TWFwcGluZy5nZXRTY3JpcHRJbnB1dE5hbWUoaSwgZGVzdE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdWJzdGl0dXRpb24ubWFwW2Rlc3ROYW1lXSA9IHVzZXJDaGFubmVsTm9kZS5pbnB1dENoYW5uZWxzLmdldENoYW5uZWwoc3JjTmFtZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgQ2hhbm5lbE5vZGU6ICBDaGFubmVsTm9kZSxcclxuICAgIFN1YnN0aXR1dGlvbjogU3Vic3RpdHV0aW9uXHJcbn07XHJcbiIsInZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XHJcbnZhciBDID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcbnZhciBCdWZmZXJFbnRyeSA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2UvZGF0YS5qc1wiKS5CdWZmZXJFbnRyeTtcclxuXHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gRGF0YVNsb3RcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIENoYW5uZWxNYXBcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vKipcclxuICogQSBtYXAgd2l0aCBjaGFubmVscy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgQ2hhbm5lbE1hcCA9IGZ1bmN0aW9uKCl7XHJcbiAgICAvKipcclxuICAgICAqIEEgbWFwIG9mIGNoYW5uZWxzLlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCB7Y2hhbm5lbDogQ2hhbm5lbCwgY2hpbGREYXRhSW5kZXg6IE51bWJlcn0+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1hcCA9IHt9O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBsaXN0IG9mIGFsbCBrZXlzLlxyXG4gKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59XHJcbiAqL1xyXG5DaGFubmVsTWFwLnByb3RvdHlwZS5nZXROYW1lcyA9IGZ1bmN0aW9uKClcclxue1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubWFwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZVxyXG4gKiBAcmV0dXJucyB7Q2hhbm5lbH1cclxuICovXHJcbkNoYW5uZWxNYXAucHJvdG90eXBlLmdldENoYW5uZWwgPSBmdW5jdGlvbihuYW1lKVxyXG57XHJcbiAgICBpZighdGhpcy5tYXBbbmFtZV0pXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gdGhpcy5tYXBbbmFtZV0uY2hhbm5lbDtcclxufTtcclxuXHJcbkNoYW5uZWxNYXAucHJvdG90eXBlLmdldENoaWxkRGF0YUluZGV4ID0gZnVuY3Rpb24obmFtZSlcclxue1xyXG4gICAgaWYoIXRoaXMubWFwW25hbWVdKVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdGhpcy5tYXBbbmFtZV0uY2hpbGREYXRhSW5kZXg7XHJcbn07XHJcbkNoYW5uZWxNYXAucHJvdG90eXBlLmdldENoaWxkRGF0YUluZGV4Rm9yRmlsdGVyID0gZnVuY3Rpb24oZmlsdGVyKXtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICBmaWx0ZXIgPSBmaWx0ZXIgfHwgdGhpcy5nZXROYW1lcygpO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGZpbHRlci5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuZ2V0Q2hpbGREYXRhSW5kZXgoZmlsdGVyW2ldKTtcclxuICAgICAgICBpZihpZHggPT0gdW5kZWZpbmVkKSBjb250aW51ZTtcclxuICAgICAgICBpZihyZXN1bHQgIT0gdW5kZWZpbmVkICYmIHJlc3VsdCAhPSBpZHgpXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IC0xO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmVzdWx0ID0gaWR4O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUT0RPOiBBZGQgYSBtZXJnZVdpdGhDaGlsZEluZGV4IG1ldGhvZD9cclxuICogQHBhcmFtIHtDaGFubmVsTWFwfSBvdGhlckNoYW5uZWxNYXBcclxuICogQHBhcmFtIHtudW1iZXI/fSBjaGlsZERhdGFJbmRleCBJbmRleCByZWxhdGl2ZSB0byBEYXRhTm9kZS4gVXNlZCB0byBtYXJrIGlmIGNoYW5uZWwgY29tZXNcclxuICogZnJvbSBhIHNwZWNpZmljIGNoaWxkIERhdGFOb2RlLCB1bmRlZmluZWQgaWYgQ2hhbm5lbE1hcCBzaG91bGQgdGFrZSBvdmVyIGNoaWxkIGluZGV4IGZyb20gb3RoZXJDaGFubmVsTWFwXHJcbiAqL1xyXG5DaGFubmVsTWFwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG90aGVyQ2hhbm5lbE1hcCwgY2hpbGREYXRhSW5kZXgpe1xyXG4gICAgZm9yKHZhciBuYW1lIGluIG90aGVyQ2hhbm5lbE1hcC5tYXApe1xyXG4gICAgICAgIC8vIEVpdGhlciB1c2UgcHJvdmlkZWQgY2hpbGQgaW5kZXgsIG90aGVyd2lzZSB1c2UgY2hpbGQgaW5kZXggZnJvbSBDaGFubmVsTWFwIHRvIG1lcmdlXHJcbiAgICAgICAgLy8gRm9yIGlucHV0IGNoYW5uZWwgbWFwIHdlIGRlZmluZSB0aGUgY2hpbGREYXRhSW5kZXggZGlyZWN0bHksIGZvciBhcHBsaWVkIGZpbHRlcnMgd2UgdXNlIHRoZVxyXG4gICAgICAgIC8vIGNoaWxkRGF0YUluZGV4IG9mIHRoZSBwcm92aWRlZCBDaGFubmVsTWFwIChpdCdzIGp1c3QgYSByZW5hbWluZylcclxuICAgICAgICB2YXIgaW5kZXggPSBjaGlsZERhdGFJbmRleCA9PSB1bmRlZmluZWQgPyBvdGhlckNoYW5uZWxNYXAuZ2V0Q2hpbGREYXRhSW5kZXgobmFtZSkgOiBjaGlsZERhdGFJbmRleDtcclxuICAgICAgICB0aGlzLmFkZENoYW5uZWwobmFtZSwgb3RoZXJDaGFubmVsTWFwLmdldENoYW5uZWwobmFtZSksIGluZGV4KTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEFkZCBhIGNoYW5uZWwgd2l0aCBhIGNoaWxkRGF0YUluZGV4XHJcbiAqIFRoZSBjaGlsZERhdGFJbmRleCBkZWZpbmVzIHRoZSBvcmlnaW4gb2YgdGhlIGNoYW5uZWwuXHJcbiAqIElmIGNoaWxkRGF0YUluZGV4IGlzIHVuZGVmaW5lZCB0aGUgdmFsdWUgb2YgdGhlIGNoYW5uZWwgY2FuJ3QgYmUgZGV0ZXJtaW5lZCBmcm9tIG9uZSBzaW5nbGUgRGF0YU5vZGVcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICogQHBhcmFtIHtDaGFubmVsfSBjaGFubmVsXHJcbiAqIEBwYXJhbSB7TnVtYmVyP30gY2hpbGREYXRhSW5kZXhcclxuICovXHJcbkNoYW5uZWxNYXAucHJvdG90eXBlLmFkZENoYW5uZWwgPSBmdW5jdGlvbihuYW1lLCBjaGFubmVsLCBjaGlsZERhdGFJbmRleCl7XHJcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIGlzIGV2ZXIgY2FsbGVkIHdpdGggYSBwcm9wZXIgY2hpbGREYXRhSW5kZXggdmFsdWVcclxuICAgIGlmKCFjaGFubmVsKSByZXR1cm47XHJcbiAgICBpZihjaGlsZERhdGFJbmRleCA9PSB1bmRlZmluZWQpIGNoaWxkRGF0YUluZGV4ID0gLTE7XHJcbiAgICBtZXJnZUNoYW5uZWxJbnRvQ2hhbm5lbCh0aGlzLCBuYW1lLCBjaGFubmVsLCBjaGlsZERhdGFJbmRleCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkIERhdGFTbG90IHRvIHRoZSBDaGFubmVsXHJcbiAqIEBwYXJhbSBuYW1lXHJcbiAqIEBwYXJhbSBkYXRhU2xvdFxyXG4gKi9cclxuQ2hhbm5lbE1hcC5wcm90b3R5cGUuYWRkRGF0YUVudHJ5ID0gZnVuY3Rpb24obmFtZSwgZGF0YVNsb3QpXHJcbntcclxuICAgIG1lcmdlRGF0YVNsb3RJbnRvQ2hhbm5lbCh0aGlzLCBuYW1lLCBkYXRhU2xvdCwgLTEpO1xyXG59O1xyXG4vKipcclxuICogQWRkIGFuIG91dHB1dCBEYXRhU2xvdCB0aGF0IG9yaWdpbmF0ZXMgZnJvbSBhbiBvcGVyYXRvclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gKiBAcGFyYW0ge0RhdGFTbG90fSBkYXRhU2xvdFxyXG4gKiBAcGFyYW0ge1Byb2Nlc3NOb2RlfSBjcmVhdG9yTm9kZVxyXG4gKi9cclxuQ2hhbm5lbE1hcC5wcm90b3R5cGUuYWRkT3V0cHV0RGF0YVNsb3QgPSBmdW5jdGlvbihuYW1lLCBkYXRhU2xvdCwgY3JlYXRvck5vZGUpe1xyXG4gICAgdmFyIGZpbmFsQ2hhbm5lbCA9IG1lcmdlRGF0YVNsb3RJbnRvQ2hhbm5lbCh0aGlzLCBuYW1lLCBkYXRhU2xvdCwgLTEpO1xyXG4gICAgZmluYWxDaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSA9IGNyZWF0b3JOb2RlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtcHR5IHRoZSBjaGFubmVsIG1hcC5cclxuICovXHJcbkNoYW5uZWxNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKXtcclxuICAgIGZvcih2YXIgbmFtZSBpbiB0aGlzLm1hcCl7XHJcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLm1hcFtuYW1lXTtcclxuICAgICAgICBpZihjaGFubmVsICYmIGNoYW5uZWwubWFwID09IHRoaXMpXHJcbiAgICAgICAgICAgIGNoYW5uZWwuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIHRoaXMubWFwID0ge307XHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0Q2hhbm5lbFNsb3QoY2hhbm5lbE1hcCwgbmFtZSl7XHJcbiAgICBpZighY2hhbm5lbE1hcC5tYXBbbmFtZV0pe1xyXG4gICAgICAgIGNoYW5uZWxNYXAubWFwW25hbWVdID0ge1xyXG4gICAgICAgICAgICBjaGFubmVsOiBudWxsLFxyXG4gICAgICAgICAgICBjaGlsZERhdGFJbmRleDogdW5kZWZpbmVkXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZUNoYW5uZWxJbnRvQ2hhbm5lbChjaGFubmVsTWFwLCBuYW1lLCBuZXdDaGFubmVsLCBjaGlsZERhdGFJbmRleCl7XHJcbiAgICBpbml0Q2hhbm5lbFNsb3QoY2hhbm5lbE1hcCwgbmFtZSk7XHJcbiAgICB2YXIgY3VycmVudENoYW5uZWwgPSBjaGFubmVsTWFwLm1hcFtuYW1lXS5jaGFubmVsO1xyXG4gICAgaWYoIWN1cnJlbnRDaGFubmVsIHx8ICFjdXJyZW50Q2hhbm5lbC53aWxsTWVyZ2VXaXRoQ2hhbm5lbChuZXdDaGFubmVsKSkge1xyXG4gICAgICAgIGNoYW5uZWxNYXAubWFwW25hbWVdLmNoYW5uZWwgPSBuZXdDaGFubmVsO1xyXG4gICAgICAgIGNoYW5uZWxNYXAubWFwW25hbWVdLmNoaWxkRGF0YUluZGV4ID0gY2hpbGREYXRhSW5kZXg7XHJcbiAgICAgICAgcmV0dXJuIG5ld0NoYW5uZWw7XHJcbiAgICB9XHJcbiAgICBjdXJyZW50Q2hhbm5lbCA9IGdldE1hcE93bmVkQ2hhbm5lbChjaGFubmVsTWFwLCBjdXJyZW50Q2hhbm5lbCk7XHJcbiAgICBjdXJyZW50Q2hhbm5lbC5hZGRDaGFubmVsRW50cmllcyhuZXdDaGFubmVsKTtcclxuICAgIGNoYW5uZWxNYXAubWFwW25hbWVdLmNoYW5uZWwgPSBjdXJyZW50Q2hhbm5lbDtcclxuICAgIGNoYW5uZWxNYXAubWFwW25hbWVdLmNoaWxkRGF0YUluZGV4ID0gLTE7XHJcbiAgICByZXR1cm4gY3VycmVudENoYW5uZWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlRGF0YVNsb3RJbnRvQ2hhbm5lbChjaGFubmVsTWFwLCBuYW1lLCBkYXRhU2xvdCwgY2hpbGREYXRhSW5kZXgpe1xyXG4gICAgaW5pdENoYW5uZWxTbG90KGNoYW5uZWxNYXAsIG5hbWUpO1xyXG4gICAgdmFyIGN1cnJlbnRDaGFubmVsID0gY2hhbm5lbE1hcC5tYXBbbmFtZV0uY2hhbm5lbDtcclxuICAgIGlmKCFjdXJyZW50Q2hhbm5lbCB8fCAhY3VycmVudENoYW5uZWwud2lsbE1lcmdlV2l0aERhdGFTbG90KGRhdGFTbG90KSl7XHJcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgQ2hhbm5lbChjaGFubmVsTWFwLCBkYXRhU2xvdCk7XHJcbiAgICAgICAgY2hhbm5lbE1hcC5tYXBbbmFtZV0uY2hhbm5lbCA9IGNoYW5uZWw7XHJcbiAgICAgICAgY2hhbm5lbE1hcC5tYXBbbmFtZV0uY2hpbGREYXRhSW5kZXggPSBjaGlsZERhdGFJbmRleDtcclxuICAgICAgICByZXR1cm4gY2hhbm5lbDtcclxuICAgIH1cclxuICAgIGN1cnJlbnRDaGFubmVsID0gZ2V0TWFwT3duZWRDaGFubmVsKGNoYW5uZWxNYXAsIGN1cnJlbnRDaGFubmVsKTtcclxuICAgIGN1cnJlbnRDaGFubmVsLmFkZERhdGFTbG90KGRhdGFTbG90KTtcclxuICAgIGNoYW5uZWxNYXAubWFwW25hbWVdLmNoYW5uZWwgPSBjdXJyZW50Q2hhbm5lbDtcclxuICAgIGNoYW5uZWxNYXAubWFwW25hbWVdLmNoaWxkRGF0YUluZGV4ID0gLTE7XHJcbiAgICByZXR1cm4gY3VycmVudENoYW5uZWw7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBnZXRNYXBPd25lZENoYW5uZWwobWFwLCBjaGFubmVsKXtcclxuICAgIGlmKGNoYW5uZWwubWFwICE9IG1hcCl7XHJcbiAgICAgICAgdmFyIG5ld0NoYW5uZWwgPSBuZXcgQ2hhbm5lbChtYXApO1xyXG4gICAgICAgIG5ld0NoYW5uZWwuYWRkQ2hhbm5lbEVudHJpZXMoY2hhbm5lbCk7XHJcbiAgICAgICAgbmV3Q2hhbm5lbC5jcmVhdG9yUHJvY2Vzc05vZGUgPSBjaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZTtcclxuICAgICAgICByZXR1cm4gbmV3Q2hhbm5lbFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoYW5uZWw7XHJcbn1cclxuXHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gQ2hhbm5lbFxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4vKipcclxuICogQSBjaGFubmVsIG1heSBpbmNsdWUgc2V2ZXJhbCBEYXRhU2xvdHMvRGF0YUVudHJpZXNcclxuICogQSBkZWNsYXJlZCBTZXF1ZW5jZSB3aWxsIHJlc3VsdCBpbiBvbiBjaGFubmVsIHdpdGggbXVsdGlwbGUgRGF0YUVudHJpZXMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0NoYW5uZWxNYXB9IG1hcCBPd25lciBvZiB0aGUgY2hhbm5lbFxyXG4gKiBAcGFyYW0ge0RhdGFTbG90PX0gZGF0YVNsb3QgT3B0aW9uYWwgRGF0YVNsb3QgYWRkZWQgdG8gdGhlIGNoYW5uZWxcclxuICovXHJcbnZhciBDaGFubmVsID0gZnVuY3Rpb24obWFwLCBkYXRhU2xvdCl7XHJcbiAgICAvKipcclxuICAgICAqIERhdGFTbG90IGVudHJpZXMgc29ydGVkIGJ5IGtleSB2YWx1ZVxyXG4gICAgICogQHR5cGUge0FycmF5LjxEYXRhU2xvdD59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZW50cmllcyA9IFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBPd25lciBDaGFubmVsTWFwIHRoYXQgY3JlYXRlZCB3aXRoIGNoYW5uZWwuXHJcbiAgICAgKiBOb3RlOiBhIGNoYW5uZWwgY2FuIHN0aWxsIGV4aXN0IGluIHNldmVyYWwgQ2hhbm5lbE1hcHNcclxuICAgICAqIEB0eXBlIHtDaGFubmVsTWFwfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1hcCA9IG1hcDtcclxuICAgIC8qKlxyXG4gICAgICogVW5pcXVlIElEIGZvciB0aGlzIGNoYW5uZWwuIElzIHVzZWQgZm9yIHNldmVyYWwgb3B0aW1pemF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5pZCA9IGdlbmVyYXRlQ2hhbm5lbElkKCk7XHJcbiAgICAvKipcclxuICAgICAqIExpc3RlbmVycyBvZiB0aGlzIGNoYW5uZWxzICh1c3VhbGx5IFByb2Nlc3NOb2RlcyBhbmQgUmVxdWVzdE5vZGVzKVxyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgUHJvY2Vzc05vZGUgdGhhdCBjcmVhdGVkL2V4dGVuZGVkIHRoZSBjb250ZW50IG9mIHRoaXMgY2hhbm5lbFxyXG4gICAgICogVGhlcmUgY2FuIGJlIG9ubHkgb25lIGNyZWF0b3JQcm9jZXNzTm9kZSBwZXIgY2hhbm5lbCBiZWNhdXNlXHJcbiAgICAgKiB0aGVuIG91cHV0IERhdGFTbG90cyBvZiBhbiBvcGVyYXRvciB3aWxsIGFsd2F5cyBoYXZlIGtleSBcIjBcIlxyXG4gICAgICogSWYgdHdvIG9wZXJhdG9ycyBpbmZsdWVuY2UgdGhlIHNhbWUgc2VxdWVuY2UsIHRoZSBzZWNvbmQgb3BlcmF0b3InXHJcbiAgICAgKiBvdXRwdXQgd2lsbCByZXBsYWNlIHRoZSBmaXJzdCBvcGVyYXRvcidzIG91dHB1dCwgZWZmZWN0aXZlbHkgcmVtb3ZpbmcgdGhlIGRlcGVuZGVuY3kuXHJcbiAgICAgKiBAdHlwZSB7bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jcmVhdG9yUHJvY2Vzc05vZGUgPSBudWxsO1xyXG5cclxuICAgIGlmKGRhdGFTbG90KXtcclxuICAgICAgICB0aGlzLmFkZERhdGFTbG90KGRhdGFTbG90KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgYSBkYXRhU2xvdCB0byB0aGUgY2hhbm5lbCwgYWRkaW5nIGRlcGVuZGVuY2llcy5cclxuICogTm8gbm90aWZpY2F0aW9ucyBzZW5kIGV0Yy5cclxuICogTWFrZXMgc3VyZSB0aGF0IHJlc3VsdGluZyBjaGFubmVsIGhhcyBkYXRhU2xvdHMgb3JkZXJlZCBieSBrZXlcclxuICogQHBhcmFtIGRhdGFTbG90XHJcbiAqL1xyXG5DaGFubmVsLnByb3RvdHlwZS5hZGREYXRhU2xvdCA9IGZ1bmN0aW9uKGRhdGFTbG90KXtcclxuICAgIGRhdGFTbG90LmFkZENoYW5uZWwodGhpcyk7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5lbnRyaWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmVudHJpZXNbaV07XHJcbiAgICAgICAgLy8gV2UgdXNlIGVwc2lsb24gaGVyZSB0byBkZXRlY3QgZGF0YSBlbnRyaWVzIHdpdGggXCJlcXVhbFwiIGtleVxyXG4gICAgICAgIGlmKGVudHJ5LmtleSA+PSBkYXRhU2xvdC5rZXkgLSBDLkVQU0lMT04gKXtcclxuICAgICAgICAgICAgaWYoTWF0aC5hYnMoZW50cnkua2V5IC0gZGF0YVNsb3Qua2V5KSA8PSBDLkVQU0lMT04pe1xyXG4gICAgICAgICAgICAgICAgZW50cnkucmVtb3ZlQ2hhbm5lbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW50cmllcy5zcGxpY2UoaSwgMSwgZGF0YVNsb3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVudHJpZXMuc3BsaWNlKGksIDAsIGRhdGFTbG90KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmVudHJpZXMucHVzaChkYXRhU2xvdCk7XHJcbn07XHJcblxyXG5DaGFubmVsLnByb3RvdHlwZS5nZXRTZXF1ZW5jZUxlbmd0aCA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzLmxlbmd0aDtcclxufTtcclxuQ2hhbm5lbC5wcm90b3R5cGUuZ2V0U2VxdWVuY2VNaW5LZXkgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuZW50cmllc1swXS5rZXk7XHJcbn07XHJcbkNoYW5uZWwucHJvdG90eXBlLmdldFNlcXVlbmNlTWF4S2V5ID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLmVudHJpZXNbdGhpcy5lbnRyaWVzLmxlbmd0aCAtIDFdLmtleTtcclxufTtcclxuLyoqXHJcbiAqIFRoZSBEYXRhVHlwZSBvZiB0aGUgY2hhbm5lbC5cclxuICogU2luY2UgYWxsIERhdGFFbnRyaWVzIHdpdGhpbiBhIGNoYW5uZWwgaGF2ZSB0aGUgc2FtZSB0eXBlLCB3ZSBjYW4gc2ltcGx5IHJldHVybiB0aGUgdHlwZSBvZiB0aGUgZmlyc3QgZW50cnkuXHJcbiAqIEByZXR1cm5zIHtEQVRBX1RZUEV9XHJcbiAqL1xyXG5DaGFubmVsLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24oKXtcclxuICAgIGlmKHRoaXMuZW50cmllcy5sZW5ndGggPT0gMClcclxuICAgICAgICByZXR1cm4gQy5EQVRBX1RZUEUuVU5LTk9XTjtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzWzBdLmRhdGFFbnRyeS5fdHlwZTtcclxufTtcclxuLyoqXHJcbiAqIE1lcmdlIGFub3RoZXIgY2hhbm5lbCBpbnRvIHRoaXMgY2hhbm5lbC5cclxuICovXHJcbkNoYW5uZWwucHJvdG90eXBlLmFkZENoYW5uZWxFbnRyaWVzID0gZnVuY3Rpb24ob3RoZXJDaGFubmVsKXtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvdGhlckNoYW5uZWwuZW50cmllcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIHNsb3QgPSBvdGhlckNoYW5uZWwuZW50cmllc1tpXTtcclxuICAgICAgICB0aGlzLmFkZERhdGFTbG90KHNsb3QpO1xyXG4gICAgfVxyXG4gICAgLy8gRklYTUU6IG90aGVyQ2hhbm5lbCBtaWdodCBiZSB3aXRob3V0IGNyZWF0b3JQcm9jZXNzTm9kZSBidXQgc3RpbGwgZGVmaW5lIGEgRGF0YVNsb3Qgd2l0aCBrZXkgMFxyXG4gICAgLy8gSW4gdGhpcyBjYXNlIHdlIGhhdmUgdG8gc2V0IGNyZWF0b3JQcm9jZXNzTm9kZSB0byBudWxsXHJcbiAgICBpZihvdGhlckNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlKVxyXG4gICAgICAgIHRoaXMuY3JlYXRvclByb2Nlc3NOb2RlID0gb3RoZXJDaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZTtcclxuICAgIC8vZWxzZVxyXG4gICAgLy8gICAgdGhpcy5jcmVhdG9yUHJvY2Vzc05vZGUgPSBudWxsO1xyXG59O1xyXG4vKipcclxuICogUmV0dXJuIGEgRGF0YUVudHJ5IGZyb20gdGhpcyBjaGFubmVsIGRlcGVuZGluZyBvbiBzZXF1ZW5jZUtleS5cclxuICogQHBhcmFtIHtDLlNFUVVFTkNFP30gc2VxdWVuY2VBY2Nlc3NUeXBlXHJcbiAqIEBwYXJhbSB7bnVtYmVyP30gc2VxdWVuY2VLZXlcclxuICogQHJldHVybnMge0RhdGFFbnRyeX1cclxuICovXHJcbkNoYW5uZWwucHJvdG90eXBlLmdldERhdGFFbnRyeSA9IGZ1bmN0aW9uKHNlcXVlbmNlQWNjZXNzVHlwZSwgc2VxdWVuY2VLZXkpe1xyXG4gICAgaWYodGhpcy5lbnRyaWVzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgaWYoIXNlcXVlbmNlQWNjZXNzVHlwZSl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc1swXS5kYXRhRW50cnk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHZhciBpID0gMCwgbWF4ID0gdGhpcy5lbnRyaWVzLmxlbmd0aDtcclxuICAgIC8vIFRPRE86IERvIGJpbmFyeSBzZWFyY2ggaGVyZT9cclxuICAgIHdoaWxlKGkgPCBtYXggJiYgdGhpcy5lbnRyaWVzW2ldLmtleSA8IHNlcXVlbmNlS2V5KSArK2k7XHJcbiAgICBpZihzZXF1ZW5jZUFjY2Vzc1R5cGUgPT0gQy5TRVFVRU5DRS5QUkVWX0JVRkZFUil7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc1tpID8gaSAtMSA6IDBdLmRhdGFFbnRyeTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYoc2VxdWVuY2VBY2Nlc3NUeXBlID09IEMuU0VRVUVOQ0UuTkVYVF9CVUZGRVIpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXNbaSA8IG1heCA/IGkgOiBtYXggLSAxXS5kYXRhRW50cnk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKHNlcXVlbmNlQWNjZXNzVHlwZSA9PSBDLlNFUVVFTkNFLkxJTkVBUl9XRUlHSFQpe1xyXG4gICAgICAgIHZhciB3ZWlnaHQxID0gdGhpcy5lbnRyaWVzW2kgPyBpIC0gMSA6IDBdLmtleTtcclxuICAgICAgICB2YXIgd2VpZ2h0MiA9IHRoaXMuZW50cmllc1tpIDwgbWF4ID8gaSA6IG1heCAtIDFdLmtleTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xyXG4gICAgICAgIHZhbHVlWzBdID0gd2VpZ2h0MiA9PSB3ZWlnaHQxID8gMCA6IChzZXF1ZW5jZUtleSAtIHdlaWdodDEpIC8gKHdlaWdodDIgLSB3ZWlnaHQxKTtcclxuICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiByZXBlYXRlZCBCdWZmZXJFbnRyeSBhbmQgRmxvYXQzMkFycmF5IGFsbG9jYXRpb24gaXMgYSBzZXJpb3VzIGJvdHRsZW5lY2tcclxuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlckVudHJ5KEMuREFUQV9UWVBFLkZMT0FULCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gdHJ1ZSBvZiB0aGUgdHdvIGNoYW5uZWxzIG5lZWQgdG8gYmUgbWVyZ2VkIChpbnN0ZWFkIG9mIHJlcGxhY2luZyB0aGlzIGNoYW5uZWwgd2l0aCBvdGhlckNoYW5uZWwpXHJcbiAqIEBwYXJhbSBvdGhlckNoYW5uZWxcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5DaGFubmVsLnByb3RvdHlwZS53aWxsTWVyZ2VXaXRoQ2hhbm5lbCA9IGZ1bmN0aW9uKG90aGVyQ2hhbm5lbCl7XHJcbiAgICBpZih0aGlzLmVudHJpZXMubGVuZ3RoICE9IG90aGVyQ2hhbm5lbC5lbnRyaWVzLmxlbmd0aCkgcmV0dXJuIHRydWU7XHJcbiAgICBpZih0aGlzLmdldFR5cGUoKSAhPSBvdGhlckNoYW5uZWwuZ2V0VHlwZSgpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIGlmKE1hdGguYWJzKHRoaXMuZW50cmllc1tpXS5rZXkgLSBvdGhlckNoYW5uZWwuZW50cmllc1tpXS5rZXkpID4gQy5FUFNJTE9OKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuLyoqXHJcbiAqIFJldHVybiB0cnVlIGlmIHdlIG5lZWQgdG8gbWVyZ2UgdGhlIGNoYW5uZWwgd2l0aCB0aGlzIGRhdGFTbG90XHJcbiAqIChpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IGNoYW5uZWwgZnJvbXRoaXMgZGF0YVNsb3QpXHJcbiAqIEBwYXJhbSBkYXRhU2xvdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkNoYW5uZWwucHJvdG90eXBlLndpbGxNZXJnZVdpdGhEYXRhU2xvdCA9IGZ1bmN0aW9uKGRhdGFTbG90KXtcclxuICAgIGlmKHRoaXMuZW50cmllcy5sZW5ndGggPiAxKSByZXR1cm4gdHJ1ZTtcclxuICAgIGlmKHRoaXMuZ2V0VHlwZSgpICE9IGRhdGFTbG90LmRhdGFFbnRyeS5fdHlwZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIChNYXRoLmFicyh0aGlzLmVudHJpZXNbMF0ua2V5IC0gZGF0YVNsb3Qua2V5KSA+IEMuRVBTSUxPTik7XHJcbn07XHJcblxyXG5DaGFubmVsLnByb3RvdHlwZS5ub3RpZnlPbkNoYW5nZSA9IGZ1bmN0aW9uKHN0YXRlKXtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3RlbmVycy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbaV0ub25YZmxvd0NoYW5uZWxDaGFuZ2UodGhpcywgc3RhdGUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQ2hhbm5lbC5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihwcm9jZXNzTm9kZSl7XHJcbiAgICB0aGlzLmxpc3RlbmVycy5wdXNoKHByb2Nlc3NOb2RlKTtcclxufTtcclxuQ2hhbm5lbC5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihwcm9jZXNzTm9kZSl7XHJcbiAgICB2YXIgaWR4ID0gdGhpcy5saXN0ZW5lcnMuaW5kZXhPZihwcm9jZXNzTm9kZSk7XHJcbiAgICBpZihpZHggIT0gLTEpIHRoaXMubGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xyXG59O1xyXG5cclxuQ2hhbm5lbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdGhpcy5lbnRyaWVzW2ldLnJlbW92ZUNoYW5uZWwodGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgY19jaGFubmVsS2V5SWR4ID0gMDtcclxuZnVuY3Rpb24gZ2VuZXJhdGVDaGFubmVsSWQoKXtcclxuICAgIHJldHVybiArK2NfY2hhbm5lbEtleUlkeDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBDaGFubmVsOiBDaGFubmVsLFxyXG4gICAgQ2hhbm5lbE1hcDogQ2hhbm5lbE1hcFxyXG59O1xyXG4iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlLmpzXCIpO1xyXG52YXIgQyA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIEEgRGF0YVNsb3Qgd3JhcHMgYSBkYXRhRW50cnkgYW5kIGFkZHMgYSBrZXkgdmFsdWUgZm9yIHNlcXVlbmNlcy5cclxuICogVGhpcyBzdHJ1Y3R1cmUgaXMgdXNlZCBpbnRlcm5hbGx5IHdpdGhpbiBjaGFubmVscyBhbmQgcHJvY2VzcyBub2Rlc1xyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtEYXRhRW50cnl9IGRhdGFFbnRyeVxyXG4gKiBAcGFyYW0ge251bWJlcj19IGtleVxyXG4gKi9cclxudmFyIERhdGFTbG90ID0gZnVuY3Rpb24oZGF0YUVudHJ5LCBrZXkpe1xyXG4gICAgdGhpcy5rZXkgPSBrZXkgfHwgMDsgICAgICAgICAgICAvLyBzZXF1ZW5jZSBrZXlcclxuICAgIHRoaXMuZGF0YUVudHJ5ID0gZGF0YUVudHJ5OyAgICAgLy8gZGF0YUVudHJ5IG9mIHRoZSBzbG90XHJcbiAgICAvKipcclxuICAgICAqIGFsdGVybmF0aXZlIGRhdGFFbnRyeSBmb3IgYXN5bmNocm9ub3VzIHByb2Nlc3NpbmdcclxuICAgICAqIG9ubHkgdXNlZCBmb3Igb3V0cHV0IERhdGFTbG90cyBvZiBhc3luY2hyb25vdXMgb3BlcmF0b3JzXHJcbiAgICAgKiBAdHlwZSB7RGF0YUVudHJ5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmFzeW5jRGF0YUVudHJ5ID0gbnVsbDtcclxuICAgIC8qKlxyXG4gICAgICogbGlzdCBvZiBhbGwgY2hhbm5lbHMgdGhhdCBjb250YWluIHRoaXMgRGF0YVNsb3RcclxuICAgICAqIEB0eXBlIHtBcnJheS48Q2hhbm5lbD59XHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFyZW50Q2hhbm5lbHMgPSBbXTtcclxuXHJcbn07XHJcbkRhdGFTbG90LnByb3RvdHlwZS5hZGRDaGFubmVsID0gZnVuY3Rpb24oY2hhbm5lbCl7XHJcbiAgICB0aGlzLnBhcmVudENoYW5uZWxzLnB1c2goY2hhbm5lbCk7XHJcbn07XHJcbkRhdGFTbG90LnByb3RvdHlwZS5yZW1vdmVDaGFubmVsID0gZnVuY3Rpb24oY2hhbm5lbCl7XHJcbiAgICB2YXIgaWR4ID0gdGhpcy5wYXJlbnRDaGFubmVscy5pbmRleE9mKGNoYW5uZWwpO1xyXG4gICAgaWYoaWR4ICE9IC0xKSB0aGlzLnBhcmVudENoYW5uZWxzLnNwbGljZShpZHgsIDEpO1xyXG59O1xyXG5EYXRhU2xvdC5wcm90b3R5cGUuc3dhcEFzeW5jID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciB0bXAgPSB0aGlzLmRhdGFFbnRyeTtcclxuICAgIHRoaXMuZGF0YUVudHJ5ID0gdGhpcy5hc3luY0RhdGFFbnRyeTtcclxuICAgIHRoaXMuYXN5bmNEYXRhRW50cnkgPSB0bXA7XHJcbn07XHJcblxyXG5EYXRhU2xvdC5wcm90b3R5cGUuc2V0RGF0YUVudHJ5ID0gZnVuY3Rpb24oZGF0YUVudHJ5LCBjaGFuZ2VUeXBlKXtcclxuICAgIHRoaXMuZGF0YUVudHJ5ID0gZGF0YUVudHJ5O1xyXG4gICAgdmFyIHN0YXRlID0gY2hhbmdlVHlwZSA9PSBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX0RBVEFfVkFMVUUgPyBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9WQUxVRSA6XHJcbiAgICAgICAgQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfU0laRTtcclxuICAgIHRoaXMubm90aWZ5T25DaGFuZ2Uoc3RhdGUpO1xyXG59O1xyXG5cclxuRGF0YVNsb3QucHJvdG90eXBlLm5vdGlmeU9uQ2hhbmdlID0gZnVuY3Rpb24oc3RhdGUpe1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMucGFyZW50Q2hhbm5lbHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHRoaXMucGFyZW50Q2hhbm5lbHNbaV0ubm90aWZ5T25DaGFuZ2Uoc3RhdGUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU2xvdDtcclxuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcclxudmFyIEMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIE9wZXJhdG9yTGlzdCA9IHJlcXVpcmUoXCIuLi9vcGVyYXRvci9vcGVyYXRvci1saXN0LmpzXCIpO1xyXG52YXIgVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvdXRpbHMuanNcIik7XHJcbnZhciBPcGVyYXRvciA9IHJlcXVpcmUoXCIuLi9vcGVyYXRvci9vcGVyYXRvci5qc1wiKTtcclxudmFyIE9wZXJhdG9yRW50cnkgPSByZXF1aXJlKFwiLi4vb3BlcmF0b3Ivb3BlcmF0b3ItZW50cnkuanNcIik7XHJcbnZhciBQcm9ncmFtID0gcmVxdWlyZShcIi4uL29wZXJhdG9yL3Byb2dyYW0uanNcIik7XHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gRXhlY3V0b3JcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vKipcclxuICogVHJpZXMgdG8gY29tYmluZSBtdWx0aXBsZSBQcm9jZXNzTm9kZXMgaW50byBhIFByb2dyYW0uIEN1cnJlbnRseSBvbmx5IHVzZWQgZm9yIHZlcnRleCBzaGFkZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlcXVlc3ROb2RlfFByb2Nlc3NOb2RlfSBvd25lck5vZGVcclxuICogQHBhcmFtIHtDLlBMQVRGT1JNfSBwbGF0Zm9ybVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBFeGVjdXRvciA9IGZ1bmN0aW9uKG93bmVyTm9kZSwgcGxhdGZvcm0pe1xyXG4gICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9kZXMgdGhhdCBhcmUgbWVyZ2VkIGJ5IHRoaXMgZXhlY3V0b3JcclxuICAgICAqIEB0eXBlIHtBcnJheS48UHJvY2Vzc05vZGV8UmVxdWVzdE5vZGU+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1lcmdlZE5vZGVzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzZXQgb2YgdGhpcy5tZXJnZWROb2RlcyB0aGF0IGRpcmVjdGx5IHByb3ZpZGUgcmVzdWx0cyBvZiB0aGUgZXhlY3V0b3JcclxuICAgICAqIEB0eXBlIHtBcnJheS48UHJvY2Vzc05vZGU+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1lcmdlZE91dHB1dE5vZGVzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzTm9kZXMgdG8gYmUgZXhlY3V0ZWQgYmVmb3JlIHRoaXMgZXhlY3V0b3IgY2FuIGJlXHJcbiAgICAgKiBleGVjdXRlZFxyXG4gICAgICogQHR5cGUge0FycmF5LjxQcm9jZXNzTm9kZT59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3ViTm9kZXMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRPRE86IFVudXNlZC4gUmVtb3ZlP1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnVucHJvY2Vzc2VkRGF0YU5hbWVzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgVE9ETzogTWF5YmUgd2Ugc2hvdWxkIGp1c3Qgc3RvcmUgdGhlIGNsLXBsYXRmb3JtIG9iamVjdHMgaW4gZ2xvYmFsIG9iamVjdCBzbyB0aGV5IGFyZSBtb3JlIGVhc2lseSBhdmFpbGFibGUgYW5kXHJcbiAgICAgKiAgdG8gYXZvaWQgbG9uZyBwcm90b3R5cGUgY2hhaW5zLiBPciB3ZSBjb3VsZCBwYXNzIHRoZSBncmFwaCBjb250ZXh0IHRvIGVhY2ggbm9kZSBvZiB0aGUgZ3JhcGguXHJcbiAgICAgKiAgSG93ZXZlciwgaXQgd291bGQgYmUgZ29vZCB0byBhbGxvdyBlYWNoIEdyYXBoIG9iamVjdCB0byBoYXZlIGF0IGxlYXN0IG93biBjb250ZXh0LCBjbWRRdWV1ZSBhbmQga2VybmVsTWFuYWdlci5cclxuICAgICAqICBlLmcuIHBhc3NpbmcgZ3JhcGggaW5mb3JtYXRpb24gaGVyZSByZXF1aXJlcyBhIGxvbmcgcHJvdG90eXBlIGNoYWluXHJcbiAgICAgKi9cclxuICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gIG5ldyBPcGVyYXRvckxpc3QocGxhdGZvcm0pO1xyXG4gICAgdGhpcy5wcm9ncmFtRGF0YSA9ICBuZXcgUHJvZ3JhbS5Qcm9ncmFtRGF0YSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtQcm9ncmFtfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdEV4ZWN1dG9yKHRoaXMsIG93bmVyTm9kZSk7XHJcbn07XHJcblxyXG4gICAgRXhlY3V0b3IucHJvdG90eXBlLmlzUHJvY2Vzc2VkID0gZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgaSA9IHRoaXMubWVyZ2VkT3V0cHV0Tm9kZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubWVyZ2VkT3V0cHV0Tm9kZXNbaV0uc3RhdHVzICE9IEMuUFJPQ0VTU19TVEFURS5QUk9DRVNTRUQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgRXhlY3V0b3IucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKGFzeW5jQ2FsbGJhY2spe1xyXG4gICAgICAgIHJ1blN1Yk5vZGVzKHRoaXMpO1xyXG4gICAgICAgIHVwZGF0ZUl0ZXJhdGVTdGF0ZSh0aGlzKTsgLy8gVE9ETyBjaGVjayBpZiBpdGVyYXRlIFN0YXRlIGhhcyBjaGFuZ2VzIGluIGFueSB3YXkgYW5kIG9ubHkgcmVmZXRjaCBwcm9ncmFtIGluIHRoYXQgY2FzZVxyXG5cclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBQcm9ncmFtLmNyZWF0ZVByb2dyYW0odGhpcy5vcGVyYXRvckxpc3QpO1xyXG5cclxuICAgICAgICBpZih0aGlzLnByb2dyYW0pe1xyXG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yTGlzdC5hbGxvY2F0ZU91dHB1dCh0aGlzLnByb2dyYW1EYXRhLCAhIWFzeW5jQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICB0aGlzLnByb2dyYW0ucnVuKHRoaXMucHJvZ3JhbURhdGEsIGFzeW5jQ2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLnBsYXRmb3JtICE9IEMuUExBVEZPUk0uQVNZTkMpe1xyXG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMubWVyZ2VkT3V0cHV0Tm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tZXJnZWRPdXRwdXROb2Rlc1tpXS5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuUFJPQ0VTU0VEO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEV4ZWN1dG9yLnByb3RvdHlwZS5nZXRWZXJ0ZXhTaGFkZXIgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJ1blN1Yk5vZGVzKHRoaXMpO1xyXG4gICAgICAgIHVwZGF0ZUl0ZXJhdGVTdGF0ZSh0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gUHJvZ3JhbS5jcmVhdGVQcm9ncmFtKHRoaXMub3BlcmF0b3JMaXN0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbTtcclxuICAgIH07XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0IEV4ZWN1dG9yXHJcbiAqIEBwYXJhbSBleGVjdXRlclxyXG4gKiBAcGFyYW0gb3duZXJOb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25zdHJ1Y3RFeGVjdXRvcihleGVjdXRlciwgb3duZXJOb2RlKXtcclxuICAgIHZhciBjRGF0YSA9IHtcclxuICAgICAgICBibG9ja2VkTm9kZXM6IFtdLCAgIC8vIEJhZCBOb2RlcyB0aGF0IGNhbm5vdCBiZSBtZXJnZS4gRmlsbGVkIGR1cmluZyBwcmUgc2NhblxyXG4gICAgICAgIGRvbmVOb2RlczogW10sICAgICAgLy8gTm9kZXMgdGhhdCBoYXZlIGJlZW4gc2lnbmVkIHVwIGZvciBtZXJnaW5nLiBUT0RPOiBSZWR1bmRhbnQgd2l0aCBjb25zdHJ1Y3Rpb25PcmRlciBhbmQgc3ViTm9kZXM/IC0gbWF5YmUgeWVzIVxyXG4gICAgICAgIGNvbnN0cnVjdGlvbk9yZGVyOiBbXSwgLy8gU3RvcmUgbm9kZXMgaW4gb3JkZXIgb2YgY29uc3RydWN0aW9uIG9mIE9wZXJhdG9yRW50cmllcy5cclxuICAgICAgICBpbnB1dFNsb3RzOiB7fSwgICAgIC8vIENvbGxlY3RlZCBpbnB1dCBjaGFubmVscyBvZiBhbGwgbWVyZ2VkIG5vZGVzLiBVc2VkIHRvIGF2b2lkIGFzc2lnbmluZyBzYW1lIGlucHV0IGJ1ZmZlciB0d2ljZVxyXG4gICAgICAgIGZpbmFsT3V0cHV0OiBudWxsLCAgLy8gZmluYWxPdXRwdXQgY2hhbm5lcyBpbiBjYXNlIHdlIGhhdmUgYSBSZXF1ZXN0Tm9kZVxyXG4gICAgICAgIGZpcnN0T3BlcmF0b3I6IG51bGwgLy8gU2V0IHRvIGZpcnN0IG9wZXJhdG9yIHRoYXQgaGFzIGJlZW4gbWVyZ2VkICh3aWxsIGJlIGV4ZWN1dGVkIGxhc3QpXHJcbiAgICB9O1xyXG4gICAgdmFyIHJlcXVlc3ROb2RlID0gaW5pdFJlcXVlc3ROb2RlKGNEYXRhLCBleGVjdXRlciwgb3duZXJOb2RlKTtcclxuXHJcbiAgICB2YXIgbm9PcGVyYXRvcnMgPSBmYWxzZTsgLy8gVE9ETzogUmVtb3ZlIHRoaXM/XHJcbiAgICBjb25zdHJ1Y3RQcmVTY2FuKGNEYXRhLCBvd25lck5vZGUsIGV4ZWN1dGVyLnBsYXRmb3JtLCBub09wZXJhdG9ycyk7XHJcblxyXG4gICAgc2V0Q29uc3RydWN0aW9uT3JkZXJBbmRTdWJOb2RlcyhjRGF0YSwgZXhlY3V0ZXIsIG93bmVyTm9kZSk7XHJcblxyXG4gICAgY29uc3RydWN0RnJvbURhdGEoZXhlY3V0ZXIsIGNEYXRhKTtcclxufVxyXG4vKipcclxuICogT25seSByZWxldmFudCBpZiBvd25lck5vZGVzIGlzIGEgUmVxdWVzdE5vZGVcclxuICogU2V0cyBmaW5hbE91dHB1dCBvZiBjb25zdHJ1Y3Rpb24gZGF0YSBhbmQgdW5wcm9jZXNzZWREYXRhTmFtZXNcclxuICogQHBhcmFtIGNEYXRhXHJcbiAqIEBwYXJhbSBleGVjdXRlclxyXG4gKiBAcGFyYW0gb3duZXJOb2RlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaW5pdFJlcXVlc3ROb2RlKGNEYXRhLCBleGVjdXRlciwgb3duZXJOb2RlKXtcclxuICAgIGlmKHRydWUpIHsgLy8gRklYTUU6IG93bmVyTm9kZSBpbnN0YW5jZW9mIFJlcXVlc3ROb2RlKXtcclxuICAgICAgICBjRGF0YS5maW5hbE91dHB1dCA9IHt9O1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBvd25lck5vZGUuZmlsdGVyIHx8IG93bmVyTm9kZS5vd25lci5vdXRwdXRDaGFubmVscy5nZXROYW1lcygpO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBmaWx0ZXIubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IGZpbHRlcltpXTtcclxuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSBvd25lck5vZGUub3duZXIub3V0cHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChuYW1lKTtcclxuICAgICAgICAgICAgaWYoY2hhbm5lbCAmJiBjaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSlcclxuICAgICAgICAgICAgICAgIGNEYXRhLmZpbmFsT3V0cHV0W25hbWVdID0gY2hhbm5lbC5nZXREYXRhRW50cnkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgVXRpbHMubmFtZXNldC5hZGQoZXhlY3V0ZXIudW5wcm9jZXNzZWREYXRhTmFtZXMsIGZpbHRlcik7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIEdvZXMgdG8gcHJvY2Vzc2luZyBzdWJ0cmVlIGF0IGZpbGxlZCBibG9ja2VkTm9kZXMgYXJyYXkgaW4gY29uc3RydWN0aW9uIGRhdGEuXHJcbiAqIEFsbCBub2RlcyB0aGF0IGNhbm5vdCBiZSBtZXJnZWQgb3IgaGF2ZSBwYXJlbnRzIHRoYXQgY2FuJ3QgYmUgbWVyZ2VkIHdpbGwgYmUgYmxvY2tlZFxyXG4gKiBAcGFyYW0gY0RhdGFcclxuICogQHBhcmFtIG5vZGVcclxuICogQHBhcmFtIHBsYXRmb3JtXHJcbiAqIEBwYXJhbSBub09wZXJhdG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gY29uc3RydWN0UHJlU2NhbihjRGF0YSwgbm9kZSwgcGxhdGZvcm0sIG5vT3BlcmF0b3JzKXtcclxuICAgIGlmKGNEYXRhLmJsb2NrZWROb2Rlcy5pbmRleE9mKG5vZGUpICE9IC0xKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICBpZihub2RlLm9wZXJhdG9yKXtcclxuICAgICAgICBpZihub09wZXJhdG9ycyB8fCAhY2FuT3BlcmF0b3JNZXJnZShjRGF0YSwgbm9kZS5vcGVyYXRvciwgcGxhdGZvcm0pKXtcclxuICAgICAgICAgICAgYmxvY2tTdWJ0cmVlKGNEYXRhLCBub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBpZighY0RhdGEuZmlyc3RPcGVyYXRvcikgY0RhdGEuZmlyc3RPcGVyYXRvciA9IG5vZGUub3BlcmF0b3I7XHJcbiAgICAgICAgICAgIHZhciBtYXBwaW5nID0gbm9kZS5vcGVyYXRvci5tYXBwaW5nO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWFwcGluZy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICBpZihtYXBwaW5nW2ldLnNlcXVlbmNlKXtcclxuICAgICAgICAgICAgICAgICAgICBibG9ja0lucHV0KGNEYXRhLCBub2RlLCBtYXBwaW5nW2ldLnNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tJbnB1dChjRGF0YSwgbm9kZSwgbWFwcGluZ1tpXS5rZXlTb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihtYXBwaW5nW2ldLmFycmF5KXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW5hbWUgLmFycmF5IHRvIC5yYW5kb21BY2Nlc3NcclxuICAgICAgICAgICAgICAgICAgICBibG9ja0lucHV0KGNEYXRhLCBub2RlLCBtYXBwaW5nW2ldLnNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgY29uc3RydWN0UHJlU2NhbihjRGF0YSwgbm9kZS5jaGlsZHJlbltpXSwgcGxhdGZvcm0sIG5vT3BlcmF0b3JzKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2FuT3BlcmF0b3JNZXJnZShjRGF0YSwgb3BlcmF0b3IsIHBsYXRmb3JtKXtcclxuICAgIC8vIFRPRE86IERldGVjdCBtZXJnZSBzdXBwb3J0XHJcbiAgICByZXR1cm4gKHBsYXRmb3JtID09IEMuUExBVEZPUk0uQVNZTkMgfHwgIU9wZXJhdG9yLmlzT3BlcmF0b3JBc3luYyhvcGVyYXRvcikpICYmXHJcbiAgICAgICAgKCFjRGF0YS5maXJzdE9wZXJhdG9yIHx8XHJcbiAgICAgICAgKHBsYXRmb3JtID09IEMuUExBVEZPUk0uR0xTTCAmJiBjRGF0YS5maXJzdE9wZXJhdG9yLmV2YWx1YXRlX2dsc2wgJiYgb3BlcmF0b3IuZXZhbHVhdGVfZ2xzbCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBibG9ja1N1YnRyZWUoY0RhdGEsIG5vZGUpe1xyXG4gICAgaWYoY0RhdGEuYmxvY2tlZE5vZGVzLmluZGV4T2Yobm9kZSkgIT0gLTEpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGNEYXRhLmJsb2NrZWROb2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIGJsb2NrU3VidHJlZShjRGF0YSwgbm9kZS5jaGlsZHJlbltpXSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEJsb2NrIGFsbCBwcm9jZXNzTm9kZXMgYXNzaWduZWQgdG8gYW4gaW5wdXQgY2hhbm5lbFxyXG4gKiBAcGFyYW0gY0RhdGFcclxuICogQHBhcmFtIG5vZGVcclxuICogQHBhcmFtIGlucHV0TmFtZVxyXG4gKi9cclxuICAgIGZ1bmN0aW9uIGJsb2NrSW5wdXQoY0RhdGEsIG5vZGUsIGlucHV0TmFtZSl7XHJcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBub2RlLmlucHV0Q2hhbm5lbHNbaW5wdXROYW1lXTtcclxuICAgICAgICBpZihjaGFubmVsICYmIGNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlKXtcclxuICAgICAgICAgICAgYmxvY2tTdWJ0cmVlKGNEYXRhLCBjaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4vKipcclxuICogRmlsbCBkb25lTm9kZXMgYW5kIGNvbnN0cnVjdGlvbk9yZGVyIGFycmF5cyBvZiBjb25zdHJ1Y3Rpb24gZGF0YS5cclxuICogSXQgYWxzbyBmaWxscyB0aGUgc3ViTm9kZXMgYXJyYXkgb2YgdGhlIGV4ZWN1dGVyXHJcbiAqIEBwYXJhbSBjRGF0YSBjb25zdHJ1Y3Rpb24gZGF0YVxyXG4gKiBAcGFyYW0gZXhlY3V0ZXJcclxuICogQHBhcmFtIG5vZGVcclxuICovXHJcbiAgICBmdW5jdGlvbiBzZXRDb25zdHJ1Y3Rpb25PcmRlckFuZFN1Yk5vZGVzKGNEYXRhLCBleGVjdXRlciwgbm9kZSl7XHJcbiAgICAgICAgaWYoY0RhdGEuZG9uZU5vZGVzLmluZGV4T2Yobm9kZSkgIT0gLTEpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgY0RhdGEuZG9uZU5vZGVzLnB1c2gobm9kZSk7XHJcblxyXG4gICAgICAgIGlmKGNEYXRhLmJsb2NrZWROb2Rlcy5pbmRleE9mKG5vZGUpICE9IC0xKXtcclxuICAgICAgICAgICAgZXhlY3V0ZXIuc3ViTm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgc2V0Q29uc3RydWN0aW9uT3JkZXJBbmRTdWJOb2RlcyhjRGF0YSwgZXhlY3V0ZXIsIG5vZGUuY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihub2RlLm9wZXJhdG9yKXsgLy8gUmVxdWVzdE5vZGVzIGRvbid0IGhhdmUgYW4gb3BlcmF0b3IuIENvbnNpZGVyIHRoaXMgY2FzZS5cclxuICAgICAgICAgICAgICAgIGNEYXRhLmNvbnN0cnVjdGlvbk9yZGVyLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbi8qKlxyXG4gKiBMYXN0IHN0ZXAgb2YgY29uc3RydWN0aW9uOiBjcmVhdGUgT3BlcmF0b3JMaXN0IGZyb20gY29uc3RydWN0aW9uT3JkZXIgYXJyYXlcclxuICogQWxzbyBmaWxsIG1lcmdlZE5vZGVzIGFuZCBwcm9ncmFtRGF0YVxyXG4gKiBAcGFyYW0gZXhlY3V0ZXJcclxuICogQHBhcmFtIGNEYXRhXHJcbiAqL1xyXG4gICAgZnVuY3Rpb24gY29uc3RydWN0RnJvbURhdGEoZXhlY3V0ZXIsIGNEYXRhKXtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNEYXRhLmNvbnN0cnVjdGlvbk9yZGVyLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBjRGF0YS5jb25zdHJ1Y3Rpb25PcmRlcltpXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IG5ldyBPcGVyYXRvckVudHJ5KG5vZGUub3BlcmF0b3IpO1xyXG5cclxuICAgICAgICAgICAgY29uc3RydWN0SW5wdXRDb25uZWN0aW9uKGV4ZWN1dGVyLCBlbnRyeSwgY0RhdGEsIG5vZGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGlzT3V0cHV0Tm9kZSA9IGNvbnN0cnVjdE91dHB1dENvbm5lY3Rpb24oZXhlY3V0ZXIsIGVudHJ5LCBjRGF0YSwgbm9kZSk7XHJcblxyXG4gICAgICAgICAgICBleGVjdXRlci5wcm9ncmFtRGF0YS5vcGVyYXRvckRhdGEucHVzaCh7fSk7XHJcbiAgICAgICAgICAgIGV4ZWN1dGVyLm9wZXJhdG9yTGlzdC5hZGRFbnRyeShlbnRyeSk7XHJcbiAgICAgICAgICAgIGV4ZWN1dGVyLm1lcmdlZE5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIGlmKGlzT3V0cHV0Tm9kZSB8fCAoaSA9PSBjRGF0YS5jb25zdHJ1Y3Rpb25PcmRlci5sZW5ndGgtMSkpXHJcbiAgICAgICAgICAgICAgICBleGVjdXRlci5tZXJnZWRPdXRwdXROb2Rlcy5wdXNoKG5vZGUpXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3RydWN0TG9zdE91dHB1dChleGVjdXRlciwgY0RhdGEpO1xyXG4gICAgfVxyXG4vKipcclxuICogQ29uc3RydWN0IGlucHV0IGluZm8gZm9yIE9wZXJhdG9yRW50cnkuXHJcbiAqIFdpbGwgaW1wbGljaXRseSBjcmVhdGUgUHJvZ3JhbUlucHV0Q29ubmVjdGlvbnMgZm9yIFByb2dyYW1EYXRhXHJcbiAqIEBwYXJhbSB7RXhlY3V0b3J9IGV4ZWN1dGVyXHJcbiAqIEBwYXJhbSB7T3BlcmF0b3JFbnRyeX0gZW50cnlcclxuICogQHBhcmFtIHt7fX0gY0RhdGFcclxuICogQHBhcmFtIHtQcm9jZXNzTm9kZX0gbm9kZVxyXG4gKi9cclxuICAgIGZ1bmN0aW9uIGNvbnN0cnVjdElucHV0Q29ubmVjdGlvbihleGVjdXRlciwgZW50cnksIGNEYXRhLCBub2RlKXtcclxuICAgICAgICB2YXIgbWFwcGluZyA9IG5vZGUub3BlcmF0b3IubWFwcGluZztcclxuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgbWFwcGluZy5sZW5ndGg7ICsrail7XHJcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gbm9kZS5pbnB1dENoYW5uZWxzW21hcHBpbmdbal0uc291cmNlXTtcclxuICAgICAgICAgICAgdmFyIG9wZXJhdG9ySW5kZXg7XHJcbiAgICAgICAgICAgIGlmKGNoYW5uZWwgJiYgY2hhbm5lbC5jcmVhdG9yUHJvY2Vzc05vZGUgJiYgKG9wZXJhdG9ySW5kZXggPVxyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZXIubWVyZ2VkTm9kZXMuaW5kZXhPZihjaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSkgKSAhPSAtMSApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGl0J3MgdHJhbnNmZXIgaW5wdXRcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXRJbmRleCA9IGdldE9wZXJhdG9yT3V0cHV0SW5kZXgoY2hhbm5lbC5jcmVhdG9yUHJvY2Vzc05vZGUsIGNoYW5uZWwpO1xyXG4gICAgICAgICAgICAgICAgZW50cnkuc2V0VHJhbnNmZXJJbnB1dChqLCBvcGVyYXRvckluZGV4LCBvdXRwdXRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldk9wZXJhdG9yID0gZXhlY3V0ZXIub3BlcmF0b3JMaXN0LmVudHJpZXNbb3BlcmF0b3JJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZighcHJldk9wZXJhdG9yLmlzRmluYWxPdXRwdXQob3V0cHV0SW5kZXgpKXtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2T3BlcmF0b3Iuc2V0VHJhbnNmZXJPdXRwdXQob3V0cHV0SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSGFuZGxlIGRpcmVjdCBpbnB1dFxyXG5cclxuICAgICAgICAgICAgdmFyIG1hcHBlZElucHV0TmFtZSA9IG1hcHBpbmdbal0uc291cmNlO1xyXG4gICAgICAgICAgICBpZihub2RlLm93bmVyLm93bmVyLl9jb21wdXRlSW5wdXRNYXBwaW5nKVxyXG4gICAgICAgICAgICAgICAgbWFwcGVkSW5wdXROYW1lID0gbm9kZS5vd25lci5vd25lci5fY29tcHV0ZUlucHV0TWFwcGluZy5nZXRTY3JpcHRJbnB1dE5hbWUobWFwcGluZ1tqXS5wYXJhbUlkeCwgbWFwcGluZ1tqXS5zb3VyY2UpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBuZXcgUHJvZ3JhbS5Qcm9ncmFtSW5wdXRDb25uZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uY2hhbm5lbCA9IGNoYW5uZWw7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uYXJyYXlBY2Nlc3MgPSBtYXBwaW5nW2pdLmFycmF5IHx8IGZhbHNlOyAvLyBUT0RPOiByZW5hbWUgdG8gcmFuZG9tQWNjZXNzXHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VxdWVuY2VBY2Nlc3NUeXBlID0gbWFwcGluZ1tqXS5zZXF1ZW5jZSB8fCAwO1xyXG4gICAgICAgICAgICBpZihjb25uZWN0aW9uLnNlcXVlbmNlQWNjZXNzVHlwZSlcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VxdWVuY2VLZXlTb3VyY2VDaGFubmVsID0gbm9kZS5pbnB1dENoYW5uZWxzW21hcHBpbmdbal0ua2V5U291cmNlXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbi5nZXRLZXkoKTtcclxuICAgICAgICAgICAgdmFyIGlucHV0U2xvdElkeCA9IGNEYXRhLmlucHV0U2xvdHNbY29ubmVjdGlvbktleV07XHJcbiAgICAgICAgICAgIGlmKGNoYW5uZWwgJiYgaW5wdXRTbG90SWR4ICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICAvLyBEaXJlY3QgaW5wdXQgYWxyZWFkeSBleGlzdHNcclxuICAgICAgICAgICAgICAgIGVudHJ5LnNldERpcmVjdElucHV0KGosIGlucHV0U2xvdElkeCwgbWFwcGVkSW5wdXROYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgLy8gbmV3IGRpcmVjdCBpbnB1dFxyXG4gICAgICAgICAgICAgICAgaW5wdXRTbG90SWR4ID0gZXhlY3V0ZXIucHJvZ3JhbURhdGEuaW5wdXRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGNEYXRhLmlucHV0U2xvdHNbY29ubmVjdGlvbktleV0gPSBpbnB1dFNsb3RJZHg7XHJcbiAgICAgICAgICAgICAgICBleGVjdXRlci5wcm9ncmFtRGF0YS5pbnB1dHMucHVzaChjb25uZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIGVudHJ5LnNldERpcmVjdElucHV0KGosIGlucHV0U2xvdElkeCwgbWFwcGVkSW5wdXROYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3Qgb3V0cHV0IGluZm8gb2YgT3BlcmF0b3JFbnRyeVxyXG4gKiBAcGFyYW0ge0V4ZWN1dG9yfSBleGVjdXRlclxyXG4gKiBAcGFyYW0ge09wZXJhdG9yRW50cnl9IGVudHJ5XHJcbiAqIEBwYXJhbSB7e319IGNEYXRhXHJcbiAqIEBwYXJhbSB7UHJvY2Vzc05vZGV9IG5vZGVcclxuICovXHJcbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3RPdXRwdXRDb25uZWN0aW9uKGV4ZWN1dGVyLCBlbnRyeSwgY0RhdGEsIG5vZGUpe1xyXG4gICAgICAgIHZhciBvdXRwdXRzID0gbm9kZS5vcGVyYXRvci5vdXRwdXRzO1xyXG4gICAgICAgIHZhciBpc091dHB1dE5vZGUgPSB0cnVlO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvdXRwdXRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIHNsb3QgPSBub2RlLm91dHB1dERhdGFTbG90c1tvdXRwdXRzW2ldLm5hbWVdO1xyXG4gICAgICAgICAgICB2YXIgZmluYWxPdXRwdXROYW1lID0gZ2V0RmluYWxPdXRwdXROYW1lKHNsb3QsIGNEYXRhKTtcclxuICAgICAgICAgICAgaWYoZmluYWxPdXRwdXROYW1lKXtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9ICBleGVjdXRlci5wcm9ncmFtRGF0YS5vdXRwdXRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGV4ZWN1dGVyLnByb2dyYW1EYXRhLm91dHB1dHMucHVzaChzbG90KTtcclxuICAgICAgICAgICAgICAgIGVudHJ5LnNldEZpbmFsT3V0cHV0KGksIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGlmKGZpbmFsT3V0cHV0TmFtZSAhPT0gdHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMubmFtZXNldC5yZW1vdmUoZXhlY3V0ZXIudW5wcm9jZXNzZWREYXRhTmFtZXMsIGZpbmFsT3V0cHV0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGlzT3V0cHV0Tm9kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc091dHB1dE5vZGU7IC8vIFRPRE86IENoZWNrIGlmIGNvbXB1dGF0aW9uIG9mIGlzT3V0cHV0Tm9kZSBpcyByZWFsbHkgY29ycmVjdD9cclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0T3BlcmF0b3JPdXRwdXRJbmRleChwcm9jZXNzTm9kZSwgY2hhbm5lbCl7XHJcbiAgICAgICAgdmFyIG91dHB1dHMgPSBwcm9jZXNzTm9kZS5vcGVyYXRvci5vdXRwdXRzO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvdXRwdXRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYoY2hhbm5lbC5nZXREYXRhRW50cnkoKSA9PSBwcm9jZXNzTm9kZS5vdXRwdXREYXRhU2xvdHNbb3V0cHV0c1tpXS5uYW1lXS5kYXRhRW50cnkpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RmluYWxPdXRwdXROYW1lKGRhdGFTbG90LCBjRGF0YSl7XHJcbiAgICAgICAgaWYoIWNEYXRhLmZpbmFsT3V0cHV0KSAvLyBJZiByb290IG9mIEV4ZWN1dG9yIGlzIGEgUHJvY2Vzc05vZGUgd2UgZG9uJ3QgaGF2ZSBmaW5hbE91dHB1dCBkZWZpbmVkIGFuZCBhbGwgb3V0cHV0cyBhcmUgZmluYWwuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiBjRGF0YS5maW5hbE91dHB1dCl7XHJcbiAgICAgICAgICAgIGlmKGNEYXRhLmZpbmFsT3V0cHV0W25hbWVdID09IGRhdGFTbG90LmRhdGFFbnRyeSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29uc3RydWN0TG9zdE91dHB1dChleGVjdXRlciwgY0RhdGEpe1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjRGF0YS5jb25zdHJ1Y3Rpb25PcmRlci5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gY0RhdGEuY29uc3RydWN0aW9uT3JkZXJbaV07XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IGV4ZWN1dGVyLm9wZXJhdG9yTGlzdC5lbnRyaWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgdmFyIG91dHB1dHMgPSBub2RlLm9wZXJhdG9yLm91dHB1dHM7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBvdXRwdXRzLmxlbmd0aDsgKytqKXtcclxuICAgICAgICAgICAgICAgIGlmKCFlbnRyeS5pc0ZpbmFsT3V0cHV0KGopICYmICEgZW50cnkuaXNUcmFuc2Zlck91dHB1dChqKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZXhlY3V0ZXIucHJvZ3JhbURhdGEub3V0cHV0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZXIucHJvZ3JhbURhdGEub3V0cHV0cy5wdXNoKG5vZGUub3V0cHV0RGF0YVNsb3RzW291dHB1dHNbal0ubmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnNldExvc3RPdXRwdXQoaiwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVJdGVyYXRlU3RhdGUoZXhlY3V0ZXIpe1xyXG4gICAgICAgIHZhciBpbnB1dHMgPSBleGVjdXRlci5wcm9ncmFtRGF0YS5pbnB1dHM7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGV4ZWN1dGVyLnByb2dyYW1EYXRhLmlucHV0cy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IGV4ZWN1dGVyLnByb2dyYW1EYXRhLmdldERhdGFFbnRyeShpKTtcclxuICAgICAgICAgICAgdmFyIGl0ZXJhdGVDb3VudCA9IGVudHJ5ID8gZW50cnkuZ2V0SXRlcmF0ZUNvdW50ID8gZW50cnkuZ2V0SXRlcmF0ZUNvdW50KCkgOiAxIDogMDtcclxuICAgICAgICAgICAgaWYoIWl0ZXJhdGVDb3VudClcclxuICAgICAgICAgICAgICAgIGV4ZWN1dGVyLm9wZXJhdG9yTGlzdC5zZXRJbnB1dEl0ZXJhdGVUeXBlKGksIEMuSVRFUkFUSU9OX1RZUEUuTlVMTCk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYoIWlucHV0c1tpXS5hcnJheUFjY2VzcyAmJiBpdGVyYXRlQ291bnQgPiAxKVxyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZXIub3BlcmF0b3JMaXN0LnNldElucHV0SXRlcmF0ZVR5cGUoaSwgQy5JVEVSQVRJT05fVFlQRS5NQU5ZKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZXIub3BlcmF0b3JMaXN0LnNldElucHV0SXRlcmF0ZVR5cGUoaSwgQy5JVEVSQVRJT05fVFlQRS5PTkUpO1xyXG5cclxuICAgICAgICAgICAgaWYoaW5wdXRzW2ldLmFycmF5QWNjZXNzICYmIHBsYXRmb3JtUmVxdWlyZXNBcnJheVNpemUoZXhlY3V0ZXIuIHBsYXRmb3JtKSl7XHJcbiAgICAgICAgICAgICAgICBleGVjdXRlci5vcGVyYXRvckxpc3Quc2V0SW5wdXRTaXplKGksIGl0ZXJhdGVDb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgaWYgdGhlIHBsYXRmb3JtIG5lZWRzIHRvIGRlY2xhcmUgdW5pZm9ybSBhcnJheSBzaXplcyBpbiB0aGUgc291cmNlIGNvZGUuXHJcbiAqIEBwYXJhbSBwbGF0Zm9ybVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbiAgICBmdW5jdGlvbiBwbGF0Zm9ybVJlcXVpcmVzQXJyYXlTaXplKHBsYXRmb3JtKXtcclxuICAgICAgICByZXR1cm4gcGxhdGZvcm0gPT0gQy5QTEFURk9STS5HTFNMO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBydW5TdWJOb2RlcyhleGVjdXRlcil7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGV4ZWN1dGVyLnN1Yk5vZGVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgZXhlY3V0ZXIuc3ViTm9kZXNbaV0ucHJvY2VzcygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0b3I7XHJcbiIsInZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XHJcbnZhciBDID0gcmVxdWlyZShcIi4vLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxuXHJcblxyXG52YXIgb3JkZXJNYXBwaW5nUGFyc2VyID0gL14oW146LHt9XSspKCxbXjp7fSxdKykqJC87XHJcbnZhciBuYW1lTWFwcGluZ1BhcnNlciA9IC9eXFx7KChbXjose31dKzpbXjp7fSxdKykoLFteOnt9LF0rOlteOn0sXSspKil9JC87XHJcblxyXG4vKipcclxuICogQSBtYXBwaW5nIHVzZWQgZm9yIGEgZmlsdGVyIG9yIGEgY29tcHV0ZSBwcm9wZXJ0aWVzIG9mIGEgRGF0YU5vZGVcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG52YXIgTWFwcGluZyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtBcnJheTxEYXRhTm9kZT59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX293bmVycyA9IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlIGEgTWFwcGluZyAoYm90aCBDLk9yZGVyTWFwcGluZyBvciBDLkNvbXB1dGVNYXBwaW5nKSBmcm9tIGEgc3ludGF4IHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3ludGF4IHN0cmluZy5cclxuICogQHBhcmFtIHtDLkRhdGFOb2RlfSBkYXRhTm9kZSBEYXRhTm9kZSBvZiB0aGUgTWFwcGluZ1xyXG4gKiBAcmV0dXJucyB7P0MuTWFwcGluZ31cclxuICovXHJcbk1hcHBpbmcucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcsIGRhdGFOb2RlKXtcclxuICAgIHN0cmluZyA9IHN0cmluZy50cmltKCk7XHJcbiAgICB2YXIgcmVzdWx0cyA9IHN0cmluZy50cmltKCkubWF0Y2gob3JkZXJNYXBwaW5nUGFyc2VyKTtcclxuICAgIGlmKHJlc3VsdHMpXHJcbiAgICAgICAgcmV0dXJuIE9yZGVyTWFwcGluZy5wYXJzZShzdHJpbmcsIGRhdGFOb2RlKTtcclxuICAgIHJlc3VsdHMgPSBzdHJpbmcudHJpbSgpLm1hdGNoKG5hbWVNYXBwaW5nUGFyc2VyKTtcclxuICAgIGlmKHJlc3VsdHMpXHJcbiAgICAgICAgcmV0dXJuIE5hbWVNYXBwaW5nLnBhcnNlKHJlc3VsdHNbMV0sIGRhdGFOb2RlKTtcclxuICAgIEJhc2Uubm90aWZ5RXJyb3IoXCJDYW5ub3QgcGFyc2UgbmFtZSBtYXBwaW5nICdcIiArIHN0cmluZyArIFwiJ1wiLCBkYXRhTm9kZSk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RhdGFOb2RlfSBvd25lclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTWFwcGluZy5wcm90b3R5cGUuX2FkZE93bmVyID0gZnVuY3Rpb24ob3duZXIpe1xyXG4gICAgdmFyIGlkeCA9IHRoaXMuX293bmVycy5pbmRleE9mKG93bmVyKTtcclxuICAgIGlmKGlkeCA9PSAtMSlcclxuICAgICAgICB0aGlzLl9vd25lcnMucHVzaChvd25lcik7XHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtEYXRhTm9kZX0gb3duZXJcclxuICogQHByaXZhdGVcclxuICovXHJcbk1hcHBpbmcucHJvdG90eXBlLl9yZW1vdmVPd25lciA9IGZ1bmN0aW9uKG93bmVyKXtcclxuICAgIHZhciBpZHggPSB0aGlzLl9vd25lcnMuaW5kZXhPZihvd25lcik7XHJcbiAgICBpZihpZHggIT0gLTEpXHJcbiAgICAgICAgdGhpcy5fb3duZXJzLnNwbGljZShpZHgsIC0xKTtcclxufTtcclxuXHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gT3JkZXJNYXBwaW5nXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLyoqXHJcbiAqIEFuIE9yZGVyTWFwcGluZyB1c2VkIGZvciBhIGZpbHRlciBvciBjb21wdXRlIHByb3BlcnRpZXMgb2YgYSBEYXRhTm9kZVxyXG4gKiBJdCBkZXNjcmliZXMgYSBtYXBwaW5nIG9mIG5hbWVzIHJlZmVycmluZyB0byB0aGUgb3JkZXIgb2YgYXJndW1lbnRzIC8gb3V0cHV0IHZhbHVlcy5cclxuICogT3JkZXJNYXBwaW5nIHN5bnRheCBleGFtcGxlcyBpbiBjb21wdXRlOlxyXG4gKiBwb3NpdGlvbiA9IEMubW9ycGgocG9zaXRpb24sIHBvc0FkZCwgd2VpZ2h0KVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMge01hcHBpbmd9XHJcbiAqL1xyXG52YXIgT3JkZXJNYXBwaW5nID0gZnVuY3Rpb24oKXtcclxuICAgIE1hcHBpbmcuY2FsbCh0aGlzKTtcclxuICAgIHRoaXMuX25hbWVzID0gW107XHJcbn07XHJcbkJhc2UuY3JlYXRlQ2xhc3MoT3JkZXJNYXBwaW5nLCBNYXBwaW5nKTtcclxuXHJcbk9yZGVyTWFwcGluZy5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZywgZGF0YU5vZGUpe1xyXG4gICAgdmFyIG1hcHBpbmcgPSBuZXcgT3JkZXJNYXBwaW5nKGRhdGFOb2RlKTtcclxuICAgIHZhciB0b2tlbiA9IHN0cmluZy5zcGxpdChcIixcIik7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIG1hcHBpbmcuX25hbWVzLnB1c2godG9rZW5baV0udHJpbSgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXBwaW5nO1xyXG59O1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShPcmRlck1hcHBpbmcucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKCl7IHRocm93IG5ldyBFcnJvcihcImxlbmd0aCBpcyByZWFkLW9ubHlcIik7XHJcbiAgICB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fbmFtZXMubGVuZ3RoOyB9XHJcbn0pO1xyXG5cclxuT3JkZXJNYXBwaW5nLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24oaWR4KXtcclxuICAgIHJldHVybiB0aGlzLl9uYW1lc1tpZHhdO1xyXG59O1xyXG5cclxuT3JkZXJNYXBwaW5nLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLl9uYW1lcyA9IFtdO1xyXG4gICAgbWFwcGluZ05vdGlmeU93bmVyKHRoaXMpO1xyXG59O1xyXG5cclxuT3JkZXJNYXBwaW5nLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24oaW5kZXgsIG5hbWUpe1xyXG4gICAgdGhpcy5fbmFtZXNbaW5kZXhdID0gbmFtZTtcclxuICAgIG1hcHBpbmdOb3RpZnlPd25lcih0aGlzKTtcclxufTtcclxuXHJcblxyXG4vL25vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcclxuT3JkZXJNYXBwaW5nLnByb3RvdHlwZS5yZW1vdmVOYW1lID0gZnVuY3Rpb24oaW5kZXgpe1xyXG4gICAgdGhpcy5fbmFtZXMuc3BsaWNlKGluZGV4KTtcclxuICAgIG1hcHBpbmdOb3RpZnlPd25lcih0aGlzKTtcclxufTtcclxuXHJcbk9yZGVyTWFwcGluZy5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMubGVuZ3RoID09IDA7XHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtDaGFubmVsTWFwfSBkZXN0TWFwXHJcbiAqIEBwYXJhbSB7Q2hhbm5lbE1hcH0gc291cmNlTWFwXHJcbiAqIEBwYXJhbSB7ZXhwb3J0cy5DLkRBVEFfRklMVEVSX1RZUEV9IGZpbHRlclR5cGVcclxuICogQHBhcmFtIHtmdW5jdGlvbihDaGFubmVsTWFwLCBzdHJpbmcsIENoYW5uZWxNYXAsIHN0cmluZyl9IGNhbGxiYWNrXHJcbiAqL1xyXG5PcmRlck1hcHBpbmcucHJvdG90eXBlLmFwcGx5RmlsdGVyT25DaGFubmVsTWFwID0gZnVuY3Rpb24oZGVzdE1hcCwgc291cmNlTWFwLCBmaWx0ZXJUeXBlLCBjYWxsYmFjayl7XHJcbiAgICB2YXIgaTtcclxuICAgIGlmKGZpbHRlclR5cGUgPT0gQy5EQVRBX0ZJTFRFUl9UWVBFLktFRVApe1xyXG4gICAgICAgIGZvcihpID0gMDsgaSA8IHRoaXMuX25hbWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lc1tpXTtcclxuICAgICAgICAgICAgaWYoc291cmNlTWFwLm1hcFtuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZGVzdE1hcCwgbmFtZSwgc291cmNlTWFwLCBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgZm9yKGkgaW4gc291cmNlTWFwLm1hcCl7XHJcbiAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLl9uYW1lcy5pbmRleE9mKGkpO1xyXG4gICAgICAgICAgICBpZihmaWx0ZXJUeXBlID09IEMuREFUQV9GSUxURVJfVFlQRS5SRU5BTUUgfHxcclxuICAgICAgICAgICAgICAgIChmaWx0ZXJUeXBlID09IEMuREFUQV9GSUxURVJfVFlQRS5SRU1PVkUgJiYgaWR4ID09IC0xKSlcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRlc3RNYXAsIGksIHNvdXJjZU1hcCwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgaW5wdXQgdmFsdWUgYXNzaWduZWQgdG8gb3BlcmF0b3IgYXJndW1lbnQuXHJcbiAqIFJldHVybnMgbnVsbCwgaWYgbm8gbWFwcGluZyBpcyBkZWZpbmVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggUG9zaXRpb24gb2YgdGhlIG9wZXJhdG9yIGFyZ3VtZW50XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH1cclxuICovXHJcbk9yZGVyTWFwcGluZy5wcm90b3R5cGUuZ2V0U2NyaXB0SW5wdXROYW1lID0gZnVuY3Rpb24oaW5kZXggLyosIGRlc3ROYW1lICovKXtcclxuICAgIGlmKHRoaXMuX25hbWVzW2luZGV4XSlcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZXNbaW5kZXhdO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIG91dHB1dCBwYXJhbWV0ZXIgYXMgaXQgc2hvdWxkIGJlIHVzZWQgZm9yIHRoZVxyXG4gKiBmb2xsb3dpbmcgZGF0YWZsb3cuIFJldHVybnMgbnVsbCwgaWYgbm8gbWFwcGluZyBpcyBkZWZpbmVkLlxyXG4gKiBAcGFyYW0gaW5kZXhcclxuICogQHJldHVybnMge3N0cmluZ3xudWxsfVxyXG4gKi9cclxuT3JkZXJNYXBwaW5nLnByb3RvdHlwZS5nZXRTY3JpcHRPdXRwdXROYW1lID0gZnVuY3Rpb24oaW5kZXggLyosIHNyY05hbWUgKi8pe1xyXG4gICAgaWYodGhpcy5fbmFtZXNbaW5kZXhdKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lc1tpbmRleF07XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBuYW1lIG9mIHRoZSBvdXRwdXQgcGFyYW1ldGVyIGFzIGl0IHNob3VsZCBiZSB1c2VkIGZvciB0aGVcclxuICogZm9sbG93aW5nIGRhdGFmbG93LiBSZXR1cm5zIG51bGwsIGlmIG5vIG1hcHBpbmcgaXMgZGVmaW5lZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3ROYW1lXHJcbiAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gb3BlcmF0b3JPdXRwdXRzXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH1cclxuICovXHJcbk9yZGVyTWFwcGluZy5wcm90b3R5cGUuZ2V0U2NyaXB0T3V0cHV0TmFtZUludiA9IGZ1bmN0aW9uKGRlc3ROYW1lLCBvcGVyYXRvck91dHB1dHMpe1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihkZXN0TmFtZSk7XHJcbiAgICBpZihpbmRleCA9PSAtMSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiBvcGVyYXRvck91dHB1dHNbaW5kZXhdLm5hbWU7XHJcbn07XHJcblxyXG4vKipcclxuICogSWRlbnRpdHkgZnVuY3Rpb24uIFVzZWQgdG8gaW1wbGVtZW50IGludGVyZmFjZS4gVXN1YWxseSB5b3UgZG9uJ3QgcmVuYW1lIHdpdGggb3JkZXJcclxuICogbWFwcGluZy5cclxuICogQHBhcmFtIG5hbWVcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbk9yZGVyTWFwcGluZy5wcm90b3R5cGUuZ2V0UmVuYW1lU3JjTmFtZSA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgcmV0dXJuIG5hbWU7XHJcbn07XHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gTmFtZU1hcHBpbmdcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vKipcclxuICogQW4gTmFtZU1hcHBpbmcgdXNlZCBmb3IgYSBmaWx0ZXIgb3IgY29tcHV0ZSBwcm9wZXJ0aWVzIG9mIGEgRGF0YU5vZGVcclxuICogSXQgZGVzY3JpYmVzIGEgbWFwcGluZyBvZiBuYW1lcyByZWZlcnJpbmcgdG8gdGhlIG9yaWdpbmFsIG5hbWVzIG9mIHRoZSBhcmd1bWVudHMgLyBvdXRwdXQgdmFsdWVzLlxyXG4gKiBOYW1lTWFwcGluZyBzeW50YXggZXhhbXBsZXMgaW4gY29tcHV0ZTpcclxuICoge3Bvc2l0aW9uOiByZXN1bHR9ID0gQy5tb3JwaCh7dmFsdWU6IHBvc2l0aW9uLCB2YWx1ZUFkZDogcG9zQWRkLCB3ZWlnaHQ6IHdlaWdodH0pXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyB7TWFwcGluZ31cclxuICovXHJcbnZhciBOYW1lTWFwcGluZyA9IGZ1bmN0aW9uKCl7XHJcbiAgICBNYXBwaW5nLmNhbGwodGhpcyk7XHJcbiAgICB0aGlzLl9kZXN0TmFtZXMgPSBbXTtcclxuICAgIHRoaXMuX3NyY05hbWVzID0gW107XHJcblxyXG59O1xyXG5CYXNlLmNyZWF0ZUNsYXNzKE5hbWVNYXBwaW5nLCBNYXBwaW5nKTtcclxuXHJcbk5hbWVNYXBwaW5nLnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nLCBkYXRhTm9kZSkgIHtcclxuICAgIHZhciBtYXBwaW5nID0gbmV3IE5hbWVNYXBwaW5nKGRhdGFOb2RlKTtcclxuICAgIHZhciB0b2tlbiA9IHN0cmluZy5zcGxpdChcIixcIik7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHZhciBwYWlyID0gdG9rZW5baV0uc3BsaXQoXCI6XCIpO1xyXG4gICAgICAgIHZhciBkZXN0ID0gcGFpclswXS50cmltKCk7IHZhciBzcmMgPSBwYWlyWzFdLnRyaW0oKTtcclxuICAgICAgICBtYXBwaW5nLnNldE5hbWVQYWlyKGRlc3QsIHNyYyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWFwcGluZztcclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOYW1lTWFwcGluZy5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24oKXsgdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIGlzIHJlYWQtb25seVwiKTtcclxuICAgIH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9zcmNOYW1lcy5sZW5ndGg7IH1cclxufSk7XHJcblxyXG5OYW1lTWFwcGluZy5wcm90b3R5cGUuZ2V0RGVzdE5hbWUgPSBmdW5jdGlvbihpZHgpe1xyXG4gICAgcmV0dXJuIHRoaXMuX2Rlc3ROYW1lc1tpZHhdO1xyXG59O1xyXG5OYW1lTWFwcGluZy5wcm90b3R5cGUuZ2V0U3JjTmFtZSA9IGZ1bmN0aW9uKGlkeCl7XHJcbiAgICByZXR1cm4gdGhpcy5fc3JjTmFtZXNbaWR4XTtcclxufTtcclxuXHJcbk5hbWVNYXBwaW5nLnByb3RvdHlwZS5nZXRTcmNOYW1lRnJvbURlc3ROYW1lID0gZnVuY3Rpb24oZGVzdE5hbWUpe1xyXG4gICAgdmFyIGlkeCA9IHRoaXMuX2Rlc3ROYW1lcy5pbmRleE9mKGRlc3ROYW1lKTtcclxuICAgIHJldHVybiBpZHggPT0gLTEgPyBudWxsIDogdGhpcy5fc3JjTmFtZXNbaWR4XTtcclxufTtcclxuTmFtZU1hcHBpbmcucHJvdG90eXBlLmdldERlc3ROYW1lRnJvbVNyY05hbWUgPSBmdW5jdGlvbihzcmNOYW1lKXtcclxuICAgIHZhciBpZHggPSB0aGlzLl9zcmNOYW1lcy5pbmRleE9mKHNyY05hbWUpO1xyXG4gICAgcmV0dXJuIGlkeCA9PSAtMSA/IG51bGwgOiB0aGlzLl9kZXN0TmFtZXNbaWR4XTtcclxufTtcclxuXHJcbk5hbWVNYXBwaW5nLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLl9zcmNOYW1lcyA9IFtdO1xyXG4gICAgdGhpcy5fZGVzdE5hbWVzID0gW107XHJcbiAgICBtYXBwaW5nTm90aWZ5T3duZXIodGhpcyk7XHJcbn07XHJcblxyXG5OYW1lTWFwcGluZy5wcm90b3R5cGUuc2V0TmFtZVBhaXIgPSBmdW5jdGlvbihkZXN0TmFtZSwgc3JjTmFtZSl7XHJcbiAgICB2YXIgaWR4ID0gdGhpcy5fZGVzdE5hbWVzLmluZGV4T2YoZGVzdE5hbWUpO1xyXG4gICAgaWYoaWR4ICE9IC0xKXtcclxuICAgICAgICB0aGlzLl9kZXN0TmFtZXMuc3BsaWNlKGlkeCwxKTtcclxuICAgICAgICB0aGlzLl9zcmNOYW1lcy5zcGxpY2UoaWR4LDEpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fZGVzdE5hbWVzLnB1c2goZGVzdE5hbWUpO1xyXG4gICAgdGhpcy5fc3JjTmFtZXMucHVzaChzcmNOYW1lKTtcclxuICAgIG1hcHBpbmdOb3RpZnlPd25lcih0aGlzKTtcclxufTtcclxuXHJcbi8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xyXG5OYW1lTWFwcGluZy5wcm90b3R5cGUucmVtb3ZlTmFtZVBhaXIgPSBmdW5jdGlvbihkZXN0TmFtZSl7XHJcbiAgICB2YXIgaWR4ID0gdGhpcy5fZGVzdE5hbWVzLmluZGV4T2YoZGVzdE5hbWUpO1xyXG4gICAgaWYoaWR4ICE9IC0xKXtcclxuICAgICAgICB0aGlzLl9kZXN0TmFtZXMuc3BsaWNlKGlkeCwxKTtcclxuICAgICAgICB0aGlzLl9zcmNOYW1lcy5zcGxpY2UoaWR4LDEpO1xyXG4gICAgfVxyXG4gICAgbWFwcGluZ05vdGlmeU93bmVyKHRoaXMpO1xyXG59O1xyXG5cclxuTmFtZU1hcHBpbmcucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuX2Rlc3ROYW1lcy5sZW5ndGggPT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAc2VlIE9yZGVyTWFwcGluZy5hcHBseUZpbHRlck9uQ2hhbm5lbE1hcFxyXG4gKiBAcGFyYW0ge0NoYW5uZWxNYXB9IGRlc3RNYXBcclxuICogQHBhcmFtIHtDaGFubmVsTWFwfSBzb3VyY2VNYXBcclxuICogQHBhcmFtIHtDLkRBVEFfRklMVEVSX1RZUEV9IGZpbHRlclR5cGVcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcclxuICovXHJcbk5hbWVNYXBwaW5nLnByb3RvdHlwZS5hcHBseUZpbHRlck9uQ2hhbm5lbE1hcCA9IGZ1bmN0aW9uKGRlc3RNYXAsIHNvdXJjZU1hcCwgZmlsdGVyVHlwZSwgY2FsbGJhY2spIHtcclxuICAgIHZhciBpO1xyXG4gICAgaWYoZmlsdGVyVHlwZSA9PSBDLkRBVEFfRklMVEVSX1RZUEUuUkVNT1ZFKXtcclxuICAgICAgICBmb3IoaSBpbiBzb3VyY2VNYXAubWFwKVxyXG4gICAgICAgICAgICBpZih0aGlzLl9zcmNOYW1lcy5pbmRleE9mKGkpID09IC0xKVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZGVzdE1hcCwgaSwgc291cmNlTWFwLCBpKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgaWYoZmlsdGVyVHlwZSA9PSBDLkRBVEFfRklMVEVSX1RZUEUuUkVOQU1FKXtcclxuICAgICAgICAgICAgZm9yKGkgaW4gc291cmNlTWFwLm1hcClcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3NyY05hbWVzLmluZGV4T2YoaSkgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGVzdE1hcCwgaSwgc291cmNlTWFwLCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKGkgaW4gdGhpcy5fZGVzdE5hbWVzKXtcclxuICAgICAgICAgICAgY2FsbGJhY2soZGVzdE1hcCwgdGhpcy5fZGVzdE5hbWVzW2ldLCBzb3VyY2VNYXAsIHRoaXMuX3NyY05hbWVzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVuYW1lczogTG9vay11cCB0aGUgZGVzdGluYXRpb24gbmFtZSBhbmQgcmV0dXJuIHRoZSBzb3VyY2UgbmFtZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuTmFtZU1hcHBpbmcucHJvdG90eXBlLmdldFJlbmFtZVNyY05hbWUgPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHJldHVybiB0aGlzLmdldFNyY05hbWVGcm9tRGVzdE5hbWUobmFtZSkgfHwgbmFtZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGlucHV0IHZhbHVlIGFzc2lnbmVkIHRvIG9wZXJhdG9yIGFyZ3VtZW50XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBQb3NpdGlvbiBvZiB0aGUgb3BlcmF0b3IgYXJndW1lbnRcclxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RpbmF0aW9uTmFtZSBOYW1lIG9mIHRoZSBvcGVyYXRvciBhcmd1bWVudFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XHJcbiAqL1xyXG5OYW1lTWFwcGluZy5wcm90b3R5cGUuZ2V0U2NyaXB0SW5wdXROYW1lPSBmdW5jdGlvbihpbmRleCwgZGVzdGluYXRpb25OYW1lKXtcclxuICAgIHJldHVybiB0aGlzLmdldFNyY05hbWVGcm9tRGVzdE5hbWUoZGVzdGluYXRpb25OYW1lKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAc2VlIE9yZGVyTWFwcGluZy5nZXRTY3JpcHRPdXRwdXROYW1lXHJcbiAqL1xyXG5OYW1lTWFwcGluZy5wcm90b3R5cGUuZ2V0U2NyaXB0T3V0cHV0TmFtZSA9IGZ1bmN0aW9uKGluZGV4LCBzcmNOYW1lKXtcclxuICAgIHJldHVybiB0aGlzLmdldERlc3ROYW1lRnJvbVNyY05hbWUoc3JjTmFtZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHNlZSBPcmRlck1hcHBpbmcuZ2V0U2NyaXB0T3V0cHV0TmFtZUludlxyXG4gKi9cclxuTmFtZU1hcHBpbmcucHJvdG90eXBlLmdldFNjcmlwdE91dHB1dE5hbWVJbnYgPSBmdW5jdGlvbihkZXN0TmFtZSAvKiwgb3BlcmF0b3JPdXRwdXRzICovKXtcclxuICAgIHZhciBpbmRleCA9IHRoaXMuX2Rlc3ROYW1lcy5pbmRleE9mKGRlc3ROYW1lKTtcclxuICAgIGlmKGluZGV4ID09IC0xKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIHRoaXMuX3NyY05hbWVzW2luZGV4XTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOb3RpZnkgYWxsIERhdGFOb2RlcyB0aGF0IHVzZSB0aGUgbWFwcGluZyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7TWFwcGluZ30gbWFwcGluZ1xyXG4gKi9cclxuZnVuY3Rpb24gbWFwcGluZ05vdGlmeU93bmVyKG1hcHBpbmcpe1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1hcHBpbmcuX293bmVycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIG1hcHBpbmcuX293bmVyc1tpXS5ub3RpZnkoQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgfVxyXG4gICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIE5hbWVNYXBwaW5nOiBOYW1lTWFwcGluZyxcclxuICAgIE9yZGVyTWFwcGluZzogT3JkZXJNYXBwaW5nLFxyXG4gICAgTWFwcGluZzogTWFwcGluZ1xyXG59O1xyXG4iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlLmpzXCIpO1xyXG52YXIgQyA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvdXRpbHMuanNcIik7XHJcbnZhciBFeGVjdXRvciA9IHJlcXVpcmUoXCIuL2V4ZWN1dG9yLmpzXCIpO1xyXG52YXIgUmVzdWx0ID0gcmVxdWlyZShcIi4vcmVzdWx0LmpzXCIpO1xyXG52YXIgT3BlcmF0b3IgPSByZXF1aXJlKFwiLi4vb3BlcmF0b3Ivb3BlcmF0b3IuanNcIik7XHJcbnZhciBEYXRhID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9kYXRhLmpzXCIpO1xyXG52YXIgRGF0YVNsb3QgPSByZXF1aXJlKFwiLi4vcHJvY2Vzc2luZy9kYXRhLXNsb3QuanNcIik7XHJcblxyXG52YXIgQnVmZmVyRW50cnkgPSBEYXRhLkJ1ZmZlckVudHJ5O1xyXG52YXIgVGV4dHVyZUVudHJ5ID0gRGF0YS5UZXh0dXJlRW50cnk7XHJcbnZhciBJbWFnZURhdGFUZXh0dXJlRW50cnkgPSBEYXRhLkltYWdlRGF0YVRleHR1cmVFbnRyeTtcclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBDLlByb2Nlc3NOb2RlXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxudmFyIEFTWU5DX1BST0NFU1NfU1RBVEUgPSB7XHJcbiAgICBJRExFIDogMCxcclxuICAgIFJVTk5JTkcgOiAxLFxyXG4gICAgUkVTQ0hFRFVMRUQgOiAyLFxyXG4gICAgSU5JVDogM1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBPcHRpbWl6ZWQgcmVwcmVzZW50YXRpb24gZm9yIHRoZSBwcm9jZXNzaW5nIGdyYXBoLiBPbmx5IGNyZWF0ZWQgZm9yIENoYW5uZWxOb2RlcyB3aXRoIG9wZXJhdG9ycy5cclxuICogSXMgY29ubmVjdGVkIGRpcmVjdGx5IHRvIG90aGVyIFByb2Nlc3NOb2RlcywgaWdub3JpbmcgY2hhbm5lbHMgdGhhdCBhcmUgbm90IHJlbGV2YW50IGZvciBwcm9jZXNzaW5nXHJcbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IGNoYW5uZWxOb2RlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyB7R3JhcGhOb2RlfVxyXG4gKi9cclxudmFyIFByb2Nlc3NOb2RlID0gZnVuY3Rpb24oY2hhbm5lbE5vZGUpe1xyXG4gICAgdGhpcy5vd25lciA9IGNoYW5uZWxOb2RlO1xyXG4gICAgdGhpcy5vcGVyYXRvciA9IGNoYW5uZWxOb2RlLm9wZXJhdG9yO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5wdXQgY2hhbm5lbHMgZm9yIHRoZSBvcGVyYXRvclxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBDaGFubmVsPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbnB1dENoYW5uZWxzID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPdXRwdXRzIG9mIG9wZXJhdG9yXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIERhdGFTbG90Pn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vdXRwdXREYXRhU2xvdHMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtleHBvcnRzLkMuUFJPQ0VTU19TVEFURX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuTU9ESUZJRUQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7QVNZTkNfUFJPQ0VTU19TVEFURX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5hc3luY1Byb2Nlc3NTdGF0ZSA9IEFTWU5DX1BST0NFU1NfU1RBVEUuSU5JVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERpcmVjdCBDaGlsZHJlbiB3aXRob3V0IHRyYW5zaXRpdmUgY2hpbGRyZW4gb2YgY2hpbGRyZW5cclxuICAgICAqIFRPRE86IFVzZSBTZXQoKT9cclxuICAgICAqIEB0eXBlIHtBcnJheS48UHJvY2Vzc05vZGU+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGlsZHJlbiB3aXRoIHRyYW5zaXRpdmUgZGVwZW5kZW5jaWVzXHJcbiAgICAgKiBUT0RPOiBVc2UgU2V0KCk/XHJcbiAgICAgKiBAdHlwZSB7QXJyYXkuPFByb2Nlc3NOb2RlPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kZXNjZW5kYW50cyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2ssIHRoZSBleGVjdXRvciBuZWVkcyB0byBjYWxsIHdoZW4gdGhlIGNvbXB1dGF0aW9uIGlzIHJlYWR5XHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9iaW5kZWRBc3luY0NhbGxiYWNrID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGV4IG9mIGFycmF5IG1hdGNoZXMgcGxhdGZvcm0gaWQgKEMuUExBVEZPUk0pXHJcbiAgICAgKiBAdHlwZSB7QXJyYXkuPEV4ZWN1dG9yPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5leGVjdXRlcnMgPSBbXTtcclxuXHJcbiAgICBjb25zdHJ1Y3RQcm9jZXNzTm9kZSh0aGlzLCBjaGFubmVsTm9kZSk7XHJcblxyXG4gICAgaWYoT3BlcmF0b3IuaXNPcGVyYXRvckFzeW5jKHRoaXMub3BlcmF0b3IpKXtcclxuICAgICAgICB0aGlzLl9iaW5kZWRBc3luY0NhbGxiYWNrID0gdGhpcy5yZWNlaXZlQXN5bmNQcm9jZXNzaW5nLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Qcm9jZXNzTm9kZS5wcm90b3R5cGUub25YZmxvd0NoYW5uZWxDaGFuZ2UgPSBmdW5jdGlvbihjaGFubmVsLCBzdGF0ZSl7XHJcbiAgICBpZiAoT3BlcmF0b3IuaXNPcGVyYXRvckFzeW5jKHRoaXMub3BlcmF0b3IpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09IEMuUFJPQ0VTU19TVEFURS5MT0FESU5HIHx8IHRoaXMuYXN5bmNQcm9jZXNzU3RhdGUgIT0gQVNZTkNfUFJPQ0VTU19TVEFURS5JTklUKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLk1PRElGSUVEO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcblxyXG4gICAgICAgIGlmIChzdGF0ZSA9PSBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9WQUxVRSAmJiB0aGlzLnN0YXR1cyA+IEMuUFJPQ0VTU19TVEFURS5VTlBST0NFU1NFRCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEMuUFJPQ0VTU19TVEFURS5VTlBST0NFU1NFRDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEMuUFJPQ0VTU19TVEFURS5NT0RJRklFRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ub3RpZnlPdXRwdXRDaGFuZ2VkKHN0YXRlKTtcclxuICAgIH1cclxufTtcclxuXHJcblByb2Nlc3NOb2RlLnByb3RvdHlwZS5zdGFydEFzeW5jUHJvY2Vzc2luZyA9IGZ1bmN0aW9uKCl7XHJcbiAgICBpZih0aGlzLmFzeW5jUHJvY2Vzc1N0YXRlID09IEFTWU5DX1BST0NFU1NfU1RBVEUuSURMRSB8fCB0aGlzLmFzeW5jUHJvY2Vzc1N0YXRlID09IEFTWU5DX1BST0NFU1NfU1RBVEUuSU5JVCl7XHJcbiAgICAgICAgdGhpcy5hc3luY1Byb2Nlc3NTdGF0ZSA9IEFTWU5DX1BST0NFU1NfU1RBVEUuUlVOTklORztcclxuICAgICAgICB2YXIgZXhlY3V0ZXIgPSBnZXRPckNyZWF0ZUV4ZWN1dGVyKHRoaXMsIEMuUExBVEZPUk0uQVNZTkMpO1xyXG4gICAgICAgIGV4ZWN1dGVyLnJ1bih0aGlzLl9iaW5kZWRBc3luY0NhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgdGhpcy5hc3luY1Byb2Nlc3NTdGF0ZSA9IEFTWU5DX1BST0NFU1NfU1RBVEUuUkVTQ0hFRFVMRUQ7XHJcbiAgICB9XHJcbn07XHJcblByb2Nlc3NOb2RlLnByb3RvdHlwZS5yZWNlaXZlQXN5bmNQcm9jZXNzaW5nID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLlBST0NFU1NFRDtcclxuICAgIHRoaXMubm90aWZ5T3V0cHV0Q2hhbmdlZChDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9TSVpFX1RZUEUpO1xyXG4gICAgaWYodGhpcy5hc3luY1Byb2Nlc3NTdGF0ZSA9PSBBU1lOQ19QUk9DRVNTX1NUQVRFLlJFU0NIRURVTEVEKXtcclxuICAgICAgICB0aGlzLmFzeW5jUHJvY2Vzc1N0YXRlID0gQVNZTkNfUFJPQ0VTU19TVEFURS5JRExFO1xyXG4gICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLk1PRElGSUVEO1xyXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgdGhpcy5hc3luY1Byb2Nlc3NTdGF0ZSA9IEFTWU5DX1BST0NFU1NfU1RBVEUuSURMRTtcclxuICAgIH1cclxuICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbn07XHJcblxyXG5cclxuXHJcblByb2Nlc3NOb2RlLnByb3RvdHlwZS5ub3RpZnlPdXRwdXRDaGFuZ2VkID0gZnVuY3Rpb24oc3RhdGUpe1xyXG4gICAgZm9yKHZhciBuYW1lIGluIHRoaXMub3V0cHV0RGF0YVNsb3RzKXtcclxuICAgICAgICB0aGlzLm91dHB1dERhdGFTbG90c1tuYW1lXS5ub3RpZnlPbkNoYW5nZShzdGF0ZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuUHJvY2Vzc05vZGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKXtcclxuICAgIGZvcih2YXIgbmFtZSBpbiB0aGlzLmlucHV0Q2hhbm5lbHMpe1xyXG4gICAgICAgIHRoaXMuaW5wdXRDaGFubmVsc1tuYW1lXSAmJiB0aGlzLmlucHV0Q2hhbm5lbHNbbmFtZV0ucmVtb3ZlTGlzdGVuZXIodGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Qcm9jZXNzTm9kZS5wcm90b3R5cGUudXBkYXRlU3RhdGUgPSBmdW5jdGlvbigpe1xyXG4gICAgaWYodGhpcy5zdGF0dXMgPT0gQy5QUk9DRVNTX1NUQVRFLk1PRElGSUVEKXtcclxuICAgICAgICB0aGlzLnN0YXR1cyA9IEMuUFJPQ0VTU19TVEFURS5VTlBST0NFU1NFRDtcclxuXHJcbiAgICAgICAgWE1MM0QuZGVidWcuYXNzZXJ0KCF0aGlzLm93bmVyLmxvYWRpbmcsIFwiVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuXCIpO1xyXG5cclxuICAgICAgICBpZih0aGlzLm93bmVyLmxvYWRpbmcpXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLkxPQURJTkc7XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBNYXRoLm1pbih0aGlzLnN0YXR1cywgdGhpcy5jaGlsZHJlbltpXS51cGRhdGVTdGF0ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0aGlzLnN0YXR1cyA+IEMuUFJPQ0VTU19TVEFURS5MT0FESU5HICYmIGlzSW5wdXRMb2FkaW5nKHRoaXMub3BlcmF0b3IsIHRoaXMuaW5wdXRDaGFubmVscykpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEMuUFJPQ0VTU19TVEFURS5MT0FESU5HO1xyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5zdGF0dXMgPiBDLlBST0NFU1NfU1RBVEUuSU5WQUxJRCAmJlxyXG4gICAgICAgICAgICAgICAgIWNoZWNrSW5wdXQodGhpcywgdGhpcy5vcGVyYXRvciwgdGhpcy5vd25lci5vd25lci5fY29tcHV0ZUlucHV0TWFwcGluZywgdGhpcy5pbnB1dENoYW5uZWxzKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLklOVkFMSUQ7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLnN0YXR1cyA9PSBDLlBST0NFU1NfU1RBVEUuVU5QUk9DRVNTRUQgJiYgT3BlcmF0b3IuaXNPcGVyYXRvckFzeW5jKHRoaXMub3BlcmF0b3IpKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gdGhpcy5hc3luY1Byb2Nlc3NTdGF0ZSA9PSBBU1lOQ19QUk9DRVNTX1NUQVRFLklOSVQgPyBDLlBST0NFU1NfU1RBVEUuTE9BRElOR1xyXG4gICAgICAgICAgICAgICAgICAgIDogQy5QUk9DRVNTX1NUQVRFLlBST0NFU1NFRDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRBc3luY1Byb2Nlc3NpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5zdGF0dXM7XHJcbn07XHJcblxyXG5Qcm9jZXNzTm9kZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgaWYodGhpcy5zdGF0dXMgPT0gQy5QUk9DRVNTX1NUQVRFLlVOUFJPQ0VTU0VEKXtcclxuICAgICAgICB2YXIgZXhlY3V0ZXIgPSBnZXRPckNyZWF0ZUV4ZWN1dGVyKHRoaXMsIHRoaXMub3duZXIucGxhdGZvcm0pO1xyXG4gICAgICAgIGV4ZWN1dGVyLnJ1bigpO1xyXG4gICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLlBST0NFU1NFRDtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge1Byb2Nlc3NOb2RlfSBwcm9jZXNzTm9kZVxyXG4gKiBAcGFyYW0ge0NoYW5uZWxOb2RlfSBjaGFubmVsTm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gY29uc3RydWN0UHJvY2Vzc05vZGUocHJvY2Vzc05vZGUsIGNoYW5uZWxOb2RlKXtcclxuICAgIHZhciBkYXRhTm9kZSA9IGNoYW5uZWxOb2RlLm93bmVyO1xyXG4gICAgc3luY2hyb25pemVJbnB1dENoYW5uZWxzKHByb2Nlc3NOb2RlLCBjaGFubmVsTm9kZSwgZGF0YU5vZGUpO1xyXG4gICAgc3luY2hyb25pemVDaGlsZHJlbkFuZERlc2NlbmRhbnRzKHByb2Nlc3NOb2RlLmNoaWxkcmVuLCBwcm9jZXNzTm9kZS5kZXNjZW5kYW50cywgcHJvY2Vzc05vZGUuaW5wdXRDaGFubmVscyk7XHJcbiAgICBzeW5jaHJvbml6ZU91dHB1dChwcm9jZXNzTm9kZS5vcGVyYXRvciwgcHJvY2Vzc05vZGUub3V0cHV0RGF0YVNsb3RzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBwcm9jZXNzTm9kZVxyXG4gKiBAcGFyYW0gY2hhbm5lbE5vZGVcclxuICogQHBhcmFtIGRhdGFOb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jaHJvbml6ZUlucHV0Q2hhbm5lbHMocHJvY2Vzc05vZGUsIGNoYW5uZWxOb2RlLCBkYXRhTm9kZSl7XHJcbiAgICB2YXIgb3BlcmF0b3IgPSBwcm9jZXNzTm9kZS5vcGVyYXRvciwgaW5wdXRNYXBwaW5nID0gZGF0YU5vZGUuX2NvbXB1dGVJbnB1dE1hcHBpbmc7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3BlcmF0b3IucGFyYW1zLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgc291cmNlTmFtZSA9IG9wZXJhdG9yLnBhcmFtc1tpXS5zb3VyY2U7XHJcbiAgICAgICAgdmFyIGRhdGFOYW1lID0gaW5wdXRNYXBwaW5nID8gaW5wdXRNYXBwaW5nLmdldFNjcmlwdElucHV0TmFtZShpLCBzb3VyY2VOYW1lKSA6IHNvdXJjZU5hbWU7XHJcbiAgICAgICAgaWYoZGF0YU5hbWUpe1xyXG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IGNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChkYXRhTmFtZSk7XHJcbiAgICAgICAgICAgIGlmKGNoYW5uZWwpIGNoYW5uZWwuYWRkTGlzdGVuZXIocHJvY2Vzc05vZGUpO1xyXG4gICAgICAgICAgICBwcm9jZXNzTm9kZS5pbnB1dENoYW5uZWxzW3NvdXJjZU5hbWVdID0gY2hhbm5lbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzSW5wdXRMb2FkaW5nKG9wZXJhdG9yLCBpbnB1dENoYW5uZWxzKXtcclxuICAgIGZvcih2YXIgaSBpbiBvcGVyYXRvci5wYXJhbXMpe1xyXG4gICAgICAgIHZhciBlbnRyeSA9IG9wZXJhdG9yLnBhcmFtc1tpXTtcclxuICAgICAgICB2YXIgY2hhbm5lbCA9IGlucHV0Q2hhbm5lbHNbZW50cnkuc291cmNlXTtcclxuICAgICAgICBpZighY2hhbm5lbCkgY29udGludWU7XHJcbiAgICAgICAgdmFyIGRhdGFFbnRyeSA9IGNoYW5uZWwuZ2V0RGF0YUVudHJ5KCk7XHJcbiAgICAgICAgaWYoIWRhdGFFbnRyeSkgY29udGludWU7XHJcbiAgICAgICAgaWYoZGF0YUVudHJ5LmlzTG9hZGluZyAmJiBkYXRhRW50cnkuaXNMb2FkaW5nKCkpIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0lucHV0KHByb2Nlc3NOb2RlLCBvcGVyYXRvciwgaW5wdXRNYXBwaW5nLCBpbnB1dENoYW5uZWxzKXtcclxuICAgIHZhciBkYXRhTm9kZSA9IHByb2Nlc3NOb2RlLm93bmVyLm93bmVyO1xyXG4gICAgZm9yKHZhciBpIGluIG9wZXJhdG9yLnBhcmFtcyl7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gb3BlcmF0b3IucGFyYW1zW2ldO1xyXG4gICAgICAgIHZhciBkYXRhTmFtZSA9IGlucHV0TWFwcGluZyA/IGlucHV0TWFwcGluZy5nZXRTY3JpcHRJbnB1dE5hbWUoaSwgZW50cnkuc291cmNlKSA6IGVudHJ5LnNvdXJjZTtcclxuICAgICAgICBpZighZW50cnkub3B0aW9uYWwgJiYgIWRhdGFOYW1lKXtcclxuICAgICAgICAgICAgQmFzZS5ub3RpZnlFcnJvcihcIlhmbG93OiBvcGVyYXRvciBcIiArIG9wZXJhdG9yLm5hbWUgKyBcIjogTWlzc2luZyBpbnB1dCBhcmd1bWVudCBmb3IgXCJcclxuICAgICAgICAgICAgICAgICsgZW50cnkuc291cmNlLCBkYXRhTm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZGF0YU5hbWUpe1xyXG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IGlucHV0Q2hhbm5lbHNbZW50cnkuc291cmNlXTtcclxuICAgICAgICAgICAgaWYoIWNoYW5uZWwpe1xyXG4gICAgICAgICAgICAgICAgaWYoIWlucHV0TWFwcGluZykgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBCYXNlLm5vdGlmeUVycm9yKFwiWGZsb3c6IG9wZXJhdG9yIFwiICsgb3BlcmF0b3IubmFtZSArIFwiOiBJbnB1dCBvZiBuYW1lICdcIiArIGRhdGFOYW1lICtcclxuICAgICAgICAgICAgICAgICAgICBcIicgbm90IGZvdW5kLiBVc2VkIGZvciBwYXJhbWV0ZXIgXCIgKyBlbnRyeS5zb3VyY2UsIGRhdGFOb2RlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZGF0YUVudHJ5ID0gY2hhbm5lbC5nZXREYXRhRW50cnkoKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCFjaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSl7XHJcbiAgICAgICAgICAgICAgICBpZighZW50cnkub3B0aW9uYWwgJiYgKCFkYXRhRW50cnkgfHwgZGF0YUVudHJ5LmlzRW1wdHkoKSkpe1xyXG4gICAgICAgICAgICAgICAgICAgIEJhc2Uubm90aWZ5RXJyb3IoXCJYZmxvdzogb3BlcmF0b3IgXCIgKyBvcGVyYXRvci5uYW1lICsgXCI6IElucHV0IGZvciBcIiArIGVudHJ5LnNvdXJjZSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcgY29udGFpbnMgbm8gZGF0YS4nLCBkYXRhTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGRhdGFFbnRyeSAmJiBkYXRhRW50cnkudHlwZSAhPSBlbnRyeS50eXBlKXtcclxuICAgICAgICAgICAgICAgIEJhc2Uubm90aWZ5RXJyb3IoXCJYZmxvdzogb3BlcmF0b3IgXCIgKyBvcGVyYXRvci5uYW1lICsgXCI6IElucHV0IGZvciBcIiArIGVudHJ5LnNvdXJjZSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCIgaGFzIHdyb25nIHR5cGUuIEV4cGVjdGVkOiBcIiArIEMuZ2V0VHlwZU5hbWUoZW50cnkudHlwZSlcclxuICAgICAgICAgICAgICAgICAgICArIFwiLCBidXQgZ290OiBcIiArICBDLmdldFR5cGVOYW1lKGRhdGFFbnRyeS50eXBlKSwgZGF0YU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN5bmNocm9uaXplQ2hpbGRyZW5BbmREZXNjZW5kYW50cyhjaGlsZHJlbiwgZGVzY2VuZGFudHMsIGlucHV0Q2hhbm5lbHMpe1xyXG4gICAgdmFyIGNoYW5uZWw7XHJcbiAgICBmb3IodmFyIG5hbWUgaW4gaW5wdXRDaGFubmVscyl7XHJcbiAgICAgICAgY2hhbm5lbCA9IGlucHV0Q2hhbm5lbHNbbmFtZV07XHJcbiAgICAgICAgaWYoY2hhbm5lbCAmJiBjaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSl7XHJcbiAgICAgICAgICAgIHV0aWxzLnNldC5hZGQoY2hpbGRyZW4sIGNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlKTtcclxuICAgICAgICAgICAgdXRpbHMuc2V0LmFkZChkZXNjZW5kYW50cywgY2hhbm5lbC5jcmVhdG9yUHJvY2Vzc05vZGUuZGVzY2VuZGFudHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHV0aWxzLnNldC5yZW1vdmUoY2hpbGRyZW4sIGRlc2NlbmRhbnRzKTtcclxuICAgIHV0aWxzLnNldC5hZGQoZGVzY2VuZGFudHMsIGNoaWxkcmVuKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3luY2hyb25pemVPdXRwdXQob3BlcmF0b3IsIG91dHB1dHMpe1xyXG4gICAgdmFyIGFzeW5jID0gT3BlcmF0b3IuaXNPcGVyYXRvckFzeW5jKG9wZXJhdG9yKTtcclxuICAgIGZvcih2YXIgaSBpbiBvcGVyYXRvci5vdXRwdXRzKXtcclxuICAgICAgICB2YXIgZGF0YUVudHJ5ID0gb3BlcmF0b3Iub3V0cHV0c1tpXTtcclxuXHJcbiAgICAgICAgdmFyIGVudHJ5LCBhc3luY0VudHJ5O1xyXG4gICAgICAgIHZhciB0eXBlID0gZGF0YUVudHJ5LnR5cGU7XHJcbiAgICAgICAgaWYodHlwZSAhPSBDLkRBVEFfVFlQRS5URVhUVVJFKXtcclxuICAgICAgICAgICAgZW50cnkgPSBuZXcgQnVmZmVyRW50cnkodHlwZSwgbnVsbCk7XHJcbiAgICAgICAgICAgIGlmKGFzeW5jKSBhc3luY0VudHJ5ID0gbmV3IEJ1ZmZlckVudHJ5KHR5cGUsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBlbnRyeSA9IHdpbmRvdy5kb2N1bWVudCA/IG5ldyBUZXh0dXJlRW50cnkobnVsbCkgOiBuZXcgSW1hZ2VEYXRhVGV4dHVyZUVudHJ5KG51bGwpO1xyXG4gICAgICAgICAgICBpZihhc3luYykgYXN5bmNFbnRyeSA9IHdpbmRvdy5kb2N1bWVudCA/IG5ldyBUZXh0dXJlRW50cnkobnVsbCkgOiBuZXcgSW1hZ2VEYXRhVGV4dHVyZUVudHJ5KG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvdXRwdXRzW2RhdGFFbnRyeS5uYW1lXSA9IG5ldyBEYXRhU2xvdChlbnRyeSwgMCk7XHJcbiAgICAgICAgaWYoYXN5bmMpIG91dHB1dHNbZGF0YUVudHJ5Lm5hbWVdLmFzeW5jRGF0YUVudHJ5ID0gYXN5bmNFbnRyeTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVFeGVjdXRlcihub2RlLCBwbGF0Zm9ybSl7XHJcbiAgICBpZighbm9kZS5leGVjdXRlcnNbcGxhdGZvcm1dKXtcclxuICAgICAgICBub2RlLmV4ZWN1dGVyc1twbGF0Zm9ybV0gPSBuZXcgRXhlY3V0b3Iobm9kZSwgcGxhdGZvcm0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGUuZXhlY3V0ZXJzW3BsYXRmb3JtXTtcclxufVxyXG5cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBSZXF1ZXN0Tm9kZVxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLyoqXHJcbiAqXHJcbiAqIEZJWE1FOiBSZXF1ZXN0Tm9kZXMgYXJlIG5ldmVyIGRlbGV0ZWQuXHJcbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IGNoYW5uZWxOb2RlXHJcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGZpbHRlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBSZXF1ZXN0Tm9kZSA9IGZ1bmN0aW9uKGNoYW5uZWxOb2RlLCBmaWx0ZXIpe1xyXG4gICAgdGhpcy5vd25lciA9IGNoYW5uZWxOb2RlO1xyXG4gICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge09iamVjdDxDLlBMQVRGT1JNLCBleHBvcnRzLlJlc3VsdD59XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzdWx0cyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge2V4cG9ydHMuQy5QUk9DRVNTX1NUQVRFfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0YXR1cyA9IEMuUFJPQ0VTU19TVEFURS5NT0RJRklFRDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgQ2hhbm5lbD59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2hhbm5lbHMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBzZWUgUHJvY2Vzc05vZGUuY2hpbGRyZW5cclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHNlZSBQcm9jZXNzTm9kZS5leGVjdXRlcnNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5leGVjdXRlcnMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBzZWUgUHJvY2Vzc05vZGUub3V0T2ZTeW5jXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vdXRPZlN5bmMgPSB0cnVlO1xyXG59O1xyXG5cclxuUmVxdWVzdE5vZGUucHJvdG90eXBlLnN5bmNocm9uaXplID0gZnVuY3Rpb24oKXtcclxuICAgIGlmKHRoaXMub3V0T2ZTeW5jKXtcclxuICAgICAgICB0aGlzLm91dE9mU3luYyA9IGZhbHNlO1xyXG4gICAgICAgIHN5bmNocm9uaXplUmVxdWVzdENoYW5uZWxzKHRoaXMsIHRoaXMub3duZXIpO1xyXG4gICAgICAgIHN5bmNocm9uaXplQ2hpbGRyZW5BbmREZXNjZW5kYW50cyh0aGlzLmNoaWxkcmVuLCBbXSwgdGhpcy5jaGFubmVscyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5SZXF1ZXN0Tm9kZS5wcm90b3R5cGUudXBkYXRlU3RhdGUgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5zeW5jaHJvbml6ZSgpO1xyXG4gICAgaWYodGhpcy5zdGF0dXMgPT0gQy5QUk9DRVNTX1NUQVRFLk1PRElGSUVEKXtcclxuICAgICAgICB0aGlzLnN0YXR1cyA9IEMuUFJPQ0VTU19TVEFURS5VTlBST0NFU1NFRDtcclxuXHJcbiAgICAgICAgaWYodGhpcy5vd25lci5sb2FkaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLkxPQURJTkc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBNYXRoLm1pbih0aGlzLnN0YXR1cywgdGhpcy5jaGlsZHJlbltpXS51cGRhdGVTdGF0ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnN0YXR1cztcclxufTtcclxuXHJcblJlcXVlc3ROb2RlLnByb3RvdHlwZS5nZXRSZXN1bHQgPSBmdW5jdGlvbihyZXN1bHRUeXBlKXtcclxuICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcclxuXHJcbiAgICAvLyBUT0RPOiBUaGlzIGNvdWxkIGJlIGluIGdldFJlcXVlc3RDb21wdXRlUmVzdWx0XHJcbiAgICBpZih0aGlzLnN0YXR1cyA9PSBDLlBST0NFU1NfU1RBVEUuVU5QUk9DRVNTRUQpe1xyXG4gICAgICAgIGlmKHJlc3VsdFR5cGUgPT0gQy5SRVNVTFRfVFlQRS5DT01QVVRFKXtcclxuICAgICAgICAgICAgdmFyIGV4ZWN1dGVyID0gZ2V0T3JDcmVhdGVFeGVjdXRlcih0aGlzLCB0aGlzLm93bmVyLnBsYXRmb3JtKTtcclxuICAgICAgICAgICAgaWYoIWV4ZWN1dGVyLmlzUHJvY2Vzc2VkKCkpXHJcbiAgICAgICAgICAgICAgICBleGVjdXRlci5ydW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuUFJPQ0VTU0VEO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XHJcbiAgICBpZiAocmVzdWx0VHlwZSA9PSBDLlJFU1VMVF9UWVBFLkNPTVBVVEUpIHtcclxuICAgICAgICByZXN1bHQgPSBnZXRSZXF1ZXN0Q29tcHV0ZVJlc3VsdCh0aGlzKTtcclxuICAgIH0gZWxzZSBpZiAocmVzdWx0VHlwZSA9PSBDLlJFU1VMVF9UWVBFLlZTKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gZ2V0UmVxdWVzdFZTUmVzdWx0KHRoaXMpO1xyXG4gICAgfVxyXG4gICAgcmVzdWx0LmxvYWRpbmcgPSAodGhpcy5zdGF0dXMgPT0gQy5QUk9DRVNTX1NUQVRFLkxPQURJTkcpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblJlcXVlc3ROb2RlLnByb3RvdHlwZS5zZXRTdHJ1Y3R1cmVPdXRPZlN5bmMgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5vdXRPZlN5bmMgPSB0cnVlO1xyXG4gICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuTU9ESUZJRUQ7XHJcbiAgICBmb3IodmFyIHR5cGUgaW4gdGhpcy5yZXN1bHRzKXtcclxuICAgICAgICB0aGlzLnJlc3VsdHNbdHlwZV0uX25vdGlmeUNoYW5nZWQoQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgfVxyXG4gICAgZm9yKHZhciBuYW1lIGluIHRoaXMuY2hhbm5lbHMpe1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbHNbbmFtZV0ucmVtb3ZlTGlzdGVuZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNoYW5uZWxzID0gW107XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICB0aGlzLmV4ZWN1dGVycyA9IFtdO1xyXG59O1xyXG5cclxuUmVxdWVzdE5vZGUucHJvdG90eXBlLm9uWGZsb3dDaGFubmVsQ2hhbmdlID0gZnVuY3Rpb24oY2hhbm5lbCwgc3RhdGUpe1xyXG4gICAgaWYoY2hhbm5lbC5jcmVhdG9yUHJvY2Vzc05vZGUpXHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuTU9ESUZJRUQ7XHJcbiAgICB2YXIgbm90aWZ5U3RhdGUgPSAoc3RhdGUgPT0gQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfVkFMVUUgPyBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX0RBVEFfVkFMVUVcclxuICAgICAgICAgICAgOiBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX0RBVEFfU0laRSk7XHJcblxyXG4gICAgZm9yKHZhciB0eXBlIGluIHRoaXMucmVzdWx0cyl7XHJcbiAgICAgICAgdGhpcy5yZXN1bHRzW3R5cGVdLl9ub3RpZnlDaGFuZ2VkKG5vdGlmeVN0YXRlKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVxdWVzdE5vZGVcclxuICogQHBhcmFtIGNoYW5uZWxOb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jaHJvbml6ZVJlcXVlc3RDaGFubmVscyhyZXF1ZXN0Tm9kZSwgY2hhbm5lbE5vZGUpe1xyXG4gICAgdmFyIG5hbWVzID0gcmVxdWVzdE5vZGUuZmlsdGVyO1xyXG4gICAgaWYoIW5hbWVzKXtcclxuICAgICAgICBuYW1lcyA9IGNoYW5uZWxOb2RlLm91dHB1dENoYW5uZWxzLmdldE5hbWVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xyXG4gICAgICAgIHZhciBjaGFubmVsID0gY2hhbm5lbE5vZGUub3V0cHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChuYW1lKTtcclxuICAgICAgICBpZihjaGFubmVsKXtcclxuICAgICAgICAgICAgcmVxdWVzdE5vZGUuY2hhbm5lbHNbbmFtZV0gPSBjaGFubmVsO1xyXG4gICAgICAgICAgICBjaGFubmVsLmFkZExpc3RlbmVyKHJlcXVlc3ROb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlcXVlc3ROb2RlfSByZXF1ZXN0Tm9kZVxyXG4gKiBAcmV0dXJucyB7UmVzdWx0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmVxdWVzdENvbXB1dGVSZXN1bHQocmVxdWVzdE5vZGUpXHJcbntcclxuICAgIGlmKCFyZXF1ZXN0Tm9kZS5yZXN1bHRzW0MuUkVTVUxUX1RZUEUuQ09NUFVURV0pXHJcbiAgICAgICAgcmVxdWVzdE5vZGUucmVzdWx0c1tDLlJFU1VMVF9UWVBFLkNPTVBVVEVdID0gbmV3IFJlc3VsdC5Db21wdXRlUmVzdWx0KCk7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IHJlcXVlc3ROb2RlLnJlc3VsdHNbQy5SRVNVTFRfVFlQRS5DT01QVVRFXTtcclxuICAgIHJlc3VsdC5fZGF0YUVudHJpZXMgPSB7fTsgcmVzdWx0Ll9vdXRwdXROYW1lcyA9IFtdO1xyXG5cclxuICAgIGZvcih2YXIgbmFtZSBpbiByZXF1ZXN0Tm9kZS5jaGFubmVscyl7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gcmVxdWVzdE5vZGUuY2hhbm5lbHNbbmFtZV0uZ2V0RGF0YUVudHJ5KCk7XHJcbiAgICAgICAgcmVzdWx0Ll9kYXRhRW50cmllc1tuYW1lXSA9IGVudHJ5ICYmICFlbnRyeS5pc0VtcHR5KCkgPyBlbnRyeSA6IG51bGw7XHJcbiAgICAgICAgcmVzdWx0Ll9vdXRwdXROYW1lcy5wdXNoKG5hbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSByZXF1ZXN0Tm9kZVxyXG4gKiBAcmV0dXJucyB7ZXhwb3J0cy5WU0RhdGFSZXN1bHR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSZXF1ZXN0VlNSZXN1bHQocmVxdWVzdE5vZGUpXHJcbntcclxuICAgIHZhciBleGVjdXRlciA9IGdldE9yQ3JlYXRlRXhlY3V0ZXIocmVxdWVzdE5vZGUsIEMuUExBVEZPUk0uR0xTTCk7XHJcbiAgICBpZighcmVxdWVzdE5vZGUucmVzdWx0c1tDLlJFU1VMVF9UWVBFLlZTXSlcclxuICAgICAgICByZXF1ZXN0Tm9kZS5yZXN1bHRzW0MuUkVTVUxUX1RZUEUuVlNdID0gbmV3IFJlc3VsdC5WU0RhdGFSZXN1bHQoKTtcclxuICAgIHZhciByZXN1bHQgPSByZXF1ZXN0Tm9kZS5yZXN1bHRzW0MuUkVTVUxUX1RZUEUuVlNdO1xyXG5cclxuICAgIHZhciBwcm9ncmFtID0gZXhlY3V0ZXIuZ2V0VmVydGV4U2hhZGVyKCk7XHJcbiAgICByZXN1bHQuX3Byb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgcmVzdWx0Ll9wcm9ncmFtRGF0YSA9IGV4ZWN1dGVyLnByb2dyYW1EYXRhO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgUmVxdWVzdE5vZGU6IFJlcXVlc3ROb2RlLFxyXG4gICAgUHJvY2Vzc05vZGU6IFByb2Nlc3NOb2RlXHJcbn07XHJcblxyXG4iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi4vLi4vdXRpbHMvYXJyYXkuanNcIik7XHJcblxyXG52YXIgcXVldWVSZXN1bHRDYWxsYmFjayA9IEJhc2UuX3F1ZXVlUmVzdWx0Q2FsbGJhY2s7XHJcblxyXG4vKipcclxuICogQ29udGVudCBvZiB0aGlzIGZpbGU6XHJcbiAqIFJlc3VsdCBjbGFzc2VzIG9mIGFuIFhmbG93IGdyYXBoIHdoaWNoIGFyZSByZWNlaXZlZCB0aHJvdWdoIFJlcXVlc3RzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdCBSZXN1bHQgc3RydWN0dXJlIGNvbnRhaW5pbmcgYSAocHJvY2Vzc2VkKSByZXN1bHQgb2YgdGhlIFhmbG93IGdyYXBoLlxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbnZhciBSZXN1bHQgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAvKiogVmFsaWQgaXMgZmFsc2UgaWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBwcm9jZXNzaW5nIG9mIHRoZSByZXN1bHQgKi9cclxuICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xyXG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFJlc3VsdCwgQy5SRVNVTFRfU1RBVEUpfSBjYWxsYmFja1xyXG4gKi9cclxuUmVzdWx0LnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFJlc3VsdCwgQy5SRVNVTFRfU1RBVEUpfSBjYWxsYmFja1xyXG4gKi9cclxuUmVzdWx0LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuICAgIEFycmF5LmVyYXNlKHRoaXMuX2xpc3RlbmVycywgY2FsbGJhY2spO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUmVzdWx0LCBDLlJFU1VMVF9TVEFURSl9IGNhbGxiYWNrXHJcbiAqL1xyXG5SZXN1bHQucHJvdG90eXBlLl9hZGRSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdCl7XHJcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUmVzdWx0LCBDLlJFU1VMVF9TVEFURSl9IGNhbGxiYWNrXHJcbiAqL1xyXG5SZXN1bHQucHJvdG90eXBlLl9yZW1vdmVSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdCl7XHJcbiAgICBBcnJheS5lcmFzZSh0aGlzLl9yZXF1ZXN0cywgcmVxdWVzdCk7XHJcbn07XHJcblxyXG5cclxuUmVzdWx0LnByb3RvdHlwZS5fbm90aWZ5Q2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlKXtcclxuICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9yZXF1ZXN0cy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdHNbaV0uX29uUmVzdWx0Q2hhbmdlZChzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBxdWV1ZVJlc3VsdENhbGxiYWNrKHRoaXMsIHN0YXRlKTtcclxufVxyXG5cclxuUmVzdWx0LnByb3RvdHlwZS5fb25Qb3N0cG9uZWRSZXN1bHRDaGFuZ2VkID0gZnVuY3Rpb24oc3RhdGUpe1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RlbmVycy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2ldKHRoaXMsIHN0YXRlKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29tcHV0ZVJlc3VsdCBjb250YWlucyBhIG5hbWVkIG1hcCBvZiB0eXBlZCB2YWx1ZXMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyB7UmVzdWx0fVxyXG4gKi9cclxudmFyIENvbXB1dGVSZXN1bHQgPSBmdW5jdGlvbigpe1xyXG4gICAgUmVzdWx0LmNhbGwodGhpcyk7XHJcbiAgICB0aGlzLl9vdXRwdXROYW1lcyA9IFtdO1xyXG4gICAgLyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxEYXRhRW50cnk+fSAqL1xyXG4gICAgdGhpcy5fZGF0YUVudHJpZXMgPSB7fTtcclxufTtcclxuQmFzZS5jcmVhdGVDbGFzcyhDb21wdXRlUmVzdWx0LCBSZXN1bHQpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXB1dGVSZXN1bHQucHJvdG90eXBlLCBcIm91dHB1dE5hbWVzXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24odil7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0TmFtZXMgaXMgcmVhZG9ubHlcIik7XHJcbiAgICB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fb3V0cHV0TmFtZXM7IH1cclxufSk7XHJcblxyXG5Db21wdXRlUmVzdWx0LnByb3RvdHlwZS5nZXRPdXRwdXREYXRhID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YUVudHJpZXNbbmFtZV07XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLERhdGFFbnRyeT59XHJcbiAqL1xyXG5Db21wdXRlUmVzdWx0LnByb3RvdHlwZS5nZXRPdXRwdXRNYXAgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhRW50cmllcztcclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFZTRGF0YVJlc3VsdCBpcyB1c2VkIHRvIGFuYWx5c2UgdGhlIG91dHB1dCBvZiBhIFZlcnRleFNoYWRlclxyXG4gKiBOb3RlIHRoYXQgdGhlIFZTRGF0YVJlc3VsdCBpcyBub3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgVmVydGV4U2hhZGVyIGRpcmVjdGx5LlxyXG4gKiBGb3IgdGhhdCwgdGhlIFZlcnRleFNoYWRlciBzdHJ1Y3R1cmUgbXVzdCBiZSBjcmVhdGVkIGZyb20gVmVydGV4U2hhZGVyUmVxdWVzdFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMge1Jlc3VsdH1cclxuICovXHJcbnZhciBWU0RhdGFSZXN1bHQgPSBmdW5jdGlvbigpe1xyXG4gICAgUmVzdWx0LmNhbGwodGhpcyk7XHJcbiAgICB0aGlzLl9wcm9ncmFtID0gbnVsbDtcclxuICAgIHRoaXMuX3Byb2dyYW1EYXRhID0gbnVsbDtcclxufTtcclxuQmFzZS5jcmVhdGVDbGFzcyhWU0RhdGFSZXN1bHQsIFJlc3VsdCk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVlNEYXRhUmVzdWx0LnByb3RvdHlwZSwgXCJvdXRwdXROYW1lc1wiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNoYWRlck91dHB1dE5hbWVzIGlzIHJlYWRvbmx5XCIpO1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX3Byb2dyYW0uZ2V0T3V0cHV0TmFtZXMoKTsgfVxyXG59KTtcclxuXHJcblZTRGF0YVJlc3VsdC5wcm90b3R5cGUuaXNPdXRwdXRVbmlmb3JtID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbS5pc091dHB1dFVuaWZvcm0obmFtZSk7XHJcbn1cclxuVlNEYXRhUmVzdWx0LnByb3RvdHlwZS5pc091dHB1dE51bGwgPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHJldHVybiB0aGlzLl9wcm9ncmFtLmlzT3V0cHV0TnVsbChuYW1lKTtcclxufVxyXG5WU0RhdGFSZXN1bHQucHJvdG90eXBlLmdldE91dHB1dFR5cGUgPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHJldHVybiB0aGlzLl9wcm9ncmFtLmdldE91dHB1dFR5cGUobmFtZSk7XHJcbn1cclxuVlNEYXRhUmVzdWx0LnByb3RvdHlwZS5nZXRWZXJ0ZXhTaGFkZXIgPSBmdW5jdGlvbih2c0NvbmZpZyl7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbS5jcmVhdGVWZXJ0ZXhTaGFkZXIodGhpcy5fcHJvZ3JhbURhdGEsIHZzQ29uZmlnKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBDb21wdXRlUmVzdWx0OiAgQ29tcHV0ZVJlc3VsdCxcclxuICAgIFZTRGF0YVJlc3VsdDogVlNEYXRhUmVzdWx0XHJcbn07XHJcbiIsInZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XHJcbnZhciBDID0gcmVxdWlyZShcIi4vLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxuXHJcbnZhciBpbml0QW5vbnltb3VzT3BlcmF0b3IgPSByZXF1aXJlKFwiLi4vb3BlcmF0b3Ivb3BlcmF0b3IuanNcIikuaW5pdEFub255bW91c09wZXJhdG9yO1xyXG5cclxudmFyIHNoYWRlckNvbnN0YW50ID0ge307XHJcbnNoYWRlckNvbnN0YW50W0MuU0hBREVSX0NPTlNUQU5UX0tFWS5PQkpFQ1RfSURdID0gXCJvYmplY3RJRFwiO1xyXG5zaGFkZXJDb25zdGFudFtDLlNIQURFUl9DT05TVEFOVF9LRVkuU0NSRUVOX1RSQU5TRk9STV0gPSBcInNjcmVlblRyYW5zZm9ybVwiO1xyXG5zaGFkZXJDb25zdGFudFtDLlNIQURFUl9DT05TVEFOVF9LRVkuU0NSRUVOX1RSQU5TRk9STV9OT1JNQUxdID0gXCJzY3JlZW5UcmFuc2Zvcm1Ob3JtYWxcIjtcclxuc2hhZGVyQ29uc3RhbnRbQy5TSEFERVJfQ09OU1RBTlRfS0VZLlZJRVdfVFJBTlNGT1JNXSA9IFwidmlld1RyYW5zZm9ybVwiO1xyXG5zaGFkZXJDb25zdGFudFtDLlNIQURFUl9DT05TVEFOVF9LRVkuVklFV19UUkFOU0ZPUk1fTk9STUFMXSA9IFwidmlld1RyYW5zZm9ybU5vcm1hbFwiO1xyXG5zaGFkZXJDb25zdGFudFtDLlNIQURFUl9DT05TVEFOVF9LRVkuV09STERfVFJBTlNGT1JNXSA9IFwid29ybGRUcmFuc2Zvcm1cIjtcclxuc2hhZGVyQ29uc3RhbnRbQy5TSEFERVJfQ09OU1RBTlRfS0VZLldPUkxEX1RSQU5TRk9STV9OT1JNQUxdID0gXCJ3b3JsZFRyYW5zZm9ybU5vcm1hbFwiO1xyXG5cclxudmFyIHNldFNoYWRlckNvbnN0YW50ID0gZnVuY3Rpb24odHlwZSwgbmFtZSl7XHJcbiAgICBzaGFkZXJDb25zdGFudFt0eXBlXSA9IG5hbWU7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBvdXRwdXQgY29uZmlndXJhdGlvbiBvZiBhIFZlcnRleFNoYWRlciBnZW5lcmF0ZWQgYnkgWGZsb3dcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgVlNDb25maWcgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IHt9O1xyXG4gICAgdGhpcy5fYmxvY2tlZE5hbWVzID0gW107XHJcbiAgICB0aGlzLl9hZGRJbnB1dCA9IHt9O1xyXG4gICAgdGhpcy5fYWRkT3V0cHV0ID0ge307XHJcbiAgICB0aGlzLl9jb2RlRnJhZ21lbnRzID0gW107XHJcbiAgICB0aGlzLl9vdXRwdXRDaGFubmVsaW5nID0ge307XHJcbn07XHJcblxyXG5WU0NvbmZpZy5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgb3B0aW9uYWwpe1xyXG4gICAgaWYodGhpcy5fYXR0cmlidXRlc1tuYW1lXSl7XHJcbiAgICAgICAgaWYodGhpcy5fYXR0cmlidXRlc1tuYW1lXS50eXBlICE9IHR5cGUpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVzIHRvIGFkZCB0d28gYXR0cmlidXRlcyB3aXRoIGRpZmZlcmVudCB0eXBlcyBvZiBuYW1lICdcIiArIG5hbWUgKyAnXCInKTtcclxuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdLm9wdGlvbmFsID0gdGhpcy5fYXR0cmlidXRlc1tuYW1lXS5vcHRpb25hbCAmJiBvcHRpb25hbDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdID0ge3R5cGU6IHR5cGUsIG9wdGlvbmFsOiBvcHRpb25hbCwgY2hhbm5lbGluZzogW119O1xyXG59O1xyXG5cclxuVlNDb25maWcucHJvdG90eXBlLmNoYW5uZWxBdHRyaWJ1dGUgPSBmdW5jdGlvbihpbnB1dE5hbWUsIG91dHB1dE5hbWUsIGNvZGUpe1xyXG4gICAgdGhpcy5fYXR0cmlidXRlc1tpbnB1dE5hbWVdLmNoYW5uZWxpbmcucHVzaCggeyBvdXRwdXROYW1lIDogb3V0cHV0TmFtZSwgY29kZSA6IGNvZGUgfSk7XHJcbn07XHJcblxyXG5WU0NvbmZpZy5wcm90b3R5cGUuYWRkSW5wdXRQYXJhbWV0ZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCB1bmlmb3JtKXtcclxuICAgIGlmKHRoaXMuX2FkZElucHV0W25hbWVdKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHRoaXMuX2FkZElucHV0W25hbWVdID0geyB0eXBlOiB0eXBlLCB1bmlmb3JtOiB1bmlmb3JtIH07XHJcbiAgICB0aGlzLl9ibG9ja2VkTmFtZXMucHVzaChuYW1lKTtcclxufTtcclxuVlNDb25maWcucHJvdG90eXBlLmFkZE91dHB1dFBhcmFtZXRlciA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUpe1xyXG4gICAgaWYodGhpcy5fYWRkT3V0cHV0W25hbWVdKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHRoaXMuX2FkZE91dHB1dFtuYW1lXSA9IHsgdHlwZTogdHlwZSB9O1xyXG4gICAgdGhpcy5fYmxvY2tlZE5hbWVzLnB1c2gobmFtZSk7XHJcbn07XHJcblZTQ29uZmlnLnByb3RvdHlwZS5hZGRDb2RlRnJhZ21lbnQgPSBmdW5jdGlvbihjb2RlRnJhZ21lbnQpe1xyXG4gICAgdGhpcy5fY29kZUZyYWdtZW50cy5wdXNoKGNvZGVGcmFnbWVudCk7XHJcbn07XHJcblxyXG5WU0NvbmZpZy5wcm90b3R5cGUuYWRkQmxvY2tlZE5hbWUgPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHRoaXMuX2Jsb2NrZWROYW1lcy5wdXNoKG5hbWUpO1xyXG59O1xyXG5cclxuVlNDb25maWcucHJvdG90eXBlLmdldEJsb2NrZWROYW1lcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tlZE5hbWVzO1xyXG59O1xyXG5cclxuVlNDb25maWcucHJvdG90eXBlLmdldEZpbHRlciA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fYXR0cmlidXRlcyk7XHJcbn07XHJcblZTQ29uZmlnLnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGtleSA9IFwiXCI7XHJcbiAgICBmb3IodmFyIG5hbWUgaW4gdGhpcy5fYXR0cmlidXRlcyl7XHJcbiAgICAgICAgdmFyIGF0dHIgPSB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdO1xyXG4gICAgICAgIGtleSArPSBcIjtcIiArIGF0dHIudHlwZSArIFwiLFwiICsgbmFtZSArIFwiLFwiICsgYXR0ci5vcHRpb25hbDtcclxuICAgIH1cclxuICAgIHJldHVybiBrZXk7XHJcbn07XHJcblxyXG52YXIgY192c19vcGVyYXRvcl9jYWNoZSA9IHt9O1xyXG5cclxuVlNDb25maWcucHJvdG90eXBlLmdldE9wZXJhdG9yID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBrZXkgPSB0aGlzLmdldEtleSgpO1xyXG4gICAgaWYoY192c19vcGVyYXRvcl9jYWNoZVtrZXldKVxyXG4gICAgICAgIHJldHVybiBjX3ZzX29wZXJhdG9yX2NhY2hlW2tleV07XHJcblxyXG4gICAgdmFyIG91dHB1dHMgPSBbXSwgcGFyYW1zID0gW10sIGdsc2xDb2RlID0gXCJcXHQvLyBWUyBDb25uZWN0b3JcXG5cIjtcclxuICAgIG5hbWUgPSBcIlZTQ29ubmVjdFwiO1xyXG4gICAgZm9yKHZhciBuYW1lIGluIHRoaXMuX2F0dHJpYnV0ZXMpe1xyXG4gICAgICAgIHZhciBhdHRyID0gdGhpcy5fYXR0cmlidXRlc1tuYW1lXTtcclxuICAgICAgICB2YXIgdHlwZSA9IEMuZ2V0VHlwZU5hbWUoYXR0ci50eXBlKTtcclxuICAgICAgICBvdXRwdXRzLnB1c2goIHsgdHlwZTogdHlwZSwgbmFtZTogbmFtZX0gKTtcclxuICAgICAgICBwYXJhbXMucHVzaCggeyB0eXBlOiB0eXBlLCBzb3VyY2U6IG5hbWUsIG9wdGlvbmFsOiBhdHRyLm9wdGlvbmFsfSApO1xyXG4gICAgICAgIG5hbWUgKz0gXCJUXCIgKyB0eXBlICsgXCJOXCIgKyBuYW1lICsgXCJPXCIgKyBhdHRyLm9wdGlvbmFsICsgXCIuXCI7XHJcbiAgICB9XHJcbiAgICB2YXIgb3BlcmF0b3IgPSBpbml0QW5vbnltb3VzT3BlcmF0b3IobmFtZSxcclxuICAgIHtcclxuICAgICAgICBvdXRwdXRzOiBvdXRwdXRzLFxyXG4gICAgICAgIHBhcmFtczogIHBhcmFtcyxcclxuICAgICAgICBldmFsdWF0ZV9nbHNsOiBnbHNsQ29kZVxyXG4gICAgfSk7XHJcbiAgICBjX3ZzX29wZXJhdG9yX2NhY2hlW2tleV0gPSBvcGVyYXRvcjtcclxuICAgIHJldHVybiBvcGVyYXRvcjtcclxufTtcclxuXHJcbnZhciBWZXJ0ZXhTaGFkZXIgPSBmdW5jdGlvbihwcm9ncmFtRGF0YSl7XHJcbiAgICB0aGlzLl9wcm9ncmFtRGF0YSA9IHByb2dyYW1EYXRhO1xyXG4gICAgdGhpcy5fZ2xzbENvZGUgPSBudWxsO1xyXG4gICAgdGhpcy5faW5wdXROYW1lcyA9IFtdO1xyXG4gICAgdGhpcy5fb3V0cHV0TmFtZXMgPSBbXTtcclxuICAgIHRoaXMuX2lucHV0SW5mbyA9IHt9O1xyXG4gICAgdGhpcy5fb3V0cHV0SW5mbyA9IHt9O1xyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlcnRleFNoYWRlci5wcm90b3R5cGUsIFwiaW5wdXROYW1lc1wiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0TmFtZXMgaXMgcmVhZG9ubHlcIik7XHJcbiAgICB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5faW5wdXROYW1lczsgfVxyXG59KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZXJ0ZXhTaGFkZXIucHJvdG90eXBlLCBcIm91dHB1dE5hbWVzXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24odil7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0TmFtZXMgaXMgcmVhZG9ubHlcIik7XHJcbiAgICB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fb3V0cHV0TmFtZXM7IH1cclxufSk7XHJcblxyXG5WZXJ0ZXhTaGFkZXIucHJvdG90eXBlLmlzSW5wdXRVbmlmb3JtID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gdGhpcy5faW5wdXRJbmZvW25hbWVdLnVuaWZvcm07XHJcbn07XHJcblZlcnRleFNoYWRlci5wcm90b3R5cGUuZ2V0SW5wdXREYXRhID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbURhdGEuZ2V0RGF0YUVudHJ5KHRoaXMuX2lucHV0SW5mb1tuYW1lXS5pbmRleCk7XHJcbn07XHJcblxyXG5WZXJ0ZXhTaGFkZXIucHJvdG90eXBlLmlzT3V0cHV0TnVsbCA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgcmV0dXJuIHRoaXMuX291dHB1dEluZm9bbmFtZV0uaXRlcmF0aW9uID09IEMuSVRFUkFUSU9OX1RZUEUuTlVMTDtcclxufTtcclxuVmVydGV4U2hhZGVyLnByb3RvdHlwZS5pc091dHB1dEZyYWdtZW50VW5pZm9ybSA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgcmV0dXJuIHRoaXMuX291dHB1dEluZm9bbmFtZV0uaXRlcmF0aW9uID09IEMuSVRFUkFUSU9OX1RZUEUuT05FO1xyXG59O1xyXG5WZXJ0ZXhTaGFkZXIucHJvdG90eXBlLmdldFVuaWZvcm1PdXRwdXREYXRhID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbURhdGEuZ2V0RGF0YUVudHJ5KHRoaXMuX291dHB1dEluZm9bbmFtZV0uaW5kZXgpO1xyXG59O1xyXG5WZXJ0ZXhTaGFkZXIucHJvdG90eXBlLmdldE91dHB1dFR5cGUgPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHJldHVybiB0aGlzLl9vdXRwdXRJbmZvW25hbWVdLnR5cGU7XHJcbn07XHJcblZlcnRleFNoYWRlci5wcm90b3R5cGUuZ2V0T3V0cHV0U291cmNlTmFtZSA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgcmV0dXJuIHRoaXMuX291dHB1dEluZm9bbmFtZV0uc291cmNlTmFtZTtcclxufTtcclxuVmVydGV4U2hhZGVyLnByb3RvdHlwZS5nZXRHTFNMQ29kZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5fZ2xzbENvZGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHNoYWRlckNvbnN0YW50OiBzaGFkZXJDb25zdGFudCxcclxuICAgIHNldFNoYWRlckNvbnN0YW50OiBzZXRTaGFkZXJDb25zdGFudCxcclxuICAgIFZTQ29uZmlnOiBWU0NvbmZpZyxcclxuICAgIFZlcnRleFNoYWRlcjogVmVydGV4U2hhZGVyXHJcbn07XHJcbiIsInJlcXVpcmUoXCIuLi8uLi91dGlscy9hcnJheS5qc1wiKTtcclxudmFyIHNldCA9IHt9O1xyXG5cclxuXHJcbnNldC5hZGQgPSBmdW5jdGlvbihzZXRBcnJheSwgc2V0VG9BZGQpe1xyXG4gICAgaWYoQXJyYXkuaXNBcnJheShzZXRUb0FkZCkpe1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZXRUb0FkZC5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIGlmKHNldEFycmF5LmluZGV4T2Yoc2V0VG9BZGRbaV0pID09IC0xKVxyXG4gICAgICAgICAgICAgICAgc2V0QXJyYXkucHVzaChzZXRUb0FkZFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICBpZihzZXRBcnJheS5pbmRleE9mKHNldFRvQWRkKSA9PSAtMSlcclxuICAgICAgICAgICAgc2V0QXJyYXkucHVzaChzZXRUb0FkZCk7XHJcbiAgICB9XHJcbn1cclxuc2V0LnJlbW92ZSA9IGZ1bmN0aW9uKHNldEFycmF5LCBzZXRUb1JlbW92ZSl7XHJcbiAgICB2YXIgaWR4O1xyXG4gICAgaWYoQXJyYXkuaXNBcnJheShzZXRUb1JlbW92ZSkpe1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZXRUb1JlbW92ZS5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIGlmKCAoaWR4ID0gc2V0QXJyYXkuaW5kZXhPZihzZXRUb1JlbW92ZVtpXSkpICE9IC0xKVxyXG4gICAgICAgICAgICAgICAgc2V0QXJyYXkuc3BsaWNlKGlkeCwxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIGlmKCAoaWR4ID0gc2V0QXJyYXkuaW5kZXhPZihzZXRUb1JlbW92ZSkpICE9IC0xKVxyXG4gICAgICAgICAgICBzZXRBcnJheS5zcGxpY2UoaWR4LDEpO1xyXG4gICAgfVxyXG59XHJcblxyXG5zZXQuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oZGVzdCwgc2V0QSwgc2V0Qil7XHJcbiAgICB2YXIgc2l6ZSA9IHNldEEubGVuZ3RoO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSl7XHJcbiAgICAgICAgaWYoc2V0Qi5pbmRleE9mKHNldEFbaV0pICE9IC0xKVxyXG4gICAgICAgICAgICBkZXN0LnB1c2goc2V0QVtpXSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnNldC5pc0ludGVyc2VjdGluZyA9IGZ1bmN0aW9uKHNldEEsIHNldEIpe1xyXG4gICAgdmFyIGkgPSBzZXRBLmxlbmd0aDtcclxuICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgaWYoc2V0Qi5pbmRleE9mKHNldEFbaV0pICE9IC0xKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuc2V0LmlzU3Vic2V0ID0gZnVuY3Rpb24oc21hbGxlclNldCwgbGFyZ2VyU2V0KXtcclxuICAgIHZhciBpID0gc21hbGxlclNldC5sZW5ndGg7XHJcbiAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgIGlmKGxhcmdlclNldC5pbmRleE9mKHNtYWxsZXJTZXRbaV0pID09IC0xKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE5hbWVzZXQgVXRpbGl0aWVzIGZvciBYZmxvd1xyXG4gKi9cclxudmFyIG5hbWVzZXQgPSB7fTtcclxuXHJcbm5hbWVzZXQuYWRkID0gZnVuY3Rpb24obmFtZVNldCwgdG9BZGQpe1xyXG4gICAgaWYoIXRvQWRkKSByZXR1cm47XHJcbiAgICBpZih0eXBlb2YgdG9BZGQgPT0gXCJzdHJpbmdcIil7XHJcbiAgICAgICAgaWYobmFtZVNldC5pbmRleE9mKHRvQWRkKSA9PSAtMSlcclxuICAgICAgICAgICAgbmFtZVNldC5wdXNoKHRvQWRkKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYobmFtZVNldC5pbmRleE9mKHRvQWRkW2ldKSA9PSAtMSlcclxuICAgICAgICAgICAgICAgIG5hbWVTZXQucHVzaCh0b0FkZFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5uYW1lc2V0LnJlbW92ZSA9IGZ1bmN0aW9uKG5hbWVTZXQsIHRvUmVtb3ZlKXtcclxuICAgIGlmKCF0b1JlbW92ZSkgcmV0dXJuO1xyXG4gICAgaWYodHlwZW9mIHRvUmVtb3ZlID09IFwic3RyaW5nXCIpe1xyXG4gICAgICAgIHZhciByZW1vdmVJZHggPSBuYW1lU2V0LmluZGV4T2YodG9SZW1vdmUpO1xyXG4gICAgICAgIGlmKHJlbW92ZUlkeCAhPSAtMSlcclxuICAgICAgICAgICAgbmFtZVNldC5zcGxpY2UocmVtb3ZlSWR4LCAxKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIHJlbW92ZUlkeCA9IG5hbWVTZXQuaW5kZXhPZih0b1JlbW92ZVtpXSk7XHJcbiAgICAgICAgICAgIGlmKHJlbW92ZUlkeCAhPSAtMSlcclxuICAgICAgICAgICAgICAgIG5hbWVTZXQuc3BsaWNlKHJlbW92ZUlkeCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5uYW1lc2V0LmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKG5hbWVTZXRBLCBuYW1lU2V0Qil7XHJcbiAgICB2YXIgaSA9IG5hbWVTZXRBLmxlbmd0aDtcclxuICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgaWYobmFtZVNldEIuaW5kZXhPZihuYW1lU2V0QVtpXSkgPT0gLTEpe1xyXG4gICAgICAgICAgICBuYW1lU2V0QS5zcGxpY2UoaSwxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG52YXIgYmluYXJ5U2VhcmNoID0gZnVuY3Rpb24oa2V5cywga2V5LCBtYXhJbmRleCl7XHJcbiAgICB2YXIgbWluID0gMCwgbWF4ID0gbWF4SW5kZXggLSAxO1xyXG4gICAgd2hpbGUobWluIDw9IG1heCl7XHJcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKChtaW4gKyBtYXgpIC8gMik7XHJcbiAgICAgICAgaWYoa2V5c1tpXSA9PSBrZXkpe1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihrZXlzW2ldIDwga2V5KVxyXG4gICAgICAgICAgICBtaW4gPSBpICsgMTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIG1heCA9IGkgLSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1heDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBzZXQ6IHNldCxcclxuICAgIG5hbWVzZXQ6IG5hbWVzZXQsXHJcbiAgICBiaW5hcnlTZWFyY2g6IGJpbmFyeVNlYXJjaFxyXG59IiwiXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaW5pdC5qc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIFhNTDNEOiByZXF1aXJlKFwiLi4vLi4vc3JjL3htbDNkLmpzXCIpLlhNTDNELFxyXG4gICAgRnJ1c3R1bTogcmVxdWlyZShcIi4uLy4uL3NyYy9yZW5kZXJlci9yZW5kZXJlci90b29scy9mcnVzdHVtXCIpLFxyXG4gICAgU2NlbmU6IHJlcXVpcmUoXCIuLi8uLi9zcmMvcmVuZGVyZXIvcmVuZGVyZXIvc2NlbmUvc2NlbmVcIiksXHJcbiAgICBTY2VuZUNvbnN0YW50czogcmVxdWlyZShcIi4uLy4uL3NyYy9yZW5kZXJlci9yZW5kZXJlci9zY2VuZS9jb25zdGFudHNcIiksXHJcbiAgICBYZmxvd0NvbnN0YW50czogcmVxdWlyZShcIi4uLy4uL3NyYy94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpLFxyXG4gICAgRGF0YU5vZGU6IHJlcXVpcmUoXCIuLi8uLi9zcmMveGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLkRhdGFOb2RlLFxyXG4gICAgVlNDb25maWc6IHJlcXVpcmUoXCIuLi8uLi9zcmMveGZsb3cvcHJvY2Vzc2luZy92cy1jb25uZWN0LmpzXCIpLlZTQ29uZmlnLFxyXG4gICAgVmVydGV4U2hhZGVyUmVxdWVzdDogcmVxdWlyZShcIi4uLy4uL3NyYy94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5WZXJ0ZXhTaGFkZXJSZXF1ZXN0LFxyXG4gICAgQ29tcHV0ZVJlcXVlc3Q6IHJlcXVpcmUoXCIuLi8uLi9zcmMveGZsb3cvaW50ZXJmYWNlL3JlcXVlc3QuanNcIikuQ29tcHV0ZVJlcXVlc3QsXHJcbiAgICBFdmVudHM6IHJlcXVpcmUoXCIuLi8uLi9zcmMvaW50ZXJmYWNlL25vdGlmaWNhdGlvbi5qc1wiKSxcclxuICAgIFVSSTogcmVxdWlyZShcIi4uLy4uL3NyYy91dGlscy91cmkuanNcIiksXHJcbiAgICBBZGFwdGVySGFuZGxlOiByZXF1aXJlKFwiLi4vLi4vc3JjL2Jhc2UvYWRhcHRlcmhhbmRsZS5qc1wiKSxcclxuICAgIEFkYXB0ZXI6IHJlcXVpcmUoXCIuLi8uLi9zcmMvYmFzZS9hZGFwdGVyLmpzXCIpLFxyXG4gICAgYWRkRnJhZ21lbnRTaGFkZXJIZWFkZXI6IHJlcXVpcmUoXCIuLi8uLi9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVyL3NoYWRlci11dGlscy5qc1wiKS5hZGRGcmFnbWVudFNoYWRlckhlYWRlcixcclxuICAgIGNhbGxBZGFwdGVyRnVuYzogcmVxdWlyZShcIi4uLy4uL3NyYy91dGlscy9taXNjLmpzXCIpLmNhbGxBZGFwdGVyRnVuY1xyXG59O1xyXG4iXX0=
